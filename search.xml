<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2017 resolutions</title>
    <url>/2017/02/22/2017-resolutions/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在是大年初七, 是大多数有工作的人上班的日子, 也是襄中开学的日子, 而我作为一个大学生, 居然可以放假到农历二月, 致使现在凌晨2点还有时间码字. 刚刚看了<a href="http://www.jianshu.com/p/0566385dceff">一篇文章</a>, 作者的话很大程度上描述了我的状态, 咸鱼懒的翻身. 而作者的亲身经历和劝说也让我愧疚. </p>
<p>最近刚读了蔡东藩的<a href="https://book.douban.com/subject/3089584/">五代史</a>, 了解五代混乱的历史, 感叹大多数主子昏庸误国, 英明的主子也多少有瑕疵的同时, 也将心比心, 自己是否是一个英明的帝王. 答案却是否定的. 我是一个懒惰的人, 没有意志力的人, 不喜欢批评, 只喜欢表扬. 如果把自己放在帝王的位置上, 一定是个亡国之君了. 想想还是很可怕的.</p>
<p>综上两点原因, 我打算在新的一年里有所改变, 制定新年目标, 完成新年计划, 做更好地自己.</p>
<h2 id="2017目标及计划"><a href="#2017目标及计划" class="headerlink" title="2017目标及计划"></a>2017目标及计划</h2><ul>
<li>英语每日打卡学习, 加大任务量(小镇做题家欠下的，语言关必须过)</li>
<li>早起, 8点之前</li>
<li>早睡, 12点之前</li>
<li>坚持吃早饭</li>
<li>坚持每日锻炼身体, 天气好出门跑步, 天气差在室内运动</li>
<li>凡事不要以懒惰为借口</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>姐姐今年就要毕业找工作了, 我也要准备尽力保研了, 深感世事艰辛, 人间险阻, 唯有努力学习才能获得拯救.</p>
<p>最后, 二句”名言”镇文.</p>
<pre><code>学习使我快乐.

我爱学习, 学习爱我.
</code></pre>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年终总结 与 2019新年愿望</title>
    <url>/2018/12/12/2018-summary-and-2019-resolutions/</url>
    <content><![CDATA[<p>Merry Christmas!</p>
<p>离2019年还有5天，2018年就要结束了。一年过的真快呀。不知道你的2018年怎么样呀？一年前制定的新年计划实现了多少呢？</p>
<p>我曾在2017年的新年计划中写下这样一段话：</p>
<blockquote>
<p>最近刚读了蔡东藩的<a href="https://book.douban.com/subject/3089584/">五代史</a>, 了解五代混乱的历史, 感叹大多数主子昏庸误国, 英明的主子也多少有瑕疵的同时, 也将心比心, 自己是否是一个英明的帝王. 答案却是否定的. 我是一个懒惰的人, 没有意志力的人, 不喜欢批评, 只喜欢表扬. 如果把自己放在帝王的位置上, 一定是个亡国之君了. 想想还是很可怕的.</p>
</blockquote>
<p>当时真的是处于人生中一个非常没有自信的阶段。大三的寒假，刚刚被编译虐了一学期，面临未来人生道路的选择，自己完全没有信心把握自己的未来，甚至对人生的职业规划完全没有一个清楚的认识。现在近2年过去了(当时是农历新年写的)，不敢说我的境遇好了多少，但起码对未来，对自己有了更清醒的认识。自信心也逐渐建立起来了。<br>现在如果重新回答17年时的问题，我会有不一样的答案。</p>
<p>将心比心, 自己是否是一个英明的帝王。<br>我想，我可能会成为宋仁宗那样的君主。虽然在唐宗宋祖、秦皇汉武看来，完全没有帝王的权威。但宋仁宗是真正的仁主，他在位的40年，北宋人才辈出，经济也发展到古中国的顶峰。他是一个读书人所期待的最理想的皇帝。感兴趣的同学可以更多地了解一下那个时代，那个皇帝。类似的帝王还有汉文帝、明孝宗。“仁”是他们的共同特点，也是我给自己的一个很高的评价。</p>
<h2 id="回顾与展望"><a href="#回顾与展望" class="headerlink" title="回顾与展望"></a>回顾与展望</h2><p>新的一年，既要坚持既往好的传统，又要摒弃坏的习惯，培养好的习性。</p>
<p>坚持一切以<strong>找一份好的工作</strong>为中心。</p>
<p>2018年我为此着实付出了不少努力，包括3次实习和多次实习面试。<br>3次实习分别是，17年9月到今年3月的偶数科技的云平台开发工程师，4月到6月在快手的推荐系统算法工程师，还有11月到目前的文远知行数据平台开发工程师。3次实习极大地让我接触到业界的需求和实际工作，提高了我的代码能力，最重要的是，帮助我更好地认识自己，从而作出合理的职业规划。<br>实习面试有：快手、face++、Microsoft、小红书、景驰、商汤。成功率大概只有一半，而且成功与否更多地和对方缺人程度相关。</p>
<p>来年要准备的：2019年暑期的实习，希望可以找个大厂(最好是跨国外企)历练历练。2019年后半年，有微软的冬季实习可以争取。已经得知Google的第一次电面会在一月末，好好为之准备吧。微软的暑期实习还没有消息，改天找师兄打探打探消息。</p>
<p>根据我本身的兴趣和市场需求，我确认后端的软件工程师(高级点的称呼叫做架构师)是我今后的职业方向。<br>因为经过4年半时间的探索，我发觉我对<strong>计算机系统</strong>是真的感兴趣，比如数据结构、计算机组成、操作系统、编译器、计算机网络这些基础设施。相反，对计算机科学不是很感冒，尤其是最近几年特别火的CV/NLP，经过简单的尝试(其实也就是上了斯坦福的机器学习网课和视觉的网课CS231n)，我认为虽然这些研究确实很震撼，也挺好玩的，但比不上计算机系统带给我的快感。<br>其次，从市场上的需求来说，软件工程师(SDE)的需求永远是最大的，虽然今年所谓的算法岗很火，但其实这个岗位从名字到工作内容都很可笑，明明就是不同领域的SDE嘛。弄的名字听起来和科学家一样。说到名字，我想起了MIT对CS的解释</p>
<blockquote>
<p>其实CS(Computer Science)根本就不是Science，更多的是Engineering或是art。<br>– <a href="https://www.bilibili.com/video/av8515129">CS61A</a></p>
</blockquote>
<p>根据自己的爱好和性格，我想外企是一个更适合我成长的平台。一是不用加班，比较强调work-life balance。虽然比不上美帝的公司，但比起国内互联网公司要强好多呀。二是可以专心写代码，享受coding的乐趣。外企相对来说氛围更宽松，技术气息也更浓厚。当然选择外企也就意味着放弃国内互联网公司快速成长的机会，财务自由的可能。我想我完全可以接受。我本身并不是一个野心很大的人，能够开开心心工作，享受coding，回家后陪老婆孩子，就是我向往的生活了。<br>尤其是在文远知行实习的这段时间，见证了众多的大佬和同事为了事业和财富而奋斗，却置家庭和生活于不顾。这样的人我是很佩服的，也尊重他们的选择。但我做不到，这不是我想要的生活。我需要从家庭和生活中汲取能量，才能更好的工作，我也想活的时间更久些。<br>这样的讲起来的话，其实技术移民可能是更适合我发展的一条道路。不过我现在对相关信息了解的还不清楚，留学、找工作、抽签证、绿卡这条更便捷的路线也已经与我无缘了。</p>
<p>说到留学，还有一个问题我想要回答一下，要不要读博。我的观点是要的，但什么时候读、在哪里读就很值得考虑了。</p>
<p>首先，因为我认为我对计算机系统是真正喜爱的，自己也有耐心深入地研究，读博之后无论是继续从事开发工作还是教书育人，都是不错的选择。我本身很看中自己的impact，如果因为自己可以给社会或他人带来一点积极的影响，我就很开心了。</p>
<p>其次，获得博士学位的过程本身是一种很系统的科学训练。这种训练之后不仅可以用在科研上，对解决问题也有帮助。这也是快手的大mentor的观点。</p>
<p>最后，博士学位本身的价值。作为一个普通人，博士学位的好处远大于一个牛人。无论是可以有个title，还是别人的重视，都是无形中的价值。</p>
<p>那什么时候读呢？我认为当然越早越好，但是宁缺毋滥。所以，我需要先工作若干年，然后才能找到好的机会，去读名校牛导的博士。争取40岁之前获得博士学位吧。</p>
<h2 id="2019-resolution"><a href="#2019-resolution" class="headerlink" title="2019 resolution"></a>2019 resolution</h2><p>之前总结和展望了一大堆大道理，最后却没有具体的计划和愿景？还是需要有的，虽然我认为上面那些对自己的认识才是更重要的。这些resolution很具体，是最理想的情况了，如果最后能实现80%，我就很满意了。因为具体的计划受影响的因素众多，也有自己不能加以控制的。</p>
<ul>
<li>健康的身体和良好的生活习惯。老生常谈了，但每年还是会给自己提个醒。因为你跑的速度已经比不上同行了，但你可以比他们跑的时间更长呀。</li>
<li>一段大大厂(大师兄的说法，即指谷歌、微软等大厂，与BAT区分)的暑期实习，争取获得良好印象，得到return offer</li>
<li>一段海外的交换经历，获得对进入外企有用的能力和经历</li>
<li>进一步深入计算机系统 和 算法上的进阶。一方面是为了兴趣，另一方面更重要的是提升专业技能，为找工作做准备。<ul>
<li>LeetCode 300+题。今年做了115道，虽然绝大多数都是Easy难度的题目，明年的努力方向在于可以在限定时间内解决Medium的题目。</li>
<li>书籍：<ul>
<li>CTCI(Cracking the Coding Interview)，美帝程序员准备面试的神书</li>
<li>剑指Offer，国内程序员准备面试的神书</li>
<li>CSAPP，CMU镇校神课及其参考书</li>
<li>SICP，计算机程序的构造和解释</li>
<li>C++ Primer, 精通一门面试/工作语言</li>
<li>算法 第四版，基础算法</li>
<li>算法导论，同样是算法</li>
<li>编程之美，面试和算法</li>
<li>设计模式，OOP</li>
</ul>
</li>
<li>多参加些实际的面试</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 summary and 2020 resolutions</title>
    <url>/2020/02/20/2019-summary-and-2020-resolutions/</url>
    <content><![CDATA[<p><a href="https://youngforest.github.io/2020/02/20/2019-summary-and-2020-resolutions/">转发自我的博客</a></p>
<p>2020年注定对我是一个不平凡的一年，主要原因在于我面临着毕业和求职的关口。这一关口是我近2年面临的最重要的挑战和任务，我也为之筹备良久，期待可以厚积薄发。然而事实却并不如愿。</p>
<h2 id="2019年工作回顾"><a href="#2019年工作回顾" class="headerlink" title="2019年工作回顾"></a>2019年工作回顾</h2><p>在<a href="https://youngforest.github.io/2018/12/12/2018-summary-and-2019-resolutions/">去年的规划</a>中，我写了自己对2019年的规划和畅想。</p>
<p>LeetCode 刷题任务超额完成，如今已经刷了800+道了。</p>
<p>C++的学习虽然没有按照预期学完C++ Primer，但是基本学完了 Effective C++系列 和 C++ Standard Library。也算是成为我的主语言了。（最近在搞Rust，学完C++后学Rust有很多好处，2者有许多共性。不过这次折腾更多的是兴趣使然，不会改变C++是我的主语言的身份。<br>CTCI 基本看完。<br>其他的书就几乎没有进展了，愧疚。</p>
<p>实际的面试，3月份参加了 字节跳动广告系统 的 后端开发实习生面试，因为实习时间原因没过。8月底参加了为期一周的字节跳动夏令营的工程组。这个夏令营我只在6月份参加笔试，由于笔试成绩还可以，免了面试。11份收到参加A day with Google的邀请，但由于我已人在比利时，当然无法参加。好是遗憾。</p>
<p>大厂的实习依旧是0。上半年在商汤实习了半年，得到了一些技术上的历练。但总体还说不是很满意。首先，实习对课题研究起了负面作用，并没有之前预计的两者兼顾。其次，商汤的环境也不大令我满意。科研实力业界有目共睹，但工程技术方面的实力着实一般，内部项目管理也相当混乱。最后，商汤本身是个中厂。规模和产品、技术和快手都差一个档次。</p>
<p>强身健体方面更是不进则退，办了的健身卡，一年也去了只有大约20次。</p>
<p>去年的OKR完成度60%吧。</p>
<p>在这一年里，我也发现了自己一些比较明显的缺点：</p>
<h3 id="学习脱离社交"><a href="#学习脱离社交" class="headerlink" title="学习脱离社交"></a>学习脱离社交</h3><p>由于家庭环境的整体内向和“万般皆下品，唯有读书高”的家训，长久以来，我养成了独立思考学习的习惯。这点在过去看来并不是缺点，反而是优点，可以向内更多地寻求力量。然而，到了研究生阶段，这却成了一个大问题。研究生不比从前，你不需要刻意在学习方面寻求社交，也不会过分脱离社交。因为周围的同学大体上学习内容和学习要求与你相同，大家彼此之间的交流就不可避免。而现在，尤其是研一过后连课程也没了，只有科研任务。我的研究课题又是只有我一个人做的。之前实验室有很多人做，最多时多达4人，都成了一个课题组。然而最近该走的走，该毕业的毕业，只剩下我一个人苦苦支撑。如果我不去寻求社交帮助，真的是没有人会和我交流。<br>脱离社交的坏处是明显的。我经常会剑走偏锋，在错误的道路上越走越远；得不到情感支持和技术支持；懒惰、退缩的情绪被放大。</p>
<p>可行的解决方法：<br>无论时候求职还是课题研究，多与同学进行交流。虽然大家的研究课题不同，但可以提供起码的情感支持和技术建议。<br>在工作中多与老师沟通。我本人与老师的沟通特别少，得益于从小对老师的恐惧之情。虽然大学老师和之前的老师差别很大，很大程度上亦师亦友，但我小学和初中被老师体罚的阴影却一直挥之不去，成为我现在与导师交流的心里障碍。<br>提高沟通的欲望和经验。之前在与人的接触交流中，我的宗旨是能少说话就少说话，能关系不进一步就保持原地。这一宗旨是时候发生改变了。我的目标是维护一个庞大的普通朋友的圈子，至少50人，包括维持原先认识的人和今年新认识的人。标准是一年累计的交流时间超过1个小时，或微信交流条数超过50条。</p>
<h2 id="2020年美好生活的向往"><a href="#2020年美好生活的向往" class="headerlink" title="2020年美好生活的向往"></a>2020年美好生活的向往</h2><p>继续以毕业和找工作为重心。两手都要抓，双手都要硬。</p>
<ul>
<li>坚持每天刷题，培养手感和bug-free, debug能力。今年争取攻克hard题目，在半小时内可以解决绝大多数hard题目。</li>
<li>大厂实习。认真准备暑期实习面试，高质量地完成可能是有生之年最后一次实习了。目标是谷歌、微软、hulu等外企。</li>
<li>求职和面试准备。秋招时可以找到满意的工作，有个体面的饭碗。</li>
<li>完成毕业设计和导师的要求，绝不耽误毕业。目前看可能需要延期半年。这也应该是有生之年最后的科研时光了。</li>
<li>强身健体。希望穿衣显瘦、脱衣有肉。体重增重到70公斤。把剩下的3颗智齿拔了，右下槽牙加冠。</li>
</ul>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 summary and 2021 resolutions</title>
    <url>/2020/11/25/2020-summary-and-2021-resolutions/</url>
    <content><![CDATA[<p>转发自<a href="https://youngforest.github.io/2020/11/25/2020-summary-and-2021-resolutions/">我的博客</a></p>
<p>今年也年终总结有些早，还没有步入12月份。不过因为今天刚交了大论文查重，虽然很多事儿要做，但完全没有工作的心情。不如就利用这种烦躁的心情写个年终总结的初稿，不知道会不会受影响。</p>
<p>2020年从一开始就是注定不平凡的一年，之前我只预见到因为我要毕业，只是对我而言，没想到一场席卷全球的疫情使得它成为了对所有人都很有挑战的年份。</p>
<h2 id="2020年工作回顾"><a href="#2020年工作回顾" class="headerlink" title="2020年工作回顾"></a>2020年工作回顾</h2><p>首先，我对照我<a href="https://youngforest.github.io/2020/02/20/2019-summary-and-2020-resolutions/">去年写的展望</a>，回顾一下完成度。</p>
<p>每天刷题算是如愿完成，尤其是加入<a href="https://wisdompeak.github.io/lc-score-board/">残酷打卡群</a>后，刷题还可以领红包真开心。在群里还可以认识一堆大佬，个个都是人才，说话又好听。研究生2年半刷题1k+，LeetCode周赛参加近100场，世界排名一度进入前500，rating稳定在2200+，rating排名稳定在前1000，周赛一半以上可以完成4题，保证3题，排名经常前500，最高前100，国服也3次拿礼物，虽然不值钱，但很开心。残酷群排名最高11名，稳定前40，偶尔稳定前20。这些成绩还是让我小骄傲的。虽然别人可能并不会很看重这些，但我自己乐在其中，取得了成就感，形成了刷题的正反馈。<br>但之后我不会投入更多的时间刷题了，如今已经过了刷题高峰，暂时没有找工作的压力，而且刷题的水平已经到了一定高度，刷题的收益没之前那么大了。之后计划每日做一两题保证手感，周末争取每周打周赛，继续在残酷群当镰刀。更多时间会被投入到其他技能上，如工作技能、系统设计、英语口语等。</p>
<p>外企大厂也如愿完成。虽然由于疫情原因，第一志愿Google全面取消了今年的暑期实习项目，本来一面都过了。甚至之后的秋招也直接没了。不过如愿到第二志愿亚马逊参加了6个月的远程实习。虽然不是一开始报的后端岗位，而是iOS客户端岗位，但是好在亚麻SDE都是全栈的，工作中也有不少涉及后端的工作；自己这几个月的实习体验也还不错；之后也有不少转组和transfer的机会。<br>之后如果不出意外的话还是会转正留任。</p>
<p>今年求职主要分2个部分，春季的实习面试和秋招。<br>因为目标明确再加上准备充分（4段实习经历+1k道leetcode+科班背书），虽然上半年疫情半年呆在家，不少公司都缩招了，尤其是外企，我仍然拿到不少不错的offer。最后综合考虑（也是一直以来的规划导致）选择在亚马逊这样的外企大厂实习和留任，放弃了国内互联网企业和高薪的独角兽。总体求职和面试过程加结果都比较顺利和满意。</p>
<p>科研和毕设这块也十分满意。虽然上半年花了不少功夫写了篇小论文投了3m，但惨被拒，但完成小论文过程中的实验和经历很好的帮助我按时写完了大论文，今天刚递交查重，不出意外可以按时毕业不需要延毕。最近一年也是研究生涯中最投入科研的一年，虽然没啥成果，但也尽力了。自己真的不是做学术这块料。还是好好做个软件开发工程师实在。</p>
<p>12月更新。按时毕业的期望还是出了意外。由于去年下半年在外交换，和导师商量下学期开学再开题。然而，到了下学期竟然直接半年没开，也是醉了。导师一直拖到8月份才给我开了题。到12月答辩时不足6个月，不符合学校规定，无法参加答辩。只能改为明年6月的第二批答辩。<br>随之带来一系列影响，最大的还是只能7月份才能正式入职公司。<br>原来以为马上就要脱离苦海了，没想到又要多呆半年。学院也是最后一步才卡你。早些告知我不能按时答辩，我之前也不用为了12月的答辩那么赶了。学院领导也是不顾学生的死活和疫情的事实，只关心自己的乌纱帽。我就差从学院跳楼了。导师也找学院领导求情了也是不行。</p>
<p>锻炼身体却像往年一样没有进展。穿衣一直显瘦，脱衣一直没肉。智齿也因为疫情和学业实习太忙的原因没能处理。倒是找了一个经常锻炼身体的女朋友，以后可以一起强身健体，奔向美好幸福生活。</p>
<p>总的来说，虽然今年充满了黑天鹅和坎坷，也没完美实现预期，但总体上还是十分满意，给自己点个赞。继续加油！</p>
<h2 id="2021年美好生活的向往"><a href="#2021年美好生活的向往" class="headerlink" title="2021年美好生活的向往"></a>2021年美好生活的向往</h2><ul>
<li>顺利毕业。</li>
<li>和老婆小可爱一起开开心心。</li>
<li>业余时间投入到需要的技能上，主要包括工作技能、系统设计、英语口语等。</li>
<li>认真实习和工作，平安度过试用期。为之后升职L5做准备。</li>
<li>解决智齿和其他牙齿问题。</li>
<li>坚持每日刷题，当作一种爱好和习惯。</li>
</ul>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 暑期实习 求职总结</title>
    <url>/2020/04/30/2021-summer-intern-interview-summary/</url>
    <content><![CDATA[<p>从在牛客网发暑期实习的第一篇面经开始，到现在已经过去近2个月了。中间陆陆续续参加了8个厂的招聘。岗位均为后端/服务器开发。base地点为北京。</p>
<h2 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h2><h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><p><a href="https://www.nowcoder.com/discuss/371946">一面</a>就凉。字节跳动还是一家和我很有缘分，我也很喜欢的一家公司。去年参加过一次广告系统的暑期实习面试，经历残酷四面。面到lead力哲。最后因为实习时间不合适没去。去年暑假还参加了ByteDance 的夏令营。由于是长久以来的第一次面试，准备不足、发挥也不是很好。算法题 编辑距离 没做出来，遂一面即凉。</p>
<h3 id="微软"><a href="#微软" class="headerlink" title="微软"></a>微软</h3><p>找了之前在微软工作的一位师兄，托他又联系到正在微软工作的一位同事，做了内推。18年时曾面过一次<a href="https://youngforest.github.io/2018/06/01/suzhou-microsoft-interview/">苏州微软</a>, 当时水平有限，无奈地凉了。今年踌躇满志，想要一雪前耻。没想到同样翻船了。不过吸取了很重要的经验，不要吹牛打过比赛。<br>一面面试官问我打过什么比赛吗？我当时作死回答说，打过一些LeetCode、kickstart、codeforces、atcoder。实际上，只有LeetCode我是经常参加周赛，kickstart参加每月的轮次（如果时间合适的话）。其他平台的赛事加起来也只有几场。面试官因此误解了我的实力，认为是cf水平的（实际上，我cf的rating都不到1500）。只问了我系统设计的问题，没有手撕代码，我尽管在LeetCode上刷了900题，也没发发挥。<br>二面面试官上来就问了2道很难的算法题，感觉是准备给ACM选手的。都怪我一面时吹了牛，二面被安排了。</p>
<ul>
<li><a href="https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/">find the closet point pair</a></li>
<li>在平面上找到任意直线，将N个点分为数量相等的2部分</li>
</ul>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><h3 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h3><p>通过了电话一面，但无奈因为疫情的原因，Google中国取消了暑期实习项目。我的面试进程也止于一面了。</p>
<h3 id="钉钉"><a href="#钉钉" class="headerlink" title="钉钉"></a>钉钉</h3><p>因为之前以为蚂蚁金服是独立的公司，所以投了蚂蚁和钉钉。正式在阿里系统里投递时，才得知只能投递一个。因为蚂蚁在北京，遂选择了蚂蚁。录入系统前参加了一次面试。</p>
<p><a href="https://www.nowcoder.com/discuss/375152">钉钉一面</a></p>
<h2 id="成功上岸"><a href="#成功上岸" class="headerlink" title="成功上岸"></a>成功上岸</h2><h3 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h3><p>收到意向书。今年暑期情况不明，也不知道是否可以会北京参加实习。</p>
<p><a href="https://www.nowcoder.com/discuss/377900">一面</a><br><a href="https://www.nowcoder.com/discuss/390413">二面</a><br><a href="https://www.nowcoder.com/discuss/392312">三面</a><br><a href="https://www.nowcoder.com/discuss/399613">四面</a></p>
<h3 id="米哈游"><a href="#米哈游" class="headerlink" title="米哈游"></a>米哈游</h3><p>通过了面试，但是因为暑假不可能去上海实习，遂拒绝了。</p>
<p><a href="https://www.nowcoder.com/discuss/387235">一面</a><br><a href="https://www.nowcoder.com/discuss/399642">二面</a><br><a href="https://www.nowcoder.com/discuss/402613">三面</a></p>
<h2 id="进行中"><a href="#进行中" class="headerlink" title="进行中"></a>进行中</h2><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><p>由于工作岗位base地点的原因，换着面了很多组。都聊到HR了，但北京这边就是恰好没有HC。</p>
<p><a href="https://www.nowcoder.com/discuss/378468">一面</a><br><a href="https://www.nowcoder.com/discuss/384452">二面</a><br><a href="https://www.nowcoder.com/discuss/385528">三面</a><br><a href="https://www.nowcoder.com/discuss/386661">四面</a><br><a href="https://www.nowcoder.com/discuss/387415">五面</a><br><a href="https://www.nowcoder.com/discuss/396952">七面</a><br><a href="https://www.nowcoder.com/discuss/406795">八面</a><br><a href="https://www.nowcoder.com/discuss/409853">九面</a><br><a href="https://www.nowcoder.com/discuss/419602">笔试</a></p>
<h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><p>参加了线上的笔试，难度不大。LeetCode medium吧。</p>
<h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>参加了线上笔试。效果不佳。5道编程题，只A了2道，有2道过了一半，还有最后一道最后一直没有调出来。题目看起来难度不是很大，但做的效果实在不行。感觉要凉。<br>美团还是实验室亲师兄推我的，感觉辜负了期望。</p>
<h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><p>由于2位很强的亲师兄在美团，我还是被抬进面试了。而且面试也没问很难的题目，感觉被大佬担保了。瑟瑟发抖。</p>
<p>字符串查找。以为要写KMP，这不抄模版哪里是最后10min能写出来的。最后解释了下，写了个N*M的brute force的解法。</p>
<h4 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h4><p>twoSum，找到所有和为target的两数下标对。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL实践进阶</title>
    <url>/2018/05/07/Advanced-SQL-practice/</url>
    <content><![CDATA[<p>这一周在公司写了很多很长功能很复杂的sql语句，深感自己的数据库和SQL学的还只是皮毛，完全没法满足工程上的要求。<br>负责带我的二mentor对SQL比较也精通，对我有很多指导和建议。<br>没有对比就没有伤害，自己的菜和师兄的强让我知耻而后勇，有了进阶SQL的想法和行动。</p>
<span id="more"></span>
<p>我被推荐的2份教程（感谢快手师兄和二mentor）：</p>
<ul>
<li>sql必知必会</li>
<li><a href="http://www.runoob.com/sql/sql-constraints.html">runoob</a></li>
</ul>
<p>其中《sql必知必会》我系统的看过一遍，runoob教程只是大致浏览一遍。<br>我认为只看一个教程就够了。<br>runoob的优点是可以在网站提供的线上数据库进行测试和练习，这一点和<a href="https://www.w3schools.com/sql/">w3school的教程</a>有些像。<br>《sql必知必会》的优点是内容比较多，作者会传授一些写sql的经验，还会涉及到不同数据库的移植性和区别。</p>
<p><a href="https://leetcode.com/problemset/database/">leetcode上有42道Database的面试题目</a>，有时间一定要刷一刷。</p>
<h1 id="实践中遇到的问题"><a href="#实践中遇到的问题" class="headerlink" title="实践中遇到的问题"></a>实践中遇到的问题</h1><p>由于我的岗位是推荐组的算法工程师，有大量的数据挖掘的需要。<br>而且写的不是纯sql，而是<a href="https://cwiki.apache.org/confluence/display/Hive/Home">Hive</a>-sql。<br>Hive上存在很多限制和挑战，比如不能在select中嵌套select子句，<code>select 2 * (select 3);</code>就是不可以的（最后摸索出得解决方案是：使用聚集函数或列之间的可计算进行需要的计算，这就很考验<code>union</code>或<code>join</code>的灵活使用了。）；数据量特别大，每次查询很耗时（学会了用小的查询验证想法，从内到外层层验证，还有在‘jupyter notebook’上进行查询和计算）。</p>
<h1 id="回答面试中的问题"><a href="#回答面试中的问题" class="headerlink" title="回答面试中的问题"></a>回答面试中的问题</h1><p>一面的小哥哥当时问我：你会SQL吗？</p>
<p>我：会，而且我之前还有在数据库公司的实习经历。</p>
<p>小哥哥：那你说说‘left join’，’right join’，’inner join’的区别。</p>
<p>我：不知道…</p>
<p>小哥哥：那你知道partition吗？</p>
<p>我：这个我也不知道。</p>
<p>小哥哥：你会的SQL仅限于上过的“数据库原理”和“课程设计”课吗？</p>
<p>我：是的，而且因为一段时间不用有些生疏了。</p>
<p>小哥哥就没再问SQL相关的内容了。</p>
<p>经过一周的工作和SQL的重新系统学习，我现在可以回答这两个问题了。</p>
<h3 id="‘left-join’，’right-join’，’inner-join’的区别"><a href="#‘left-join’，’right-join’，’inner-join’的区别" class="headerlink" title="‘left join’，’right join’，’inner join’的区别"></a>‘left join’，’right join’，’inner join’的区别</h3><p>‘inner join’即内联结，对于不匹配的项，不存在于联结结果中；’left join’，左外联结，如果左边的项在右边的表中没有匹配项，仍存在一条记录于联结结果中，此时右边表列均为NULL；’right join’，右联结与之类似。事实上，’left join’和’right join’可以互换，只是联结的左右两表也需要互换位置。</p>
<h3 id="partition的概念"><a href="#partition的概念" class="headerlink" title="partition的概念"></a>partition的概念</h3><p>partion是为了加快查询速度，而将一个表分成不同的区。<br>限制是，select时，被partition的列必须写在where里作为filter。</p>
]]></content>
      <categories>
        <category>intern</category>
      </categories>
      <tags>
        <tag>tech</tag>
        <tag>kuaishou</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴 蚂蚁金服 后端开发 暑期实习生</title>
    <url>/2020/03/09/Alibaba-Ant-backend-intern-interview/</url>
    <content><![CDATA[<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>time: 2020-03-09 16:45:44</p>
<h2 id="简历经历"><a href="#简历经历" class="headerlink" title="简历经历"></a>简历经历</h2><p>对各段项目的介绍。根据项目随时提问，如RESTful API, SOAP之类的知识。</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>HashMap 的实现</p>
<ul>
<li>Hash值如何映射到桶中？？？？</li>
<li>hashcode和equals函数的要求（修改equals为什么必须要修改hashcode)</li>
<li>扩容机制和均摊复杂度</li>
</ul>
<p>Java 开箱 和 装箱 机制。（一开始没反应过来，说不会。在面试官的提醒下，基础类型 和 对象类型 的关系，我才会了。因为之前看的都是英文材料，box和unbox，对中文不是很敏感。）</p>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>编辑距离的递推公式</p>
<p>K-means算法。没答好，很久之前学过机器学习。但是因为放下的时间太久了，几乎都忘记了。</p>
<h2 id="对面试官的反问"><a href="#对面试官的反问" class="headerlink" title="对面试官的反问"></a>对面试官的反问</h2><p>问面试官的问题：我投递的岗位是 后端开发，是否需要复习机器学习的算法？</p>
<p>答：这和公司的产品线有关，蚂蚁金服的产品和机器学习密切相关。开发不需要对机器学习有很深的了解，但需要有基础的了解。如果会的话，有加分。</p>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>time: 2020-03-24 16:20:56</p>
<p>距离一面已经2周了，昨天收到电话，约了今天下午3点的电话面试。时长半个小时。</p>
<p>商汤实习项目。</p>
<p>ArrayList（自增数组）实现，底层链表和数组的区别。</p>
<p>1千万个数共10M，内存只有2M, 寻找出现次数最多的10个数字。<br>答：先分组，可以按照数字的个别数位来分成小组，在每个组里寻找这10个数字。在合并，寻找总的10个数字。</p>
<p>看了哪些书？</p>
<p>熟悉SQL是个啥意思？</p>
<p>并发的知识:</p>
<ul>
<li>ConcurrencyHashMap</li>
<li>无锁编程</li>
</ul>
<p>职业规划。</p>
<p>大概回答的不是很好，面试官催促我完成笔试，要不然只能问我简历上的内容。笔试完会有人再联系我。今天下午状态不大好，没发挥好。没有手撕代码环节，差评～</p>
<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><p>阿里笔试有多场。我做的是3.25这天的。</p>
<p>笔试难度不大，在牛客网上完成，2道算法题，LeetCode medium难度。拿了满分，导致貌似阿里那边觉得我很优秀，后面的流程就顺风顺水，特别想我过去。好多同事和lead加我微信，打电话劝我。所以最后拒阿里offer时还挺不好意思的。</p>
<blockquote>
<p>给3xn的矩阵，每列选择其中的一个数, 形成最后的数组。<br>使得最后的</p>
</blockquote>
<blockquote>
<p>$$\sum_{i = 0}^{n-1} |b_{i+1} - b_i|$$<br>最小。<br>输出最小的这个值。</p>
</blockquote>
<p>DP求解即可。</p>
<p>时间复杂度: O(3N),<br>空间复杂度: O(3).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">last_dp</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">matrix</span>(<span class="number">3</span>, vector&lt;ll&gt; (n));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">dp</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dp_index = <span class="number">0</span>; dp_index &lt; <span class="number">3</span>; ++dp_index) &#123;</span><br><span class="line">            dp[dp_index] = <span class="built_in">abs</span>(matrix[dp_index][i] - matrix[<span class="number">0</span>][i<span class="number">-1</span>]) + last_dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                ll new_value = <span class="built_in">abs</span>(matrix[dp_index][i] - matrix[j][i<span class="number">-1</span>]) + last_dp[j];</span><br><span class="line">                <span class="keyword">if</span> (new_value &lt; dp[dp_index]) &#123;</span><br><span class="line">                    dp[dp_index] = new_value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last_dp = <span class="built_in">move</span>(dp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;  <span class="built_in">min</span>(&#123;last_dp[<span class="number">0</span>], last_dp[<span class="number">1</span>], last_dp[<span class="number">2</span>]&#125;) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>一个n x m的矩阵，每列每行都是等差数列，公差为整数。<br>输入n x m个数，如果为0表示不知道，否则知道。<br>q个查询，特定位置（下标1开始）的值是否可确定。</p>
</blockquote>
<p>递归求解，进行推测即可。可以用一些数组维护：每行/列是否已经被推断、每行/列已知道的数的下标、行列信息。</p>
<p>时间复杂度: O(N * M),<br>空间复杂度: O(N * M).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt;  n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">A</span>(n, vector&lt;<span class="keyword">int</span>&gt; (m, INF));</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">row</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">row_ok</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">col</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">col_ok</span><span class="params">(m, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; fill = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> value) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        A[i][j] = value;</span><br><span class="line">        <span class="keyword">if</span> (col_ok[j] &amp;&amp; row_ok[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!col_ok[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (col[j] == <span class="number">-1</span> || col[j] == i) &#123;</span><br><span class="line">                    col[j] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    col_ok[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> diff = (A[i][j] - A[col[j]][j]) / (i - col[j]);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> r = i - <span class="number">1</span>; r &gt;= <span class="number">0</span>; --r) &#123;</span><br><span class="line">                        <span class="built_in">fill</span>(r, j, A[r + <span class="number">1</span>][j] - diff);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> r = i + <span class="number">1</span>; r &lt; n; ++r) &#123;</span><br><span class="line">                        <span class="built_in">fill</span>(r, j, A[r - <span class="number">1</span>][j] + diff);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!row_ok[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] == <span class="number">-1</span> || row[i] == j) &#123;</span><br><span class="line">                    row[i] = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    row_ok[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> diff = (A[i][j] - A[i][row[i]]) / (j - row[i]);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> c = j - <span class="number">1</span>; c &gt;= <span class="number">0</span>; --c) &#123;</span><br><span class="line">                        <span class="built_in">fill</span>(i, c, A[i][c + <span class="number">1</span>] - diff);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> c = j + <span class="number">1</span>; c &lt; m; ++c) &#123;</span><br><span class="line">                        <span class="built_in">fill</span>(i, c, A[i][c - <span class="number">1</span>] + diff);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v;</span><br><span class="line">            cin &gt;&gt; v;</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fill</span>(i, j, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r, c;</span><br><span class="line">        cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        --r;</span><br><span class="line">        --c;</span><br><span class="line">        <span class="keyword">if</span> (A[r][c] == INF) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Unknown&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; A[r][c] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测评"><a href="#测评" class="headerlink" title="测评"></a>测评</h1><p>笔试没难倒我，测试却花了我不少时间。<br>主要是测试</p>
<ul>
<li>语文：阅读理解、成语使用、归纳和排除 10min</li>
<li>数学：表格、图、经济用语 10min</li>
<li>智商：看图找规律 10min</li>
<li>性格：是否抗压、反社会 30min</li>
</ul>
<p>全靠高中学习到的知识和技能。智商就天生的呗。<br>据说和公务员的考试很像，行测。有了解的朋友可以看看。</p>
<p>应该也不会用测评去筛人，又不是考公务员，手撕代码才是王道。</p>
<h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1><p>time: 2020-04-03 11:36:14</p>
<p>昨天电话约了今天的电话面试，11:30，聊了40分钟。<br>昨天下午做了阿里的线上笔试，晚上做了测评。</p>
<p>面试官很NICE，还加了我微信进行沟通。<br>主要聊了项目，还有一些数据处理的知识和Java的了解。</p>
<ul>
<li>数据预处理，对缺失值的处理</li>
<li>给一个信用评估的数据，如何利用和上线</li>
<li>Java了解程度和使用，Spring boot</li>
</ul>
<p>最后问了英语怎样，口语如何。可能是因为对方是 国际化事业群 吧。</p>
<p>我最后问了面试官所在的组和业务。<br>面向海外的个人信贷业务，类似花呗和借呗。</p>
<h1 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h1><p>time: 2020-04-03 15:22:02</p>
<p>上周和HR约了这周的交叉面。本来是周一的视频面试，后来面试官出差了，换了一个面试官，改约周三（4.1）。而且新的面试官很忙，没有约具体时间，只是让我下午和晚上等电话。晚上7点半收到电话，聊了40min。</p>
<p>面试因为只是电话面试，无法手撕代码，只问了一个简单的算法题：桶排序。<br>除此之外都是项目，但项目问的很深，很细节。我简历上的实习项目都是当时花了很大功夫完成的，但无奈过去的时间过于久远，很多细节和考虑一时也无法答上来。而且当时做实习的时候更多的是着眼眼前遇到的困难，而不是深入了解整个公司的架构，所以答的并不是很好。面试官问了很多BQ(Behavior Question)的问题。如：</p>
<ul>
<li>你之前项目上遇到的最大的困难是什么？</li>
<li>你实习时发生的最难过的事是？</li>
<li>你之前坚持过最久的事是？<br>了解的都很细，很多问题我从未遇到，也没有认真思考过。之前听说外企才有BQ，而且也大都是HR问。所以虽然不手撕代码，但全程依然很累。</li>
</ul>
<p>最后面试官问 我还有什么问题吗？我竟然说“没什么问题了，我家长叫我吃饭呢！”这样的大实话。哈哈～</p>
<p>昨天接到电话，又约了下周二(4.7)的HR面。愿一切顺利。</p>
<p>现在最担心的是因为疫情的原因，暑假都不一定有了，暑期实习恐怕也去不了。</p>
<p>Google的面试进度也停了3周。说是因为实习生招收政策的调整，要推迟到4月中。听过美国疫情很严重，发的offer很多都鸽了。难倒谷歌中国也要减少HC，有同学知道内部消息不？我苦呀！</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>Alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里钉钉 服务器开发 暑期实习生 面试</title>
    <url>/2020/03/04/Alibaba-Dingding-backend-intern-interview/</url>
    <content><![CDATA[<p>通过钉钉电话视频面试，手撕代码通过阿里在线平台完成。</p>
<p>算法题2道：</p>
<p>1. 实现一个双向链表的数据结构。</p>
<p>2. twoSum。寻找数组中2数和等于target的下标。</p>
<p>难度属于LeetCode Easy吧。但是面试时，需要自己和面试官询问沟通好理解题目。并且面试官很注重代码的整洁和效率。比如 函数参数的检查，实现本身的预设。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//评测题目: 实现一个简单的双向链表，要求完成 node和list的构造函数，以及 list类的void push_back(node*), void remove(node*) 方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	node* prev;</span><br><span class="line">	node* next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">node</span>() &#123;</span><br><span class="line">      prev = <span class="literal">nullptr</span>;</span><br><span class="line">      next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	node* head;</span><br><span class="line">	node* tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">list</span>() &#123;</span><br><span class="line">      head = <span class="literal">nullptr</span>;</span><br><span class="line">      tail = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(node* n)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 假设n不在list中</span></span><br><span class="line">    	<span class="keyword">if</span> (n) &#123;</span><br><span class="line">          <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">          	tail-&gt;next = n;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = n;</span><br><span class="line">          &#125;</span><br><span class="line">          n-&gt;prev = tail;</span><br><span class="line">          tail = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(node* n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">auto</span> current = head;</span><br><span class="line">      <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current == n) &#123;</span><br><span class="line">          <span class="comment">// find</span></span><br><span class="line">          <span class="keyword">if</span> (current-&gt;prev &amp;&amp; current-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = current-&gt;prev;</span><br><span class="line">            <span class="keyword">auto</span> n = current-&gt;next;</span><br><span class="line">            p-&gt;next = n;</span><br><span class="line">            n-&gt;prev = p;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;prev) &#123;</span><br><span class="line">            tail = current-&gt;prev;</span><br><span class="line">            tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            current-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;next) &#123;</span><br><span class="line">            head = current-&gt;next;</span><br><span class="line">            head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">            current-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = <span class="literal">nullptr</span>;</span><br><span class="line">            tail = <span class="literal">nullptr</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给定一个vecotr&lt;int&gt;v和一个目标target，找到v中两个数字的和等于target，返回数字在原数组中的下标（多个解的返回任意一个即可），无解返回空vector。</span></span><br><span class="line"><span class="comment">//Example:  v=[7,11,2,15],target=9,</span></span><br><span class="line"><span class="comment">//因为nums[0]+nums[2]=7+2=9, </span></span><br><span class="line"><span class="comment">//return[0,2].</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; copy = v;</span><br><span class="line">    <span class="built_in">sort</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> current_sum = copy[left] + copy[right];</span><br><span class="line">    	<span class="keyword">if</span> (current_sum == target) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;copy[left], copy[right]&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_sum &lt; target) &#123;</span><br><span class="line">          ++left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">auto</span> values = <span class="built_in">helper</span>(v, target);</span><br><span class="line">  	<span class="keyword">if</span> (values.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> index =  <span class="number">0</span>;</span><br><span class="line">  	</span><br><span class="line">      <span class="keyword">if</span> (values[<span class="number">0</span>] == values[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">          <span class="keyword">if</span> (v[i]  == values[<span class="number">0</span>])  &#123;</span><br><span class="line">            ans[index] = i;</span><br><span class="line">            ++index;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">2</span>)</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">          <span class="keyword">if</span> (v[i] == values[<span class="number">0</span>]) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = i;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[i] == values[<span class="number">1</span>]) &#123;</span><br><span class="line">            ans[<span class="number">1</span>] = i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的主语言是C++，所以问了很多C++相关的题目。</p>
<p>从我的简历里，看了我的<a href="https://github.com/YoungForest">GitHub主页</a>。询问了最想介绍的项目。我介绍了自己大三时实现的<a href="https://github.com/YoungForest/C0Compiler">编译器</a>。然后询问了编译的一些过程和数据结构，如 词法分析、语法分析、中间代码生成、目标代码生成、优化，符号表、DAG图优化等。</p>
<p>C++中输入<code>&gt;&gt;</code>和模版嵌套时’&gt;&gt;<code>在编译时如何区分。我答应该是语法分析时就可以区别开。然后聊了些这个故事的历史，之前模版的</code>&gt;&gt;<code>必需写成</code>&gt; &gt;`才能编译通过。</p>
<p>C++ HashMap容器的实现，和hash值如何映射到桶中。<br>STL 中vector的扩容实现。<br>new 和 malloc的区别。<br>move语义和右值引用。<br>weak_ptr, shared_ptr, unique_ptr的区别。</p>
<p>平时对什么感兴趣，高级的数据结构:<br>Order tree, 线段树。</p>
<p>快排和堆排的实现。最小堆的维护。</p>
<p>进程和线程的区别。</p>
<p>锁的种类 和 读写控制。</p>
<p>Linux内存管理机制。</p>
<p>常用的shell命令。文件操作、进程信息(top, ps)、堆栈信息(lldb).</p>
<p>TCP丢包处理。这题我答的不好，大三下学的计算机网络很多知识都忘记了。</p>
<p>24点的智力游戏，4 4 10 10， （10 * 10 - 4) / 4。<br>我一开始以为是编程问题，答曰回溯。后来才发现是纯考智力。</p>
<p>职业规划。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>Alibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>阿姆斯特丹</title>
    <url>/2019/09/23/Amsterdam/</url>
    <content><![CDATA[<p>来到欧洲安顿下来的第一周，我们去了美丽的荷兰-阿姆斯特丹和周围的2座村庄。<br>由于是第一次出来玩，许多行程安排的有问题，花费也相对不菲。人均大概450欧。相比之下，一周之后的巴黎之旅只花了300欧，并且体验也更棒。<br>我认为荷兰绝对是欣赏北欧乡村风光的最佳地点。</p>
<p>本次成行人员：zfn, lxf, lsd, zjz（张导）和 我。</p>
<h2 id="第一天-落脚羊角村"><a href="#第一天-落脚羊角村" class="headerlink" title="第一天 落脚羊角村"></a>第一天 落脚羊角村</h2><p>第一天大多数 时间 都 花在路上了。因为张导住在鲁汶，所以我们选择在布鲁塞尔集合。因为是第一次出行，中间误了一趟车，并且开启了本次旅行的首次奔跑，为了帮张导赶车，在站台上3个人提着行李狂奔。鉴于之后的为了赶行程狂奔，本次狂奔只能算是前菜。<br>吸取 的教训是，安排行程要量力而为，不要对自己和队友太过自信。<br>由于 中途大量 时间浪费在火车站和等人上，我们晚上11点 才到达羊角村预定的民宿。最后的民宿离镇上有10min的车程，我们有5个人，打车不方便，最后打了一辆7座的车。开车的司机脾气也比较火爆，对我们换车貌似有些不满，开的比较猛，大家纷纷晕车。虽然路途颠簸，但到达 民宿后，感觉一切都是值得的。</p>
<p>首先，house的女主人超级nice。到达 鸟不拉屎的住处后，我先下车，和女主人聊了起来。因为她下腹比较胖，我很友善地问她是不是pregnant了？本想着和女主人套套近乎。没成想，女主人回复 不不，她已经有3个男孩子了。瞬间气氛变得很尴尬。不过女主人并不放在心上，继续很愉快的招待起我们。</p>
<p>在这里，我看到了多年未见的银河，甚至 有幸看到流星。也足见这里的偏僻程度。我们开心地就像一群孩子一样，在后院里看了一个多小时银河。银河真是太美了，我们这样的星空震撼的哇哇叫。自从大概 上小学后，我就再也没能亲眼看到银河了。足以原谅我的激动。天空真的是分外清澈，银河和各个星座清晰可见。随着我们在外面呆的时间越长，眼睛对光线越发适应，看到的星空越美。洁白的月亮也出现在地平线上，并不与银河争光，所以银河就像一道牛奶的带子一样清晰可见。难怪叫做milky way. 因为照片拍不出银河的效果，只有肉眼可见，才能感受到震撼和美。</p>
<h2 id="第二天-阿姆斯特丹"><a href="#第二天-阿姆斯特丹" class="headerlink" title="第二天 阿姆斯特丹"></a>第二天 阿姆斯特丹</h2><p>高空秋千。<br>游船。<br>集市。<br>啤酒博物馆。<br>逛街。<br>海鲜大餐。<br>红灯区。</p>
<h2 id="第三天-风车村"><a href="#第三天-风车村" class="headerlink" title="第三天 风车村"></a>第三天 风车村</h2><p>风车村<br>梵高博物馆</p>
<p>FlixBus.</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA daily health report</title>
    <url>/2021/04/01/BUAA-daily-health-report/</url>
    <content><![CDATA[<p>Auto daily health report solution for BUAA.</p>
<span id="more"></span>

<h2 id="报告脚本"><a href="#报告脚本" class="headerlink" title="报告脚本"></a>报告脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/javascript, */*; q=0.01&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9,en;q=0.8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;app.buaa.edu.cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/80.0.3987.87 Chrome/80.0.3987.87 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">report</span>(<span class="params">uesrname, password, dataform</span>):</span></span><br><span class="line">    x = requests.session()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># login, fetch cookies</span></span><br><span class="line">    <span class="built_in">print</span>(time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Logging in......&#x27;</span>)</span><br><span class="line">    rep = x.post(</span><br><span class="line">        <span class="string">&#x27;https://app.buaa.edu.cn/uc/wap/login/check&#x27;</span>,</span><br><span class="line">        data=&#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: uesrname,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: password </span><br><span class="line">        &#125;,</span><br><span class="line">        headers=headers,</span><br><span class="line">        timeout=<span class="number">360</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(rep.text)</span><br><span class="line">    <span class="built_in">print</span>(rep.status_code)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Save report......&#x27;</span>)</span><br><span class="line">    saveReport = x.post(</span><br><span class="line">        <span class="string">&#x27;https://app.buaa.edu.cn/buaaxsncov/wap/default/save&#x27;</span>,</span><br><span class="line">        headers=headers,</span><br><span class="line">        data = dataform</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(saveReport.text)</span><br><span class="line">    <span class="built_in">print</span>(saveReport.status_code)</span><br><span class="line">    </span><br><span class="line">content = <span class="string">&#x27;sfzs=1&amp;bzxyy=&amp;bzxyy_other=&amp;brsfzc=1&amp;tw=&amp;sfcxzz=&amp;zdjg=&amp;zdjg_other=&amp;sfgl=&amp;gldd=&amp;gldd_other=&amp;glyy=&amp;glyy_other=&amp;gl_start=&amp;gl_end=&amp;sfmqjc=&amp;sfzc_14=1&amp;sfqw_14=0&amp;sfqw_14_remark=&amp;sfzgfx=0&amp;sfzgfx_remark=&amp;sfjc_14=0&amp;sfjc_14_remark=&amp;sfjcqz_14=0&amp;sfjcqz_14_remark=&amp;sfgtjz_14=0&amp;sfgtjz_14_remark=&amp;szsqqz=0&amp;sfyqk=&amp;szdd=1&amp;area=%E5%8C%97%E4%BA%AC%E5%B8%82%20%E6%B5%B7%E6%B7%80%E5%8C%BA&amp;city=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;province=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;address=%E5%8C%97%E4%BA%AC%E5%B8%82%E6%B5%B7%E6%B7%80%E5%8C%BA%E8%8A%B1%E5%9B%AD%E8%B7%AF%E8%A1%97%E9%81%93%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%E5%AD%A6%E9%99%A2%E8%B7%AF%E6%A0%A1%E5%8C%BA&amp;geo_api_info=%7B%22type%22%3A%22complete%22%2C%22position%22%3A%7B%22Q%22%3A39.980937228733%2C%22R%22%3A116.35092936197998%2C%22lng%22%3A116.350929%2C%22lat%22%3A39.980937%7D%2C%22location_type%22%3A%22html5%22%2C%22message%22%3A%22Get%20geolocation%20success.Convert%20Success.Get%20address%20success.%22%2C%22accuracy%22%3A29%2C%22isConverted%22%3Atrue%2C%22status%22%3A1%2C%22addressComponent%22%3A%7B%22citycode%22%3A%22010%22%2C%22adcode%22%3A%22110108%22%2C%22businessAreas%22%3A%5B%7B%22name%22%3A%22%E4%BA%94%E9%81%93%E5%8F%A3%22%2C%22id%22%3A%22110108%22%2C%22location%22%3A%7B%22Q%22%3A39.99118%2C%22R%22%3A116.34157800000003%2C%22lng%22%3A116.341578%2C%22lat%22%3A39.99118%7D%7D%2C%7B%22name%22%3A%22%E7%89%A1%E4%B8%B9%E5%9B%AD%22%2C%22id%22%3A%22110108%22%2C%22location%22%3A%7B%22Q%22%3A39.977965%2C%22R%22%3A116.37172700000002%2C%22lng%22%3A116.371727%2C%22lat%22%3A39.977965%7D%7D%5D%2C%22neighborhoodType%22%3A%22%E7%94%9F%E6%B4%BB%E6%9C%8D%E5%8A%A1%3B%E7%94%9F%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%89%80%3B%E7%94%9F%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%89%80%22%2C%22neighborhood%22%3A%22%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%22%2C%22building%22%3A%22%22%2C%22buildingType%22%3A%22%22%2C%22street%22%3A%22%E5%AD%A6%E9%99%A2%E8%B7%AF%22%2C%22streetNumber%22%3A%2237%E5%8F%B7%22%2C%22country%22%3A%22%E4%B8%AD%E5%9B%BD%22%2C%22province%22%3A%22%E5%8C%97%E4%BA%AC%E5%B8%82%22%2C%22city%22%3A%22%22%2C%22district%22%3A%22%E6%B5%B7%E6%B7%80%E5%8C%BA%22%2C%22township%22%3A%22%E8%8A%B1%E5%9B%AD%E8%B7%AF%E8%A1%97%E9%81%93%22%7D%2C%22formattedAddress%22%3A%22%E5%8C%97%E4%BA%AC%E5%B8%82%E6%B5%B7%E6%B7%80%E5%8C%BA%E8%8A%B1%E5%9B%AD%E8%B7%AF%E8%A1%97%E9%81%93%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%E5%AD%A6%E9%99%A2%E8%B7%AF%E6%A0%A1%E5%8C%BA%22%2C%22roads%22%3A%5B%5D%2C%22crosses%22%3A%5B%5D%2C%22pois%22%3A%5B%5D%2C%22info%22%3A%22SUCCESS%22%7D&amp;gwdz=&amp;is_move=0&amp;move_reason=&amp;move_remark=&amp;realname=%E6%9D%A8%E6%A3%AE&amp;number=ZY1806711&amp;uid=305542&amp;created=1614692203&amp;date=20210302&amp;id=28752&amp;gwszdd=&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span>(<span class="params">event, context</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Checking health info at &#123;&#125;...&#x27;</span>.<span class="built_in">format</span>(event[<span class="string">&#x27;time&#x27;</span>]))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        report(<span class="string">&#x27;学号&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>, content)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Check failed!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Check passed!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> event[<span class="string">&#x27;time&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> (lambda_handler(&#123;<span class="string">&#x27;time&#x27;</span>: datetime.datetime.now()&#125;, &#123;&#125;))</span><br></pre></td></tr></table></figure>


<p>如果<code>python</code>脚本报错</p>
<blockquote>
<p>‘ascii’ codec can’t encode characters in position 12-15: ordinal not in range(128)</p>
</blockquote>
<p>应该是编码的问题，按照<a href="https://www.jianshu.com/p/4e2000920332">网络上的教程</a>. 在命令前增加环境变量解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PYTHONIOENCODING=utf-8 python report.py</span><br></pre></td></tr></table></figure>

<h2 id="Cron-定时"><a href="#Cron-定时" class="headerlink" title="Cron 定时"></a>Cron 定时</h2><p>配合Unix/Linux的<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html">crontab</a>，可以达到每天定时打卡的效果.</p>
<p>rentaocron文件内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16 18 * * * PYTHONIOENCODING=utf-8 python3 /home/rentao/workspace/report.py</span><br></pre></td></tr></table></figure>

<p>启动定时任务:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab rentaocron</span><br></pre></td></tr></table></figure>

<p>查看定时任务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<h2 id="获得打卡地址"><a href="#获得打卡地址" class="headerlink" title="获得打卡地址"></a>获得打卡地址</h2><h3 id="Mac-配置代理服务器"><a href="#Mac-配置代理服务器" class="headerlink" title="Mac 配置代理服务器"></a>Mac 配置代理服务器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install mitmproxy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
  </entry>
  <entry>
    <title>比利时交换之旅</title>
    <url>/2019/09/17/Beligum/</url>
    <content><![CDATA[<p>今年的下半年，有幸有机会来比利时交换一学期，大概5个月时间。<br>这是我首次出国这么长时间。之前也是参加学校的项目，去英国游学了半个月，详情可以看我3年前写的<a href="https://youngforest.github.io/2016/08/25/my-britain-trip/">英伦游学所见所思</a>。</p>
<h2 id="悲惨的生活安顿"><a href="#悲惨的生活安顿" class="headerlink" title="悲惨的生活安顿"></a>悲惨的生活安顿</h2><p>没有被子。<br>没有网。<br>想买鲜奶却买成了酸奶。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 字节跳动夏令营</title>
    <url>/2019/09/06/ByteDance-Camp/</url>
    <content><![CDATA[<p>总的体验是很开心，收获很大。</p>
<p>很幸运可以参加今年的Byte Camp，我认为这一周的活动是我今年参加过的最有意义的活动了。今年的夏令营共分为3个赛道：工程、算法、和 产品。我参加的是工程赛道。</p>
<p>工程和算法赛道进入夏令营的选拔都是通过笔试和面试完成的。笔试的题目也都一样，就是通过牛客网的平台在线完成。笔试有2次机会，都参加的话取分高的。笔试题目分为基础题（操作系统、计算机组成原理、计算机网络）和编程题。编程题有4题，难度依次递增。我参加的是第一场，AC了前3道，难度大约等于是LeetCode medium，最后一题的难度直接飙升到 ICPC world final的难度，要用费用流的知识。我也没打过ACM，第一次听说费用流，就没做出来。由于笔试答的还行，面试我没参加，直接拿到入营资格了。不过听参加面试的同学反映，面试也挺水的，难度很低。</p>
<p>然后就是夏令营的正式活动了。活动虽然只有一周，但是日程安排的十分紧凑，基本是9 10 6。开幕式是有 AI-lab的主管 李航老师 主持。以前只在网上和书上久闻大名，这次竟然可以见到真人了，还有一起合影的机会。学机器学习的同学应该都听说过他，他的《统计学习方法》也是入门算法岗工作的维几之选。我们每人还获赠他签名的《统计学习方法》一书（工程赛道的同学可能对此不是很感冒，哈哈）。</p>
<p><img src="/images/ByteDance-camp-jiti.jpg" alt="集体照"></p>
<p>之后的日程主要分为2天的听课和3天的做项目。课程安排和项目都可以在<a href="https://bytecamp.toutiao.com/course">官网上</a>看到，每天要上7节课之多。课上也是干货满满，每个主题都是字节跳动内部负责相关技术的资深工程师负责讲解，从基础设施架构到前后端，覆盖工程的同学可能感兴趣和从事的所有内容。<br>算法那边除了请公司内部的大牛之外，还有像 Yoshua Bengio、Oren Etzioni 这样的外部嘉宾参与。因为这2个人实在是太牛了（我也是后来才知道的，毕竟不搞算法），我们工程的也被要求参加他们的课程。课程内容倒是一般，比较入门和浅显（难道是为了照顾我们工程的孩子？），实质内容反而不多。</p>
<p>我选择的项目是“服务治理：基于共享内存的高性能通信中间件”。说实话，我对共享内存和进程间通信不是特别熟，但是当时选题目的时候只有这个题目能看懂，其他的题目更是一头雾水，所以选择了“中间件”这一看起来比较靠谱的项目。（后来证明，这样的项目反而不如小游戏这样的项目容易拿奖，也更难完成）。项目的具体细节就不便透露了。我和交大的一位大佬一起完成，3天的时间里，完成了设计、实现、测试、性能测试、PPT和展示。别的组都是4～5人，我们组因为有2个队友提前退营了，只有2人。这3天的代码不是我写的最难的，但算是我这一年来写的最开心的了。白天写一天代码，晚上10点回到酒店里接着肝到一两点。（有五星级酒店住，也是我学校在北京，但仍和大家一起住酒店的原因。标间一晚九百多，很舒服）。我俩甚至把项目开源了：<a href="https://github.com/Yellow-Pay/MakeTheAmericanGreatAgain">Yellow-Pay/MakeTheAmericanGreatAgain</a>。在GitHub上可以搜到很多shm-ipc的库，我们的目的更多的是为了用git协同工作。</p>
<p><img src="/images/Bytedance-camp.jpg" alt="做项目的第二天"></p>
<p><img src="/images/us.jpg" alt="我和队友黄富乾"></p>
<p>上周五下午刚刚结束夏令营，回学校正式开工，才发现字节跳动的总部中航广场离学校如此之近。本来想坐地铁回来，可是走到知春里的时候发现，学校竟然只有半站路，就直接走回宿舍了。期待以后有机会可以和字节跳动有更多的接触，这么近的距离，偷偷出来实习一定很方便。</p>
<p>总结一下我这一周的收获，重要程度从前向后：</p>
<ol>
<li>结识了很多小伙伴，其中不乏大佬。</li>
<li>对字节跳动这个公司的氛围、技术栈有了比较深的了解。</li>
<li>虽然很累，但整个活动我都很开心。</li>
</ol>
<p>最后，感谢为此次夏令营奔波劳碌的蔓莲姐姐和其他工作人员及志愿者。</p>
<p>整个夏令营需要吐槽的地方有，希望明年能有所改善：</p>
<ol>
<li>开幕晚宴的饭菜比较难吃，不是太咸、就是太甜。</li>
<li>中午没有休息的地方。虽然坐着6k元的椅子，但是靠背没有放脖子和脑袋的地方，每天只能靠着墙凑活睡了。到现在我腰还因此疼。</li>
</ol>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>ByteDance</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>字节跳动 暑期实习 广告系统后端开发 面试</title>
    <url>/2020/02/27/Bytedance-Ads-backend-intern-interview/</url>
    <content><![CDATA[<ul>
<li>HashMap</li>
<li>数据库<ul>
<li>索引、优化、事务</li>
<li>聚簇索引和非聚簇索引</li>
</ul>
</li>
<li>并发编程</li>
<li>网络编程，RPC</li>
<li>算法题:<ul>
<li>编辑距离</li>
</ul>
</li>
</ul>
<p>算法题问了一道计算<a href="https://en.wikipedia.org/wiki/Levenshtein_distance">编辑距离(Levenshtein Distance)</a>的问题。编辑距离的问题恰好我在之前度《图解算法》的时候有所涉及，用DP解决即可。但本题目稍微复杂度写，需要在很多字符串中，寻找距离最近的字符串。可以理解为”Fuzzy matching”。<br>题面大概为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">莱文斯坦距离，又称 Levenshtein 距离，是编辑距离的一种。指两个字串之间，由一个转成另一个所需的最少编辑操作次数。</span><br><span class="line">允许的编辑操作包括：</span><br><span class="line">插入一个字符</span><br><span class="line">删除一个字符</span><br><span class="line">将一个字符替换成另一个字符</span><br><span class="line">需要你编写一个程序，实现以下功能：</span><br><span class="line">给定一个字符串集合 S 以及一个模板串 P，从 S 中找出与 P 莱文斯坦距离最小的字符串 T，输出 T 以及其对应的编辑距离 D。如果 S 中出现多个满足条件的字符串，则取按字典序排列的第一个。</span><br></pre></td></tr></table></figure>

<p>并没有想到很好的解法，暴力解法的话, 比较所有字符串和P的距离 时间复杂度为: O(P.size() * sum(S_i.size()).</p>
<p>后在网上搜索解法，并不难找到。利用Trie以避免不同字符串的DP重复的计算，时间复杂度为: O(P.size() * Trie的节点数). 虽然最坏时间复杂度没有变好，但是实实在在的优化。应该这就是面试官想要的解法了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    array, <span class="number">26</span>&gt; children;</span><br><span class="line">    vector distance;</span><br><span class="line">    <span class="built_in">Node</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        distance.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">pair <span class="title">solve</span><span class="params">(<span class="keyword">const</span> string&amp; target, <span class="keyword">const</span> vector&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> k = target.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> root = <span class="built_in">make_shared</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i distance.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        root-&gt;distance[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans_distance = <span class="number">0x3f3f3f3f</span>,  ans_index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">const</span> string&amp; str = s[j];</span><br><span class="line">        <span class="keyword">auto</span> current = root;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl &lt;&lt; &quot;debug: &quot; &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> distance_from_empty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                current-&gt;children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="built_in">make_shared</span>(k);</span><br><span class="line">                <span class="keyword">auto</span> next_current = current-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                next_current-&gt;distance[<span class="number">0</span>] = distance_from_empty;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c == target[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        next_current-&gt;distance[i] = current-&gt;distance[i - <span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        next_current-&gt;distance[i] = <span class="built_in">min</span>(&#123;</span><br><span class="line">                            current-&gt;distance[i - <span class="number">1</span>],</span><br><span class="line">                            current-&gt;distance[i],</span><br><span class="line">                            next_current-&gt;distance[i - <span class="number">1</span>]</span><br><span class="line">                        &#125;) + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// cout distance[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            current = current-&gt;children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++distance_from_empty;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;distance[k - <span class="number">1</span>] &lt; ans_distance) &#123;</span><br><span class="line">            ans_distance = current-&gt;distance[k - <span class="number">1</span>];</span><br><span class="line">            ans_index = j;</span><br><span class="line">        &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (current-&gt;distance[k - <span class="number">1</span>] == ans_distance) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[ans_index] &gt; s[j])</span><br><span class="line">                ans_index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;ans_distance, s[ans_index]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string P;</span><br><span class="line">    cin &gt;&gt; P;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector <span class="title">S</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">solve</span>(P, S);</span><br><span class="line">    cout &lt;&lt; ans.first &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>ByteDance</tag>
      </tags>
  </entry>
  <entry>
    <title>Bytedance 秋招面试 2020</title>
    <url>/2020/06/23/Bytedance-new-graduate-interview/</url>
    <content><![CDATA[<p>我字节跳动提前批投了 技术中台 的 后端开发岗位。<br>计算机基础没复习到位，答得不好。<br>许愿offer。</p>
<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>我自介绍。</p>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>先给暴力解，再优化。</p>
<blockquote>
<p>题目：数组代表股票每天价格，每天只允许买或者卖一次，也可以不买卖，需要先买入才能卖出，在只交易一次（即只买和卖一次）的情况下求最大收益。<br>输入：[2,1,4,1,5,6,1]<br>输出： 5 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// time: N ^ 2</span></span><br><span class="line">    <span class="comment">// space: 1</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> buy = <span class="number">0</span>; buy &lt; prices.<span class="built_in">size</span>(); ++buy) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sell = buy + <span class="number">1</span>; sell &lt; prices.<span class="built_in">size</span>(); ++sell) &#123;</span><br><span class="line">            <span class="keyword">int</span> profit = prices[sell] - prices[buy];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, profit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution2</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// time: O(N)</span></span><br><span class="line">    <span class="comment">// space: 1</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minPrices = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sell = <span class="number">1</span>; sell &lt; prices.<span class="built_in">size</span>(); ++sell) &#123;</span><br><span class="line">        <span class="keyword">int</span> profit = prices[sell] - minPrices;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, profit);</span><br><span class="line">        minPrices = <span class="built_in">min</span>(minPrices, prices[sell]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int a;</span></span><br><span class="line">    <span class="comment">//cin &gt;&gt; a;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; prices = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solution2</span>(prices) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>IPC 种类<br>信号量</p>
<p>进程 和 线程<br>各有几种状态、状态转移图。</p>
<p>虚拟内存</p>
<p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html">Linux的一些常用命令</a>, 今天刚复习过。<br>如 查看端口、内存、进程状态.<br><a href="https://unix.stackexchange.com/questions/94357/find-out-current-working-directory-of-a-running-process">进程的current working directory</a>: <code>lsof -p &lt;PID&gt; | grep cwd</code></p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>3次握手 4次挥手 的过程和必要性. 答的很糟糕。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>几种范式<br>深入了解吗？不了解</p>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>python</p>
<ul>
<li>GIL</li>
<li>引用还是值</li>
</ul>
<p>贵组大概率是写python的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>昨天约了今天的面试，失误呀。太过仓促。本来秋招提前批是很重要的，计算机基础知识就是题库里的那些题，花3天时间背背还是有必要的。要不靠着本科时学的知识，回答不会太好，会很伤。</p>
<p>好多同学问题库在哪里。我也是在网上找的，<a href="https://github.com/CyC2018/CS-Notes">https://github.com/CyC2018/CS-Notes</a><br>感觉还是挺全的. 已经在背了。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>ByteDance</tag>
        <tag>New Graduate</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 中实现生成器(Generator, yield in Python)</title>
    <url>/2019/12/15/Cpp-generator-implement/</url>
    <content><![CDATA[<p>问题的起因是因为LeetCode上的一个题目<a href="https://leetcode.com/problems/iterator-for-combination/">1286. Iterator for Combination</a>。最完美的实现是利用 生成器(Generator)，也就是Python中的<code>yield</code>。但是我不会，只实现了一个提前计算，然后存起来的解法。并不优雅，赛后，学习了一个C++中Generator的实现，在此分享下。因为我并未在网上找到很好的中文的关于此的文章。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Django使用总结</title>
    <url>/2017/01/23/Django-note/</url>
    <content><![CDATA[<p><strong>[摘要]</strong> <a href="https://www.djangoproject.com/">Django</a> 是一个高水平的Python Web框架, 可以帮助我们迅速开发, 设计一个干净, 程序化的应用. 虽然Django比较臃肿(现在大神都用<a href="http://flask.pocoo.org/">Flask</a>?), 适合大型Web应用的开发, 笔者的数据库课程设计是一个小型工程, 但Django名声是在太大, 笔者之前在实验室也稍稍接触过, 所以和队友果断选择了Django. 我们的课设, 在Django的帮助下, 实现起来就和切菜一样.</p>
<span id="more"></span>
<p>数据库课设最近出分了, 只得了良好, 未如愿取得优秀. 但两天完成数据库的经验确实使笔者学到了很多, Django框架的使用, 前后端的概念, 结对编程的合作… 其中最想和大家分享的是Django框架的使用, 幸亏有该框架, 让我们可以专注于后端和数据库的设计实现, 还能轻松实现一个看得过去的前端. 事半功倍, 没有被拖延症害死.</p>
<h4 id="时间分配"><a href="#时间分配" class="headerlink" title="时间分配:"></a>时间分配:</h4><p>完成数据库用了两天(而且有一天是边刷”潜伏”边写程序的), 之前都是在学习Django, 文档甚至大部分是答辩完之后补完的.</p>
<h4 id="人员分配"><a href="#人员分配" class="headerlink" title="人员分配:"></a>人员分配:</h4><p>原本的计划是抱tls大腿, 所有前后端由tls完成, 笔者帮助写写文档. 不过后来, 鉴于tls经常养精蓄锐, 一直在学习Django, 最后几个小时仍未有看的见的成果. 笔者就慌了, 在之前练习的基础上, 修补完善, 勉强实现预计功能, 完成课设. 最后文档是两个人一起紧急补完的, tls最后一个小时又帮助实现了两个新功能.</p>
<h2 id="Django使用总结"><a href="#Django使用总结" class="headerlink" title="Django使用总结"></a>Django使用总结</h2><p><a href="https://docs.djangoproject.com/en/1.10/">官方文档</a>是很完善和亲民的, 需要用的功能都可以在上面找到. 缺点是, 太庞大, 不好找; 而且是英文的, 官方文档更新太快, 中文文档的翻译根本跟不上, 笔者的六级刚刚飘过, 很是头疼, 不过仍是喜欢看官方的英文文档, 感觉更有帮助.</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>笔者是跟着andrew-liu的用<a href="https://andrew-liu.gitbooks.io/django-blog/content/">Django搭建博客</a>的教程, 熟悉一步步的命令和操作的. 这个教程很适合初学者用来熟悉Django的基础命令和文件结构. 但一个明显的恶果是, 最后, 我们的课设<code>电动汽车充电站管理系统</code>的效果看上去和博客差不多.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇post干货比较少, 实在是因为笔者学艺不精, 没有更过可以分享的. 如果下次要需要再次使用Django, 笔者一定会回来再次补充的.</p>
]]></content>
      <tags>
        <tag>Database</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Modern C++</title>
    <url>/2019/05/05/Effective-Modern-C/</url>
    <content><![CDATA[<p><a href="https://book.douban.com/review/10131903/">我的书评</a></p>
]]></content>
      <categories>
        <category>书评</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>留学在欧洲，聊聊关于银行和钱的事儿</title>
    <url>/2019/12/07/Europe-bank-accounts/</url>
    <content><![CDATA[<p>本学期有幸来比利时交换一学期，在“钱”上遇到很多困难，在同学的帮助下逐步克服。在此感谢帮助过我的一系列好友，并将自己的经验分享给大家，让更多的人收益。</p>
<p>在全球化的今天，来到欧洲，如何方便的花钱，省钱，是每个留学生关心的事情。在欧洲花钱基本可以分为2类：现金、刷卡。2者是相辅相成的关系，并不像在国内，一部手机走天下。<br>我的经历是：在国内换了700欧的现金带过来，还带了一张招商银行的Visa全币种信用卡。因为办签证需要经济证明，我还提前转了3000多欧给学校的账户，学校之后每个月给我的账户返还666欧，作为生活费。来了之后，我分别办了 ING的Green Account，网上银行 Revult, Curve, Bunq, Monese; 配置了Google Pay 和 PayPal。并经过到欧洲到处自由行，结合不同的花钱方式，达到最便利和最省钱。</p>
<p>接下来，我分别介绍各种方式的办理方法和优缺点。</p>
<h1 id="现金-和-刷卡"><a href="#现金-和-刷卡" class="headerlink" title="现金 和 刷卡"></a>现金 和 刷卡</h1><p>在刚来比利时的时候，从国内带足够的现金是必要的，心里也有底。我带了700欧，事实证明，在有信用卡夹持的情况下，这些绰绰有余。比利时作为欧洲最发达的地区之一，刷卡几乎可以覆盖大多数消费场景。甚至一些大额的消费，如交房租，必须刷卡。幸好我信用卡的额度足够，在第一次交房租时，我还需要替同行的2个同学帮付。这时候就体现出国带信用卡的好处了。</p>
<h2 id="现金"><a href="#现金" class="headerlink" title="现金"></a>现金</h2><p><img src="/images/money/5euro.jpg" alt="5Euro 纸币"></p>
<p>在欧洲，身上带少量现金是必要的。尤其是50分的硬币，因为这里很多公共卫生间都是收费的，大多数是50分, 这可是救命钱。我建议多带些5欧的钱，面额越大，用处越小，越不方便。在某些消费场合，比如集市、地摊，也只能用现金。在欧洲某些相对欠发达地区，如希腊、意大利，不能刷卡的场合也比较多。西欧和北欧相对好很多，丹麦甚至上厕所都能刷卡。</p>
<h2 id="信用卡"><a href="#信用卡" class="headerlink" title="信用卡"></a>信用卡</h2><p><img src="/images/money/zhaohang-visa-credit.jpg" alt="招商银行全币种Visa信用卡"></p>
<p>信用卡最大的好处是方便，支持<strong>全币种</strong>，人民币还款。还款可以直接向信用卡转账，所以父母在国内也可以很方便地还款。招商银行还根据你的消费地点，提醒你可以提高临时额度，满足境外的大额消费需求。招行也是相对容易给学生办下卡的一家银行，并且额度还不错。<br>缺点是：</p>
<ol>
<li>并不足够经济。具体的汇率可以在<a href="https://www.kylc.com/huilv/whichcard.html?ccy=eur">kylc</a>网站上查到。招行信用卡的还款策略是：当你消费非美元的货币时，先根据Visa的汇率购入美元入账，过2天再根据招行的汇率换成人民币。虽然没有所谓的货币转换费（DCC），但其实招行的汇率并不好，尤其是相比 中国银行。相比下面介绍的网上银行，和私下换hui, 也不很经济。</li>
<li>容易多花钱。这是信用卡的通病，在国内也一样。每个月出账单和还款的时候，才发现自己竟然花了这么多钱。</li>
</ol>
<p>如果有想办该卡的小伙伴，可以找有卡的同学推荐，这样2个人都可以获得不错的礼物。</p>
<h1 id="传统银行-ING"><a href="#传统银行-ING" class="headerlink" title="传统银行 ING"></a>传统银行 ING</h1><p><img src="/images/money/ing.jpg" alt="ING debit card"></p>
<p>因为我门需要学校返还生活费，必须办理账户。在大多数银行办理账户都需要居留卡，只有在ING办理只需要临时的居留证明即可，也即15号文件。我办的是一种年费40欧的Green Account，每3个月扣10欧。后来听说可以办更实惠的Lion Account，这种账户面向25岁以下青年，还会给你40欧。<br>ING办卡需要先预约，然后再开户。前前后后大概需要2周多时间才能拿到卡片。拿到卡片后，如果使用网上银行或是手机银行，还需要一个类似U盾的Reader。这个Reader按理说会和卡片一起寄给你。但是我们几个人都没有收到，后来特意从官网上又<strong>重新申请</strong>了一个，大概3天后就得到了。</p>
<p>ING卡会给你一个比利时的账户和一张卡片。<br>账户可以用来收钱和转账。同银行间转账一般即刻到账，跨行转账需要一个工作日。这个账户还可以绑定PayPal进行网上支付。<br>卡片支持Maestro支付和Bancontact支付。2种支付渠道都比较有限，无法和Visa或MasterCard相比。尤其是Bancontact, 是比利时的一家公司控制的支付渠道，基本上出了比利时就不能用了。Bancontact也支持手机和线上支付，不过基本上也是比利时的公司和网站会使用。而且这张卡片没有CVV码，这意味着很多线上支付的场景无法使用。<br>ING的刷卡消费也不是即时提醒的，需要等几个工作日。所以消费起来无法立刻知道扣了多少钱。作为国人可能心中不安，这里的人好像都习惯这种消费方式了，也不会出现多扣钱的情况。</p>
<p>我通常的处理方式是，把大钱放在ING账户里，转小钱给其他网上银行的账户，方便消费。</p>
<p>ING 还有个缺点是换汇的汇率比较差，大概会比市场上的汇率差个10%。而且需要提前预约。线上预约需要7个工作日，可以订面值，线下预约快一些，大概3个工作日，但不可以订面值，十分不方便。我换过一次匈牙利福林，拿了9张1万块就回来了（事实上只相当于大概300欧）。</p>
<h1 id="网上银行"><a href="#网上银行" class="headerlink" title="网上银行"></a>网上银行</h1><p>欧洲是银行业的起源地，银行业十分发达，金融经济等制度十分完善。除了传统的银行外，还有很多网上银行的存在。这些网上银行解决了传统银行的诸多痛点：</p>
<ul>
<li>收费高</li>
<li>效率底</li>
<li>不方便</li>
<li>余额变更提醒不及时</li>
</ul>
<p>经台湾同胞Benjemin推荐和我的自己摸索，我共尝试了4种网上银行，它们功能和解决的需求各不相同。大家有旅行需求和线上消费需求的一定要尝试下，会发现欧洲的生活其实还是很方便的。</p>
<ul>
<li>Revult</li>
<li>Curve</li>
<li>Bunq</li>
<li>Monese</li>
</ul>
<p>各家网上银行的认证大同小异，都需要上传你在欧洲居住的证明，可以是 护照 + 签证，也可以是 居留卡。从我的经验看来，用居留卡办审核更容易通过些。</p>
<h2 id="Revolt"><a href="#Revolt" class="headerlink" title="Revolt"></a>Revolt</h2><p><img src="/images/money/revolut.jpg" alt="Revolt debit card"></p>
<p>名气最大的网上银行，会给你一个英国的账户，支持多种货币，每种货币之前兑换的话，使用很经济的interbank rate。可以免费预订一张实体卡片和多张虚拟卡。<br>我开通了一张实体卡片和一张虚拟卡。<br>虚拟卡可以用以网上支付，绑定Google Pay和 PayPal，和Curve（结合Curve使用有奇效）。<br>实体卡片会邮寄给你，大约2周时间，使用起来和普通的卡片没有区别。<br>实体卡片就有丢失和被盗的风险。我的卡片就在伊斯坦布尔取钱的时候被ATM吞了，好在网上银行都可以立刻冻结和挂失，没有造成更大的损失。我马上预定了第二张实体卡片，不过第二张就要花大概2欧了。</p>
<p>Revolt作为我的主力网上银行使用。我通常从ING转账到Revolt，保证它的余额在100～200欧。实体卡随身携带，方便消费。虚拟卡 绑定Google Pay，PayPal，Curve，发挥最大作用。<br>去非欧元区旅行时，提前在APP上换好汇，再去机场的ATM取出来即可。可能有3.5%左右的取款费，但省掉了货币转换费（DCC），也比从ING换汇或机场换汇要好很多。</p>
<p>其突出的优点是：</p>
<ul>
<li>下卡快、开户方便</li>
<li>余额变化实时提醒</li>
<li>换汇汇率比较好</li>
<li>支持虚拟卡，有CVV码</li>
</ul>
<p><a href="https://revolut.com/referral/sen15gok">推广链接</a></p>
<h2 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h2><p><img src="/images/money/curve.png" alt="Curve debit card"></p>
<p>Curve也是一家英国的网上银行，主打功能是 集合多张银行卡到一张卡，省去货币转化费。<br>这也是我的第二主力卡。英国果然是金融中心，网上银行的先行者。<br>它工作的原理是：你申请通过后，会给你发一张MasterCard的贮蓄卡。但并没有真正的银行账户，你可以在APP上绑定多张别的银行的卡片，只要有CVV码就可以。刷卡消费时，真正扣款的是后面的这张卡。Curve卡相当于是一个代理的功能。<br>学过<strong>设计模式之代理模式</strong>的同学应该都知道，有了这层代理，我们可以干很多事情。比如，</p>
<ul>
<li>免除货币转化费。消费外币时，用Curve进行购汇，实际扣除后面那张银行卡的货币类型就是它本身的货币类型了。即 将换汇的操作挪到Curve进行。Curve采用的也是很好的interbank rate。需要注意的一点是 千万不要周末使用换汇功能，周末伦敦货币交易市场关门，就产生0.5%-1.5%的货币转换费。</li>
<li>伪装信用卡到储蓄卡。信用卡有许多好处，少数场合需要信用的地方不能使用储蓄卡，如 租车、在 <a href="https://www.booking.com/">booking</a>上担保。但也有一些场合只能用储蓄卡（我目前还没有遇到，国内支付宝消费的时候，倒是经常遇到不能用花呗的场景）。这时，就可以刷Curve卡，扣款的其实是信用卡。</li>
<li>出门只带一张卡。这也是其杀手特性。现代社会，很多人有多张银行卡，在不同的场景下需要使用不同的卡片，这时，只需要在APP里切换卡片就可以了。</li>
</ul>
<p>缺点是目前还不支持欧洲地区的Google Pay。无法和Google Pay结合实现更骚的操作。</p>
<p>推广码，可以赠送5英镑哦：<br>I’m using @imaginecurve! All my cards in one + a great way to save &amp; manage money. Sign up with code DL6LOLZE &amp; get £5 <a href="https://curve.page.link/HyuYB">https://curve.page.link/HyuYB</a></p>
<h2 id="Bunq"><a href="#Bunq" class="headerlink" title="Bunq"></a>Bunq</h2><p><img src="/images/money/bunq.png" alt="Bunq travel card"></p>
<p>这是一家荷兰的银行。会给你一张银行卡（彩虹卡）和一个<strong>荷兰</strong>的银行账户。主打的也是旅行时消除货币转换费。荷兰账户也可以干更多的事情，比如开通<a href="https://www.ideal.nl/">iDEAL Payment</a>，这是荷兰版的Bancontact。一些荷兰的公司和网站用此支付手段有优惠。</p>
<p>另外改账户还有一个杀手特性：从信用卡中Top Up，也就是我们常说的套现。结合信用卡，可以发挥各种资产运作，如 扩大现金流。</p>
<h2 id="Monese"><a href="#Monese" class="headerlink" title="Monese"></a>Monese</h2><p>同样是一家英国的网上银行，会给你一个英国的账户和一张银行卡。<br>优点和其他网上银行类似，我也用的比较少，开发程度低。<br>缺点是 只有英镑(GBP)和欧元(EUR) 的账户。</p>
<h1 id="支付方式"><a href="#支付方式" class="headerlink" title="支付方式"></a>支付方式</h1><p>除了常见的用卡支付外，欧洲还流行2种支付方式</p>
<ul>
<li>Google Pay</li>
<li>Pay Pal<br>一些功能有些像 支付宝。</li>
</ul>
<h2 id="Google-Pay"><a href="#Google-Pay" class="headerlink" title="Google Pay"></a>Google Pay</h2><p>支持线下的非接触支付和线上支付（通常通过手机）。<br>由于国内买的安卓手机，Google服务一般是被阉割的，是否能用还需要看你具体的手机型号。<br>我使用的是 小米9，通过一些配置就可以正常使用Google Pay。<br>只需要把系统默认的钱包从 “小米钱包”更改为“HEC钱包”即可。</p>
<p>线下刷手机真的是及其方便，不需要掏卡，甚至不需要解锁。比国内扫二维码 或 出示付款码 都更方便。</p>
<p>除此之外，Google Pay还可以集合各种会员卡。在欧洲这里和国内一样，许多超市会发行会员卡，有积分和打折。可以使用Google Pay录入会员卡的 条形码 或 二维码，付款时可以很方便地调出来，减少了保管和掏实体卡片的麻烦。</p>
<h2 id="Pay-Pal"><a href="#Pay-Pal" class="headerlink" title="Pay Pal"></a>Pay Pal</h2><p>PayPal 主要解决的是线上支付问题。在欧洲买个机票，订个旅店，除了直接用卡支付外，很多支持且只支持PayPal。PayPal可以绑定ING的银行账户和网上银行的卡，也可以绑定信用卡，和支付宝很像。除了方便网上支付外，它还有个汇率上的优点。当你支付货币和卡里的钱不一样时，你可以选择通过PayPal直接换汇，可能会比银行的汇率要好。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>bank</tag>
        <tag>money</tag>
        <tag>Europe</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next 配置 Google AdSense</title>
    <url>/2021/02/25/Google-AdSense-for-hexo-next/</url>
    <content><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>最近由于看了“半佛仙人”的一些视频，我对钱更感兴趣了。除了拿出积蓄的一部分投资A股外，还想着怎么提高被动收入。自己一直有写博客的习惯，写了有5年多，攒了一百余篇文章。虽然每日浏览量只有几十，但苍蝇再小也是肉。参照大佬的一些经验，尝试着通过投放广告来牟利。<br>一般网站的广告收入都是通过广告联盟接入的。简而言之就是，你只用出租广告位给广告联盟，他们在此投放针对用户的广告，然后按照流量给你钱。<br>面向国际的主要就是Google AdSense了，国内也有一些，如百度。<br>因为我本职是一名程序员，博客内容也不分国界，因此选择了Google AdSense作为广告商。Google AdSense的配置十分简单。</p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p><a href="https://www.google.com/adsense/">注册新的AdSense账号</a>.</p>
<p>从Google AdSense上获取针对你网站的广告脚本，类似这样</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-ad-client</span>=<span class="string">&quot;ca-pub-9*******6&quot;</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将广告脚本粘贴在<code>./themes/next/layout/_partials/head/head-unique.swig</code>的末尾。</p>
<p>然后进行验证。一般几天就会通过，发邮件通知到你。</p>
<p>通过审核后，需要去AdSense上进行配置。基本上把 <strong>自动广告</strong> 打开即可。</p>
<h3 id="ads-txt-的设置"><a href="#ads-txt-的设置" class="headerlink" title="ads.txt 的设置"></a>ads.txt 的设置</h3><p>该文件放置在 <code>./source/</code> 下即可，和<code>_posts/</code> 同级。<br><code>hexo d -g</code>部署后，对应的文件就会自动部署到<code>/public/</code>也就是你的博客上了。<br>其他需要生成放置在博客根目录下的文件也是类似的处理。</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Happy birthday 2019</title>
    <url>/2019/07/15/Happy-birthday-2019/</url>
    <content><![CDATA[<p>今年仍然是在学校度过了自己23岁的生日。下午和舍友出去看了电影《狮子王》，晚上去 城南旧事 吃了“北京菜。算是庆祝了自己的生日吧。祝我生日快乐。<br>自从18岁之后离开家，独自来到帝都读书。过生日就不再像在家里那么热闹和有人情味了。在外地漂泊，虽说还有同学或朋友祝你生日快乐，亲近的还会陪伴我一起过生日，但家人的温暖却再也没有了。大家来来往往，身边的人也基本只能陪伴一段时间。每每此时，都会怀念小时候。</p>
<p>最近北京的天气特别热，不由的心情烦躁。持续性混吃等死，间断性踌躇满志。经常思考些所谓的人生意义，努力的价值，自己的目标。<br>我本人可以说是胸无大志，从小读过不少书，尤其是历史书。早早地就明白了自己与王侯将相无缘，只是个贩夫走卒。现在想要的也不多，在大城市有立锥之地，有个温暖的家。这样的想法，恐怕也是千千万万北漂一族的目标吧。这也是我努力学习的动力所在呀。<br>最近在看一部很火的网剧“长安十二时辰”，里面有句台词很引起我的共鸣：有些人生来就是长安人，有些人到死都没成为长安人。剧中无数长安底层人的生活，不正是影射的北漂族的生活嘛。</p>
<p>时间如白驹过隙。匆匆之间，2019年已经过了一半。回望自己半年前写下的新年愿景，有些容易的已经实现，难的只能推迟到后半年，甚至来年了。</p>
<ul>
<li>健康的身体和良好的生活习惯。这点做的很不够，因为贪睡、怕热、懒等缘由，跑步、健身 并没有坚持下来。我需要做自我批评。</li>
<li>一段大大厂的实习。在ST实习了一学期，并不算大厂。大大厂的实习需要推迟到明年实现了。</li>
<li>一段交换经历。预计下学期执行。</li>
<li>计算机系统 和 算法 的进阶。LeetCode的最初任务已经超额完成了，算法相关的书CTCI也翻过一遍，这点是值得肯定的。事实上，我在此下的功夫不少。除此之外，对C++的熟悉也基本完成了，可以在简历上或面试上大胆的说C++是自己的主语言了。剩余的 CSAPP、SICP、设计模式，并没有很大的进展，聊胜于无。</li>
<li>实际面试经历。参加了字节跳动广告组的面试，和 字节跳动夏令营的笔试、以及 Google的电话面试。这些面试经历真的很刺激人，让人深入的认识到自己的短处。比如算法上离Kick start的标准还差的远呢！</li>
</ul>
<p>我认为自己需要牢记的2点：</p>
<ul>
<li>时间就是金钱！</li>
<li>身体是革命的本钱！</li>
</ul>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + github 搭建个人博客</title>
    <url>/2016/11/02/Hexo-github-building-personal-blog/</url>
    <content><![CDATA[<h2 id="动机-放在前面"><a href="#动机-放在前面" class="headerlink" title="动机(放在前面)"></a>动机(放在前面)</h2><p>之前在cnblog上有个博客, 但是也不经常维护, 到现在满打满算也才有3篇随笔, 1个粉. 主要是因为自己没有写东西的习惯. 高中的时候记过一段时间的日记, 零零总总写了有大半本, 都是一些励志(自欺欺人)的东西, 写给自己看的.</p>
<span id="more"></span>

<p>首先, 之前感觉没有可写的, 但现在觉得可写的还是挺多的.自己这两年也折腾了不少东西.但折腾完后, 说实话忘得挺快的, 下次自己再弄或者给别人处理相同问题的时候, 基本上又要重新来过. 记下来下之后, 不管是自己日后需要, 还是给小伙伴们借鉴都是极有用的.</p>
<p>其次, 经高人安利, 经常写博客, 总结自己的工作学习, 和网络上的大牛们交流是学习计算机的基本技能. 写下来, 不仅可以系统地记录自己的学习历程, 供后日回顾, 或后人参考, 还可以督促自己坚持下来. 何乐而不为呢?</p>
<p>最后, 最近在搞编译课设的时候, 看到了<a href="http://jcf94.com/2016/02/21/2016-02-21-pl0/">这篇博客</a>. 学习编译知识的同时, 感觉这个博客设计的很美观, 博主也很nice. 了解到使用<code>Hexo</code>搭建的时候, 便有了自己搭建博客的想法, 现在也终于有时间实现了.</p>
<h2 id="介绍Hexo"><a href="#介绍Hexo" class="headerlink" title="介绍Hexo"></a>介绍<code>Hexo</code></h2><p>有很多专门用来搭建博客的框架, 如 WordPress, Jekyll, Octopress, Joomla等. 这些我都没有用过, 就不评论了. 事实上, 这是我第一次搭建博客的经历, 也算是一种猿粪吧, 遇上了Hexo.</p>
<p>这里我就自己的感受, 说说Hexo的优点:</p>
<ol>
<li>文档完善.</li>
<li>中文支持好, 包括文档各个方面. 事实上, 开发者就是中国人.</li>
<li>主题丰富.(作为一个看脸的人)</li>
</ol>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="本地Hexo安装配置"><a href="#本地Hexo安装配置" class="headerlink" title="本地Hexo安装配置"></a>本地Hexo安装配置</h3><p>关于如何搭建, 我这里推荐官方的<a href="https://hexo.io/zh-cn/docs/">文档</a>. 文档中说的已经很详细了, 而且遇到问题的话, 还可以直接在文档最下面的讨论区提问, 貌似遇到奇奇怪怪问题的人挺多的, 我遇到问题一般靠谷歌, 事实上, 很多时候都被谷歌引到讨论区或者文档中的<a href="https://hexo.io/zh-cn/docs/troubleshooting.html">Troubleshoot</a>了.</p>
<p>我安装hexo使用的环境的Ubuntu14.04, 在安装hexo的时候<code>$ npm install -g hexo-cli</code>, 会遇到这样的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh: 1: node: not found</span><br><span class="line">npm WARN This failure might be due to the use of legacy binary &quot;node&quot;</span><br><span class="line">npm WARN For further explanations, please read</span><br><span class="line">/usr/share/doc/nodejs/README.Debian</span><br></pre></td></tr></table></figure>

<p>通过搜索可以很快找到解决问题的<a href="http://stackoverflow.com/questions/21168141/cannot-install-packages-using-node-package-manager-in-ubuntu">方法</a>. 只需要<code>sudo apt-get install nodejs-legacy</code>就可以了.</p>
<p>出现这个问题的原因是, debian社区发现, nodejs解释器的命令是<code>node</code>. 然而, 这个命令和其他的包有命名空间的冲突, 比如 node 包中的 ax25-node. 所以, 他们决定把nodejs解释器命令改为<code>nodejs</code>, 大家需要用到nodejs的解释器时需要<code>nodejs</code>命令, 而不是<code>node</code>. 但是这样就会带来向后兼容的问题, 之前的nodejs脚本中的命令还用的是<code>node</code>, 其他Linux发行版也一直在用<code>node</code>. 所以他们想了一个兼容的方法, 创建一个符号链接, 将/usr/bin/node链接到/usr/bin/nodejs. 这个工作又<code>node-legacy</code>包来实现, 不推荐用户自己手动链接. 并且他们也规定, ‘nodejs’的源代码包应该也提供一个<code>node-legacy</code>的可执行包. 这样就”完美”地解决了兼容问题.</p>
<p>由此看来, debian系的发布版都会出现这个问题.</p>
<h3 id="发布到github上"><a href="#发布到github上" class="headerlink" title="发布到github上"></a>发布到github上</h3><p>在github上新建一个库, 库名为 “$(你想要的名字).github.io”, 比如, 我的是”youngforest.github.io”. 事实上, 以这样的格式命名, github会默认配置好你的<code>[GitHub Pages](https://pages.github.com/)</code>, 默认发布到”https://$(你想要的名字).github.io/“, 比如我的就是”<a href="https://youngforest.github.io/&quot;">https://youngforest.github.io/&quot;</a>.<br>当然, 如果你不这样命名的话, 自己也可去库中的设置中设置发布<code>GitHub Page</code>.</p>
<p>在本地的博客目录下, 运行<code>hexo generate</code>, 即可在<code>public/</code>中生成你博客的静态页面, 在这个文件夹下, 将其中所有的文件推到你在github上建好的库就可以了.</p>
<p>关于具体如何将本地的文件夹推到新建好的库, 在你新建好空库的时候, github应该会告诉你.</p>
<p><img src="https://cloud.githubusercontent.com/assets/13612111/20461580/713552e6-af3d-11e6-8078-a8c570e594af.png" alt="initial a repository in github"></p>
<p>如果你想要一条命令完成github部署的话, 可以参考<a href="https://hexo.io/zh-cn/docs/deployment.html">相关文档</a>.</p>
<p>我在运行<code>hexo deploy</code>是会遇到这样的错误<code>ERROR Deployer not found: git</code>.</p>
<p>查了半天在<a href="https://github.com/hexojs/hexo/issues/1040">hexo的isuue</a>中找到了解决方法. 在bash中运行如下命令就好了.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure>

<p>当你在浏览器中访问你的”GitHub Pages”时, 就会看到部署好的博客.<br>在<a href="https://youngforest.github.io/">这里</a>可以看到我部署好的博客.</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣2021春季赛 - 个人赛</title>
    <url>/2021/04/05/LCCUP-21-Spring-Solo/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (2)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
<th>Q5 (10)</th>
</tr>
</thead>
<tbody><tr>
<td>171 / 2750</td>
<td>YoungForest</td>
<td>12</td>
<td>0:56:51</td>
<td>0:06:21</td>
<td>0:49:14</td>
<td>0:56:55</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<p><a href="https://leetcode-cn.com/contest/season/2021-spring/ranking/solo/">比赛链接</a></p>
<h2 id="LCP-28-采购方案"><a href="#LCP-28-采购方案" class="headerlink" title="LCP 28. 采购方案"></a>LCP 28. 采购方案</h2><p>签到题。可以看到总共2750名选手签到。</p>
<p>二分搜索。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">purchasePlans</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 1 2 4 5 6/</span></span><br><span class="line">        <span class="comment">// target = 5</span></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">begin</span>() + i, target - x);</span><br><span class="line">            ans = (ans + <span class="built_in">distance</span>(nums.<span class="built_in">begin</span>(), it)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<h2 id="LCP-29-乐团站位"><a href="#LCP-29-乐团站位" class="headerlink" title="LCP 29. 乐团站位"></a>LCP 29. 乐团站位</h2><p>一开始很简单想到模拟填数，时间复杂度为 O（N^2), 因为n 最大 <code>10^9</code>. 显然已经超时了，我们需要考虑更优的解法。</p>
<p>观察发现，数字填写的规律十分明显。我们其实只需要计算其离起点的位置即可。通过计算目标点距离四周的距离，我们可以得到外侧总共有多少层，再通过等差数列求和，可以快速计算出外侧有多少数。然后，问题简化为目标点一定再最外圈的情况。分4种情况（上边，右边，下边，左边）分别计算目标点与左上角的距离。</p>
<p>虽然想出这样O(1)的解法不难，但由于过程中设计数列求和，4边情况等细节，实现起来还是有些挑战，而且一不小心还挺容易出错的。我比赛过程中也是，自己写了覆盖所有情况的test case，解决了一些bug，才一次提交通过的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Sn=n*a1+n(n-1)d/2</span></span><br><span class="line">        <span class="keyword">const</span> ll left = y, right = n - <span class="number">1</span> - y, up = x, down = n - <span class="number">1</span> - x;</span><br><span class="line">        <span class="keyword">const</span> ll shell = <span class="built_in">min</span>(&#123;left, right, up, down&#125;);</span><br><span class="line">        <span class="keyword">const</span> ll a1 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> ll d = <span class="number">-2</span>;</span><br><span class="line">        ll shellAmount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (shell &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            shellAmount = <span class="number">4</span> * (shell * a1 + shell * (shell - <span class="number">1</span>) * d / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> ll startX = shell, startY = shell, len = n - <span class="number">2</span> * shell;</span><br><span class="line">        <span class="keyword">const</span> ll start = (shellAmount) % <span class="number">9</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; shell &lt;&lt; &quot; &quot; &lt;&lt; start &lt;&lt; &quot; &quot; &lt;&lt; startX &lt;&lt; &quot; &quot; &lt;&lt; startY &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (shell == up) &#123;</span><br><span class="line">            <span class="keyword">return</span> (y - startY + start) % <span class="number">9</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shell == right) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (x - startX + start + len - <span class="number">1</span>) % <span class="number">9</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shell == down) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (len - <span class="number">1</span> - (y - startY) + start + <span class="number">2</span> * (len - <span class="number">1</span>)) % <span class="number">9</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// shell == left</span></span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (len - <span class="number">1</span> - (x - startX) + start + <span class="number">3</span> * (len - <span class="number">1</span>)) % <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orchestraLayout</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(n, x, y) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<h2 id="LCP-30-魔塔游戏"><a href="#LCP-30-魔塔游戏" class="headerlink" title="LCP 30. 魔塔游戏"></a>LCP 30. 魔塔游戏</h2><p>贪心。<br>先遍历一遍判断和是否大于等于0，以决定最终的胜利与否。<br>当血量少于1时，把之前减血最多的怪物放到最后。<br>用一个优先队列维护怪物的减血量，方便快速找到最大的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">magicTower</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        ll total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            total += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (total &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ll current = <span class="number">1</span>;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            current += x;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">                pq.<span class="built_in">push</span>(-x);</span><br><span class="line">            <span class="keyword">if</span> (current &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                current += pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<h2 id="LCP-31-变换的迷宫"><a href="#LCP-31-变换的迷宫" class="headerlink" title="LCP 31. 变换的迷宫"></a>LCP 31. 变换的迷宫</h2><p>比赛时只想出了暴力的 DFS + DP 解法。<br>时间复杂度: O(times * rows * cols * 2 * rows * cols * 5) = 100 * 50 * 50 * 2 * 50 * 50 * 5 = 6,250,000,000. 果不其然，TLE了。<br>虽然如此，也在此给出自己TLE版本的代码。因为我认为这是一个针对类似路径问题不错的一个解法，可以针对大多数medium的题目。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">escapeMaze</span>(<span class="params">self, maze: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        maxT = <span class="built_in">len</span>(maze)</span><br><span class="line">        rows = <span class="built_in">len</span>(maze[<span class="number">0</span>])</span><br><span class="line">        cols = <span class="built_in">len</span>(maze[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        nextStep = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">t, i, j, temp, forever</span>):</span></span><br><span class="line">            <span class="keyword">if</span> t &gt;= maxT: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i == rows - <span class="number">1</span> <span class="keyword">and</span> j == cols - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            maxTry = rows - <span class="number">1</span> - i + cols - <span class="number">1</span> - j</span><br><span class="line">            <span class="keyword">if</span> maxTry &gt; maxT - t - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> di, dj <span class="keyword">in</span> nextStep:</span><br><span class="line">                ni = i + di</span><br><span class="line">                nj = j + dj</span><br><span class="line">                <span class="keyword">if</span> ni &gt;= <span class="number">0</span> <span class="keyword">and</span> ni &lt; rows <span class="keyword">and</span> nj &gt;= <span class="number">0</span> <span class="keyword">and</span> nj &lt; cols <span class="keyword">and</span> t + <span class="number">1</span> &lt; maxT:</span><br><span class="line">                    <span class="keyword">if</span> maze[t + <span class="number">1</span>][ni][nj] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span> (dfs(t + <span class="number">1</span>, ni, nj, temp, forever)):</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="comment"># &#x27;#&#x27;</span></span><br><span class="line">                        <span class="keyword">if</span> forever == (ni, nj):</span><br><span class="line">                            <span class="keyword">if</span> (dfs(t + <span class="number">1</span>, ni, nj, temp, forever)):</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">if</span> forever == (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">                                <span class="keyword">if</span> (dfs(t + <span class="number">1</span>, ni, nj, temp, (ni, nj))):</span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">if</span> temp:</span><br><span class="line">                                <span class="keyword">if</span> (dfs(t + <span class="number">1</span>, ni, nj, <span class="literal">False</span>, forever)):</span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        ans = dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        dfs.cache_clear()</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>

<p>赛后，还是要学习一下大佬们的解法。事实上，比赛中只有100名选手通过。</p>
<p><a href="https://leetcode-cn.com/problems/Db3wC1/solution/ji-yi-hua-sou-suo-si-lu-xiang-jie-by-hal-mmnj/">这个题解</a> 是我看了所有高赞（其实也都是个位数）回答发现最有说服力，也是最好的解法。也可以辅助<a href="https://leetcode-cn.com/problems/Db3wC1/solution/dong-tai-gui-hua-he-xin-yao-dian-you-hua-gnas/">另外一个题解看</a>, 思路类似。<br>问题的核心在于:</p>
<blockquote>
<p>如果将一个位置的陷阱 “永久” 消除，那么我们可以多次经过这一位置。但是，这等同于我们在这个位置上停留了一段时间。比如，行进的路径为 a→b→a→c→a，那么这等效于一直待在 a 不动。</p>
</blockquote>
<p>因此，可以把时间复杂度中用于枚举永久消失术位置的因子去掉，也就少了<code>50*50</code>，缩减到了<code>5,000,000</code>.</p>
<h2 id="LCP-32-批量处理任务"><a href="#LCP-32-批量处理任务" class="headerlink" title="LCP 32. 批量处理任务"></a>LCP 32. 批量处理任务</h2><p>真正的难题，比赛时只有31人通过。题解都少了不少。<br>看了不少使用高级算法做的ACM大佬，我连代码都没看懂。<br>找到这个<a href="https://leetcode-cn.com/problems/t3fKg1/solution/c-tan-xin-by-zqy1018-03bd/">贪心解法的题解</a>，分享给大家。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣2021春季赛 - 战队赛</title>
    <url>/2021/04/11/LCCUP-21-Spring-Team/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (2)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
<th>Q5 (9)</th>
<th>Q6(12)</th>
</tr>
</thead>
<tbody><tr>
<td>228 / 781</td>
<td>佛系刷题</td>
<td>6/41</td>
<td>1:00:00</td>
<td>0:42:42</td>
<td>1:00:00</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<p><a href="https://leetcode-cn.com/contest/season/2021-spring/ranking/team/">比赛链接</a></p>
<p>之前LC-CN举办的春季赛和秋季赛我都没参加，因为实验室之前每周六下午开组会，时间完美冲突。现在老板改为平时开小组会，一月开一次大组会，终于有机会参加2021年的春季赛了。<br>周一清明节参加了个人赛，<a href="https://youngforest.github.io/2021/04/05/LCCUP-21-Spring-Solo/">总结博客于此</a>.<br>周六和 <strong>佛系刷题群</strong> 的 老赖 还有 George 组队一起佛系出征，最后的结果果然很佛系，2题结束。我第一题，George第二题（还是我提供思路，帮忙 review + debug). 不得不说，跟2个人组队打比赛还不如我一个人效果好。怪不得ACM比赛的队伍都要磨合好久。</p>
<h2 id="LCP-33-蓄水"><a href="#LCP-33-蓄水" class="headerlink" title="LCP 33. 蓄水"></a>LCP 33. 蓄水</h2><p>签到题。虽然是Easy，不过作为竞赛第一题，本题的难度还是相当大的。</p>
<p>观察 + 暴力。</p>
<p>操作共分为 升级 和 蓄水 2种。显然 <strong>蓄水</strong>操作应排在<strong>升级</strong>之后.<br>一个朴素的暴力方法是，我们先枚举所有可能的蓄水次数，升级次数就因之而定，然后在其中选最小的。枚举蓄水次数也存在剪枝的过程。先试小的，如果已经比全局最小总次数大了，就直接结束了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">storeWater</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; bucket, vector&lt;<span class="keyword">int</span>&gt;&amp; vat)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// time: max(buckets[i]) * buckets.size() = 10^4 * 100</span></span><br><span class="line">        <span class="keyword">int</span> ans = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = bucket.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">accumulate</span>(vat.<span class="built_in">begin</span>(), vat.<span class="built_in">end</span>(), <span class="number">0</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> need = vat[i] - bucket[i] * x;</span><br><span class="line">                <span class="keyword">if</span> (need &gt; <span class="number">0</span>) ans += (need + x - <span class="number">1</span>) / x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">1e4</span>; ++x) &#123; <span class="comment">// 蓄水次数</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt;= ans) <span class="keyword">break</span>;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, x + <span class="built_in">check</span>(x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(max(vat[i]) * buckets.length) = O(10^4 * 100),<br>空间复杂度: O(1).</p>
<h2 id="LCP-34-二叉树染色"><a href="#LCP-34-二叉树染色" class="headerlink" title="LCP 34. 二叉树染色"></a>LCP 34. 二叉树染色</h2><p>DFS。需要注意的是，因为蓝色<strong>连接体</strong>节点数目为k，我们需要枚举把当前剩下的蓝色点数分配给左子树和右子树的方式。另外，观察到k的数目其实不大，只有10。更加印证了我的猜想。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root: TreeNode, remain: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            ans = dfs(root.left, k) + dfs(root.right, k)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, remain):</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dfs(root.left, i) + dfs(root.right, remain - <span class="number">1</span> - i) + root.val)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root, k)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(结点数 * k)，<br>空间负载的: O(结点数 * k).</p>
<h2 id="LCP-35-电动车游城市"><a href="#LCP-35-电动车游城市" class="headerlink" title="LCP 35. 电动车游城市"></a>LCP 35. 电动车游城市</h2><h2 id="LCP-36-最多牌组数"><a href="#LCP-36-最多牌组数" class="headerlink" title="LCP 36. 最多牌组数"></a>LCP 36. 最多牌组数</h2><h2 id="LCP-37-最小矩形面积"><a href="#LCP-37-最小矩形面积" class="headerlink" title="LCP 37. 最小矩形面积"></a>LCP 37. 最小矩形面积</h2><h2 id="LCP-38-守卫城堡"><a href="#LCP-38-守卫城堡" class="headerlink" title="LCP 38. 守卫城堡"></a>LCP 38. 守卫城堡</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 134 Gas Station</title>
    <url>/2019/09/06/LeetCode-134-Gas-Station/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problems/gas-station/description/">题目描述</a></p>
<p>本题是我2月份Google实习生电话面试遇到的一道题目。我当时做的很混乱，一面直接挂了。今天看到<a href="https://zhuanlan.zhihu.com/p/81412559">同学发的讲解</a>，决定重新尝试一下这道题目。毕竟自己这半年来刷了有500+道题目，算法实力有一定的增长。我只看到了讲解的题目，并没有看内容，算是自己半年后可以独立解决这个问题了吧。AC后，我竟然都哭了，为当时实力不济而伤心。不知道之后还有那么好的机会吗？<br>这半年也参加了3次Kick start，除了第一次的A轮收到简历通知外，D轮和E轮都挂了。<br>就像我之前反复讲的，我很想去Google，微软这样的外企，自己也为之付出了半年的努力。希望努力会有回报吧！如果可以拿到明年暑期的Google或微软的暑期实习，我就奖励自己一次端午节假期去韩国的自由行。有青梅竹马在那里，可以去找她。</p>
<p>本题的思路是这样的:</p>
<p>首先暴力的O(N^2)解法很简单.<br>枚举所有的起点，从起点出发模拟循环的过程。<br>可以用2个前缀和数组gas_prefix和cost_prefix追踪油量和花费，保证油量永远大于等于花费。</p>
<p>然后尝试进一步的优化，思考不同起点之间的信息是否可以互相利用。<br>观察有, 如果在第i个加油站油量小于花费了，则从起点到i（包含）的加油站都不必作为起点尝试了。因为如果<code>起点 &lt; j &lt;= i</code>，则<code>j</code>作为起点，到<code>i</code>时的gas_prefix = 旧起点的gas_prefix - 旧起点到j的gas_prefix, 同理cost_prefix = 旧起点的cost_prefix- 旧起点到j的cost_prefix. 因为旧起点到j是成功的，所以有<code>旧起点到j的gas_prefix &gt;= 旧起点到j的cost_prefix</code>, 所以gas_prefix还是小于 cost_prefix。j就不用尝试了，可以直接跳过。<br>所以我们有了在O(N)的复杂度下的解法，起点直接跳到失败节点之后。</p>
<p>同学的解法是通过反证法证明这一优化正确性的，也是很好的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; gas, vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">gas_prefix</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cost_prefix</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> begin_index = <span class="number">0</span>; begin_index &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    gas_prefix[i] = gas[(begin_index + i) % n];</span><br><span class="line">                    cost_prefix[i] = cost[(begin_index + i) % n];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    gas_prefix[i] = gas_prefix[i - <span class="number">1</span>] + gas[(begin_index + i) % n];</span><br><span class="line">                    cost_prefix[i] = cost_prefix[i - <span class="number">1</span>] + cost[(begin_index + i) % n];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (gas_prefix[i] &lt; cost_prefix[i]) &#123;</span><br><span class="line">                    begin_index += i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> begin_index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #136 Single Number</title>
    <url>/2018/09/12/LeetCode-136-Single-Number/</url>
    <content><![CDATA[<p>Description: <a href="https://leetcode.com/problems/single-number/description/">https://leetcode.com/problems/single-number/description/</a><br>Solution: <a href="https://leetcode.com/problems/single-number/solution/">https://leetcode.com/problems/single-number/solution/</a><br>Difficulty: Easy</p>
<p>题目的难点在于：Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>我苦思冥想，实在无法同时满足时间复杂度O(n)，空间复杂的O(1)的要求。跑去看题解，Approach 4满足条件。使用了异或的位运算的性质，确实需要技巧。也可以看到评论区充满了”awesome”的感叹。会者不难，以后再遇到就Easy了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            ret ^= i</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode #15 3Sum</title>
    <url>/2018/10/25/LeetCode-15-3Sum/</url>
    <content><![CDATA[<p>这道很经典的题目我恰好在面试“景驰”的时候遇到过，当时是二面的Eric问的。我没做过这道题，但与之关联的2Sum做过（毕竟是LeetCode的首题，大概很多人都做过）。而且算法第4版中讨论算法复杂度的时候，用的也是一样的问题（细节可能不同，比如要求了结果中没有重复的triplet…），当时还有些印象。顺利地写出了O(n^2)时间复杂度的Solution，虽然事后发现有些小bug，比如list的sort是inplace的。但无伤大雅。<br>今天我把面试时的solution整理了一下，submit后竟然Time Limit Exceeded了。</p>
<p>Description: <a href="https://leetcode.com/problems/3sum/description/">https://leetcode.com/problems/3sum/description/</a><br>Solution: None<br>Difficulty: Medium</p>
<h2 id="面试时的solution"><a href="#面试时的solution" class="headerlink" title="面试时的solution"></a>面试时的solution</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        mymap = &#123;&#125;</span><br><span class="line">        results = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> - nums[i] - nums[j] <span class="keyword">in</span> mymap:</span><br><span class="line">                    a = [- nums[i] - nums[j], nums[i], nums[j]]</span><br><span class="line">                    a.sort()</span><br><span class="line">                    results.add(<span class="built_in">tuple</span>(a))</span><br><span class="line">            mymap[nums[i]] = i</span><br><span class="line">        </span><br><span class="line">        re = []</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> results:</span><br><span class="line">            re.append(<span class="built_in">list</span>(a))</span><br><span class="line">        <span class="keyword">return</span> re</span><br></pre></td></tr></table></figure>

<h2 id="解决超时问题"><a href="#解决超时问题" class="headerlink" title="解决超时问题"></a>解决超时问题</h2><p>reference[<a href="https://fizzbuzzed.com/top-interview-questions-1/]">https://fizzbuzzed.com/top-interview-questions-1/]</a></p>
<p>总的思想是，O(n^2)的时间复杂度已经不能再低了。更多的是尝试一些小的技巧，降低时间复杂度中的常数。</p>
<h3 id="先排序"><a href="#先排序" class="headerlink" title="先排序"></a>先排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        mymap = <span class="built_in">set</span>()</span><br><span class="line">        results = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> j != i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> - nums[i] - nums[j] <span class="keyword">in</span> mymap:</span><br><span class="line">                    a = [- nums[i] - nums[j], nums[i], nums[j]]</span><br><span class="line">                    a.sort()</span><br><span class="line">                    results.add(<span class="built_in">tuple</span>(a))</span><br><span class="line">            mymap.add(nums[i])</span><br><span class="line">        </span><br><span class="line">        re = []</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> results:</span><br><span class="line">            re.append(<span class="built_in">list</span>(a))</span><br><span class="line">        <span class="keyword">return</span> re</span><br></pre></td></tr></table></figure>

<p>增加了排序，和2层循环中的判断，使得重复的triplet出现的次数更少(<code>result.add(tuple(a))</code>被执行的次数更少)。<br>观察之前TLE的Test case可以发现，leetcode卡了重复的triplet这块。python <code>set.add</code>操作的时间复杂度为O(1)，所以还是被卡了常数。</p>
<h3 id="two-pointer-空间复杂度降为O-1"><a href="#two-pointer-空间复杂度降为O-1" class="headerlink" title="two pointer, 空间复杂度降为O(1)"></a>two pointer, 空间复杂度降为O(1)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        results = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># never let i refer to the same value twice</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[k] == <span class="number">0</span>:</span><br><span class="line">                    results.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]: <span class="comment"># never let j refer the same value twice</span></span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[j] + nums[k] &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<p>第一次提交上去仍然是超时，然而啥也没改再次提交就Accepted了。看来leetcode也是看脸。</p>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #215 Kth Largest Element in an Array</title>
    <url>/2018/09/15/LeetCode-215-Kth-Largest-Element-in-an-Array/</url>
    <content><![CDATA[<p>Description: <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">https://leetcode.com/problems/kth-largest-element-in-an-array/description/</a><br>Solution: <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/">https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/</a><br>Difficulty: Medium</p>
<p>这是二师兄面试景驰的一道题目。因为他的面试在上午，我的在下午。所以，和他交流过面试内容后，我把他被面的题目都做了一遍。包括这道题目和<a href="https://leetcode.com/problems/coin-change/description/">找硬币</a>。</p>
<h2 id="我的动态规划"><a href="#我的动态规划" class="headerlink" title="我的动态规划"></a>我的动态规划</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        mi = nums[<span class="number">0</span>]</span><br><span class="line">        ma = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            ma = <span class="built_in">max</span>(ma, nums[i])</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, nums[i])</span><br><span class="line">            memo[(i, i+<span class="number">1</span>)] = mi</span><br><span class="line">            memo[(i, <span class="number">1</span>)] = ma</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">n, k</span>):</span></span><br><span class="line">            <span class="keyword">if</span> (n, k) <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">return</span> memo[(n, k)]</span><br><span class="line">            </span><br><span class="line">            n_sub_1_k = find(n-<span class="number">1</span>, k)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[n] &lt;= n_sub_1_k:</span><br><span class="line">                <span class="keyword">return</span> n_sub_1_k</span><br><span class="line">            </span><br><span class="line">            n_sub_1_k_sub_1 = find(n-<span class="number">1</span>, k-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[n] &gt;= n_sub_1_k_sub_1:</span><br><span class="line">                <span class="keyword">return</span> n_sub_1_k_sub_1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[n]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> find(<span class="built_in">len</span>(nums)-<span class="number">1</span>, k)</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n^2)，memo中的每个元素需要遍历一遍;<br>空间复杂度 O(n^2)，创建一个二维的memo.</p>
<p>结果：TLE 超时。<br>还不如直接快排找第k个值。</p>
<h2 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a><a href="https://en.wikipedia.org/wiki/Selection_algorithm">选择算法</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">nums, lo, hi</span>):</span></span><br><span class="line">            i = lo + <span class="number">1</span></span><br><span class="line">            j = hi</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">while</span> i &lt;= hi <span class="keyword">and</span> nums[i] &lt; nums[lo]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &gt; lo <span class="keyword">and</span> nums[j] &gt; nums[lo]:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                    </span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            nums[lo], nums[j] = nums[j], nums[lo]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> j</span><br><span class="line">        </span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        k = <span class="built_in">len</span>(nums) - k</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            j = partition(nums, lo, hi)</span><br><span class="line">            <span class="keyword">if</span> j &lt; k:</span><br><span class="line">                lo = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &gt; k:</span><br><span class="line">                hi = j - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> nums[k]</span><br></pre></td></tr></table></figure>

<p>和快排很像，尤其是<code>partition</code>部分。<br>时间复杂度O(n)，空间复杂度O(n)。<br>具体解释见<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60294/Solution-explained">Discuss</a>。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode 258 Add Digits</title>
    <url>/2019/04/06/LeetCode-258-Add-Digits/</url>
    <content><![CDATA[<p>今天刷题的时候遇到一个有趣的题目，求一个数字各个位相加的和，知道和小于10。<a href="https://leetcode.com/problems/add-digits/description/">链接</a>.<br>题目本身并不难，递归或者迭代都可以解决。但如何在O(1)的复杂度内求解，才是真正的考点。</p>
<p>答案很简单: 1 + (num - 1) % 9.<br>有兴趣的可以看看证明和扩展: <a href="https://en.wikipedia.org/wiki/Digital_root#Congruence_formula">wikipedia</a>.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 29 Divide Two Integer</title>
    <url>/2018/10/23/LeetCode-29-Divide-Two-Integer/</url>
    <content><![CDATA[<p>有4周时间没有刷LeetCode了，理由一方面是紧迫感下降，另一方面是行动力不足。<br>最近又有一场面试要准备，小红书 视频组 的算法实习生。<br>一面看 机器学习的知识，防止重蹈 快手 面试的覆辙；另一面回顾自己的代码能力，果然4周不刷题，连代码都写不好了。作为未来的程序员，代码能力不好怎么行呢？还是要重新有规划的开始刷leetcode的。</p>
<p>Description: <a href="https://leetcode.com/problems/divide-two-integers/description/">https://leetcode.com/problems/divide-two-integers/description/</a><br>Solution: 无<br>Difficulty: Medium</p>
<h2 id="brute-approach"><a href="#brute-approach" class="headerlink" title="brute approach"></a>brute approach</h2><p>直接暴力，用减法代替除法。不出所料，果然超时。<br>时间复杂度：O(m)，m为商的绝对值。<br>空间复杂度：O(1), 除常量外，并未申请额外空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">1</span>) <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> positive = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (Integer.signum(dividend) + Integer.signum(divisor) == <span class="number">0</span>) positive = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> originalDividend = dividend;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            dividend = positive ? dividend - divisor : dividend + divisor;</span><br><span class="line">            <span class="keyword">if</span> (Integer.signum(dividend) == <span class="number">0</span>) &#123;</span><br><span class="line">                count = positive ? count + <span class="number">1</span> : count - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Integer.signum(dividend) + Integer.signum(originalDividend) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            count = positive ? count + <span class="number">1</span> : count - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模拟除法笔算"><a href="#模拟除法笔算" class="headerlink" title="模拟除法笔算"></a>模拟除法笔算</h2><ul>
<li><a href="https://leetcode.com/problems/divide-two-integers/discuss/179759/Python-7-lines-(beats-99):-How-you-learned-to-divide-when-you-were-7-years-old">很好的解释和python代码</a></li>
<li><a href="https://leetcode.com/problems/divide-two-integers/discuss/13417/No-Use-of-Long-Java-Solution">Java Solution, explanation awful though</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dividend==Integer.MIN_VALUE &amp;&amp; divisor==-<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(dividend &gt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>) <span class="keyword">return</span> divideHelper(-dividend, -divisor);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dividend &gt; <span class="number">0</span>) <span class="keyword">return</span> -divideHelper(-dividend,divisor);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(divisor &gt; <span class="number">0</span>) <span class="keyword">return</span> -divideHelper(dividend,-divisor);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> divideHelper(dividend, divisor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">divideHelper</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span></span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(divisor &lt; dividend) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// get highest digit of divisor</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((divisor &lt;&lt; cur) &gt;= dividend &amp;&amp; divisor &lt;&lt; cur &lt; <span class="number">0</span> &amp;&amp; cur &lt; <span class="number">31</span>) cur++;</span><br><span class="line">        res = dividend - (divisor &lt;&lt; cur-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res &gt; divisor) <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; cur-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 每次调用都只计算出来商里为1的一位</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; cur-<span class="number">1</span>)+divide(res, divisor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode #380 Insert Delete GetRandom O(1)</title>
    <url>/2018/10/26/LeetCode-380-Insert-Delete-GetRandomO-1/</url>
    <content><![CDATA[<p>此题的重点在于理解“average O(1) time”，这是也是时间复杂度分析中的一个重要概念”amortized”。<br>在 算法第4版 中，很多数据结构的操作的分析都是用的这个方法。所以，“amortized time complexity”常常和对应的数据结构的操作相对应。我5月时面试旷世科技的时候，第二题问的是构造一个维护最大值的队的数据结构，最后要求操作的时间复杂度是“amortized O(1)”。很遗憾，当时我对“amortized”这一概念还不熟悉，对最差情况下的时间复杂度分析的倒是可以，虽然在面试官的引导下最后得出正确答案，但可想而知，最后的结果是no hire。</p>
<p>Description: <a href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/">https://leetcode.com/problems/insert-delete-getrandom-o1/description/</a><br>Solution: None<br>Difficulty: Medium</p>
<p><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/discuss/85401/Java-solution-using-a-HashMap-and-an-ArrayList-along-with-a-follow-up.-(131-ms)">answer</a></p>
<p>关键点在于，利用hashmap查找效率为O(1),ArrayList很方便用下标来产生随机数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.array = []</span><br><span class="line">        self.index_map = &#123;&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.index_map:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        self.index_map[val] = <span class="built_in">len</span>(self.array)</span><br><span class="line">        self.array.append(val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.index_map:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        self.array[self.index_map[val]] = self.array[-<span class="number">1</span>]</span><br><span class="line">        self.index_map[self.array[-<span class="number">1</span>]] = self.index_map[val]</span><br><span class="line">        self.array.pop()</span><br><span class="line">        self.index_map.pop(val)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rnd = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(self.array)-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.array[rnd]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RandomizedSet()</span></span><br><span class="line"><span class="comment"># param_1 = obj.insert(val)</span></span><br><span class="line"><span class="comment"># param_2 = obj.remove(val)</span></span><br><span class="line"><span class="comment"># param_3 = obj.getRandom()</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode #538 Convert BST to Greater Tree</title>
    <url>/2018/09/14/LeetCode-538-Convert-BST-to-Greater-Tree/</url>
    <content><![CDATA[<p>Description: <a href="https://leetcode.com/problems/convert-bst-to-greater-tree/description/">https://leetcode.com/problems/convert-bst-to-greater-tree/description/</a><br>Solution: <a href="https://leetcode.com/problems/convert-bst-to-greater-tree/solution/">https://leetcode.com/problems/convert-bst-to-greater-tree/solution/</a><br>Difficulty: Easy</p>
<p>此题虽为Easy难度，但一遍写对还是很困难的。<br>看到二叉树，就要想到用递归解决。本题的一个trick是，如何把需要累加的值这个信息，在递归过程中传递。</p>
<p>递归调用右子树时，需要返回整个右子树的和，将这个和加到根节点上。具体到我的解法，右子树的和可能存在于2个地方。1. 右子树的最左叶子节点 2. 右子树的根节点(此时，右子树无左子树)。</p>
<p>递归调用左子树时，需要把根节点和右子树的和，这些信息传递进去，加到右子树的最左叶子上（也就是右子树中最大的那个值）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">root, addition</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> addition</span><br><span class="line">            root.val += convert(root.right, addition)</span><br><span class="line">            <span class="keyword">if</span> root.left == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            <span class="keyword">return</span> convert(root.left, root.val)</span><br><span class="line">        </span><br><span class="line">        convert(root, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，需要遍历每个节点一次。<br>空间复杂度 平均O(log n)，最差O(n)，递归调用的最大深度。</p>
<p>看过Solution后，惊觉自己把问题搞得太复杂了。传递累加的值这一信息，通过一个全局变量维护即可。然后再对树右序遍历，代码写起来也简单很多。Solution中的Approach #3最好，其空间复杂度为O(1)。</p>
<h2 id="迭代版本（无递归）"><a href="#迭代版本（无递归）" class="headerlink" title="迭代版本（无递归）"></a>迭代版本（无递归）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        node = root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">or</span> node != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> node != <span class="literal">None</span>:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.right</span><br><span class="line">            </span><br><span class="line">            node = stack.pop()</span><br><span class="line">            </span><br><span class="line">            total += node.val</span><br><span class="line">            node.val = total</span><br><span class="line">            </span><br><span class="line">            node = node.left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 1</title>
    <url>/2019/06/03/LeetCode-biweekly-contest-1/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>241 / 983</td>
<td>YoungForest</td>
<td>7</td>
<td>0:18:23</td>
<td>0:09:56</td>
<td>0:18:23</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<p>LeetCode开放了首届的双周赛，每周六晚上10:30~12:30。目的可能是方便欧洲的同学参赛（平时的单周赛欧洲那边都是凌晨），可以出更难的题目。因为时长扩展到2个小时了。</p>
<p>由于19:00~21:30已经参加了Byte dance 的summer camp笔试。该笔试题也很难，3道编程题只有第二题过了30%。所以稍后的biweekly contest也翻车了，完成的 并不理想。只作出了2道Easy的题目。</p>
<h2 id="1055-Fixed-Point"><a href="#1055-Fixed-Point" class="headerlink" title="1055. Fixed Point"></a>1055. Fixed Point</h2><p>Intuition:<br>Straight forward. One pass.</p>
<p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(1)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fixedPoint</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于数组A是升序的，所以还可以用 二分搜索 的算法，实现<code>O(log N)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fixedPoint</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt; mid) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> A[lo] == lo ? lo : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1056-Index-Pairs-of-a-String"><a href="#1056-Index-Pairs-of-a-String" class="headerlink" title="1056. Index Pairs of a String"></a>1056. Index Pairs of a String</h2><p>Intuition:<br>题目为Easy，数据规模也比较小，考虑暴力解法即可。<br>时间复杂度: O(words.size() * text.size() * words[i].size()),<br>空间复杂度: O(words.size() * text.size()).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">indexPairs</span>(string text, vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> string&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((pos = text.<span class="built_in">find</span>(word, pos)) != string::npos) &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(&#123;pos, pos + word.<span class="built_in">size</span>() - <span class="number">1</span>&#125;);</span><br><span class="line">                pos += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>(), [](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; rhs) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs[<span class="number">0</span>] != rhs[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">return</span> lhs[<span class="number">0</span>] &lt; rhs[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> lhs[<span class="number">1</span>] &lt; rhs[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1066-Campus-Bikes-II"><a href="#1066-Campus-Bikes-II" class="headerlink" title="1066. Campus Bikes II"></a>1066. Campus Bikes II</h2><p>由于数据规模很小，1 &lt;= workers.length &lt;= bikes.length &lt;= 10，考虑暴力的backtracking。<br>时间复杂度: O(workers.length ^ bikes.length).<br>空间复杂度: O(bikes.length).</p>
<p>无奈超时了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 因为1 &lt;= workers.length &lt;= bikes.length &lt;= 10，</span></span><br><span class="line">    <span class="comment">// 考虑阶乘算法 + 剪枝</span></span><br><span class="line">    <span class="keyword">int</span> global_minimum = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; workers, <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bikes, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited, <span class="keyword">int</span> local_distance, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (step == workers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            global_minimum = <span class="built_in">min</span>(global_minimum, local_distance);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (local_distance &gt;= global_minimum)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visited.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(workers, bikes, visited, local_distance + <span class="built_in">abs</span>(workers[step][<span class="number">0</span>] - bikes[i][<span class="number">0</span>]) + <span class="built_in">abs</span>(workers[step][<span class="number">1</span>] - bikes[i][<span class="number">1</span>]), step + <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">assignBikes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; workers, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bikes)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(bikes.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(workers, bikes, visited, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> global_minimum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看了Discuss, 共有2种解法。优先队列 或 DP。</p>
<h2 id="1067-Digit-Count-in-Range"><a href="#1067-Digit-Count-in-Range" class="headerlink" title="1067. Digit Count in Range"></a>1067. Digit Count in Range</h2><p>首先，先解决一个更简单的问题。<br><a href="https://leetcode.com/problems/number-of-digit-one/solution/">Solution</a><br>求数字1的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> countr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> divider = i * <span class="number">10</span>;</span><br><span class="line">        countr += (n / divider) * i + <span class="built_in">min</span>(<span class="built_in">max</span>(n % divider - i + <span class="number">1</span>, <span class="number">0LL</span>), i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上解法，很容易扩充到任何数字。<br>需要注意数字<code>0</code>因为不能开头，所以需要特殊处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// include n</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> divisor = i * <span class="number">10</span>;</span><br><span class="line">            ret += (n / divisor) * i + <span class="built_in">min</span>(i, <span class="built_in">max</span>(<span class="number">0LL</span>, n % divisor - d * i + <span class="number">1</span>)) - (d == <span class="number">0</span> ? i : <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; ret &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; ret &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitsCount</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(d, high) - <span class="built_in">helper</span>(d, low - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log N)<br>空间复杂度: O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 14</title>
    <url>/2019/12/14/LeetCode-biweekly-contest-15/</url>
    <content><![CDATA[<p>这周没有出去玩，恰好遇到双周赛。久违地参加了一场，确实难得。<br>本次双周赛都是常规题目，不难。我提前50min全部一次AC, 典型的手速场。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (2)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>119 / 2503</td>
<td>YoungForest</td>
<td>18</td>
<td>0:39:28</td>
<td>0:02:18</td>
<td>0:08:49</td>
<td>0:21:07</td>
<td>0:39:28</td>
</tr>
</tbody></table>
<p>比赛结束之前的排名是92，参与人数为1900，赛后发现名次掉了。我猜测并验证是，赛后的排名把中国区的人也算进来了。增加的人数和第一名的变化完全符合我的猜测。到leetcode-cn上看了下，那里的排名是分为中国区和全球区的。看来以后比赛时要更加油了，有许多不知道的人在中国区打同样的比赛。</p>
<h2 id="1287-Element-Appearing-More-Than-25-In-Sorted-Array"><a href="#1287-Element-Appearing-More-Than-25-In-Sorted-Array" class="headerlink" title="1287. Element Appearing More Than 25% In Sorted Array"></a>1287. Element Appearing More Than 25% In Sorted Array</h2><p>One pass统计所有数的出现次数。<br>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSpecialInteger</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> target = arr.<span class="built_in">size</span>() / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            ++count[i];</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; target)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个解法的缺陷在于没有利用题目中给的限制条件，数组是已经排好序的。但本题是签到题，数据规模10^4，此解法方便快速实现。</p>
<p>更优的解法，利用二分搜索，每次可以递增的更快些。<br>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSpecialInteger</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = arr.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (it != arr.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it2 = <span class="built_in">upper_bound</span>(it, arr.<span class="built_in">end</span>(), *it);</span><br><span class="line">            <span class="keyword">auto</span> diff = it2 - it;</span><br><span class="line">            <span class="keyword">if</span> (diff &gt; arr.<span class="built_in">size</span>() / <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">return</span> *it;</span><br><span class="line">            it = it2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1288-Remove-Covered-Intervals"><a href="#1288-Remove-Covered-Intervals" class="headerlink" title="1288. Remove Covered Intervals"></a>1288. Remove Covered Intervals</h2><p>数据规模为1000，所以O(N ^ 2)的解法就可以过。<br>最暴力的方法就是两两比较，该remove的remove。<br>我的代码还使用了一个技巧，先按区间大小排序，然后从大到小开始比较。因为小的不可能包含大的，减少了比较数量。虽然时间复杂度不变，但会在常数上稍快些。</p>
<p>时间复杂度: O(N ^ 2),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; remains;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> length_a = a[<span class="number">1</span>] - a[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> length_b = b[<span class="number">1</span>] - b[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> length_b &lt; length_a;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : intervals) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> p : remains) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.first &lt;= v[<span class="number">0</span>] &amp;&amp; v[<span class="number">1</span>] &lt;= p.second) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> remove;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remains.<span class="built_in">insert</span>(&#123;v[<span class="number">0</span>], v[<span class="number">1</span>]&#125;);</span><br><span class="line">            remove:;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> remains.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更优的解法。先排序，排序规则为 区间左侧小的靠前，如果左侧相等，则右侧大的靠前。<br>然后One pass遍历一边即可, 比较当前的右侧和之前最大的右侧的值。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b)  -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[<span class="number">1</span>] &gt; right) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            right = <span class="built_in">max</span>(right, v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1286-Iterator-for-Combination"><a href="#1286-Iterator-for-Combination" class="headerlink" title="1286. Iterator for Combination"></a>1286. Iterator for Combination</h2><p>最暴力的方法是用回溯法生成所有的组合，存起来，然后封装迭代器。缺点是：空间消耗会比较大；在next调用次数小的时候，速度上没有懒运算经济。无奈我不知道C++中如何实现 Python 的 <code>yield</code>，否则就可以懒运算了。<br>当然，赛后有时间我还是研究了下C++ yield的实现策略。<br>参考: [C++ yield实现](how C++ implement yield)</p>
<p>时间复杂度: O(C^n_characters.size()),<br>空间复杂度: O(combinationLength * C^n_characters.size()).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombinationIterator</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;string&gt;&amp; results, string&amp; current, <span class="keyword">int</span> remain, <span class="keyword">const</span> string&amp; characters, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">            results.<span class="built_in">push_back</span>(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == characters.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remain &gt; characters.<span class="built_in">size</span>() - index) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add</span></span><br><span class="line">        current.<span class="built_in">push_back</span>(characters[index]);</span><br><span class="line">        <span class="built_in">backtracking</span>(results, current, remain - <span class="number">1</span>, characters, index + <span class="number">1</span>);</span><br><span class="line">        current.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">// not add</span></span><br><span class="line">        <span class="built_in">backtracking</span>(results, current, remain, characters, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; results;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CombinationIterator</span>(string characters, <span class="keyword">int</span> combinationLength) &#123;</span><br><span class="line">        string current;</span><br><span class="line">        <span class="built_in">backtracking</span>(results, current, combinationLength, characters, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> results[index++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; results.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CombinationIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CombinationIterator* obj = new CombinationIterator(characters, combinationLength);</span></span><br><span class="line"><span class="comment"> * string param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1289-Minimum-Falling-Path-Sum-II"><a href="#1289-Minimum-Falling-Path-Sum-II" class="headerlink" title="1289. Minimum Falling Path Sum II"></a>1289. Minimum Falling Path Sum II</h2><p>和<a href="https://leetcode.com/problems/minimum-falling-path-sum/">Minimum Falling Path Sum I</a>一样，属于 DP 问题。<br>状态转移方程为:<br><code>dp[row][column] = arr[row][column] + min(dp[row - 1][last_column] for last_column in [0, column_size) and last_column != column)</code>.<br>而且实现寻找上一层的最小值并不需要多一层循环，只需要保存上一层中最小值和次小值即可。</p>
<p>时间复杂度: O(row_size * column_size),<br>空间复杂度: O(row_size * column_size)，另一个明显的优化是dp只需要保存上一层的，可以减小到O(column_size).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFallingPathSum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> row_size = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> column_size = arr[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;  <span class="built_in">dp</span>(row_size, vector&lt;<span class="keyword">int</span>&gt; (column_size, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min_first = MAX_N, min_second = MAX_N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; column_size; ++column) &#123;</span><br><span class="line">            dp[row][column] = arr[row][column];</span><br><span class="line">            <span class="keyword">if</span> (dp[row][column] &lt; min_first) &#123;</span><br><span class="line">                min_second  = min_first;</span><br><span class="line">                min_first = dp[row][column];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[row][column] &lt; min_second) &#123;</span><br><span class="line">                min_second = dp[row][column];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; dp[row][column] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot; | &quot; &lt;&lt; min_first &lt;&lt; &quot; &quot; &lt;&lt; min_second;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> last_row_min_first = min_first;</span><br><span class="line">        <span class="keyword">int</span> last_row_min_second = min_second;</span><br><span class="line">        <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt; row_size; ++row) &#123;</span><br><span class="line">            min_first = min_second = MAX_N;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; column_size; ++column) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[row - <span class="number">1</span>][column] == last_row_min_first) &#123;</span><br><span class="line">                    dp[row][column] = last_row_min_second + arr[row][column];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[row][column] = last_row_min_first + arr[row][column];</span><br><span class="line">                &#125;           </span><br><span class="line">                <span class="keyword">if</span> (dp[row][column] &lt; min_first) &#123;</span><br><span class="line">                    min_second  = min_first;</span><br><span class="line">                    min_first = dp[row][column];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[row][column] &lt; min_second) &#123;</span><br><span class="line">                    min_second = dp[row][column];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; dp[row][column] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot; | &quot; &lt;&lt; min_first &lt;&lt; &quot; &quot; &lt;&lt; min_second;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            last_row_min_first = min_first;</span><br><span class="line">            last_row_min_second = min_second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 19</title>
    <url>/2020/02/10/LeetCode-biweekly-contest-19/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>179 / 3745</td>
<td>YoungForest</td>
<td>18</td>
<td>0:41:10</td>
<td>0:02:39</td>
<td>0:10:36</td>
<td>0:12:53</td>
<td>0:36:10 1</td>
</tr>
</tbody></table>
<p>回国后第一次参加双周赛，手有些生，状态还在恢复。最近因为新型冠状病毒的瘟疫，一直在家隔离，除了买菜外几乎无法出门。今年的年味也因此没有了。我在家呆的几乎都快产后抑郁了。比赛结果还行。手速场也是我一直不擅长的类型。</p>
<h2 id="1342-Number-of-Steps-to-Reduce-a-Number-to-Zero"><a href="#1342-Number-of-Steps-to-Reduce-a-Number-to-Zero" class="headerlink" title="1342. Number of Steps to Reduce a Number to Zero"></a>1342. Number of Steps to Reduce a Number to Zero</h2><p>签到题。直接模拟 除2 和 减一 的2中操作即可。</p>
<p>时间复杂度: O(log N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSteps</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                num /= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --num;</span><br><span class="line">            &#125;</span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1343-Number-of-Sub-arrays-of-Size-K-and-Average-Greater-than-or-Equal-to-Threshold"><a href="#1343-Number-of-Sub-arrays-of-Size-K-and-Average-Greater-than-or-Equal-to-Threshold" class="headerlink" title="1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold"></a>1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold</h2><p>简单的滑动窗口，可以直接套用模版。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfSubarrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            s += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= threshold * k) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            s = s + arr[i] - arr[i - k];</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= threshold * k) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1344-Angle-Between-Hands-of-a-Clock"><a href="#1344-Angle-Between-Hands-of-a-Clock" class="headerlink" title="1344. Angle Between Hands of a Clock"></a>1344. Angle Between Hands of a Clock</h2><p>计算钟表上时针和分针之间的角度。分别计算时针和分针的位置，然后算夹角即可。</p>
<p>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">angleClock</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> h = hour;</span><br><span class="line">        <span class="keyword">double</span> m = minutes;</span><br><span class="line">        h = h * <span class="number">5</span> + m / <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="built_in">abs</span>(h - m) * <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">180</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">360</span> - x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1345-Jump-Game-IV"><a href="#1345-Jump-Game-IV" class="headerlink" title="1345. Jump Game IV"></a>1345. Jump Game IV</h2><p>又一道Jump Game的题目，本以为和之前一样都要用动态规划。尝试一次后，发现其实需要用BFS解决。<br>有一点需要注意的是，每次用过reverse数组后，需要把数组清空，这样就不会导致重复的计算。感谢<a href="https://leetcode.com/problems/jump-game-iv/discuss/502699/JavaC%2B%2B-BFS-Solution-Clean-code-O(N)">hiepit的帖子</a>。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minJumps</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> target = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; reverse;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            reverse[arr[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">        seen.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">auto</span>&amp; condidates = reverse[arr[index]];</span><br><span class="line">                condidates.<span class="built_in">push_back</span>(index + <span class="number">1</span>);</span><br><span class="line">                condidates.<span class="built_in">push_back</span>(index - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> next : condidates) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (next == target)</span><br><span class="line">                        <span class="keyword">return</span> step;</span><br><span class="line">                    <span class="keyword">if</span> (next &lt; arr.<span class="built_in">size</span>() &amp;&amp; next &gt;= <span class="number">0</span> &amp;&amp; seen.<span class="built_in">find</span>(next) == seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        seen.<span class="built_in">insert</span>(next);</span><br><span class="line">                        q.<span class="built_in">push</span>(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                condidates.<span class="built_in">clear</span>(); <span class="comment">// important, avoid duplicated computing</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 20</title>
    <url>/2020/02/23/LeetCode-biweekly-contest-20/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>233 / 4347</td>
<td>YoungForest</td>
<td>18</td>
<td>0:41:39</td>
<td>0:03:32</td>
<td>0:13:58  1</td>
<td>0:24:13</td>
<td>0:31:39  1</td>
</tr>
</tbody></table>
<p>本次比赛题目比较简单，又是一次手速和bug-free的比拼。<br>真的是错过比赛半年，连人数较少的双周赛都进不了前200了，吓～</p>
<h2 id="1356-Sort-Integers-by-The-Number-of-1-Bits"><a href="#1356-Sort-Integers-by-The-Number-of-1-Bits" class="headerlink" title="1356. Sort Integers by The Number of 1 Bits"></a>1356. Sort Integers by The Number of 1 Bits</h2><p>利用C++标准库中的排序函数和lambda表达式。</p>
<p>时间复杂度: O(n log n),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortByBits</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> aa = __builtin_popcount(a);</span><br><span class="line">            <span class="keyword">auto</span> bb = __builtin_popcount(b);</span><br><span class="line">            <span class="keyword">if</span> (aa == bb) &#123;</span><br><span class="line">                <span class="keyword">return</span> a &lt; b;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> aa &lt; bb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1357-Apply-Discount-Every-n-Orders"><a href="#1357-Apply-Discount-Every-n-Orders" class="headerlink" title="1357. Apply Discount Every n Orders"></a>1357. Apply Discount Every n Orders</h2><p>考察对数据结构的熟悉程度。根据题意直接实现即可。<br>因为读题不仔细，把discount的定义搞错了（是减价多少，而不是剩下多少），导致了一次错误提交。</p>
<p>时间复杂度：O(product.length),<br>空间复杂度：O(getBill.length).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cashier</span> &#123;</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">int</span> nn;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cashier</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> discount, vector&lt;<span class="keyword">int</span>&gt;&amp; products, vector&lt;<span class="keyword">int</span>&gt;&amp; prices) &#123;</span><br><span class="line">        d = discount;</span><br><span class="line">        nn = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; products.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            m[products[i]] = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getBill</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; product, vector&lt;<span class="keyword">int</span>&gt; amount)</span> </span>&#123;</span><br><span class="line">        ++index;</span><br><span class="line">        <span class="keyword">bool</span> discount = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == nn) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            discount = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; product.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ans += amount[i] * m[product[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (discount)</span><br><span class="line">            ans *= <span class="number">1</span> - d / <span class="number">100.0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Cashier object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Cashier* obj = new Cashier(n, discount, products, prices);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj-&gt;getBill(product,amount);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1358-Number-of-Substrings-Containing-All-Three-Characters"><a href="#1358-Number-of-Substrings-Containing-All-Three-Characters" class="headerlink" title="1358. Number of Substrings Containing All Three Characters"></a>1358. Number of Substrings Containing All Three Characters</h2><p>滑动窗口。在右侧移动的时候，保持窗口最小，此时，左侧窗口的左边都是符合条件的子串。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ++count[s[right] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; count[s[left] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                --count[s[left] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count[<span class="number">0</span>] &gt;= <span class="number">1</span> &amp;&amp; count[<span class="number">1</span>] &gt;= <span class="number">1</span> &amp;&amp; count[<span class="number">2</span>] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ans += (left + <span class="number">1</span>) * <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1359-Count-All-Valid-Pickup-and-Delivery-Options"><a href="#1359-Count-All-Valid-Pickup-and-Delivery-Options" class="headerlink" title="1359. Count All Valid Pickup and Delivery Options"></a>1359. Count All Valid Pickup and Delivery Options</h2><p>一个典型的递归问题。<br>对于n个物件，我们从中选择任何一个作为第一个pickup, 然后计算剩余n-1个物件的排序问题。diliver可以插入在任意位置(<code>2 * (n - 1) + 1</code>种情况)。</p>
<p>因为取余问题导致一次Wrong Answer，已经不是第一次了。下次需要注意。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N) -&gt; O(1), 使用迭代解法或尾递归解法，这里就不予展示了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ll <span class="title">countOrders</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (n * (<span class="built_in">countOrders</span>(n - <span class="number">1</span>) * (<span class="number">2</span> * (n - <span class="number">1</span>) + <span class="number">1</span>)) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 21</title>
    <url>/2020/03/08/LeetCode-biweekly-contest-21/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>175 / 4729</td>
<td>YoungForest</td>
<td>19</td>
<td>1:05:07</td>
<td>0:21:38</td>
<td>0:39:43</td>
<td>0:50:40</td>
<td>1:05:07</td>
</tr>
</tbody></table>
<p>整体难度不大，尤其是后2题并没有该有的难度。</p>
<h2 id="1370-Increasing-Decreasing-String"><a href="#1370-Increasing-Decreasing-String" class="headerlink" title="1370. Increasing Decreasing String"></a>1370. Increasing Decreasing String</h2><p>直接模拟构造结果字符串的过程即可。这里寻找字符串的过程可以使用二分查找，因为原始字符串需要更新，所以使用二叉查找树这一数据结构较好。</p>
<p>时间复杂度: O(N * log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">sortString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        multiset&lt;<span class="keyword">char</span>&gt; container;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            container.<span class="built_in">insert</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!container.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">char</span> smallest = *container.<span class="built_in">begin</span>();</span><br><span class="line">            container.<span class="built_in">erase</span>(container.<span class="built_in">begin</span>());</span><br><span class="line">            ans.<span class="built_in">push_back</span>(smallest);</span><br><span class="line">            <span class="keyword">decltype</span>(container.<span class="built_in">begin</span>()) it;</span><br><span class="line">            <span class="keyword">while</span> ((it = container.<span class="built_in">upper_bound</span>(smallest)) != container.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(*it);</span><br><span class="line">                smallest = *it;</span><br><span class="line">                container.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!container.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">char</span> largest = *(<span class="built_in">prev</span>(container.<span class="built_in">end</span>()));</span><br><span class="line">                container.<span class="built_in">erase</span>(<span class="built_in">prev</span>(container.<span class="built_in">end</span>()));</span><br><span class="line">                ans.<span class="built_in">push_back</span>(largest);</span><br><span class="line">                <span class="keyword">while</span> ((it = container.<span class="built_in">lower_bound</span>(largest)) != container.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(*<span class="built_in">prev</span>(it));</span><br><span class="line">                    largest = *<span class="built_in">prev</span>(it);</span><br><span class="line">                    container.<span class="built_in">erase</span>(<span class="built_in">prev</span>(it));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts"><a href="#1371-Find-the-Longest-Substring-Containing-Vowels-in-Even-Counts" class="headerlink" title="1371. Find the Longest Substring Containing Vowels in Even Counts"></a>1371. Find the Longest Substring Containing Vowels in Even Counts</h2><p>观察有：奇数减奇数等于偶数，偶数减偶数等于偶数。所以问题可以转化为，寻找最左边计数为奇数（或偶数）的位置。因为有5个元音字母，分奇偶，共32种状态。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left_state</span><span class="params">(<span class="number">32</span>, <span class="number">-2</span>)</span></span>;</span><br><span class="line">        left_state[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> code = [&amp;](unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; m) -&gt; <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">static</span> vector&lt;<span class="keyword">char</span>&gt; position = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line">            <span class="keyword">unsigned</span>  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span>  <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>  (m[position[i]] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ++m[s[i]];</span><br><span class="line">            <span class="keyword">auto</span> c = <span class="built_in">code</span>(m);</span><br><span class="line">            <span class="keyword">if</span> (left_state[c] != <span class="number">-2</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, i - left_state[c]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left_state[c] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1372-Longest-ZigZag-Path-in-a-Binary-Tree"><a href="#1372-Longest-ZigZag-Path-in-a-Binary-Tree" class="headerlink" title="1372. Longest ZigZag Path in a Binary Tree"></a>1372. Longest ZigZag Path in a Binary Tree</h2><p>树的问题用递归解。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// left, right</span></span><br><span class="line">    <span class="comment">// return result if root is left/right child</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">recurse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l = <span class="built_in">recurse</span>(root-&gt;left);</span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">recurse</span>(root-&gt;right);</span><br><span class="line">            ret = <span class="built_in">max</span>(&#123;ret, r.second + <span class="number">1</span>, l.first + <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">return</span> &#123;r.second + <span class="number">1</span>, l.first + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">recurse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1373-Maximum-Sum-BST-in-Binary-Tree"><a href="#1373-Maximum-Sum-BST-in-Binary-Tree" class="headerlink" title="1373. Maximum Sum BST in Binary Tree"></a>1373. Maximum Sum BST in Binary Tree</h2><p>仍然是 树的问题用递归解决。<br>返回值依次为：</p>
<ul>
<li>子树中的最小值</li>
<li>子树中的最大值</li>
<li>是否为BST</li>
<li>子树的和</li>
</ul>
<p>时间复杂度: O(N),<br>空间复杂度: O(height).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// smallest, largest, BST?, sum</span></span><br><span class="line">    <span class="function">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>, <span class="keyword">int</span>&gt; <span class="title">recurse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> l = <span class="built_in">recurse</span>(root-&gt;left);</span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">recurse</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">bool</span> isBST = (root-&gt;left == <span class="literal">nullptr</span> || get&lt;<span class="number">1</span>&gt;(l) &lt; root-&gt;val) &amp;&amp; (root-&gt;right == <span class="literal">nullptr</span> || get&lt;<span class="number">0</span>&gt;(r) &gt; root-&gt;val) &amp;&amp; get&lt;<span class="number">2</span>&gt;(l) &amp;&amp; get&lt;<span class="number">2</span>&gt;(r);</span><br><span class="line">            <span class="keyword">int</span> smallest = root-&gt;val, largest = root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                smallest = <span class="built_in">min</span>(smallest, get&lt;<span class="number">0</span>&gt;(l));</span><br><span class="line">                largest = <span class="built_in">max</span>(largest, get&lt;<span class="number">1</span>&gt;(l));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                smallest = <span class="built_in">min</span>(smallest, get&lt;<span class="number">0</span>&gt;(r));</span><br><span class="line">                largest = <span class="built_in">max</span>(largest, get&lt;<span class="number">1</span>&gt;(r));</span><br><span class="line">            &#125;</span><br><span class="line">                   </span><br><span class="line">            <span class="keyword">int</span> s = get&lt;<span class="number">3</span>&gt;(l) + get&lt;<span class="number">3</span>&gt;(r) + root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (isBST)</span><br><span class="line">                ret = <span class="built_in">max</span>(s, ret);</span><br><span class="line">            <span class="keyword">return</span> &#123;smallest, largest, isBST, s&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">recurse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 22</title>
    <url>/2020/03/23/LeetCode-biweekly-contest-22/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>1357 / 5632</td>
<td>YoungForest</td>
<td>12</td>
<td>1:27:09</td>
<td>0:05:06</td>
<td>0:48:41  1</td>
<td>1:22:09</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1385-Find-the-Distance-Value-Between-Two-Arrays"><a href="#1385-Find-the-Distance-Value-Between-Two-Arrays" class="headerlink" title="1385. Find the Distance Value Between Two Arrays"></a>1385. Find the Distance Value Between Two Arrays</h2><p>先对<code>arr2</code>进行排序，再对<code>arr1</code>中的每一个元素，利用二分搜索，判断<code>arr2</code>中是否有距离在<code>d</code>中的值。</p>
<p>时间复杂度: O(arr2.size() * log arr2.size() + arr1.size() * log arr2.size()),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheDistanceValue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr1) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it1 = <span class="built_in">lower_bound</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>(), i - d);</span><br><span class="line">            <span class="keyword">auto</span> it2 = <span class="built_in">upper_bound</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>(), i + d);</span><br><span class="line">            <span class="keyword">if</span> (it1 == it2)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1386-Cinema-Seat-Allocation"><a href="#1386-Cinema-Seat-Allocation" class="headerlink" title="1386. Cinema Seat Allocation"></a>1386. Cinema Seat Allocation</h2><p>贪心。每排尝试放2个family，再尝试放一个family。因为一行10个座位，所以可以用bitmap来表示占用情况。对于没reserverd的行，直接放2个。</p>
<p>时间复杂度: O(reservedSeats.size() * log reserveredSeats.size() + max(n, reservedSeats.size())),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfFamilies</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; reservedSeats)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(reservedSeats.<span class="built_in">begin</span>(), reservedSeats.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, row = <span class="number">1</span>; row &lt;= n;) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> current_row = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; index &lt; reservedSeats.<span class="built_in">size</span>() &amp;&amp; reservedSeats[index][<span class="number">0</span>] == row; ++ index) &#123;</span><br><span class="line">                current_row |= <span class="number">1</span> &lt;&lt; (reservedSeats[index][<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            current_row = ~current_row;</span><br><span class="line">            <span class="keyword">if</span> ((current_row &amp; <span class="number">0b0111111110</span>) == <span class="number">0b0111111110</span>)</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((current_row &amp; <span class="number">0b0001111000</span>) == <span class="number">0b0001111000</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((current_row &amp; <span class="number">0b0000011110</span>) == <span class="number">0b0000011110</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((current_row &amp; <span class="number">0b0111100000</span>) == <span class="number">0b0111100000</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; reservedSeats.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ans += (reservedSeats[index][<span class="number">0</span>] - row - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">                row = reservedSeats[index][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += (n + <span class="number">1</span> - row - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">                row = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1387-Sort-Integers-by-The-Power-Value"><a href="#1387-Sort-Integers-by-The-Power-Value" class="headerlink" title="1387. Sort Integers by The Power Value"></a>1387. Sort Integers by The Power Value</h2><p>刚开始想的是BFS，从1开始搜索。但是会超时，最后返回值的下标也不好处理，浪费了很多时间调试。</p>
<p>时间复杂度: O(2 ^ value of Kth),<br>空间复杂度: O(2 ^ value of Kth).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        seen.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &gt;= lo &amp;&amp; <span class="number">1</span> &lt;= hi) ++count;</span><br><span class="line">        <span class="keyword">if</span> (count == k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> x = (y - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> ((y - <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; x % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; seen.<span class="built_in">find</span>(x) == seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(x);</span><br><span class="line">                    seen.<span class="built_in">insert</span>(x);</span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= lo &amp;&amp; x &lt;= hi) ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (y &lt;= numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">                    x = y * <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (seen.<span class="built_in">find</span>(x) == seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(x);</span><br><span class="line">                        seen.<span class="built_in">insert</span>(x);</span><br><span class="line">                        <span class="keyword">if</span> (x &gt;= lo &amp;&amp; x &lt;= hi) ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++level;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; remain;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">front</span>() &gt;= lo &amp;&amp; q.<span class="built_in">front</span>() &lt;= hi) &#123;</span><br><span class="line">                remain.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(remain.<span class="built_in">begin</span>(), remain.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;count: &quot; &lt;&lt; count &lt;&lt; &quot;, &quot; &lt;&lt; remain.size() &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> remain[k - (count - remain.<span class="built_in">size</span>()) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后来发现其实是 记忆化搜索 即可，代码实现简单，效率还高。</p>
<p>时间复杂度: O((hi - lo) * log (hi - lo) * value),<br>空间复杂度: O(hi  -  lo).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; recurse = [&amp;](<span class="keyword">int</span> index) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (memo.<span class="built_in">find</span>(index) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (index % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> memo[index] = <span class="built_in">recurse</span>(index / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> memo[index] = <span class="built_in">recurse</span>(<span class="number">3</span> * index + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; ++i) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a_value = <span class="built_in">recurse</span>(a);</span><br><span class="line">            <span class="keyword">int</span> b_value = <span class="built_in">recurse</span>(b);</span><br><span class="line">            <span class="keyword">if</span> (a_value != b_value)</span><br><span class="line">                <span class="keyword">return</span> a_value &lt; b_value;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> v[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1388-Pizza-With-3n-Slices"><a href="#1388-Pizza-With-3n-Slices" class="headerlink" title="1388. Pizza With 3n Slices"></a>1388. Pizza With 3n Slices</h2><p>因为前面的题目花了太长时间，第4题只有10min，看了下题目，没有思路就放弃了。<br>其实，如果将问题转换一下，解法就呼之欲出了。</p>
<p>问题可以转换为：从3*n数组中挑选n个元素，要求元素不能邻接，并且不能同时挑 头和尾，使得得到的和最大。和<a href="https://leetcode.com/problems/house-robber-ii/description/">213. House Robber II</a>类似。<br>状态转移方程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(begin, end, remain, cycle)</span><br><span class="line">= max&#123;</span><br><span class="line">    nums[end] + f(begin + cycle, end - 2, remain - 1, 0), // take end</span><br><span class="line">    f(begin, end - 1, remain, 0)    // not take end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N ^ 3),<br>空间复杂度: O(N ^ 3).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSizeSlices</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; slices)</span> </span>&#123;</span><br><span class="line">        map&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; f = [&amp;](<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> remain, <span class="keyword">int</span> cycle) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = memo.<span class="built_in">find</span>(&#123;begin, end, remain, cycle&#125;);</span><br><span class="line">            <span class="keyword">if</span> (it == memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (remain == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans = *<span class="built_in">max_element</span>(slices.<span class="built_in">begin</span>() + begin, slices.<span class="built_in">begin</span>() + end + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end - begin + <span class="number">1</span> &lt; <span class="number">2</span> * remain - <span class="number">1</span>)  &#123;</span><br><span class="line">                    ans = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(</span><br><span class="line">                        slices[end] + <span class="built_in">f</span>(begin + cycle, end - <span class="number">2</span>, remain - <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">                        <span class="built_in">f</span>(begin, end - <span class="number">1</span>, remain, <span class="number">0</span>)</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> memo[&#123;begin, end, remain, cycle&#125;] = ans;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(<span class="number">0</span>, slices.<span class="built_in">size</span>() - <span class="number">1</span>, slices.<span class="built_in">size</span>() / <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 23</title>
    <url>/2020/04/07/LeetCode-biweekly-contest-23/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>199 / 7026</td>
<td>YoungForest</td>
<td>19</td>
<td>0:40:57</td>
<td>0:08:05</td>
<td>0:11:44</td>
<td>0:33:38</td>
<td>0:40:57</td>
</tr>
</tbody></table>
<p>不难，手速场。发现很多手速场的比赛，第三题甚至都比第四题更难。</p>
<h2 id="1399-Count-Largest-Group"><a href="#1399-Count-Largest-Group" class="headerlink" title="1399. Count Largest Group"></a>1399. Count Largest Group</h2><p>straight forward. 用一个hashmap统计digit_sum -&gt; count, 最后再找出count最大的几组。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLargestGroup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; seen;</span><br><span class="line">        <span class="keyword">int</span> largestSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)  &#123;</span><br><span class="line">            <span class="keyword">int</span> sumOfDigit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> current = i;</span><br><span class="line">            <span class="keyword">while</span> (current &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sumOfDigit += current % <span class="number">10</span>;</span><br><span class="line">                current /= <span class="number">10</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            ++seen[sumOfDigit];</span><br><span class="line">            largestSize = <span class="built_in">max</span>(largestSize, seen[sumOfDigit]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = seen.<span class="built_in">begin</span>(); it != seen.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second == largestSize)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1400-Construct-K-Palindrome-Strings"><a href="#1400-Construct-K-Palindrome-Strings" class="headerlink" title="1400. Construct K Palindrome Strings"></a>1400. Construct K Palindrome Strings</h2><p>统计出现的奇数字符数目，必需小于等于k。并且因为要求回文串非空，所以需要<code>s.size() &gt;= k</code>。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++count[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                ++single;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1401-Circle-and-Rectangle-Overlapping"><a href="#1401-Circle-and-Rectangle-Overlapping" class="headerlink" title="1401. Circle and Rectangle Overlapping"></a>1401. Circle and Rectangle Overlapping</h2><p>可以根据正方形的四条边，将空间分为9个部分，把圆的圆心的位置分为9种情况。每种情况是否和正方形overlap就很好判断了。</p>
<p>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 -y1);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x_center, <span class="keyword">int</span> y_center, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> closeEnough = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> radius * radius &gt;= <span class="built_in">distance</span>(x_center, y_center, x, y);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> inSquare = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x_center &lt;= x2 &amp;&amp; x_center &gt;= x1 &amp;&amp; y_center &lt;= y2 &amp;&amp; y_center &gt;= y1;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">closeEnough</span>(x1, y1) || <span class="built_in">closeEnough</span>(x1, y2) || <span class="built_in">closeEnough</span>(x2, y2) || <span class="built_in">closeEnough</span>(x2, y1) ||</span><br><span class="line">            <span class="built_in">inSquare</span>() || </span><br><span class="line">            (x_center &lt;= x2 &amp;&amp; x_center &gt;= x1 &amp;&amp; (y_center &lt;= y2 + radius &amp;&amp; y_center &gt;= y1 - radius)) ||</span><br><span class="line">            (y_center &lt;= y2 &amp;&amp; y_center &gt;= y1 &amp;&amp; (x_center &lt;= x2 + radius &amp;&amp; x_center &gt;= x1 - radius)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>讨论区中还有一种实现起来<a href="https://leetcode.com/problems/circle-and-rectangle-overlapping/discuss/563441/JAVA-compare-distance-between-radius-and-closest-point-on-rectangle-to-circle">更简单的方法</a>，可以快速找到长方形中离一个点（圆心）最近的点。</p>
<h2 id="1402-Reducing-Dishes"><a href="#1402-Reducing-Dishes" class="headerlink" title="1402. Reducing Dishes"></a>1402. Reducing Dishes</h2><p>贪心。先排序, 先取satisfaction最大的dish，直到后缀和小于0.</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfaction</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; satisfaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = satisfaction.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(satisfaction.<span class="built_in">begin</span>(), satisfaction.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> suffixSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            suffixSum += satisfaction[i];</span><br><span class="line">            <span class="keyword">if</span> (suffixSum &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                currentSum += suffixSum; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> currentSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一次提交用的N^2的解法，排序后枚举起点，竟然都过了。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 24</title>
    <url>/2020/04/19/LeetCode-biweekly-contest-24/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>700 / 7729</td>
<td>YoungForest</td>
<td>18</td>
<td>1:17:49</td>
<td>0:04:50</td>
<td>0:10:38</td>
<td>0:17:45</td>
<td>1:02:49 3</td>
</tr>
</tbody></table>
<p>最近参加了2场codforces的比赛，cf的rating徘徊在1400+。cf的题目相对leetcode还是难的多的。并没有坚持下来。这也和cf没有很好的discuss区有关，每届比赛结束后，只能看官方的editorial。</p>
<h2 id="1413-Minimum-Value-to-Get-Positive-Step-by-Step-Sum"><a href="#1413-Minimum-Value-to-Get-Positive-Step-by-Step-Sum" class="headerlink" title="1413. Minimum Value to Get Positive Step by Step Sum"></a>1413. Minimum Value to Get Positive Step by Step Sum</h2><p>统计presum的最负值，需要注意的是startValue必须是正数。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minStartValue</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        min_sum = <span class="number">0</span></span><br><span class="line">        current_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            current_sum += i</span><br><span class="line">            min_sum = <span class="built_in">min</span>(current_sum, min_sum)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - min_sum <span class="keyword">if</span> min_sum &lt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="1414-Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K"><a href="#1414-Find-the-Minimum-Number-of-Fibonacci-Numbers-Whose-Sum-Is-K" class="headerlink" title="1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K"></a>1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K</h2><p>贪心，永远选用小于等于i的最大的Fibonacci数，然后递归解决剩余的数。</p>
<p>时间复杂度：O((log k)^2),<br>空间复杂度: O(log k).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinFibonacciNumbers</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findLargestFibonacciLessEqualThan</span>(<span class="params">i</span>):</span></span><br><span class="line">            a = <span class="number">1</span></span><br><span class="line">            b = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> a &lt;= i:</span><br><span class="line">                a, b = a + b, a</span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i</span>):</span></span><br><span class="line">            x = findLargestFibonacciLessEqualThan(i)</span><br><span class="line">            <span class="keyword">if</span> x == i:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + dp(i - x)</span><br><span class="line">        <span class="keyword">return</span> dp(k)</span><br></pre></td></tr></table></figure>

<h2 id="1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n"><a href="#1415-The-k-th-Lexicographical-String-of-All-Happy-Strings-of-Length-n" class="headerlink" title="1415. The k-th Lexicographical String of All Happy Strings of Length n"></a>1415. The k-th Lexicographical String of All Happy Strings of Length n</h2><p>回溯法按字典序枚举所有的Happy string, 直到找到第<code>k</code>个。</p>
<p>时间复杂度: O(min(3 ^ n, k)),<br>空间复杂度: O(n).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHappyString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">        string ans;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(string&amp;)&gt; backtracking = [&amp;](string&amp; current) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">                ++rank;</span><br><span class="line">                <span class="keyword">if</span> (rank == k) &#123;</span><br><span class="line">                    ans = current;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> last = current.<span class="built_in">empty</span>() ? <span class="string">&#x27;0&#x27;</span> : current.<span class="built_in">back</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c == last) <span class="keyword">continue</span>;</span><br><span class="line">                    current.<span class="built_in">push_back</span>(c);</span><br><span class="line">                    <span class="built_in">backtracking</span>(current);</span><br><span class="line">                    <span class="keyword">if</span> (rank &gt;= k) <span class="keyword">return</span>;</span><br><span class="line">                    current.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        string current;</span><br><span class="line">        <span class="built_in">backtracking</span>(current);</span><br><span class="line">        end:;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1416-Restore-The-Array"><a href="#1416-Restore-The-Array" class="headerlink" title="1416. Restore The Array"></a>1416. Restore The Array</h2><p>DP. dp[i]: 以第i个元素结尾的array可以有多少种分割方法。<br><code>dp[i] = sum(dp[j] for j + 1, ..., i 可以组成一个有效的数字)</code></p>
<p>时间复杂度: O(N * log K),<br>空间复杂度: O(N).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArrays</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="number">10</span>**<span class="number">5</span> + <span class="number">5</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            i = index</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            current = <span class="built_in">int</span>(s[i])</span><br><span class="line">            base = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> current &lt;= k <span class="keyword">and</span> <span class="number">10</span>**(index - i) &lt;= k <span class="keyword">and</span> i - <span class="number">1</span> &gt;= <span class="number">0</span>:</span><br><span class="line">                ans += dp[i-<span class="number">1</span>] <span class="keyword">if</span> s[i] != <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                base *= <span class="number">10</span></span><br><span class="line">                current = current + <span class="built_in">int</span>(s[i]) * base</span><br><span class="line">            <span class="keyword">if</span> current &lt;= k <span class="keyword">and</span> <span class="number">10</span>**(index - i) &lt;= k:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            dp[index] = ans</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(s) - <span class="number">1</span>] % <span class="built_in">int</span>(<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 26</title>
    <url>/2020/05/17/LeetCode-biweekly-contest-26/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>115 / 7795</td>
<td>YoungForest</td>
<td>19</td>
<td>0:33:49</td>
<td>0:03:55</td>
<td>0:08:25</td>
<td>0:11:57</td>
<td>0:28:49  1</td>
</tr>
</tbody></table>
<p>上上周是五一假期，去河北正定和，因疫情原因，3个月没有见面的女朋友约会。所以周六晚上就时间不太合适，鸽了一场双周赛。之后还是会尽量参加的。最近比赛越来越顺手了，无论是每次的排名，还是rating，或是残酷群的排名。比之前都有所上升。尤其要感谢残酷群的每日一题和不定时的讲座，让我对DP和很多Hard的题目有了解决的信心。在此，再次安利一下<a href="https://wisdompeak.github.io/lc-score-board/">残酷刷题群</a>.</p>
<h2 id="1446-Consecutive-Characters"><a href="#1446-Consecutive-Characters" class="headerlink" title="1446. Consecutive Characters"></a>1446. Consecutive Characters</h2><p>滑动窗口，维持整个窗口的字母相等。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPower</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[r] == s[l]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, r - l);</span><br><span class="line">                l = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, n - l);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1447-Simplified-Fractions"><a href="#1447-Simplified-Fractions" class="headerlink" title="1447. Simplified Fractions"></a>1447. Simplified Fractions</h2><p>枚举所有的分母和分子，并判断是否是最简形式。幸运的是，C++17已经内置提供<code>gcd</code>函数。</p>
<p>时间复杂度: O(n^2),<br>空间复杂度: O(n).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">simplifiedFractions</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> down = <span class="number">2</span>; down &lt;= n; ++down) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> up = <span class="number">1</span>; up &lt; down; ++up) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">gcd</span>(up, down) == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(up) + <span class="string">&quot;/&quot;</span> + <span class="built_in">to_string</span>(down));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1448-Count-Good-Nodes-in-Binary-Tree"><a href="#1448-Count-Good-Nodes-in-Binary-Tree" class="headerlink" title="1448. Count Good Nodes in Binary Tree"></a>1448. Count Good Nodes in Binary Tree</h2><p>dfs, 把祖先节点的最大值作为参数传入。</p>
<p>时间复杂度: O(n),<br>空间复杂度: O(n).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="keyword">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt;= maxValue) ans = <span class="number">1</span>;</span><br><span class="line">        maxValue = <span class="built_in">max</span>(maxValue, root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recurse</span>(root-&gt;left, maxValue) + <span class="built_in">recurse</span>(root-&gt;right, maxValue) + ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recurse</span>(root, -INF);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1449-Form-Largest-Integer-With-Digits-That-Add-up-to-Target"><a href="#1449-Form-Largest-Integer-With-Digits-That-Add-up-to-Target" class="headerlink" title="1449. Form Largest Integer With Digits That Add up to Target"></a>1449. Form Largest Integer With Digits That Add up to Target</h2><p>DP. 背包问题，每次尝试加入一个数字。<br>可以利用Greedy的思路，如果2个数的cost相同，则只有大数有用，进行常数上的优化。</p>
<p>时间复杂度: O(target * target * 9),<br>空间复杂度: O(target * target).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        unique = &#123;&#125;</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cost) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> cost[i] <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(cost[i])</span><br><span class="line">                unique[i + <span class="number">1</span>] = cost[i]</span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            ans = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> unique:</span><br><span class="line">                tmp = dp(t - unique[i])</span><br><span class="line">                <span class="keyword">if</span> tmp &gt;= <span class="number">0</span>:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,  tmp * <span class="number">10</span> + i)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        ans = dp(target)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(ans) <span class="keyword">if</span> ans &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/discuss/635267/C%2B%2BJavaPython-Strict-O(Target)">Discuss</a>中有O(target)的解法，主要思路是，不再以dp存储最大的字符串，而只存数位长度，然后再backward构造出结果。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 27</title>
    <url>/2020/05/31/LeetCode-biweekly-contest-27/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>231 / 7926</td>
<td>YoungForest</td>
<td>18</td>
<td>0:42:16</td>
<td>0:04:51</td>
<td>0:10:55</td>
<td>0:22:31  1</td>
<td>0:37:16</td>
</tr>
</tbody></table>
<p>质量还可以的手速场。有些问题值得思考，只有发现本质，才能迅速解决。</p>
<h2 id="1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays"><a href="#1460-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays" class="headerlink" title="1460. Make Two Arrays Equal by Reversing Sub-arrays"></a>1460. Make Two Arrays Equal by Reversing Sub-arrays</h2><p>由于对reverse操作的数目不限，我们可以采用这样的策略构造将2个array转成相同的array。用类似select sort的思想，每次reverse可以将一个位置排好序。所以问题转化为，2个数组排好序后是否相等。<br>C++中vector的<code>==</code>的作用正是如此。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeEqual</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; target, vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(target.<span class="built_in">begin</span>(), target.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> target == arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K"><a href="#1461-Check-If-a-String-Contains-All-Binary-Codes-of-Size-K" class="headerlink" title="1461. Check If a String Contains All Binary Codes of Size K"></a>1461. Check If a String Contains All Binary Codes of Size K</h2><p>滑动窗口。窗口大小K，判断所有<code>0 - 2^K - 1</code>的二进制是否出现。</p>
<p>时间复杂度: O(s.size()),<br>空间复杂度: O(1 &lt;&lt; K).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAllCodes</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">seen</span><span class="params">(<span class="number">1</span> &lt;&lt; k, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            current = current * <span class="number">2</span> - <span class="string">&#x27;0&#x27;</span> + s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        seen[current] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            current = (current - (s[i-k]-<span class="string">&#x27;0&#x27;</span>) * (<span class="number">1</span> &lt;&lt; (k<span class="number">-1</span>))) * <span class="number">2</span> - <span class="string">&#x27;0&#x27;</span> + s[i];</span><br><span class="line">            seen[current] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all_of</span>(seen.<span class="built_in">begin</span>(), seen.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1462-Course-Schedule-IV"><a href="#1462-Course-Schedule-IV" class="headerlink" title="1462. Course Schedule IV"></a>1462. Course Schedule IV</h2><p>DFS. 这里要注意queries本身很大，但是n很小。所以需要采用记忆化的DFS，防止重复计算。</p>
<p>时间复杂度: O(n ^ 3 + queries),<br>空间复杂度: O(n ^ 2).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : prerequisites) &#123;</span><br><span class="line">            edges[v[<span class="number">1</span>]].<span class="built_in">push_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; memo;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>,unordered_set&lt;<span class="keyword">int</span>&gt;&amp;)&gt; dfs = [&amp;](<span class="keyword">int</span> root, <span class="keyword">int</span> target, unordered_set&lt;<span class="keyword">int</span>&gt;&amp; seen) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo.<span class="built_in">find</span>(&#123;root, target&#125;) == memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target == root) <span class="keyword">return</span> memo[&#123;root, target&#125;] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : edges[root]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (seen.<span class="built_in">find</span>(neighbor) == seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        seen.<span class="built_in">insert</span>(neighbor);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">dfs</span>(neighbor, target, seen)) <span class="keyword">return</span> memo[&#123;root, target&#125;] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> memo[&#123;root, target&#125;] = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[&#123;root, target&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">ans</span><span class="params">(queries.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            unordered_set&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">            ans[i] = <span class="built_in">dfs</span>(queries[i][<span class="number">1</span>], queries[i][<span class="number">0</span>], seen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Discuss中提到可以用 <a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95">Floyd-Warshall 算法</a>，计算有向图中2点的最短距离。</p>
<h2 id="1463-Cherry-Pickup-II"><a href="#1463-Cherry-Pickup-II" class="headerlink" title="1463. Cherry Pickup II"></a>1463. Cherry Pickup II</h2><p>DP.<br>dp[i][first][second]: 机器人走到第i行，第一个机器人的位置在first, 第二个在second 时，最大的cherry pick。</p>
<p><code>dp[i][first][second] = max(dp[i-1][for last_first in range(first - 1, first + 2)])[for last_second in range(second - 1, second + 2)] + (grid[i][first] + grid[i][second]) if first != second else grid[i][first]</code>.</p>
<p>时间复杂度: O(rows * cols^2 * 9),<br>空间复杂度: O(rows * cols^2) -&gt; O(cols^2).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cherryPickup</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> rows = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> cols = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">dp</span> (rows, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(cols, vector&lt;<span class="keyword">int</span>&gt;(cols, -INF)));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][cols<span class="number">-1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] + grid[<span class="number">0</span>][cols<span class="number">-1</span>];</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; cols; ++first) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> second = <span class="number">0</span>; second &lt; cols; ++second) &#123;</span><br><span class="line">                    <span class="keyword">int</span> add =  first == second ? grid[i][first] : grid[i][first] + grid[i][second];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> dfirst : dj) &#123;</span><br><span class="line">                        <span class="keyword">int</span> last_first = first + dfirst;</span><br><span class="line">                        <span class="keyword">if</span> (last_first &gt;= <span class="number">0</span> &amp;&amp; last_first &lt; cols) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> dsecond : dj) &#123;</span><br><span class="line">                                <span class="keyword">int</span> last_second = second + dsecond;</span><br><span class="line">                                <span class="keyword">if</span> (last_second &gt;= <span class="number">0</span> &amp;&amp; last_second &lt; cols) &#123;</span><br><span class="line">                                    dp[i][first][second] = <span class="built_in">max</span>(dp[i][first][second], dp[i<span class="number">-1</span>][last_first][last_second] + add);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> first = <span class="number">0</span>; first &lt; cols; ++first) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> second = <span class="number">0</span>; second &lt; cols; ++second) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[rows<span class="number">-1</span>][first][second]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 28</title>
    <url>/2020/06/15/LeetCode-biweekly-contest-28/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>448 / 8571</td>
<td>YoungForest</td>
<td>14</td>
<td>1:22:34</td>
<td>0:07:28</td>
<td>0:11:43</td>
<td>null</td>
<td>1:17:34  1</td>
</tr>
</tbody></table>
<p>最后一题debug耽误了不少时间，最后发现是<code>range</code>函数的cache写错了，修改了函数的参数。以后切记memo时要把参数写成<code>const</code>的。<br>第三题，没有想到效率比较高的DP解法，一直TLE。</p>
<h2 id="1475-Final-Prices-With-a-Special-Discount-in-a-Shop"><a href="#1475-Final-Prices-With-a-Special-Discount-in-a-Shop" class="headerlink" title="1475. Final Prices With a Special Discount in a Shop"></a>1475. Final Prices With a Special Discount in a Shop</h2><p>寻找下一个大于的数。使用单调递增栈解决。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">finalPrices</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; increasing;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!increasing.<span class="built_in">empty</span>() &amp;&amp; increasing.<span class="built_in">top</span>() &gt; prices[i]) &#123;</span><br><span class="line">                increasing.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (increasing.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ans[i] = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = prices[i] - increasing.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            increasing.<span class="built_in">push</span>(prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1476-Subrectangle-Queries"><a href="#1476-Subrectangle-Queries" class="headerlink" title="1476. Subrectangle Queries"></a>1476. Subrectangle Queries</h2><p>burte force.</p>
<p>时间复杂度: </p>
<ul>
<li>updateSubrectangle: O((row2 - row1) * (col2 - col1)),</li>
<li>getValue: O(1).<br>空间复杂度: O(rows * cols).</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubrectangleQueries</span> &#123;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; rect;</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SubrectangleQueries</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangle) : <span class="built_in">rect</span>(<span class="built_in">move</span>(rectangle))&#123;</span><br><span class="line">        rows = rect.<span class="built_in">size</span>();</span><br><span class="line">        cols = rect[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateSubrectangle</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row1; i &lt;= row2; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col1; j &lt;= col2; ++j) &#123;</span><br><span class="line">                rect[i][j] = newValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rect[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SubrectangleQueries object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SubrectangleQueries* obj = new SubrectangleQueries(rectangle);</span></span><br><span class="line"><span class="comment"> * obj-&gt;updateSubrectangle(row1,col1,row2,col2,newValue);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;getValue(row,col);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>也有一种2个函数都是<code>O(log N)</code>的<a href="https://leetcode.com/problems/subrectangle-queries/discuss/686094/Python-O(logn)-for-both-update-and-query-2D-Dynamic-Segment-Tree-with-Lazy-Tag">解法, 2D segment tree</a>，预处理<code>O(N log N)</code>.</p>
<h2 id="1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum"><a href="#1477-Find-Two-Non-overlapping-Sub-arrays-Each-With-Target-Sum" class="headerlink" title="1477. Find Two Non-overlapping Sub-arrays Each With Target Sum"></a>1477. Find Two Non-overlapping Sub-arrays Each With Target Sum</h2><p>使用前缀数组快速计算和为target，以i结尾的最短子数组。更新答案，更新i之前的最短子数组。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSumOfLengths</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INF;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">best_till</span><span class="params">(n, INF)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; presum;</span><br><span class="line">        presum[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">auto</span> it = presum.<span class="built_in">find</span>(sum - target);</span><br><span class="line">            <span class="keyword">if</span> (it != presum.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">int</span> left = it-&gt;second;</span><br><span class="line">                <span class="keyword">int</span> length = i - left;</span><br><span class="line">                <span class="keyword">if</span> (left &gt;= <span class="number">0</span>)</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, best_till[left] + length);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                    best_till[i] = <span class="built_in">min</span>(best_till[i<span class="number">-1</span>], length);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    best_till[i] = length;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                    best_till[i] = best_till[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            presum[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &gt;= INF ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1478-Allocate-Mailboxes"><a href="#1478-Allocate-Mailboxes" class="headerlink" title="1478. Allocate Mailboxes"></a>1478. Allocate Mailboxes</h2><p>区段DP。每次给前面几个house分配一个邮箱，一个邮箱的问题可以采用贪心解决。<br>我写了top-bottom的写法，相比bottom-top更方便实现些。</p>
<p>时间复杂度: O(N log N + N * K * N + N ^ 2),<br>空间复杂度L O(N * K + N * N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="keyword">int</span> kk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = houses.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(houses.<span class="built_in">begin</span>(), houses.<span class="built_in">end</span>());</span><br><span class="line">        map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; memo_range;</span><br><span class="line">        <span class="keyword">auto</span> range = [&amp;](<span class="keyword">int</span> left, <span class="keyword">int</span> right) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = memo_range.<span class="built_in">find</span>(&#123;left, right&#125;);</span><br><span class="line">            <span class="keyword">if</span> (it != memo_range.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">            <span class="keyword">else</span> &#123;            </span><br><span class="line">                <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> l = left, r = right;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    ans += houses[r] - houses[l];</span><br><span class="line">                    ++l;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> memo_range[&#123;left, right&#125;] = ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        map&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; memo_dp;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; dp = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> k) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = memo_dp.<span class="built_in">find</span>(&#123;i, k&#125;);</span><br><span class="line">            <span class="keyword">if</span> (it != memo_dp.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">            <span class="keyword">else</span> &#123;            </span><br><span class="line">                <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ans = <span class="built_in">range</span>(i, n - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;k == 1 &quot; &lt;&lt;  i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">return</span> memo_dp[&#123;i, k&#125;] = ans;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n - i &lt;= k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> ans = INF;</span><br><span class="line">                    <span class="comment">// n - ni &gt;= k - 1</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> ni = i + <span class="number">1</span>; ni &lt;= n; ++ni) &#123;</span><br><span class="line">                        <span class="comment">// if (i == 2) &#123;</span></span><br><span class="line">                        <span class="comment">//     cout &lt;&lt; &quot;2 :: &quot; &lt;&lt; ni &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                        <span class="comment">//     cout &lt;&lt; range(i, ni - 1) &lt;&lt; endl;</span></span><br><span class="line">                        <span class="comment">// &#125;</span></span><br><span class="line">                        ans = <span class="built_in">min</span>(ans, <span class="built_in">range</span>(i, ni - <span class="number">1</span>) + <span class="built_in">dp</span>(ni, k - <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">return</span> memo_dp[&#123;i, k&#125;] = ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(<span class="number">0</span>, kk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 36</title>
    <url>/2020/10/06/LeetCode-biweekly-contest-36/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>1667 / 8332</td>
<td>YoungForest</td>
<td>7</td>
<td>0:15:37</td>
<td>0:01:46</td>
<td>0:15:37</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<p>这次双周赛有跪了，生活真是起起落落落落…三四题其实还是有机会做出来的，但比赛时状态不好，决策有失误。在第3题看了2分钟没思路时转到第四题了，然后第四题想复杂了，实现花了不少时间，最后还是被卡时间TLE了。</p>
<h2 id="1603-Design-Parking-System"><a href="#1603-Design-Parking-System" class="headerlink" title="1603. Design Parking System"></a>1603. Design Parking System</h2><p>签到题。维护各个类型剩余车位数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkingSystem</span> &#123;</span></span><br><span class="line">    array&lt;<span class="keyword">int</span>, 4&gt; cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ParkingSystem</span>(<span class="keyword">int</span> big, <span class="keyword">int</span> medium, <span class="keyword">int</span> small) &#123;</span><br><span class="line">        cnt[<span class="number">1</span>] = big;</span><br><span class="line">        cnt[<span class="number">2</span>] = medium;</span><br><span class="line">        cnt[<span class="number">3</span>] = small;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addCar</span><span class="params">(<span class="keyword">int</span> carType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[carType] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            --cnt[carType];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ParkingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ParkingSystem* obj = new ParkingSystem(big, medium, small);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;addCar(carType);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(addCar calls),<br>空间复杂度: O(1).</p>
<h2 id="1604-Alert-Using-Same-Key-Card-Three-or-More-Times-in-a-One-Hour-Period"><a href="#1604-Alert-Using-Same-Key-Card-Three-or-More-Times-in-a-One-Hour-Period" class="headerlink" title="1604. Alert Using Same Key-Card Three or More Times in a One Hour Period"></a>1604. Alert Using Same Key-Card Three or More Times in a One Hour Period</h2><p>先按时间进行排序，然后依次遍历，记录每个人进入的时间，检查最后3次进入是否处于同一个小时。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">alertNames</span><span class="params">(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pss  = pair&lt;string, string&gt;;</span><br><span class="line">        set&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = keyName.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pss&gt; records;</span><br><span class="line">        records.<span class="built_in">reserve</span>(n);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">             records.<span class="built_in">emplace_back</span>(keyTime[i], keyName[i]);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">sort</span>(records.<span class="built_in">begin</span>(), records.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> hour = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; enter;</span><br><span class="line">        <span class="keyword">auto</span> convert2int = [&amp;](<span class="keyword">const</span> string&amp; x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="built_in">stoi</span>(x.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">int</span> m = <span class="built_in">stoi</span>(x.<span class="built_in">substr</span>(<span class="number">3</span>));</span><br><span class="line">            <span class="keyword">return</span> h * <span class="number">60</span> + m;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="keyword">const</span> string&amp; x) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (enter[x].<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> a = <span class="built_in">convert2int</span>(enter[x][enter[x].<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">int</span> b = <span class="built_in">convert2int</span>(enter[x][enter[x].<span class="built_in">size</span>() - <span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">int</span> c = <span class="built_in">convert2int</span>(enter[x][enter[x].<span class="built_in">size</span>() - <span class="number">3</span>]);</span><br><span class="line">                <span class="keyword">return</span> a - c &lt;= <span class="number">60</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            enter[records[i].second].<span class="built_in">push_back</span>(records[i].first);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(records[i].second)) &#123;</span><br><span class="line">                ans.<span class="built_in">insert</span>(records[i].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N * nameLength),<br>空间复杂度: O(N).</p>
<h2 id="1605-Find-Valid-Matrix-Given-Row-and-Column-Sums"><a href="#1605-Find-Valid-Matrix-Given-Row-and-Column-Sums" class="headerlink" title="1605. Find Valid Matrix Given Row and Column Sums"></a>1605. Find Valid Matrix Given Row and Column Sums</h2><p>贪心。对于每个位置，选择行列和小的那个，可以证明最后一定可以得到解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">restoreMatrix</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; rowSum, vector&lt;<span class="keyword">int</span>&gt;&amp; colSum) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> rows = rowSum.<span class="built_in">size</span>(), cols = colSum.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">                ans[i][j] = <span class="built_in">min</span>(rowSum[i], colSum[j]);</span><br><span class="line">                rowSum[i] -= ans[i][j];</span><br><span class="line">                colSum[j] -= ans[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(rows * cols),<br>空间复杂度: O(rows * cols).</p>
<h2 id="1606-Find-Servers-That-Handled-Most-Number-of-Requests"><a href="#1606-Find-Servers-That-Handled-Most-Number-of-Requests" class="headerlink" title="1606. Find Servers That Handled Most Number of Requests"></a>1606. Find Servers That Handled Most Number of Requests</h2><p>用一个 set 维护可用server。用priority_queue维护server变空闲时间，并更新set。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">busiestServers</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; arrival, vector&lt;<span class="keyword">int</span>&gt;&amp; load)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; availble;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            availble.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrival.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> time = arrival[i];</span><br><span class="line">            <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>() &amp;&amp; pq.<span class="built_in">top</span>().first &lt;= time) &#123;</span><br><span class="line">                availble.<span class="built_in">insert</span>(pq.<span class="built_in">top</span>().second);</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (availble.<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> j = i % k;</span><br><span class="line">            <span class="keyword">auto</span> it = availble.<span class="built_in">lower_bound</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (it == availble.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                it = availble.<span class="built_in">begin</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt[*it];</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;arrival[i] + load[i], *it&#125;);</span><br><span class="line">            availble.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> maxRequests = *<span class="built_in">max_element</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] == maxRequests) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(arrival.size() * k),<br>空间复杂度: O(k).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 37</title>
    <url>/2020/10/18/LeetCode-biweekly-contest-37/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>893 / 8250</td>
<td>YoungForest</td>
<td>7</td>
<td>0:27:31</td>
<td>0:11:24</td>
<td>0:27:31</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<p>连续2次双周赛遭遇滑铁卢了。<br>第3题在赛后2分钟通过了，本来是在能力范围内的题目，但最后心太急了。本来晚上状态就不好，反而是比赛结束后，就写出来了。</p>
<h2 id="1619-Mean-of-Array-After-Removing-Some-Elements"><a href="#1619-Mean-of-Array-After-Removing-Some-Elements" class="headerlink" title="1619. Mean of Array After Removing Some Elements"></a>1619. Mean of Array After Removing Some Elements</h2><p>签到题。先排序，后求和，在求平均。<br>这里需要注意题目中限制了<code>arr.size() % 20 == 0</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">trimMean</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> x = n / <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; x || (n - <span class="number">1</span> - i) &lt; x) <span class="keyword">continue</span>;</span><br><span class="line">            s += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s / (n - <span class="number">2</span> * x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<h2 id="1620-Coordinate-With-Maximum-Network-Quality"><a href="#1620-Coordinate-With-Maximum-Network-Quality" class="headerlink" title="1620. Coordinate With Maximum Network Quality"></a>1620. Coordinate With Maximum Network Quality</h2><p>由于数据范围比较小，只有50，直接暴力。遍历每一个位置，遍历每个塔求它的信号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">bestCoordinate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; towers, <span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 50 * 50 * 50</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> r = radius;</span><br><span class="line">        <span class="keyword">int</span> maxSignal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxI = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxJ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> distance = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> a1, <span class="keyword">const</span> <span class="keyword">int</span> b1, <span class="keyword">const</span> <span class="keyword">int</span> a2, <span class="keyword">const</span> <span class="keyword">int</span> b2) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="built_in">sqrt</span>((a1 - a2) * (a1 - a2) + (b1 - b2) * (b1 - b2));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> getSignal = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : towers) &#123;</span><br><span class="line">                <span class="keyword">double</span> d = <span class="built_in">distance</span>(t[<span class="number">0</span>], t[<span class="number">1</span>], i, j);</span><br><span class="line">                <span class="keyword">if</span> (d &gt; r) <span class="keyword">continue</span>;</span><br><span class="line">                ans += <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">floor</span>(t[<span class="number">2</span>] / (<span class="number">1</span> + d)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">50</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">50</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> signal = <span class="built_in">getSignal</span>(i, j);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; signal &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (signal &gt; maxSignal) &#123;</span><br><span class="line">                    maxI = i;</span><br><span class="line">                    maxJ = j;</span><br><span class="line">                    maxSignal = signal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;maxI, maxJ&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(rows * cols * towers),<br>空间复杂度: O(1).</p>
<h2 id="1621-Number-of-Sets-of-K-Non-Overlapping-Line-Segments"><a href="#1621-Number-of-Sets-of-K-Non-Overlapping-Line-Segments" class="headerlink" title="1621. Number of Sets of K Non-Overlapping Line Segments"></a>1621. Number of Sets of K Non-Overlapping Line Segments</h2><p>动态规划。虽然一下子就看出是DP了，但还是走了弯路。一开始写了<code>O(n^2 * k)</code>的算法，没有充分利用子问题。<br>其实需要多设置一个变量表示开始是否必须是一个segment就好写了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function">def <span class="title">numberOfSets</span><span class="params">(self, m: <span class="keyword">int</span>, kk: <span class="keyword">int</span>)</span> -&gt; <span class="keyword">int</span>:</span></span><br><span class="line"><span class="function">        MOD =</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        @<span class="built_in">lru_cache</span>(None)</span><br><span class="line">        <span class="function">def <span class="title">dp</span><span class="params">(n, k, first)</span>:</span></span><br><span class="line"><span class="function">            if n &lt; k:</span></span><br><span class="line"><span class="function">                return <span class="number">0</span></span></span><br><span class="line"><span class="function">            if n =</span>= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">                <span class="built_in"><span class="keyword">return</span></span> ((n + <span class="number">1</span>) * n) <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> first:</span><br><span class="line">                <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">dp</span>(n - <span class="number">1</span>, k, True) + <span class="built_in">dp</span>(n - <span class="number">1</span>, k - <span class="number">1</span>, False)) % MOD;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">dp</span>(n - <span class="number">1</span>, k, False) + <span class="built_in">dp</span>(n, k, True)) % MOD</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(m - <span class="number">1</span>, kk, False)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n * k),<br>空间复杂度: O(n * k).</p>
<h2 id="1622-Fancy-Sequence"><a href="#1622-Fancy-Sequence" class="headerlink" title="1622. Fancy Sequence"></a>1622. Fancy Sequence</h2><p>本题已经超出我的能力范围了，完全没有思路。<br>学习了一遍评论区，大约有2中算法：</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/fancy-sequence/solution/qi-miao-xu-lie-by-zerotrac2/">乘法逆元</a></li>
<li><a href="https://leetcode-cn.com/problems/fancy-sequence/solution/ru-guo-bu-liao-jie-cheng-fa-ni-yuan-jiu-hao-hao-xu/">懒惰线段树</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 38</title>
    <url>/2020/11/01/LeetCode-biweekly-contest-38/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>318 / 7446</td>
<td>YoungForest</td>
<td>18</td>
<td>1:07:29</td>
<td>0:12:38</td>
<td>0:16:42</td>
<td>0:57:29  2</td>
<td>0:41:26</td>
</tr>
</tbody></table>
<h2 id="5539-Sort-Array-by-Increasing-Frequency"><a href="#5539-Sort-Array-by-Increasing-Frequency" class="headerlink" title="5539. Sort Array by Increasing Frequency"></a>5539. Sort Array by Increasing Frequency</h2><p>签到题。按照题意先统计频数，再按频数排序即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">frequencySort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            ++cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">        vector&lt;pii&gt; frequency;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : cnt) &#123;</span><br><span class="line">            frequency.<span class="built_in">emplace_back</span>(p.second, p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(frequency.<span class="built_in">begin</span>(), frequency.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.first == b.first) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : frequency) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.first; ++i) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(p.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<h2 id="5540-Widest-Vertical-Area-Between-Two-Points-Containing-No-Points"><a href="#5540-Widest-Vertical-Area-Between-Two-Points-Containing-No-Points" class="headerlink" title="5540. Widest Vertical Area Between Two Points Containing No Points"></a>5540. Widest Vertical Area Between Two Points Containing No Points</h2><p>虽然看起来很复杂，但其实就是一个按x排序，找最大间隔。题目故意说难了，绕了大家一圈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthOfVerticalArea</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">        x.<span class="built_in">reserve</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : points) &#123;</span><br><span class="line">            x.<span class="built_in">push_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastx = x[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, x[i] - lastx);</span><br><span class="line">            lastx = x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<h2 id="5541-Count-Substrings-That-Differ-by-One-Character"><a href="#5541-Count-Substrings-That-Differ-by-One-Character" class="headerlink" title="5541. Count Substrings That Differ by One Character"></a>5541. Count Substrings That Differ by One Character</h2><p>这道题也是暴力。但一开始想复杂了，以为暴力是N^4（其实是N^3)。就跳过先做第四题了。回来后，仍然试图用所谓的25*N^3的算法做，TLE了2次。经舍友提醒，想恍然大悟，原来真是暴力。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> si = <span class="number">0</span>; si &lt; s.<span class="built_in">size</span>(); ++si) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sj = <span class="number">1</span>; si + sj &lt;= s.<span class="built_in">size</span>(); ++sj) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ti = <span class="number">0</span>; ti &lt; t.<span class="built_in">size</span>(); ++ti) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ti + sj &gt; t.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; sj; ++x) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s[si + x] != t[ti + x]) &#123;</span><br><span class="line">                            ++diff;</span><br><span class="line">                            <span class="keyword">if</span> (diff &gt; <span class="number">1</span>) <span class="keyword">goto</span> end;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (diff == <span class="number">1</span>) ++ans;</span><br><span class="line">                    end:;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N^3),<br>空间复杂度: O(1).</p>
<h2 id="5542-Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary"><a href="#5542-Number-of-Ways-to-Form-a-Target-String-Given-a-Dictionary" class="headerlink" title="5542. Number of Ways to Form a Target String Given a Dictionary"></a>5542. Number of Ways to Form a Target String Given a Dictionary</h2><p>经典DP。<code>dp(begin, i)</code>表示可以从<code>words</code>的第<code>begin</code>个字符开始，组成<code>target[i：]</code>的方案数。<br>状态转移方程为:<br><code>dp(begin, i) = dp(begin + 1, i + 1) * (target[i]在words[j][begin]中出现的次数) + dp(begin + 1, i)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        MOD = <span class="built_in">int</span>(<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        n = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">        dictionary = defaultdict(<span class="keyword">lambda</span> : defaultdict(<span class="built_in">int</span>))</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                dictionary[i][w[i]] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">begin, i</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(target):</span><br><span class="line">                <span class="comment"># print (&#x27;return &#x27;, begin, i)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> begin &gt;= n:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            appear = dictionary[begin][target[i]]</span><br><span class="line">            <span class="comment"># print (begin, i)</span></span><br><span class="line">            <span class="keyword">return</span> (dp(begin + <span class="number">1</span>, i + <span class="number">1</span>) * appear + dp(begin + <span class="number">1</span>, i)) % MOD</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(words.size() * words[0].size() + words[0].size() * target.size()),<br>空间复杂度: O(words[0].size() * target.size()).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 39</title>
    <url>/2020/11/15/LeetCode-biweekly-contest-39/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>688 / 6047</td>
<td>YoungForest</td>
<td>7</td>
<td>0:16:02</td>
<td>0:03:44</td>
<td>0:11:02  1</td>
<td>null</td>
<td>0:41:26</td>
</tr>
</tbody></table>
<p>本周双周赛难度还是很大的，虽然是3456，但三四题我觉得不止5/6分。当然我也只做出前2题。三四题只试图用暴力解法做，但事实证明虽然很接近正确答案了，但还是全部TLE了。</p>
<h2 id="5550-Defuse-the-Bomb"><a href="#5550-Defuse-the-Bomb" class="headerlink" title="5550. Defuse the Bomb"></a>5550. Defuse the Bomb</h2><p>签到题。使用辅助数组，按照题目要求填充即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">decrypt</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; code, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = code.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                    ans[i] += code[(i + j) % n];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = -k;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                    ans[i] += code[(i - j + n) % n];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="5551-Minimum-Deletions-to-Make-String-Balanced"><a href="#5551-Minimum-Deletions-to-Make-String-Balanced" class="headerlink" title="5551. Minimum Deletions to Make String Balanced"></a>5551. Minimum Deletions to Make String Balanced</h2><p>枚举每个分割点，删除分割点前所有的b，和分割点后所有的a。找到最小删除数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDeletions</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> totalA = <span class="built_in">count_if</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), [](<span class="keyword">char</span> c) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> c == <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, b + totalA - a);</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;a&#x27;</span>) ++a;</span><br><span class="line">            <span class="keyword">else</span> ++b;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, b + totalA - a);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1654-Minimum-Jumps-to-Reach-Home"><a href="#1654-Minimum-Jumps-to-Reach-Home" class="headerlink" title="1654. Minimum Jumps to Reach Home"></a>1654. Minimum Jumps to Reach Home</h2><p>算最少步数用BFS。然而，本题的关键在于如何控制状态空间，即避免一直向右走。比较自然的想法是有一个临界值，超过这一临界值后，只能向左走。关于临界值的确定，可以参考<a href="https://github.com/wisdompeak/LeetCode/tree/master/BFS/1654.Minimum-Jumps-to-Reach-Home">残酷群主的解说</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumJumps</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; forbidden, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt;; <span class="comment">// location, backward</span></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; blocks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : forbidden) blocks.<span class="built_in">insert</span>(i);</span><br><span class="line">        queue&lt;pii&gt; q;</span><br><span class="line">        set&lt;pii&gt; seen;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="literal">false</span>&#125;);</span><br><span class="line">        seen.<span class="built_in">insert</span>(&#123;<span class="number">0</span>, <span class="literal">false</span>&#125;);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> limits = <span class="built_in">max</span>(x, *<span class="built_in">max_element</span>(forbidden.<span class="built_in">begin</span>(), forbidden.<span class="built_in">end</span>())) + b;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [location, back] = q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">// cout &lt;&lt; location &lt;&lt; &quot; &quot; &lt;&lt; back &lt;&lt; endl;</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (location == x) <span class="keyword">return</span> level;</span><br><span class="line">                <span class="keyword">if</span> (location &lt;= limits) &#123;</span><br><span class="line">                    <span class="comment">// forward</span></span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> nextLocation = location + a;</span><br><span class="line">                    <span class="keyword">if</span> (blocks.<span class="built_in">find</span>(nextLocation) == blocks.<span class="built_in">end</span>() &amp;&amp; seen.<span class="built_in">find</span>(&#123;nextLocation, <span class="literal">false</span>&#125;) == seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;nextLocation, <span class="literal">false</span>&#125;);</span><br><span class="line">                        seen.<span class="built_in">insert</span>(&#123;nextLocation, <span class="literal">false</span>&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!back)&#123;</span><br><span class="line">                    <span class="comment">// backward</span></span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> nextLocation = location - b;</span><br><span class="line">                    <span class="keyword">if</span> (nextLocation &gt; <span class="number">0</span> &amp;&amp; blocks.<span class="built_in">find</span>(nextLocation) == blocks.<span class="built_in">end</span>() &amp;&amp; seen.<span class="built_in">find</span>(&#123;nextLocation, <span class="literal">true</span>&#125;) == seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;nextLocation, <span class="literal">true</span>&#125;);</span><br><span class="line">                        seen.<span class="built_in">insert</span>(&#123;nextLocation, <span class="literal">true</span>&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(max(x, max_forbidden) + b),<br>空间复杂度: O(max(x, max_forbidden) + b).</p>
<h2 id="5553-Distribute-Repeating-Integers"><a href="#5553-Distribute-Repeating-Integers" class="headerlink" title="5553. Distribute Repeating Integers"></a>5553. Distribute Repeating Integers</h2><p>比赛时只想到了暴力的回溯，试图通过剪枝优化，然而还是超时了。<br>时间复杂度为: O(50^10)，理论上就是过不了。</p>
<p>看了<a href="https://leetcode-cn.com/problems/distribute-repeating-integers/solution/zi-ji-mei-ju-jing-dian-tao-lu-zhuang-ya-dp-by-arse/">讨论区的题解</a>才恍然大悟，这是道状态压缩DP。</p>
<p><a href="">huahua的视频讲解</a>也特别清楚。在这里我实现了他的python top-bottom的版本，相比bottom-top更好写一些，也更好理解。注意在集合枚举子集时，有特别的技巧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canDistribute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], quantity: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        cnts = <span class="built_in">list</span>(Counter(nums).values())</span><br><span class="line">        m = <span class="built_in">len</span>(quantity)</span><br><span class="line">        n = <span class="built_in">len</span>(cnts)</span><br><span class="line">        sums = [<span class="number">0</span>] * (<span class="number">1</span> &lt;&lt; m)</span><br><span class="line">        <span class="keyword">for</span> mask <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; m):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> mask &amp; (<span class="number">1</span> &lt;&lt; i):</span><br><span class="line">                    sums[mask] += quantity[i]</span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">mask: <span class="built_in">int</span>, i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            <span class="keyword">if</span> mask == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= n: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = mask</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="keyword">if</span> sums[cur] &lt;= cnts[i] <span class="keyword">and</span> dp(mask ^ cur, i + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                cur = (cur - <span class="number">1</span>) &amp; mask</span><br><span class="line">            <span class="keyword">return</span> dp(mask, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp((<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(3^m * n),<br>空间复杂度: O(2^m * n).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 42</title>
    <url>/2020/12/27/LeetCode-biweekly-contest-42/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>573 / 6631</td>
<td>YoungForest</td>
<td>12</td>
<td>0:51:14</td>
<td>0:19:42</td>
<td>0:24:42  1</td>
<td>0:46:14</td>
<td>差一分钟debug出来，好气呀！</td>
</tr>
</tbody></table>
<h2 id="1700-Number-of-Students-Unable-to-Eat-Lunch"><a href="#1700-Number-of-Students-Unable-to-Eat-Lunch" class="headerlink" title="1700. Number of Students Unable to Eat Lunch"></a>1700. Number of Students Unable to Eat Lunch</h2><p>模拟题目中描述的吃饭的过程。事实上因为判断结束条件的原因，实现起来还不是那么直接了当。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countStudents</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; students, vector&lt;<span class="keyword">int</span>&gt;&amp; sandwiches)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = students.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; stu;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : students) &#123;</span><br><span class="line">            stu.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; sand;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sandwiches.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            sand.<span class="built_in">push</span>(sandwiches[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = stu.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (!stu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = stu.<span class="built_in">front</span>();</span><br><span class="line">                stu.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (s == sand.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                    sand.<span class="built_in">pop</span>();</span><br><span class="line">                    ++ans;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    --current;</span><br><span class="line">                    stu.<span class="built_in">push</span>(s);</span><br><span class="line">                    <span class="keyword">if</span> (current == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> n - ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(students.size() * sandwiches.size()),<br>空间复杂度: O(students.size() + sandwiches.size()).</p>
<p>其实我的实现想复杂了。因为要有遍历学生的操作，所以学生的顺序其实是无所谓的。统计学生喜欢的种类，然后不断判断sandwiches栈顶元素是否满足条件。</p>
<h2 id="1701-Average-Waiting-Time"><a href="#1701-Average-Waiting-Time" class="headerlink" title="1701. Average Waiting Time"></a>1701. Average Waiting Time</h2><p>模拟做饭的过程。对于每一个顾客，判断他来时是否可以直接开始做饭。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">averageWaitingTime</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; customers)</span> </span>&#123;</span><br><span class="line">        ll wait = <span class="number">0</span>;</span><br><span class="line">        ll current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : customers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current &lt;= v[<span class="number">0</span>]) &#123;</span><br><span class="line">                current = v[<span class="number">0</span>] + v[<span class="number">1</span>];</span><br><span class="line">                wait += v[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wait += (current + v[<span class="number">1</span>] - v[<span class="number">0</span>]);</span><br><span class="line">                current += v[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> n = customers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> wait / n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(customers.size()),<br>空间复杂度: O(1).</p>
<h2 id="1702-Maximum-Binary-String-After-Change"><a href="#1702-Maximum-Binary-String-After-Change" class="headerlink" title="1702. Maximum Binary String After Change"></a>1702. Maximum Binary String After Change</h2><p>贪心，思路见注释。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// greedy: change first two op</span></span><br><span class="line">    <span class="comment">// 00 -&gt; 10</span></span><br><span class="line">    <span class="comment">// 01 -&gt; change after substring, 后面可以是0吗？010 -&gt; 001 -&gt; 101, recurse i + 1</span></span><br><span class="line">    <span class="comment">//                             是 1 变 0，找0 向后传导即可。</span></span><br><span class="line">    <span class="comment">// 10 -&gt; do not change, recurse i + 1</span></span><br><span class="line">    <span class="comment">// 11 -&gt; do not change, recurse i + 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度： N * 4</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 会越变越多，然后往后移</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">maximumBinaryString</span><span class="params">(string binary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstZero = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> updateFirstZero = [&amp;]() -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            ++firstZero;</span><br><span class="line">            <span class="keyword">while</span> (firstZero &lt; binary.<span class="built_in">size</span>() &amp;&amp; binary[firstZero] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                ++firstZero;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">updateFirstZero</span>();</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>)&gt; recurse = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= binary.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == binary.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> begin = binary.<span class="built_in">substr</span>(i, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (begin == <span class="string">&quot;11&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">recurse</span>(i + <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin == <span class="string">&quot;10&quot;</span>) &#123;</span><br><span class="line">                <span class="built_in">recurse</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin == <span class="string">&quot;00&quot;</span>) &#123;</span><br><span class="line">                binary[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="built_in">recurse</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// &quot;01&quot;</span></span><br><span class="line">                <span class="keyword">while</span> (firstZero &lt;= i) &#123;</span><br><span class="line">                    <span class="built_in">updateFirstZero</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (firstZero &gt;= binary.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">                binary[firstZero] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="built_in">updateFirstZero</span>();</span><br><span class="line">                binary[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                binary[i + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                binary[i + <span class="number">2</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="built_in">recurse</span>(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">recurse</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> binary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(binary.size()),<br>空间复杂度: O(binary.size()).</p>
<p>实际上，<br>也有<a href="https://leetcode.com/problems/maximum-binary-string-after-change/discuss/987335/JavaC%2B%2BPython-Solution-with-Explanation">寒神更简单的解法</a>.</p>
<h2 id="1703-Minimum-Adjacent-Swaps-for-K-Consecutive-Ones"><a href="#1703-Minimum-Adjacent-Swaps-for-K-Consecutive-Ones" class="headerlink" title="1703. Minimum Adjacent Swaps for K Consecutive Ones"></a>1703. Minimum Adjacent Swaps for K Consecutive Ones</h2><p>枚举集合中心位置，双指针更新左右边界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; out, <span class="keyword">const</span> vector&lt;T&gt;&amp; a) &#123;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;[&quot;</span>; <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : a) &#123; out &lt;&lt; (first ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>); out &lt;&lt; v; first = <span class="number">0</span>;&#125; out &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// 二分？ 如何判定？N * log N</span></span><br><span class="line">    <span class="comment">// greedy, 向密的地方靠近</span></span><br><span class="line">    <span class="comment">// 把1移到对应位置的花费是中间0的数目</span></span><br><span class="line">    <span class="comment">// 遍历集合地点，然后左右找k个1. N * K</span></span><br><span class="line">    <span class="comment">// 右边取 x 个，左边取 k - x个</span></span><br><span class="line">    <span class="comment">// 贪心， 左边右边谁近取谁</span></span><br><span class="line">    <span class="comment">// 更新集合位置，双指针更新左右边界</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ones;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                ones.<span class="built_in">push_back</span>(zero);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++zero;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> currentAns = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// [left, right)</span></span><br><span class="line">        <span class="keyword">for</span> (; right &lt; k; ++right) &#123;</span><br><span class="line">            currentAns += ones[right];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = currentAns;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">0</span>; mid &lt; nums.<span class="built_in">size</span>(); ++mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++zero;</span><br><span class="line">                currentAns -= right - one; <span class="comment">// right</span></span><br><span class="line">                currentAns += one - left; <span class="comment">// left;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++one;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (right &lt; ones.<span class="built_in">size</span>() &amp;&amp; ones[right] - zero &lt;= zero - ones[left]) &#123;</span><br><span class="line">                currentAns += ones[right] - zero - (zero - ones[left]);</span><br><span class="line">                ++right;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, currentAns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<p>比赛过程中，因为写了2个 bug 调了半个小时。差一分钟没交上，亏死了。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 47</title>
    <url>/2021/03/07/LeetCode-biweekly-contest-47/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>64 / 9933</td>
<td>YoungForest</td>
<td>18</td>
<td>0:55:55</td>
<td>0:03:37</td>
<td>0:07:16</td>
<td>0:13:28</td>
<td>0:55:55</td>
</tr>
</tbody></table>
<p>疯狂上分场。13分钟做出3题。最后一题也思路相对比较顺畅。遇到2个阻塞。1. 一开始忘记考虑没有边相连的点对；2. 求了互补问题，但返回答案时粗心误以为总数是<code>n^2</code>，而事实上是<code>C_2 n = n * (n - 1) / 2</code>， 调试又浪费了不少时间。如果更加顺利的话，说不定成绩会突破天际。拿到前20名丰盛的礼物。</p>
<span id="more"></span>

<h2 id="1779-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate"><a href="#1779-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate" class="headerlink" title="1779. Find Nearest Point That Has the Same X or Y Coordinate"></a>1779. Find Nearest Point That Has the Same X or Y Coordinate</h2><p>签到题。遍历一遍，判断是否同列/同行，和距离是否更近。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + <span class="built_in">abs</span>(a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nearestValidPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; me = &#123;x, y&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ansDistance = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; v = points[i];</span><br><span class="line">            <span class="keyword">if</span> (v[<span class="number">0</span>] == me[<span class="number">0</span>] || v[<span class="number">1</span>] == me[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> newDistance = <span class="built_in">distance</span>(me, v);</span><br><span class="line">                <span class="keyword">if</span> (newDistance &lt; ansDistance) &#123;</span><br><span class="line">                    ansDistance = newDistance;</span><br><span class="line">                    ans = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1780-Check-if-Number-is-a-Sum-of-Powers-of-Three"><a href="#1780-Check-if-Number-is-a-Sum-of-Powers-of-Three" class="headerlink" title="1780. Check if Number is a Sum of Powers of Three"></a>1780. Check if Number is a Sum of Powers of Three</h2><p>三进制编码。每位只能是0或1，不能是2.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPowersOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x = (x - 1) / 3 or x / 3</span></span><br><span class="line">        <span class="comment">// time: log_3 (n)</span></span><br><span class="line">        <span class="keyword">int</span> x = n;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((x - <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                x = (x - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                x = x / <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log_3 N),<br>空间复杂度: O(1).</p>
<h2 id="1781-Sum-of-Beauty-of-All-Substrings"><a href="#1781-Sum-of-Beauty-of-All-Substrings" class="headerlink" title="1781. Sum of Beauty of All Substrings"></a>1781. Sum of Beauty of All Substrings</h2><p>观察到数据规模并不大，<code>500</code>. 暴力枚举所有子串，O(1)更新 <code>beauty</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beautySum</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// brute-force: n ^ 2 * log 26</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            multiset&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// s[i:j]</span></span><br><span class="line">                <span class="keyword">auto</span> it = cnt.<span class="built_in">find</span>(count[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                <span class="keyword">if</span> (it != cnt.<span class="built_in">end</span>()) cnt.<span class="built_in">erase</span>(it);</span><br><span class="line">                ++count[s[j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                cnt.<span class="built_in">insert</span>(count[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                ans += (*cnt.<span class="built_in">rbegin</span>() - *cnt.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N^2 * log 26),<br>时间复杂度: O(26).</p>
<h2 id="1782-Count-Pairs-Of-Nodes"><a href="#1782-Count-Pairs-Of-Nodes" class="headerlink" title="1782. Count Pairs Of Nodes"></a>1782. Count Pairs Of Nodes</h2><p>观察到点数<code>V</code>还是很大的：<code>2*10^4</code>，所以无法枚举所有的点对。<br>但<code>E</code>的数目不大<code>10^5</code>，不属于稠密图。<br>所以可以暴力边。<br>而且<code>queries.size()</code>较小，只有20.</p>
<p>总的思路是，先求所有点的度，如果2点度的和小于等于query，则2点的<code>cnt</code>一定小于等于<code>query</code>。因为有<code>cnt(a, b) &lt;= degree(a) + degree(b)</code>，等号成立当且仅当<code>a</code> <code>b</code>不互连。<br>我们可以先把度排序，然后用<code>two sum</code>的方式二分搜索所有的满足<code>degree(a) + degree(b) &lt;= query</code>的点对。<br>虽然题目要求<code>cnt</code>严格大于<code>query</code>, 但是我们先求<code>cnt &lt;= query</code>。因为两者是互补的。除了上述符合要求的点对，还有另外一些有边的点对也可能符合要求。这些点对是:<br><code>degree(a) + degree(b) &gt; query and degree(a) + degree(b) - edges(a, b) &lt;= query</code>. 只需要遍历一遍所有的边即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countPairs</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// time: E + 20 * (E + V log V)</span></span><br><span class="line">        map&lt;pii, <span class="keyword">int</span>&gt; edgesCount;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[<span class="number">0</span>] &gt; e[<span class="number">1</span>]) <span class="built_in">swap</span>(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">            ++degree[e[<span class="number">0</span>] - <span class="number">1</span>];</span><br><span class="line">            ++degree[e[<span class="number">1</span>] - <span class="number">1</span>];</span><br><span class="line">            ++edgesCount[&#123;e[<span class="number">0</span>] - <span class="number">1</span>, e[<span class="number">1</span>] - <span class="number">1</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; degreeV = degree;</span><br><span class="line">        <span class="built_in">sort</span>(degreeV.<span class="built_in">begin</span>(), degreeV.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; answers;</span><br><span class="line">        answers.<span class="built_in">reserve</span>(queries.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : queries) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ait = degreeV.<span class="built_in">begin</span>(); ait != degreeV.<span class="built_in">end</span>(); ++ait) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> j = *ait;</span><br><span class="line">                <span class="keyword">auto</span> bit = <span class="built_in">upper_bound</span>(degreeV.<span class="built_in">begin</span>(), ait, i - j);</span><br><span class="line">                ret += <span class="built_in">distance</span>(degreeV.<span class="built_in">begin</span>(), bit);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> p : edgesCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> (degree[p.first.first] + degree[p.first.second] &gt; i &amp;&amp; degree[p.first.first] + degree[p.first.second] - p.second &lt;= i) ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">            answers.<span class="built_in">push_back</span>((n * (n - <span class="number">1</span>)) / <span class="number">2</span> - ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(E + queries.size() * (E + V log V)),<br>空间复杂度: O(V + E).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-biweekly-contest-48</title>
    <url>/2021/03/21/LeetCode-biweekly-contest-48/</url>
    <content><![CDATA[<p>昨晚和女朋友KFC，耽误了比赛，赛后补题。</p>
<h2 id="1796-Second-Largest-Digit-in-a-String"><a href="#1796-Second-Largest-Digit-in-a-String" class="headerlink" title="1796. Second Largest Digit in a String"></a>1796. Second Largest Digit in a String</h2><p>签到题。统计所有的数字，再从大到小找第二大的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondHighest</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                ++cnt[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxNumber = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxNumber == <span class="number">-1</span>) &#123;</span><br><span class="line">                    maxNumber = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1797-Design-Authentication-Manager"><a href="#1797-Design-Authentication-Manager" class="headerlink" title="1797. Design Authentication Manager"></a>1797. Design Authentication Manager</h2><p>用字典存储每一个<code>tokenId</code>的<code>expired time</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthenticationManager</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> timeToLive;</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; expiredTime;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AuthenticationManager</span>(<span class="keyword">int</span> _timeToLive) : <span class="built_in">timeToLive</span>(_timeToLive) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(string tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        expiredTime[tokenId] = currentTime + timeToLive;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renew</span><span class="params">(string tokenId, <span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = expiredTime.<span class="built_in">find</span>(tokenId);</span><br><span class="line">        <span class="keyword">if</span> (it != expiredTime.<span class="built_in">end</span>() &amp;&amp; it-&gt;second &gt; currentTime) &#123;</span><br><span class="line">            <span class="built_in">generate</span>(tokenId, currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countUnexpiredTokens</span><span class="params">(<span class="keyword">int</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : expiredTime) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second &gt; currentTime) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your AuthenticationManager object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * AuthenticationManager* obj = new AuthenticationManager(timeToLive);</span></span><br><span class="line"><span class="comment"> * obj-&gt;generate(tokenId,currentTime);</span></span><br><span class="line"><span class="comment"> * obj-&gt;renew(tokenId,currentTime);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;countUnexpiredTokens(currentTime);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度:</p>
<ul>
<li>generate: O(1),</li>
<li>renew: O(1),</li>
<li>countUnexpiredTokens: O(expiredTime.size())<br>空间复杂度:</li>
<li>O(expiredTime.size())</li>
</ul>
<h2 id="1798-Maximum-Number-of-Consecutive-Values-You-Can-Make"><a href="#1798-Maximum-Number-of-Consecutive-Values-You-Can-Make" class="headerlink" title="1798. Maximum Number of Consecutive Values You Can Make"></a>1798. Maximum Number of Consecutive Values You Can Make</h2><p>Brute-force: O(N^2), TLE.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// max : sum(coins)</span></span><br><span class="line">        <span class="comment">// determine(X): O(N * X)</span></span><br><span class="line">        <span class="comment">// 2 ^ n, </span></span><br><span class="line">        <span class="comment">// 1 + 2 + 3 + .. + n</span></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : coins) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ns = s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : s) &#123;</span><br><span class="line">                ns.<span class="built_in">insert</span>(x + i);</span><br><span class="line">            &#125;</span><br><span class="line">            s = <span class="built_in">move</span>(ns);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(i) == s.<span class="built_in">end</span>()) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1799-Maximize-Score-After-N-Operations"><a href="#1799-Maximize-Score-After-N-Operations" class="headerlink" title="1799. Maximize Score After N Operations"></a>1799. Maximize Score After N Operations</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 49</title>
    <url>/2021/04/04/LeetCode-biweekly-contest-49/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>108 / 9082</td>
<td>YoungForest</td>
<td>18</td>
<td>1:37:36</td>
<td>0:03:39</td>
<td>0:09:01</td>
<td>0:14:28</td>
<td>1:27:36  2</td>
</tr>
</tbody></table>
<p>最近因为放松了刷题，自己竞赛水平也有所降低。不过这算是我刻意为之的。之前疯狂刷题刷了1k+，后来遇到瓶颈，改为每天刷3题（国服每日一题，美服每日一题，残酷群每日一题。分别有积分和红包奖励），现在已经基本每日0题，只是坚持打周赛维持手感和获得快乐。<br>诚然刷题和比赛是很快乐的，让人上瘾，我早已欲罢不能。<br>但是因为面临毕业和毕业论文的压力，我刻意控制了自己刷题的时间和投入。<br>不知道你能不能理解，在写论文的时候，什么东西都能成为诱惑。而刷题这种我平日里就很喜欢的活动更是成为了巨大的诱惑和逃避之地。究其根本，写论文和做实验真的是太痛苦了。<br>甚至不需要是刷题，别的什么阻止我都足够了。比如 看书，看电影，刷论坛。<br>没办法，论文总是要强迫自己投入主要精力去做的。我不是一个意志力足够坚强的人。<br>因此，刷题被我刻意远离了。仅仅品尝每周竞赛的快乐就足够了。</p>
<p>因为水平的降低和自己国服rating太高（2400+），我现在已经基本转战美服了。美服账号rating不到2200，尚且有不小的上升空间。打起来压力也不会太大。<br>之前打国服，连跌2次，险些跌出2400俱乐部。<br>我打算先把美服也打上2400. 这样不把鸡蛋放在一个篮子里，自己的rating也更稳定些。</p>
<span id="more"></span>

<h2 id="1812-Determine-Color-of-a-Chessboard-Square"><a href="#1812-Determine-Color-of-a-Chessboard-Square" class="headerlink" title="1812. Determine Color of a Chessboard Square"></a>1812. Determine Color of a Chessboard Square</h2><p>签到题。根据棋盘黑白交替的特性，推断对应坐标的颜色。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">squareIsWhite</span><span class="params">(string coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> firstBlack = ((coordinates[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) % <span class="number">2</span>) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (((coordinates[<span class="number">1</span>] - <span class="string">&#x27;1&#x27;</span>) % <span class="number">2</span> ) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> !firstBlack;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> firstBlack;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<h2 id="1813-Sentence-Similarity-III"><a href="#1813-Sentence-Similarity-III" class="headerlink" title="1813. Sentence Similarity III"></a>1813. Sentence Similarity III</h2><p>Stright forward. 根据题意，a 相似于 b的话，需要从头和尾各相等，然后在中间碰头。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">areSentencesSimilar</span>(<span class="params">self, sentence1: <span class="built_in">str</span>, sentence2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">similar</span>(<span class="params">a, b</span>):</span></span><br><span class="line">            aa = a.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            bb = b.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            <span class="comment"># a insert a sentence to b</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(aa) &gt; <span class="built_in">len</span>(bb): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            begin = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> begin &lt; <span class="built_in">len</span>(aa) <span class="keyword">and</span> aa[begin] == bb[begin]:</span><br><span class="line">                begin += <span class="number">1</span></span><br><span class="line">            end = <span class="built_in">len</span>(aa) - <span class="number">1</span></span><br><span class="line">            endB = <span class="built_in">len</span>(bb) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> end &gt;= begin <span class="keyword">and</span> endB &gt;= begin <span class="keyword">and</span> aa[end] == bb[endB]:</span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line">                endB -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> begin &gt; end</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> similar(sentence1, sentence2) <span class="keyword">or</span> similar(sentence2, sentence1)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(sentence.length),<br>空间复杂度: O(sentence.length).</p>
<h2 id="1814-Count-Nice-Pairs-in-an-Array"><a href="#1814-Count-Nice-Pairs-in-an-Array" class="headerlink" title="1814. Count Nice Pairs in an Array"></a>1814. Count Nice Pairs in an Array</h2><p><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code> 可以转化为<br><code>nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])</code>. 问题因此转换为统计相等对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rev</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNicePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> k = x - <span class="built_in">rev</span>(x);</span><br><span class="line">            ans = (ans + cnt[k]) % MOD;</span><br><span class="line">            ++cnt[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度: O(32 * N),<br>空间复杂度: O(N).</p>
<h2 id="1815-Maximum-Number-of-Groups-Getting-Fresh-Donuts"><a href="#1815-Maximum-Number-of-Groups-Getting-Fresh-Donuts" class="headerlink" title="1815. Maximum Number of Groups Getting Fresh Donuts"></a>1815. Maximum Number of Groups Getting Fresh Donuts</h2><h3 id="比赛时AC的错误贪心版本"><a href="#比赛时AC的错误贪心版本" class="headerlink" title="比赛时AC的错误贪心版本"></a>比赛时AC的错误贪心版本</h3><p>由于题目的数据规模比较小，<code>1 &lt;= batchSize &lt;= 9</code>, <code>1 &lt;= groups.length &lt;= 30</code>。因此，我们可以断定，本题的时间复杂度要求不高，很可能是回溯搜索类的解法。事实证明，确实如此，Discuss区给出的答案基本都是 <code>DFS + DP</code>。</p>
<p>比赛时，虽然我也AC了，但说实话，解法并不对。</p>
<p>首先，问题可以转化成，按<code>%batchSize</code>分类，因为显然，余数相等的数是一样的。<br>然后在对其进行分组，使得组内和等于batchSize，求最大的组数。</p>
<p>我写出一种贪心的算法，认为首先一个数一组，然后2个数一组，…, groups.length 个数一组。这样的分组方式是“最优的”。然后再<code>WA</code>后，我也很快意识到，并不是这样的。这种分组顺序并不对。<br>枚举所有分组顺序的时间复杂度是<code>30!</code>，显然不可取。而且当时时间也只剩下10分钟了。因此，我试着想对于大多数情况，少数一组还是符合直觉的。关键是测试用例中有违反的，所以我试着交换一些分组顺序，而且想，越小的数影响越大。因此，我尝试了交换2，3；再交换3，4，竟然就<code>AC</code>了。也是神奇，运气好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxHappyGroups</span><span class="params">(<span class="keyword">int</span> batchSize, vector&lt;<span class="keyword">int</span>&gt;&amp; groups)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cntOrigin</span><span class="params">(batchSize, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : groups) &#123;</span><br><span class="line">            ++cntOrigin[x % batchSize];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(groups.size())</span></span>;</span><br><span class="line">        <span class="built_in">iota</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> tryOne = [&amp;]() -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> cnt = cntOrigin;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> updateAns = [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; useCnt) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> minOne = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; useCnt.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (useCnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                minOne = <span class="built_in">min</span>(minOne, cnt[i] / useCnt[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; useCnt.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (useCnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                cnt[i] -= useCnt[i] * minOne;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += minOne;</span><br><span class="line">        &#125;;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&amp;)&gt; backtracking = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> remain, <span class="keyword">const</span> <span class="keyword">int</span> s, vector&lt;<span class="keyword">int</span>&gt;&amp; useCnt) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s % batchSize == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">updateAns</span>(useCnt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchSize; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    ++useCnt[i];</span><br><span class="line">                    <span class="built_in">backtracking</span>(remain - <span class="number">1</span>, s + i, useCnt);</span><br><span class="line">                    --useCnt[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r : v) &#123;</span><br><span class="line">            <span class="comment">// pick r elements from 0, 1, ..., batchSize - 1</span></span><br><span class="line">            <span class="comment">// allow duplicate</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">accumulate</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(), <span class="number">0</span>) &lt; r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">useCnt</span><span class="params">(batchSize, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(r, <span class="number">0</span>, useCnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">accumulate</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>(), <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">tryOne</span>();</span><br><span class="line">        <span class="built_in">swap</span>(v[<span class="number">2</span>],v[<span class="number">3</span>]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">tryOne</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: 因为回溯有很多剪枝，我也不确定真正的时间复杂度是多少。算是枚举了所有可能的组合，一定小于O(2^(group.size() + 1))的。大概可能在O(2^9)左右。<br>空间复杂度: O(group.length + batchSize).</p>
<h3 id="赛后学习的正确-DFS-DP-版本"><a href="#赛后学习的正确-DFS-DP-版本" class="headerlink" title="赛后学习的正确 DFS + DP 版本"></a>赛后学习的正确 DFS + DP 版本</h3><p><a href="https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/discuss/1140961/C%2B%2B-Greedy-%2B-Backtracking-Video-explanation-with-and-English">Discuss 中C++ 版本题解</a><br>简而言之，是每次尝试使用可用的任意group（减一），在其中找最大的。</p>
<p>也可以去看<a href="https://www.bilibili.com/video/BV1CU4y187tk">花花的视频讲解</a>，讲的还不错。</p>
<p>我的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VectorHasher</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; V)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> hash = V.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : V)</span><br><span class="line">      hash ^= i + <span class="number">0x9e3779b9</span> + (hash &lt;&lt; <span class="number">6</span>) + (hash &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxHappyGroups</span><span class="params">(<span class="keyword">int</span> batchSize, vector&lt;<span class="keyword">int</span>&gt;&amp; groups)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(batchSize, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : groups) &#123;</span><br><span class="line">            ++cnt[x % batchSize];</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;vector&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>, VectorHasher&gt; memo;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> s) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = memo.<span class="built_in">find</span>(cnt);</span><br><span class="line">            <span class="keyword">if</span> (it != memo.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; batchSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                --cnt[i];</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>((s + i) % batchSize) + (s == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">                ++cnt[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[cnt] = ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt[<span class="number">0</span>] + <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(cnt 个非0元素之积 * batchSize);<br>空间复杂度: O(cnt 个非0元素之积). (其实就是cache的空间大小).</p>
<p>在花花的视频里，他认为最坏的情况发生在cnt 均匀分布的时候。此时<br>时间复杂度: O(k * (n / k) ^ k) = 2,359,296,<br>空间复杂度: O((n / k) ^ k) = 262144.<br>其中 k = batchSize, n = groups.size().</p>
<p>因此，在最坏情况下也是可以AC的。</p>
<h2 id="Rejudge"><a href="#Rejudge" class="headerlink" title="Rejudge"></a>Rejudge</h2><p>LeetCode 每次比赛后并不会马上更新rating，而是要等3、4天。中间有个一查重和rejudge的过程，有些题目因为比赛时test cases 太弱。不对/超时的算法可能蒙混过关，比如我的第4题。白高兴了，rejudge后果然fail了。不过真心是我自己的算法不对，怪不得别人。<br>rejudge只是还一个真想，对于比赛公平其实很重要。虽然本次我是rejudge的受害者，但大多数时候，我都是受益者。我也是十分支持rejudge的。只是希望LeetCode今后可以提高比赛时题目和测试用例的质量，赛后评测和更新rating的速度更快些，别让大家等4、5天。都快下周周赛了。</p>
<p>更新后的成绩：</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>108 / 9082</td>
<td>YoungForest</td>
<td>18</td>
<td>1:37:36</td>
<td>0:03:39</td>
<td>0:09:01</td>
<td>0:14:28</td>
<td>1:27:36  2</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 5</title>
    <url>/2019/07/27/LeetCode-biweekly-contest-5/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (3)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>98 / 1634</td>
<td>YoungForest</td>
<td>18</td>
<td>0:35:23</td>
<td>0:11:01</td>
<td>0:10:53</td>
<td>0:22:40</td>
<td>0:35:23</td>
</tr>
</tbody></table>
<p>距离上次参加biweekly contest已经2个月了，编号也从1直接跳到5了。<br>本次contest十分简单，都是算法里的经典的题目，属于必会的。我做完4题后还有近1个小时。</p>
<h2 id="1133-Largest-Unique-Number"><a href="#1133-Largest-Unique-Number" class="headerlink" title="1133. Largest Unique Number"></a>1133. Largest Unique Number</h2><p>签到题。遍历一遍数组，然后计数。然后从大向小找符合要求的数。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestUniqueNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            ++count[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = count.<span class="built_in">crbegin</span>(); it != count.<span class="built_in">crend</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;second == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> it-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1134-Armstrong-Number"><a href="#1134-Armstrong-Number" class="headerlink" title="1134. Armstrong Number"></a>1134. Armstrong Number</h2><p>感觉还是一道Easy的题目。根据题意做即可，考察取数中每一个位。</p>
<p>时间复杂度: O(log N), N的位数。<br>空间复杂度: O(log N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x * <span class="built_in">pow</span>(x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isArmstrong</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> number = N;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; digits;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digits.<span class="built_in">push_back</span>(N % <span class="number">10</span>);</span><br><span class="line">            N /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> power = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> digit : digits) &#123;</span><br><span class="line">            s += <span class="built_in">pow</span>(digit, power);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s == number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1135-Connecting-Cities-With-Minimum-Cost"><a href="#1135-Connecting-Cities-With-Minimum-Cost" class="headerlink" title="1135. Connecting Cities With Minimum Cost"></a>1135. Connecting Cities With Minimum Cost</h2><p><a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">最小生成树</a></p>
<p>时间复杂度: O(E logE, E logV).<br>空间复杂度: O(E, V)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">            parent.<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            count = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A utility function to find the subset of an element i  </span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">if</span> (parent[i] == i)  </span><br><span class="line">                <span class="keyword">return</span> i;  </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(parent[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// A utility function to do union of two subsets  </span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">int</span> xset = <span class="built_in">find</span>(x);  </span><br><span class="line">            <span class="keyword">int</span> yset = <span class="built_in">find</span>(y);  </span><br><span class="line">            <span class="keyword">if</span>(xset != yset) </span><br><span class="line">            &#123;  </span><br><span class="line">                parent[xset] = yset;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumCost</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; conections)</span> </span>&#123;</span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(conections.<span class="built_in">begin</span>(), conections.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lhs, <span class="keyword">const</span> <span class="keyword">auto</span>&amp;rhs) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs[<span class="number">2</span>] &lt; rhs[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge : conections) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = edge[<span class="number">0</span>] - <span class="number">1</span>, b = edge[<span class="number">1</span>] - <span class="number">1</span>, cost = edge[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (uf.<span class="built_in">find</span>(a) != uf.<span class="built_in">find</span>(b)) &#123;</span><br><span class="line">                uf.<span class="built_in">Union</span>(a, b);</span><br><span class="line">                ans += cost;</span><br><span class="line">                <span class="keyword">if</span> (uf.count == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1136-Parallel-Courses"><a href="#1136-Parallel-Courses" class="headerlink" title="1136. Parallel Courses"></a>1136. Parallel Courses</h2><p>拓扑排序。数据结构的基础题目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumSemesters</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; relations)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; in;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; out;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge : relations) &#123;</span><br><span class="line">            <span class="keyword">int</span> X = edge[<span class="number">0</span>], Y = edge[<span class="number">1</span>];</span><br><span class="line">            in[X].<span class="built_in">push_back</span>(Y);</span><br><span class="line">            ++out[Y];</span><br><span class="line">            q.<span class="built_in">erase</span>(Y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> finish_course = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            unordered_set&lt;<span class="keyword">int</span>&gt; next_q;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : q) &#123;</span><br><span class="line">                ++finish_course;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> from : in[i]) &#123;</span><br><span class="line">                    --out[from];</span><br><span class="line">                    <span class="keyword">if</span> (out[from] == <span class="number">0</span>) &#123;</span><br><span class="line">                        out.<span class="built_in">erase</span>(from);</span><br><span class="line">                        next_q.<span class="built_in">insert</span>(from);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                in.<span class="built_in">erase</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">            q = std::<span class="built_in">move</span>(next_q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (finish_course == N)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 50</title>
    <url>/2021/04/18/LeetCode-biweekly-contest-50/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>1032 / 10097</td>
<td>YoungForest</td>
<td>12</td>
<td>0:20:28</td>
<td>0:09:10</td>
<td>0:12:51</td>
<td>0:20:28</td>
<td>null</td>
</tr>
</tbody></table>
<p>因为洗澡迟到了8分钟，否则应该可以进前500的。<br>本次的双周赛是变相的手速场，141人作出4题。剩下的比拼前3题的手速。<br>我花10min很顺利地做完了前三题，Q4却思考了一个小时也并未有重大突破。<br>虽然有些许眉目，觉得是个DP，但事后发现问题早已超纲，没做出来也实属正常。</p>
<span id="more"></span>

<h2 id="1827-Minimum-Operations-to-Make-the-Array-Increasing"><a href="#1827-Minimum-Operations-to-Make-the-Array-Increasing" class="headerlink" title="1827. Minimum Operations to Make the Array Increasing"></a>1827. Minimum Operations to Make the Array Increasing</h2><p>贪心。在保持递增的同时，使得数字尽可能小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// greedy</span></span><br><span class="line">        <span class="comment">// time: O(N)</span></span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; last) &#123;</span><br><span class="line">                last = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += last + <span class="number">1</span> - i;</span><br><span class="line">                ++last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1828-Queries-on-Number-of-Points-Inside-a-Circle"><a href="#1828-Queries-on-Number-of-Points-Inside-a-Circle" class="headerlink" title="1828. Queries on Number of Points Inside a Circle"></a>1828. Queries on Number of Points Inside a Circle</h2><p>由于点数和圆数都比较小（&lt;= 500），因此直接暴力即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inside</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; p, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] - c[<span class="number">0</span>]) * (p[<span class="number">0</span>] - c[<span class="number">0</span>]) + (p[<span class="number">1</span>] - c[<span class="number">1</span>]) * (p[<span class="number">1</span>] - c[<span class="number">1</span>]) &lt;= c[<span class="number">2</span>] * c[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.<span class="built_in">reserve</span>(queries.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : queries) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : points) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">inside</span>(p, v)) ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(points.length * queries.length),<br>空间复杂度: O(queries.length).</p>
<h2 id="1829-Maximum-XOR-for-Each-Query"><a href="#1829-Maximum-XOR-for-Each-Query" class="headerlink" title="1829. Maximum XOR for Each Query"></a>1829. Maximum XOR for Each Query</h2><p>利用前缀和（其实是前缀XOR）快速进行<code>Remove</code>操作，然后用互补的方式构造<code>k</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getMaximumXor</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> maximumBit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentXOR = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a ^ b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">auto</span> findMax = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> a) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="comment">// argmax a ^ k</span></span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = maximumBit - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(a &amp; (<span class="number">1</span> &lt;&lt; i))) &#123;</span><br><span class="line">                    k |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.<span class="built_in">reserve</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = nums.<span class="built_in">rbegin</span>(); it != nums.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> x = *it;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">findMax</span>(currentXOR));</span><br><span class="line">            currentXOR ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(nums.length * maximumBit),<br>空间复杂度: O(nums.length).</p>
<h2 id="1830-Minimum-Number-of-Operations-to-Make-String-Sorted"><a href="#1830-Minimum-Number-of-Operations-to-Make-String-Sorted" class="headerlink" title="1830. Minimum Number of Operations to Make String Sorted"></a>1830. Minimum Number of Operations to Make String Sorted</h2><p><a href="https://leetcode.com/problems/minimum-number-of-operations-to-make-string-sorted/">Problem link</a>.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 51</title>
    <url>/2021/05/02/LeetCode-biweekly-contest-51/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>150 / 9378</td>
<td>YoungForest</td>
<td>18</td>
<td>0:32:04</td>
<td>0:05:26</td>
<td>0:07:22</td>
<td>0:11:24</td>
<td>0:32:04</td>
</tr>
</tbody></table>
<p>手速场。最近手速已大不如从前，最后一题也因为不熟练花费了比较多的时间。<br>其实，手速场中，所有题目的算法其实都不难，想到正确的解法很快，但迅速实现 + bug free就考验每位程序员的功力了。</p>
<span id="more"></span>

<h2 id="1844-Replace-All-Digits-with-Characters"><a href="#1844-Replace-All-Digits-with-Characters" class="headerlink" title="1844. Replace All Digits with Characters"></a>1844. Replace All Digits with Characters</h2><p>签到题。按照题目要求完成即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">shift</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c + x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceDigits</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            s[i] = <span class="built_in">shift</span>(s[i<span class="number">-1</span>], s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1845-Seat-Reservation-Manager"><a href="#1845-Seat-Reservation-Manager" class="headerlink" title="1845. Seat Reservation Manager"></a>1845. Seat Reservation Manager</h2><p>因为每次都找最小的座位号，同时有<code>insert</code>(<code>unreserve</code>)的操作。显然需要使用 <code>priority_queue</code>优先队列/Heap 实现这一需求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeatManager</span> &#123;</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeatManager</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reserve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> ans = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unreserve</span><span class="params">(<span class="keyword">int</span> seatNumber)</span> </span>&#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(seatNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SeatManager object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SeatManager* obj = new SeatManager(n);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;reserve();</span></span><br><span class="line"><span class="comment"> * obj-&gt;unreserve(seatNumber);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度:</p>
<ul>
<li>SeatManager: O(n),</li>
<li>reserve: O(log n),</li>
<li>unreserve: O(log n).<br>空间复杂度: O(n).</li>
</ul>
<h2 id="1846-Maximum-Element-After-Decreasing-and-Rearranging"><a href="#1846-Maximum-Element-After-Decreasing-and-Rearranging" class="headerlink" title="1846. Maximum Element After Decreasing and Rearranging"></a>1846. Maximum Element After Decreasing and Rearranging</h2><p>贪心。<br>观察2种操作 <code>Decrease</code> 和 <code>Rearrange</code> 可以发现，<br>其实只需要<code>Reagrrage</code>一次，<code>Decrease</code>时，优先减小的。因为大的减起来一定可以包括小的，但小的不行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumElementAfterDecrementingAndRearranging</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; last) &#123;</span><br><span class="line">                arr[i] = last + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i] = last;</span><br><span class="line">            &#125;</span><br><span class="line">            last = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n log n + n),<br>空间复杂度: O(1).</p>
<h2 id="1847-Closest-Room"><a href="#1847-Closest-Room" class="headerlink" title="1847. Closest Room"></a>1847. Closest Room</h2><p>首先想到暴力解法，对于每一个<code>query</code>, 遍历一遍<code>rooms</code>，就可以找到答案。时间复杂度为 <code>O(k * n)</code>，显然会TLE。<br>解法时间复杂度应该是类似<code>O(n log n)</code>这种形式。</p>
<p>这里需要用到一个所谓**离线计算(offline query)**的技术。<br>所谓在线计算，就是<code>queries</code>的解答顺序是不变的，类似一个函数，每次被call，解答一次。<br>所谓离线计算，就是<code>queries</code>的解答顺序是可以变的，需要一次性求解一个数组的<code>queries</code>。此时，我们可以通过对<code>queries</code>重新排序得到均摊速度更快的算法。</p>
<p>首先，将<code>queries</code>按<code>minisize</code>排序，将<code>rooms</code>按<code>size</code>排序。<br>用双指针的方式，保证对于当前的<code>query</code>，符合要求的<code>rooms</code>都被加入候选集合中。这里我们用<code>TreeSet</code>维护候选集合，以实现<code>log n</code>的搜索最近<code>room</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">closestRoom</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// brute force: k * n</span></span><br><span class="line">        <span class="comment">// need: k * log n + n log n</span></span><br><span class="line">        <span class="comment">// online, sort queries by minisize from big to small, find close candidate</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(rooms.<span class="built_in">begin</span>(), rooms.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> k = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        vector&lt;pii&gt; searchOrder; <span class="comment">// miniSize, index</span></span><br><span class="line">        searchOrder.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            searchOrder.<span class="built_in">push_back</span>(&#123;queries[i][<span class="number">1</span>], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(searchOrder.<span class="built_in">begin</span>(), searchOrder.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; candidate;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(k, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; rooms[i][<span class="number">1</span>] &gt;= searchOrder[j].first) &#123;</span><br><span class="line">                candidate.<span class="built_in">insert</span>(rooms[i++][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> prefer = queries[searchOrder[j].second][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (!candidate.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = candidate.<span class="built_in">lower_bound</span>(prefer);</span><br><span class="line">                <span class="keyword">if</span> (it == candidate.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                    ans[searchOrder[j].second] = *it;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it == candidate.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    ans[searchOrder[j].second] = *<span class="built_in">prev</span>(it);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">abs</span>(*it - prefer) &lt; (prefer - *<span class="built_in">prev</span>(it))) &#123;</span><br><span class="line">                        ans[searchOrder[j].second] = *it;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans[searchOrder[j].second] = *<span class="built_in">prev</span>(it);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[searchOrder[j].second] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n log n + k log n + k log k),<br>空间复杂度: O(k + n).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 52</title>
    <url>/2021/05/16/LeetCode-biweekly-contest-52/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>2217 / 10364</td>
<td>YoungForest</td>
<td>12</td>
<td>0:51:47</td>
<td>0:05:11</td>
<td>0:51:47</td>
<td>0:29:51</td>
<td>null</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="1859-Sorting-the-Sentence"><a href="#1859-Sorting-the-Sentence" class="headerlink" title="1859. Sorting the Sentence"></a>1859. Sorting the Sentence</h2><p>字符串问题用<code>python</code>。虽然题目不难，就是分割字符串，按照指定内容排序，但实现起来还是比想象中复杂的。好在Python中有很多方便的API和数据结构可以灵活使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortSentence</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        words = s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">word</span>):</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">int</span>(word[-<span class="number">1</span>:]), word[<span class="number">0</span>:-<span class="number">1</span>])</span><br><span class="line">        tuples = <span class="built_in">list</span>(<span class="built_in">map</span>(f, words))</span><br><span class="line">        tuples.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">a, t</span>):</span></span><br><span class="line">            <span class="keyword">return</span> a + <span class="string">&#x27; &#x27;</span> + t[<span class="number">1</span>] </span><br><span class="line">        <span class="keyword">return</span> reduce(f2, tuples, <span class="string">&#x27;&#x27;</span>)[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(s.length),<br>空间复杂度: O(s.length).</p>
<h2 id="1860-Incremental-Memory-Leak"><a href="#1860-Incremental-Memory-Leak" class="headerlink" title="1860. Incremental Memory Leak"></a>1860. Incremental Memory Leak</h2><p>本来是想用等差数列求和+解方程，O(1)解决的。但事实上实现和解方程还是太复杂了。到最后也没做出来。做完第3题后，回过来算了一下暴力的时间复杂度: O(sqrt(2^32)) = 65536. 居然如此低，果然第二题还是不能想复杂了，直接暴力怼多好。</p>
<p>暴力模拟题目中描述的内存占用过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">memLeak</span><span class="params">(<span class="keyword">int</span> m1, <span class="keyword">int</span> m2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m1 &gt;= t || m2 &gt;= t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m1 &gt;= m2) &#123;</span><br><span class="line">                m1 -= t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m2 -= t;</span><br><span class="line">            &#125;</span><br><span class="line">            ++t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;t, m1, m2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(sqrt(memory1 + memory2)),<br>空间复杂度: O(1).</p>
<h2 id="1861-Rotating-the-Box"><a href="#1861-Rotating-the-Box" class="headerlink" title="1861. Rotating the Box"></a>1861. Rotating the Box</h2><p>了解了掉落的本质，会发现，只需要统计每个障碍物/地面左面到上个障碍物的石头有多少个即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; <span class="built_in">rotateTheBox</span>(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; box) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> rows = box.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> cols = box[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; <span class="built_in">ans</span>(cols, vector&lt;<span class="keyword">char</span>&gt;(rows, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> stoneCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (box[i][j] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                    ++stoneCnt;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (box[i][j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// fall down</span></span><br><span class="line">                    ans[j][rows - <span class="number">1</span> - i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= stoneCnt; ++k) &#123;</span><br><span class="line">                        ans[j - k][rows - <span class="number">1</span> - i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    stoneCnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= stoneCnt; ++k) &#123;</span><br><span class="line">                ans[cols - k][rows - <span class="number">1</span> - i] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(m * n),<br>空间复杂度: O(m * n).</p>
<h2 id="1862-Sum-of-Floored-Pairs"><a href="#1862-Sum-of-Floored-Pairs" class="headerlink" title="1862. Sum of Floored Pairs"></a>1862. Sum of Floored Pairs</h2><p>没啥好想法。首先尝试了暴力解，枚举所有的对：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfFlooredPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                ans += nums[j] // nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans % MOD</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N^2), TLE，<br>空间复杂度: O(1).</p>
<p>尝试使用二分查找优化，寻找每一个数的倍数范围。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfFlooredPairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> MAX = nums.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                ans = (ans + last) % MOD;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; nums[i] * j &lt;= MAX; ++j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> l = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">end</span>(), nums[i] * j);</span><br><span class="line">                <span class="keyword">auto</span> r = <span class="built_in">lower_bound</span>(l, nums.<span class="built_in">end</span>(), nums[i] * (j + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">auto</span> x = <span class="built_in">distance</span>(l, r);</span><br><span class="line">                last = (last + x * j) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + last) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N log N), 虽然有2个循环嵌套，但第二个其实是个调和级数。不过仍然TLE了。<br>空间复杂度: O(1).</p>
<p>还是看零神的题解把：<br><a href="https://leetcode-cn.com/problems/sum-of-floored-pairs/solution/xiang-xia-qu-zheng-shu-dui-he-by-leetcod-u3eg/">前缀和优化</a>。<br>可以少一个log.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 53</title>
    <url>/2021/05/30/LeetCode-biweekly-contest-53/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>219 / 12291</td>
<td>YoungForest</td>
<td>18</td>
<td>0:57:45</td>
<td>0:19:12</td>
<td>0:22:21</td>
<td>0:46:08</td>
<td>0:57:45</td>
</tr>
</tbody></table>
<p>因为今天陪npy去参加斯巴达比赛，早上不到6点就起了，在外奔波了一天。<br>比赛前想着休息一下子，就打算睡20min。没想到太累了，闹铃响了自己给关了。因此迟到了10+min，否则我排名还可以更高些。题目不难，也不简单，属于出的比较好的。</p>
<p>零神大数据<br>1876,Substrings of Size Three with Distinct Characters,substrings-of-size-three-with-distinct-characters,1248.7224675206<br>1877,Minimize Maximum Pair Sum in Array,minimize-maximum-pair-sum-in-array,1301.3817574010<br>1878,Get Biggest Three Rhombus Sums in a Grid,get-biggest-three-rhombus-sums-in-a-grid,1897.5516652727<br>1879,Minimum XOR Sum of Two Arrays,minimum-xor-sum-of-two-arrays,2145.1839952670</p>
<span id="more"></span>

<h2 id="1876-Substrings-of-Size-Three-with-Distinct-Characters"><a href="#1876-Substrings-of-Size-Three-with-Distinct-Characters" class="headerlink" title="1876. Substrings of Size Three with Distinct Characters"></a>1876. Substrings of Size Three with Distinct Characters</h2><p>签到题。因为子字符串长度是确定长度（3）。因此可以用一个滑动窗口枚举所有的长度为3的子串，判断是否每个字符都只出现一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> ok = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : cnt) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        ++cnt[s[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++cnt[s[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++cnt[s[<span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ok</span>()) ++ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++cnt[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            --cnt[s[i - <span class="number">3</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ok</span>()) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n),<br>空间复杂度: O(1).</p>
<h2 id="1877-Minimize-Maximum-Pair-Sum-in-Array"><a href="#1877-Minimize-Maximum-Pair-Sum-in-Array" class="headerlink" title="1877. Minimize Maximum Pair Sum in Array"></a>1877. Minimize Maximum Pair Sum in Array</h2><p>贪心，让大的和小的组合。<br>可以让最大和最小，同时让最小和最大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPairSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// greedy: match largest and smallest</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, nums[l++] + nums[r--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<h2 id="1878-Get-Biggest-Three-Rhombus-Sums-in-a-Grid"><a href="#1878-Get-Biggest-Three-Rhombus-Sums-in-a-Grid" class="headerlink" title="1878. Get Biggest Three Rhombus Sums in a Grid"></a>1878. Get Biggest Three Rhombus Sums in a Grid</h2><p>枚举所有的菱形，然后维护最大的3个菱形和即可。<br>我的枚举方式是，枚举菱形的中心和4个顶点到中心的距离。<br>计算菱形和可以通过前缀和presum O(1)计算。因此总的时间复杂度是 O(N^3). N最大值是100，恰好满足条件。</p>
<p>后来发现LeetCode把题目的数据范围从100改到了50.之前听说比赛时有人用N^4的暴力方法过了，我以为会赛后rejudge 的，没想到人家直接改体面。让所有人都过了。可能是懒得rejudge了，还得加数据量大的case。改数据范围多省事儿。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getBiggestThree</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// x := Rhombus number: m * n * m</span></span><br><span class="line">        <span class="comment">// time: x log x</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">presum</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">presum2</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                presum[i+<span class="number">1</span>][j+<span class="number">1</span>] = presum[i][j] + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                presum2[i+<span class="number">1</span>][j] = presum2[i][j+<span class="number">1</span>] + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(grid[i][j]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; i - len &gt;= <span class="number">0</span> &amp;&amp; j - len &gt;= <span class="number">0</span> &amp;&amp; i + len &lt; m &amp;&amp; j + len &lt; n; ++len) &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> rhombus = presum[i+<span class="number">1</span>][j+len+<span class="number">1</span>] - presum[i-len][j]</span><br><span class="line">                        + presum[i+len+<span class="number">1</span>][j+<span class="number">1</span>] - presum[i][j-len]</span><br><span class="line">                        + presum2[i+len+<span class="number">1</span>][j] - presum2[i][j+len+<span class="number">1</span>]</span><br><span class="line">                        + presum2[i+<span class="number">1</span>][j-len] - presum2[i-len][j+<span class="number">1</span>]</span><br><span class="line">                        - grid[i-len][j] - grid[i][j+len] - grid[i][j-len] - grid[i+len][j];</span><br><span class="line">                    s.<span class="built_in">insert</span>(rhombus);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">rbegin</span>(); it != s.<span class="built_in">rend</span>() &amp;&amp; i &lt; <span class="number">3</span>; ++it, ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>菱形数目<code>x = m * n * min(m,n)</code>,<br>时间复杂度: O(x log x),<br>空间复杂度: O(x + m * n)。因为只需要维护最大的3个菱形和，可优化到 -&gt; O(m*n).</p>
<h2 id="1879-Minimum-XOR-Sum-of-Two-Arrays"><a href="#1879-Minimum-XOR-Sum-of-Two-Arrays" class="headerlink" title="1879. Minimum XOR Sum of Two Arrays"></a>1879. Minimum XOR Sum of Two Arrays</h2><p>经典 DP + Bitmask.</p>
<p>一开始想到暴力的枚举所有排列，时间复杂度是 排列数 n! = 14!。一定会超时。<br>根据数据规模<code>n = 14</code>可以推测 需要使用bitmask.</p>
<p>定义dp(i, mask) 表示 nums1[i:] 和 nums2 中的子集mask 的最小异或和。<br>状态转移方程为：暴力尝试 nums[i]与mask中每一个可以的取值进行组合，取最小的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumXORSum</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># time: n * n * 2 ^ n</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i, mask</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(nums1): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; j) &amp; mask) == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, (nums1[i] ^ nums2[j]) + dp(i+<span class="number">1</span>, mask ^ (<span class="number">1</span> &lt;&lt; j)))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n * n * 2 ^ n)  = 14 * 14 * 2^14 = 3211264,<br>空间复杂度: O(n * 2^ n).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 54</title>
    <url>/2021/06/16/LeetCode-biweekly-contest-54/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>120 / 12076</td>
<td>YoungForest</td>
<td>18</td>
<td>1:19:33</td>
<td>0:03:17</td>
<td>0:09:23 🐞1</td>
<td>0:26:15</td>
<td>1:04:33 🐞2</td>
</tr>
</tbody></table>
<p>继续保持好成绩，尤其是最后一题，还是挺难的。刚开始没有思路甚至想放弃，但最后还是靠自己的思考解决了难题。</p>
<h2 id="1893-Check-if-All-the-Integers-in-a-Range-Are-Covered"><a href="#1893-Check-if-All-the-Integers-in-a-Range-Are-Covered" class="headerlink" title="1893. Check if All the Integers in a Range Are Covered"></a>1893. Check if All the Integers in a Range Are Covered</h2><p>签到题。对于<code>[right, right]</code>中每一个数，判断是否被<code>ranges</code>中的某个区间包含。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCovered</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ranges, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cover = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; range : ranges) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> l = range[<span class="number">0</span>], r = range[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (l &lt;= i &amp;&amp; i &lt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">cover</span>(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O((right - left) * ranges.length),<br>空间复杂度: O(1).</p>
<h2 id="1894-Find-the-Student-that-Will-Replace-the-Chalk"><a href="#1894-Find-the-Student-that-Will-Replace-the-Chalk" class="headerlink" title="1894. Find the Student that Will Replace the Chalk"></a>1894. Find the Student that Will Replace the Chalk</h2><p>先求前缀和，把k和和取余数，可以定位到最后一轮的遍历。然后用二分搜索寻找恰好大于k的位置，即为需要更换粉笔的学生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">chalkReplacer</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; chalk, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = chalk.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        presum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            presum[i+<span class="number">1</span>] = presum[i] + chalk[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= presum.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            k = k % presum.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the first index, presum[i] &gt; k</span></span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(presum.<span class="built_in">begin</span>(), presum.<span class="built_in">end</span>(), k);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">distance</span>(presum.<span class="built_in">begin</span>(), it) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N + log N), N = chalk.length,<br>空间复杂度: O(chalk.length).</p>
<p>需要注意数据范围，计算前缀和时可能会<code>int</code>溢出。我也因此Runtime Error一次。换成<code>long long</code>就好了。LeetCode最近坑溢出的case越来越多了，以后遇到需要先预估一下最大的值，该用<code>long long</code>用<code>long long</code>.</p>
<h2 id="1895-Largest-Magic-Square"><a href="#1895-Largest-Magic-Square" class="headerlink" title="1895. Largest Magic Square"></a>1895. Largest Magic Square</h2><p>暴力法：从大到小枚举所有的正方形，计算所有行、列、对角的和，判断是否相等。唯一的优化是采用前缀和，快速计算行列和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestMagicSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">presumLeft</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            presumLeft[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                presumLeft[i][j+<span class="number">1</span>] = presumLeft[i][j] + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">presumUp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            presumUp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                presumUp[i+<span class="number">1</span>][j] = presumUp[i][j] + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j, <span class="keyword">const</span> <span class="keyword">int</span> k) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> target = presumLeft[i][j+k] - presumLeft[i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; k; ++row) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target != presumLeft[i+row][j+k] - presumLeft[i+row][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; k; ++col) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target != presumUp[i+k][j+col] - presumUp[i][j+col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> diagonal = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; k; ++row) &#123;</span><br><span class="line">                    diagonal += grid[i+row][j+row];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (diagonal != target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> diagonal = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; k; ++row) &#123;</span><br><span class="line">                    diagonal += grid[i+row][j+k<span class="number">-1</span>-row];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (diagonal != target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">min</span>(n, m); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + k &lt;= m &amp;&amp; j + k &lt;= n &amp;&amp; <span class="built_in">check</span>(i, j, k)) <span class="keyword">return</span> k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N^4),<br>空间复杂度: O(N^2).</p>
<h2 id="1896-Minimum-Cost-to-Change-the-Final-Value-of-Expression"><a href="#1896-Minimum-Cost-to-Change-the-Final-Value-of-Expression" class="headerlink" title="1896. Minimum Cost to Change the Final Value of Expression"></a>1896. Minimum Cost to Change the Final Value of Expression</h2><p>递归，根据 &amp; | 和 子表达式的值 进行分类，寻找最小cost。<br>括号的处理需要提前用栈，找到所有的配对。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minOperationsToFlip</span>(<span class="params">self, expression: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(expression)</span><br><span class="line">        leftPair = &#123;&#125;</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        leftStack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> expression[i] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                leftPair[i] = leftStack.pop()</span><br><span class="line">            <span class="keyword">elif</span> expression[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                leftStack.append(i)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="comment"># [i, j)</span></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> == j: <span class="comment"># 0, 1</span></span><br><span class="line">                <span class="keyword">return</span> expression[i] == <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> expression[j-<span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    leftIndex = leftPair[j-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> leftIndex == i: <span class="keyword">return</span> dp(i+<span class="number">1</span>,j-<span class="number">1</span>)</span><br><span class="line">                    pivot = leftIndex - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 0, 1</span></span><br><span class="line">                    pivot = j - <span class="number">2</span></span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> expression[pivot] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> expression[pivot] == <span class="string">&#x27;1&#x27;</span>: pivot -= <span class="number">1</span></span><br><span class="line">                leftResult, leftCost = dp(i, pivot)</span><br><span class="line">                rightResult, rightCost = dp(pivot+<span class="number">1</span>, j)</span><br><span class="line">                <span class="keyword">if</span> expression[pivot] == <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> leftResult == <span class="literal">False</span> <span class="keyword">and</span> rightResult == <span class="literal">False</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span>, <span class="built_in">min</span>(leftCost, rightCost)</span><br><span class="line">                    <span class="keyword">elif</span> leftResult == <span class="literal">True</span> <span class="keyword">and</span> rightResult == <span class="literal">False</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span>, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> leftResult == <span class="literal">False</span> <span class="keyword">and</span> rightResult == <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span>, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span>, <span class="built_in">min</span>(leftCost + <span class="number">1</span>, rightCost + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">elif</span> expression[pivot] == <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> leftResult == <span class="literal">False</span> <span class="keyword">and</span> rightResult == <span class="literal">False</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span>, <span class="built_in">min</span>(leftCost + <span class="number">1</span>, rightCost + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">elif</span> leftResult == <span class="literal">True</span> <span class="keyword">and</span> rightResult == <span class="literal">False</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span>, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> leftResult == <span class="literal">False</span> <span class="keyword">and</span> rightResult == <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span>, <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span>, <span class="built_in">min</span>(leftCost, rightCost)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="built_in">len</span>(expression))[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 7</title>
    <url>/2019/08/25/LeetCode-biweekly-contest-7/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>106 / 1901</td>
<td>YoungForest</td>
<td>18</td>
<td>1:01:13</td>
<td>0:05:46</td>
<td>0:27:13</td>
<td>0:35:34</td>
<td>1:01:13</td>
</tr>
</tbody></table>
<p>本周参加 字节跳动的夏令营，周六开幕，所以本次的双周赛是在五星级酒店的床上完成的。好不舒服，比赛结果也还能看下去。<br>由于第二天上午要参加夏令营的课程，所以周赛就鸽掉了。不过下午的kick start round E还是参加了，翘掉了夏令营的课程。谁让我非常想去谷歌呢？</p>
<p>双周赛题目不难，感觉像是其他OJ上类似的beginner定位。</p>
<h2 id="1165-Single-Row-Keyboard"><a href="#1165-Single-Row-Keyboard" class="headerlink" title="1165. Single-Row Keyboard"></a>1165. Single-Row Keyboard</h2><p>考察hash table的应用, 建立字母和index的反向映射即可。</p>
<p>时间复杂度: O(N)<br>空间复杂度: O(N)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateTime</span><span class="params">(string keyboard, string word)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">location</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyboard.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            location[keyboard[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            ans += std::<span class="built_in">abs</span>(location[c - <span class="string">&#x27;a&#x27;</span>] - current);</span><br><span class="line">            current = location[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1166-Design-File-System"><a href="#1166-Design-File-System" class="headerlink" title="1166. Design File System"></a>1166. Design File System</h2><p>考察基本的数据结构（树）和字符串处理。<br>对路径进行建树，每个文件或目录是一个节点，节点上有value。查找和增长的过程都是类似字典树。<br>时间复杂度: O(N).<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        unordered_map&lt;string, shared_ptr&lt;Node&gt;&gt; children;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="keyword">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> string&amp; path)</span> </span>&#123;</span><br><span class="line">        string tmp;</span><br><span class="line">        vector&lt;string&gt; stk;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,tmp,<span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr&lt;Node&gt; m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileSystem</span>() &#123;</span><br><span class="line">        m = make_shared&lt;Node&gt;(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">create</span><span class="params">(string path, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> words = <span class="built_in">split</span>(path);</span><br><span class="line">        <span class="keyword">auto</span> current = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; word = words[i];</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;children.<span class="built_in">find</span>(word) == current-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current-&gt;children[word];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;children.<span class="built_in">find</span>(words.<span class="built_in">back</span>()) != current-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;children[words.<span class="built_in">back</span>()] = make_shared&lt;Node&gt;(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> words = <span class="built_in">split</span>(path);</span><br><span class="line">        <span class="keyword">auto</span> current = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; word = words[i];</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;children.<span class="built_in">find</span>(word) == current-&gt;children.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current-&gt;children[word];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FileSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FileSystem* obj = new FileSystem();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;create(path,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;get(path);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1167-Minimum-Cost-to-Connect-Sticks"><a href="#1167-Minimum-Cost-to-Connect-Sticks" class="headerlink" title="1167. Minimum Cost to Connect Sticks"></a>1167. Minimum Cost to Connect Sticks</h2><p>贪心算法。每次选择cost最小的2个stick进行connect操作。一个stick越早被connect，它的长度越可能影响整个cost。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connectSticks</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; sticks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*N个sticks，需要N-1次connect</span></span><br><span class="line"><span class="comment">        4</span></span><br><span class="line"><span class="comment">            4,5,8 9</span></span><br><span class="line"><span class="comment">            8,9 17</span></span><br><span class="line"><span class="comment">            17</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : sticks) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> smallest = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> second = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            ans += smallest + second;</span><br><span class="line">            pq.<span class="built_in">push</span>(smallest + second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1168-Optimize-Water-Distribution-in-a-Village"><a href="#1168-Optimize-Water-Distribution-in-a-Village" class="headerlink" title="1168. Optimize Water Distribution in a Village"></a>1168. Optimize Water Distribution in a Village</h2><p>最小生成树的变种。<br>pipe是边，除此之外，well也是边。可以当成是和水源连接的边。</p>
<p>时间复杂度: O(E log E)<br>空间复杂度: O(N)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; parents;</span><br><span class="line">        <span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">            parents.<span class="built_in">resize</span>(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                parents[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> x == parents[x] ? x : parents[x] = <span class="built_in">find</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unin</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> xp = <span class="built_in">find</span>(x);</span><br><span class="line">            <span class="keyword">int</span> yp = <span class="built_in">find</span>(y);</span><br><span class="line">            parents[xp] = yp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostToSupplyWater</span><span class="params">(<span class="keyword">int</span> n, vector&lt;<span class="keyword">int</span>&gt;&amp; wells, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; pipes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最小生成树</span></span><br><span class="line">        <span class="comment">// 每次寻找最短的边</span></span><br><span class="line">        vector&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wells.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            edges.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(wells[i], <span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pipe : pipes) &#123;</span><br><span class="line">            edges.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(pipe[<span class="number">2</span>], pipe[<span class="number">0</span>], pipe[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> cost = get&lt;<span class="number">0</span>&gt;(e);</span><br><span class="line">            <span class="keyword">int</span> left = get&lt;<span class="number">1</span>&gt;(e);</span><br><span class="line">            <span class="keyword">int</span> right = get&lt;<span class="number">2</span>&gt;(e);</span><br><span class="line">            <span class="keyword">if</span> (uf.<span class="built_in">find</span>(left) == uf.<span class="built_in">find</span>(right))</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += cost;</span><br><span class="line">                uf.<span class="built_in">unin</span>(left, right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 115</title>
    <url>/2018/12/19/LeetCode-weekly-contest-115/</url>
    <content><![CDATA[<p>有些日子没有参加LeetCode的weekly contest了，最近由于准备一月末的Google电话面试，需要重新把算法捡起来。复习算法书是一部分，另一手就是准备刷题啦。由于时间有限，LeetCode的weekly contest不失为一个更好的选择。因为contest有时间限制，和实际面试更像。<br>weekly contest时长为1个半小时，4道不同难度的题目，每周末10点半开始(之前是9点半，可能是因为美国冬令时的原因，所以后沿了一小时)。<br>和之前一样，只完成了2道题目，第三道题有些思路(后来证明不对)，第四题看了下题目，果断放弃。<br>下面分享4道题目的思路和Solution，当然后2道是之后补题的。</p>
<h2 id="958-Check-Completeness-of-a-Binary-Tree"><a href="#958-Check-Completeness-of-a-Binary-Tree" class="headerlink" title="958. Check Completeness of a Binary Tree"></a>958. Check Completeness of a Binary Tree</h2><p>判断一颗树是否是完全树。<br>关于树的题目，递归、BFS、DFS是常用手段，可以很快发现，BFS最适合解决该题目。<br>一旦发现某个结点缺少child，就将<code>no_child</code>置为True，之后再搜索的时候，其他节点就不能有child了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        no_child = <span class="literal">False</span></span><br><span class="line">        myqueue = collections.deque()</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            myqueue.append(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(myqueue) &gt; <span class="number">0</span>:</span><br><span class="line">            node = myqueue.popleft()</span><br><span class="line">            <span class="keyword">if</span> no_child:</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span> <span class="keyword">or</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                    myqueue.append(node.left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    no_child = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> no_child:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        myqueue.append(node.right)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    no_child = <span class="literal">True</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n), n 为节点数，因为在BFS中每个节点都要被遍历到(至少在完全树中，非完全树会提前退出)；<br>空间复杂度：O(n), BFS要用到一个队列，队列中最多要存一层的节点。</p>
<p>这道题的难度更像Easy，Medium真是高估了。</p>
<h2 id="957-Prison-Cells-After-N-Days"><a href="#957-Prison-Cells-After-N-Days" class="headerlink" title="957 Prison Cells After N Days"></a>957 Prison Cells After N Days</h2><p>状态转移的题目，可以直接模拟。但缺点是但N太大时，会TLE。<br>不难发现，Cells的状态最多有<code>2^6 = 64</code>种，所以在状态转移时，必然会出现循环。所以只要保存之前遇到的状态，如果再次遇到，就可以直接模掉循环长度了。<br>把状态转移打印出来，很快就可以发现，14是一个很神奇的数，每隔14必循环。所以最后的实现很多人都是直接mod 14了事。</p>
<p>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prisonAfterNDays</span>(<span class="params">self, cells, N</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type cells: List[int]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        last_day = cells</span><br><span class="line">        new_day = [<span class="number">0</span>] * <span class="number">8</span></span><br><span class="line">        N = N % <span class="number">14</span> + <span class="number">14</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">            <span class="keyword">if</span> last_day[i-<span class="number">1</span>] == last_day[i+<span class="number">1</span>]:</span><br><span class="line">                new_day[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_day[i] = <span class="number">0</span></span><br><span class="line">        new_day[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        new_day[<span class="number">7</span>] = <span class="number">0</span></span><br><span class="line">        last_day[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        last_day[<span class="number">7</span>] = <span class="number">0</span></span><br><span class="line">        last_day, new_day = new_day, last_day</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">                <span class="keyword">if</span> last_day[i-<span class="number">1</span>] == last_day[i+<span class="number">1</span>]:</span><br><span class="line">                    new_day[i] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    new_day[i] = <span class="number">0</span></span><br><span class="line">            last_day, new_day = new_day, last_day</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> last_day</span><br></pre></td></tr></table></figure>

<h2 id="959-Regions-Cut-By-Slashes"><a href="#959-Regions-Cut-By-Slashes" class="headerlink" title="959. Regions Cut By Slashes"></a>959. Regions Cut By Slashes</h2><p>问题的关键在于被划分为多少联通的区域，我最开始想用染色做，但后来被染色的顺序搞晕了。写了100行代码，最后还是不能全部正确解决。（事实上，DFS/BFS染色也是一种正确的解法）<br>看了官方的Solution后，发现Union-Find大法好。算法第4版 的第一章的最后也是着重讲解Union-Find的，解决这种联通问题最好不过了。不过因为Union-Find是太长时间前看的了，而且平时做题时几乎不用，所以根本想不到它可以很方便地解决类似的联通问题。</p>
<p>在此再次推荐 算法第4版，真的对面试和提升算法技能太有用啦。多看多有益处。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">regionsBySlashes</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">UF</span>:</span></span><br><span class="line">            <span class="comment"># quick union implement</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">                self.parents = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">                self.count = size</span><br><span class="line">                </span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x</span>):</span></span><br><span class="line">                <span class="keyword">if</span> self.parents[x] == x:</span><br><span class="line">                    <span class="keyword">return</span> x</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.parents[x] = self.find(self.parents[x])</span><br><span class="line">                    <span class="keyword">return</span> self.parents[x]</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">                i = self.find(x)</span><br><span class="line">                j = self.find(y)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> i == j: <span class="keyword">return</span> <span class="comment"># already unioned</span></span><br><span class="line">                </span><br><span class="line">                self.parents[i] = j</span><br><span class="line">                self.count -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        uf = UF(<span class="number">4</span>*<span class="built_in">len</span>(grid)*<span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> row, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> column, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(value):</span><br><span class="line">                base = (row * <span class="built_in">len</span>(grid[<span class="number">0</span>]) + column) * <span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> char == <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">                    uf.union(base, base + <span class="number">2</span>)</span><br><span class="line">                    uf.union(base + <span class="number">1</span>, base + <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">elif</span> char == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    uf.union(base, base + <span class="number">1</span>)</span><br><span class="line">                    uf.union(base + <span class="number">2</span>, base + <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">elif</span> char == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    uf.union(base, base + <span class="number">1</span>)</span><br><span class="line">                    uf.union(base, base + <span class="number">2</span>)</span><br><span class="line">                    uf.union(base, base + <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">if</span> row &gt; <span class="number">0</span>:</span><br><span class="line">                    base_up = ((row - <span class="number">1</span>) * <span class="built_in">len</span>(grid[<span class="number">0</span>]) + column) * <span class="number">4</span></span><br><span class="line">                    uf.union(base, base_up + <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">if</span> row &lt; <span class="built_in">len</span>(grid) - <span class="number">1</span>:</span><br><span class="line">                    base_down = ((row + <span class="number">1</span>) * <span class="built_in">len</span>(grid[<span class="number">0</span>]) + column) * <span class="number">4</span></span><br><span class="line">                    uf.union(base + <span class="number">3</span>, base_down)</span><br><span class="line">                <span class="keyword">if</span> column &gt; <span class="number">0</span>:</span><br><span class="line">                    base_left = base - <span class="number">4</span></span><br><span class="line">                    uf.union(base + <span class="number">1</span>, base_left + <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> column &lt; <span class="built_in">len</span>(grid[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">                    base_right = base + <span class="number">4</span></span><br><span class="line">                    uf.union(base + <span class="number">2</span>, base_right + <span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> uf.count</span><br></pre></td></tr></table></figure>

<h2 id="960-Delete-Columns-to-Make-Sorted-III"><a href="#960-Delete-Columns-to-Make-Sorted-III" class="headerlink" title="960. Delete Columns to Make Sorted III"></a>960. Delete Columns to Make Sorted III</h2><p>这是一道Dynamic Programming发挥作用的典型题目。(由于时间不够了，最后还是去看了Solution才豁然开朗。)<br>可惜的是 算法第4版 并未涉及DP这么重要的概念，如果要系统地学习DP的话，还是去看 算法导论 吧（虽然我从来都没有看完，向来都是挑着看的）。</p>
<p>我们按照算法导论上的一步一步来吧：<br>动态规划解题的4 steps:</p>
<ol>
<li>最优解结构</li>
<li>递归定义最优解的值</li>
<li>计算最优解的值</li>
<li>从计算信息中构造最优解</li>
</ol>
<p>When should we look for a Dynamic Programming solution to a problem?</p>
<ol>
<li>最优解结构</li>
<li>重叠子问题</li>
</ol>
<p>首先 最小删除列数 = 最大留下列数，我们把最大留下列数作为最优化目标。</p>
<ol>
<li>最优解结构：根据 算法导论 15.3中对最优子结构的讨论，子问题的空间越小（越简单）越好，所以我们选择dp[i]的子问题为dp[k]，其中 0 &lt;= k &lt; i, dp[i]表示只考虑前i个字符, 且第i列留下来的话，最大留下的列数。</li>
<li>递归定义最优解的值：dp[i] = max(dp[k] + 1), for every string .indexAt[i] &gt;= .indexAt[k]</li>
<li>使用 Bottom-top 方法求解答案，for i in 0～len(A[0]), 计算dp[i], 最大留下列数为max(dp)。不是dp[-1]因为最后一列不一定要留下。</li>
<li>由于问题不需要求解最后删去/留下哪几行，所以构造最优解可以忽略</li>
</ol>
<p>时间复杂度: O(A.length ^2 * A[i].length),<br>空间复杂度: O(A.length).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDeletionSize</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A[<span class="number">0</span>]))]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">all</span>(s[k] &lt;= s[i] <span class="keyword">for</span> s <span class="keyword">in</span> A):</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[k] + <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(A[<span class="number">0</span>]) - <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>革命尚未成功，同志还需努力。</p>
<p>最近在知乎上关注了一个叫做Jennica的姐姐（找她要的Google内推），小姐姐热爱生活和编程，我想我其实也是这样的。所以打算多多向其学习，万一历史进程让我阴差阳错地可以进入Google工作呐。我一直以来（起码这1年以来），一直以进入外企工作作为自己的职业规划，现在看到前人的努力和成功，更加有动力和欲望啦。我要去Google/Microsoft做程序员，哈哈。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 116</title>
    <url>/2018/12/26/LeetCode-weekly-contest-116/</url>
    <content><![CDATA[<p>又到周末LeetCode weekly contest的时候了，这次战果不佳。原因主要是，二三题都想做出来，结果都没有做出来。如果把时间都集中于第二题，应该也还是能AC的。</p>
<h2 id="961-N-Repeated-Element-in-Size-2N-Array"><a href="#961-N-Repeated-Element-in-Size-2N-Array" class="headerlink" title="961. N-Repeated Element in Size 2N Array"></a>961. N-Repeated Element in Size 2N Array</h2><p>这道题总觉得之前在LeetCode上已经做过了，还记得solution的方向。<br>思路是这样的，既然有一半的元素是一样的，我们随机抽取2个元素，判断是否相等就可以了。从概率上来讲，虽然有永远算不出来的概率，但在实际应用中效果很好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">repeatedNTimes</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            s = random.sample(A, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>] == s[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> s[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h2 id="962-Maximum-Width-Ramp"><a href="#962-Maximum-Width-Ramp" class="headerlink" title="962. Maximum Width Ramp"></a>962. Maximum Width Ramp</h2><p>或许是最近dp学的有点多，遇见道题目就想着空间换时间。殊不知，忘记了dp的用武之地：<br>When should we look for a Dynamic Programming solution to a problem?</p>
<ol>
<li>最优解结构</li>
<li>重叠子问题<br>找了半天最优解结构和重叠子问题：<br>dp[x] = max[dp[x] + x - k] for all A[x] &gt;= A[k],<br>发现时间复杂度和brute search一样，都是O(n^2)呀！</li>
</ol>
<p>真是dp学魔怔了，忘记了其他更基础的算法。其实这道题用简单的排序就能解决。<br>排序可以避免二次循环，将复杂度从O(n^2)降为O(n logn)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxWidthRamp</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        min_value = math.inf</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(A)), key=A.__getitem__):</span><br><span class="line">            min_value = <span class="built_in">min</span>(min_value, i)</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, i - min_value)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>Solution中还有一种利用二分查找的方法，我觉得很巧妙。<br>关键点在于注意到，对于j1 &lt; j2, A[j1] &lt;= A[j2], 此时，我们总是倾向于选择j2的。所以，对于这样的输入[6,0,8,2,1,5]，maximum width ramp的A[j] 一定会出现在[5, 8]中。对于i的选择，就需要遍历一遍了。那么A[j]是[5, 8]中的哪一个呢？就需要根据A[i]就行二分查找了，选择比A[i]恰好大一点的A[j]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxWidthRamp</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        condinates = [(A[-<span class="number">1</span>], <span class="built_in">len</span>(A)-<span class="number">1</span>)]</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            jx = bisect.bisect(condinates, (A[i],))</span><br><span class="line">            <span class="keyword">if</span> jx &gt;= <span class="built_in">len</span>(condinates):</span><br><span class="line">                condinates.append((A[i], i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, condinates[jx][<span class="number">1</span>] - i)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h2 id="963-Minimum-Area-Rectangle-II"><a href="#963-Minimum-Area-Rectangle-II" class="headerlink" title="963. Minimum Area Rectangle II"></a>963. Minimum Area Rectangle II</h2><p>这道题其实挺恶心的，怪不得downvote &gt;&gt; upvote。对数学的要求远大于算法的要求，brute search( O(n^3) )也能过。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAreaFreeRect</span>(<span class="params">self, points</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        EPS = <span class="number">1e-7</span></span><br><span class="line">        points_set = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">complex</span>(*x), points))</span><br><span class="line">        ans = math.inf</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> p1, p2, p3 <span class="keyword">in</span> itertools.permutations(points_set, <span class="number">3</span>):</span><br><span class="line">            p4 = p1 + p3 - p2</span><br><span class="line">            <span class="keyword">if</span> p4 <span class="keyword">in</span> points_set <span class="keyword">and</span> <span class="built_in">abs</span>((p3 - p2).real * (p1 - p2).real + (p3 - p2).imag * (p1 - p2).imag) &lt; EPS:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="built_in">abs</span>(p1 - p2) * <span class="built_in">abs</span>(p3 - p2))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; math.inf <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Solution中还有一种时间复杂度为O(n^2 log n)的解法，利用了矩形的中心这一特点。</p>
<h2 id="964-Least-Operators-to-Express-Number"><a href="#964-Least-Operators-to-Express-Number" class="headerlink" title="964. Least Operators to Express Number"></a>964. Least Operators to Express Number</h2><p>上一周的weekly contest竟然拖到本周六才完成，要知道明天就是新的weekly contest啦。我的效率真是感人呀。不过临近年底，真的是事情超级多。不过再忙也不能忘记以“找一份好工作”为中心的纲领。</p>
<p>此题难度为Hard，果然不知道怎么做。看看题解学习学习先。<br>题解看的一塌糊涂，完全不知所以。幸运的是，找到一份很好理解的<a href="https://leetcode.com/problems/least-operators-to-express-number/discuss/208376/python2-O(log-target)-chinese">Discuss</a>。<br>正如作者所云：</p>
<blockquote>
<p>此题归根结底还是考察对进制的理解</p>
</blockquote>
<p>时间复杂度: O(log target),<br>空间复杂度: O(log target).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leastOpsExpressTarget</span>(<span class="params">self, x, target</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rl = []</span><br><span class="line">        <span class="keyword">while</span> target &gt; <span class="number">0</span>:</span><br><span class="line">            rl.append(target % x)</span><br><span class="line">            target //= x</span><br><span class="line">            </span><br><span class="line">        n = <span class="built_in">len</span>(rl)</span><br><span class="line">            </span><br><span class="line">        pos = rl[<span class="number">0</span>] * <span class="number">2</span></span><br><span class="line">        neg = (x - rl[<span class="number">0</span>]) * <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            pos, neg = <span class="built_in">min</span>(rl[i] * i + pos, rl[i] * i + i + neg), <span class="built_in">min</span>((x - rl[i]) * i + pos, (x - rl[i]) * i - i + neg)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(pos - <span class="number">1</span>, n + neg - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 117</title>
    <url>/2018/12/30/LeetCode-weekly-contest-117/</url>
    <content><![CDATA[<p>今天参加LeetCode weekly contest 117, 采取了不同的策略：边做题边写博客总结。期望这样可以真实地记录所思所想，提高写博客的效率。因为之前2次，事后写博客总是耽误几天时间才写完。</p>
<h2 id="965-Univalued-Binary-Tree"><a href="#965-Univalued-Binary-Tree" class="headerlink" title="965. Univalued Binary Tree"></a>965. Univalued Binary Tree</h2><p>一道很简单、很弱智的题目，直接DFS/BFS即可。因为BFS在遇到异常节点的时候可以直接返回，更方便。我选择了BFS实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        univalue = root.val</span><br><span class="line">        queue = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>: queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>: queue.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.val != univalue: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="967-Numbers-With-Same-Consecutive-Differences"><a href="#967-Numbers-With-Same-Consecutive-Differences" class="headerlink" title="967. Numbers With Same Consecutive Differences"></a>967. Numbers With Same Consecutive Differences</h2><p>第二题也是一道十分弱智的题目，直接搜索即可。需要注意的地方是，N == 1 和 K == 0时的特殊处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numsSameConsecDiff</span>(<span class="params">self, N, K</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">        ret = []</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">10</span>):</span><br><span class="line">            hashmap[i] = []</span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">0</span>:</span><br><span class="line">                hashmap[i].append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i + K &lt;= <span class="number">9</span>:</span><br><span class="line">                    hashmap[i].append(i + K)</span><br><span class="line">                <span class="keyword">if</span> i - K &gt;= <span class="number">0</span>:</span><br><span class="line">                    hashmap[i].append(i - K)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">n, digits</span>):</span></span><br><span class="line">            <span class="keyword">if</span> n == N:</span><br><span class="line">                ret.append(reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y, digits))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> hashmap[digits[n-<span class="number">1</span>]]:</span><br><span class="line">                digits.append(i)</span><br><span class="line">                helper(n+<span class="number">1</span>, digits)</span><br><span class="line">                digits.pop()</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            digits = [i]</span><br><span class="line">            helper(<span class="number">1</span>, digits)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h2 id="966-Vowel-Spellchecker"><a href="#966-Vowel-Spellchecker" class="headerlink" title="966. Vowel Spellchecker"></a>966. Vowel Spellchecker</h2><p>由于前2题用brute search都解决了，本题我也上来就直接干。结果TLE了，因为暴力法的时间复杂度为O(MN)，M = len(wordlist), N = len(queries)。<br>怎样才能进一步降低时间复杂度呢？我脑子中闪过的第一个词是 单词书(Tire)，最近刚在 算法第四版 中学到这一技术。 时间复杂度为O(max(N * wordlist中最长单词的长度, M), 不出意料的话，可以AC，现在已经11:46了。应该写不完了，让我先看一下第4题吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spellchecker</span>(<span class="params">self, wordlist, queries</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type wordlist: List[str]</span></span><br><span class="line"><span class="string">        :type queries: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        wordlist_replace_vowel = []</span><br><span class="line">        vowel = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>]</span><br><span class="line">        word_lower = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordlist:</span><br><span class="line">            word_lower.append(word.lower())</span><br><span class="line">            temp = <span class="built_in">list</span>(word)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">                <span class="keyword">if</span> temp[i] <span class="keyword">in</span> vowel:</span><br><span class="line">                    temp[i] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            wordlist_replace_vowel.append(<span class="string">&#x27;&#x27;</span>.join(temp).lower())</span><br><span class="line">            </span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">            match = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            temp = <span class="built_in">list</span>(query)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(temp)):</span><br><span class="line">                <span class="keyword">if</span> temp[i] <span class="keyword">in</span> vowel:</span><br><span class="line">                    temp[i] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            query_replace_vowel = <span class="string">&#x27;&#x27;</span>.join(temp).lower()</span><br><span class="line">            query_lower = query.lower()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> wi, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(wordlist):</span><br><span class="line">                <span class="keyword">if</span> flag &lt; <span class="number">4</span> <span class="keyword">and</span> word == query:</span><br><span class="line">                    match = word</span><br><span class="line">                    flag = <span class="number">4</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag  &lt; <span class="number">3</span> <span class="keyword">and</span> word_lower[wi] == query_lower:</span><br><span class="line">                    match = word</span><br><span class="line">                    flag = <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> flag &lt; <span class="number">2</span> <span class="keyword">and</span> wordlist_replace_vowel[wi] == query_replace_vowel:</span><br><span class="line">                    match = word</span><br><span class="line">                    flag = <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            ret.append(match)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>看完Solution后，才发现这也是一道很弱智的题目。brute search会TLE，使用HashMap就可以了嘛。<br>时间复杂度: O(C), C为wordlist和queries的总长度。<br>空间复杂度: O(C)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spellchecker</span>(<span class="params">self, wordlist, queries</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type wordlist: List[str]</span></span><br><span class="line"><span class="string">        :type queries: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        wordlist_replace_vowel = &#123;&#125;</span><br><span class="line">        vowel = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]</span><br><span class="line">        word_lower = &#123;&#125;</span><br><span class="line">        word_set = <span class="built_in">set</span>(wordlist)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordlist:</span><br><span class="line">            wl = word.lower()</span><br><span class="line">            <span class="comment"># setdefault 的使用：第一次赋值，之后忽略。保证在wordlist中先出现的词优先</span></span><br><span class="line">            word_lower.setdefault(word.lower(), word)</span><br><span class="line">            wordlist_replace_vowel.setdefault(<span class="string">&#x27;&#x27;</span>.join(<span class="string">&#x27;0&#x27;</span> <span class="keyword">if</span> i <span class="keyword">in</span> vowel <span class="keyword">else</span> i <span class="keyword">for</span> i <span class="keyword">in</span> wl), word)</span><br><span class="line">            </span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> query <span class="keyword">in</span> queries:</span><br><span class="line">            ql = query.lower()</span><br><span class="line">            query_replace_vowel = <span class="string">&#x27;&#x27;</span>.join(<span class="string">&#x27;0&#x27;</span> <span class="keyword">if</span> i <span class="keyword">in</span> vowel <span class="keyword">else</span> i <span class="keyword">for</span> i <span class="keyword">in</span> ql)</span><br><span class="line">            <span class="keyword">if</span> query <span class="keyword">in</span> word_set:</span><br><span class="line">                ret.append(query)</span><br><span class="line">            <span class="keyword">elif</span> ql <span class="keyword">in</span> word_lower:</span><br><span class="line">                ret.append(word_lower[ql])</span><br><span class="line">            <span class="keyword">elif</span> query_replace_vowel <span class="keyword">in</span> wordlist_replace_vowel:</span><br><span class="line">                ret.append(wordlist_replace_vowel[query_replace_vowel])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret.append(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h2 id="968-Binary-Tree-Cameras"><a href="#968-Binary-Tree-Cameras" class="headerlink" title="968. Binary Tree Cameras"></a>968. Binary Tree Cameras</h2><p>看完Solution后，惊呼：动态规划还可以这样用！</p>
<p>每个节点有3种状态：</p>
<ol>
<li>子树都已被cover，但此节点没有被cover。</li>
<li>子树和此节点都被cover，但此节点没有camera。</li>
<li>子树和此节点都被cover，且此节点有camera。</li>
</ol>
<p>对于每种状态的节点，他的子节点的状态也是确定的。</p>
<ol>
<li>左右子节点都为2。</li>
<li>左右子节点为2或3，且至少有一个为3.</li>
<li>左右子节点为1或2或3，但需要增加一个camera。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCameraCover</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, math.inf</span><br><span class="line">            </span><br><span class="line">            L = solve(root.left)</span><br><span class="line">            R = solve(root.right)</span><br><span class="line">            </span><br><span class="line">            dp0 = L[<span class="number">1</span>] + R[<span class="number">1</span>]</span><br><span class="line">            dp1 = <span class="built_in">min</span>(L[<span class="number">2</span>] + <span class="built_in">min</span>(R[<span class="number">1</span>:]), R[<span class="number">2</span>] + <span class="built_in">min</span>(L[<span class="number">1</span>:]))</span><br><span class="line">            dp2 = <span class="number">1</span> + <span class="built_in">min</span>(L) + <span class="built_in">min</span>(R)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> dp0, dp1, dp2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(solve(root)[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上午参加比赛，下午5点前写完博客。<br>总的来说，contest的题目的质量并没有之前的高。我之前喜欢用Liked排序刷题，体验非常好。<br>contest的优势在于有时间限制，可以逼迫自己在限定时间内解决。想不出解法也暂时不能去看题解（一种偷懒的刷题方式）。</p>
<p>这几天元旦放假，打算把《C++ Primer》看一部分，这样以后就可以在简历上写自己会C++啦。<br>之后是读CTCI，准备Google的第一次电面。<br>然后是CSAPP，我喜欢的计算机系统。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 118</title>
    <url>/2019/01/06/LeetCode-weekly-contest-118/</url>
    <content><![CDATA[<p>一周一度的LeetCode weekly contest 开始啦。本周着实比之前有所进步，首先是对C++更加熟悉了，之前都是用Python写的。答题过程也更流畅了，差点做出来3道题目。</p>
<span id="more"></span>

<h2 id="970-Powerful-Integers"><a href="#970-Powerful-Integers" class="headerlink" title="970. Powerful Integers"></a>970. Powerful Integers</h2><p>第一题只有3分，而且无法从算法上就行优化，brute approach即可。<br>需要注意的是corner case, 当x == 1 or y == 1时，1^n = 1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">powerfulIntegers</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="built_in">pow</span>(x, i);</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; bound) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; ; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> ans_new = ans + <span class="built_in">pow</span>(y, j);</span><br><span class="line">                <span class="keyword">if</span> (ans_new &lt;= bound)</span><br><span class="line">                    res.<span class="built_in">insert</span>(ans_new);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (y == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res_vec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> a: res) &#123;</span><br><span class="line">            res_vec.<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="969-Pancake-Sorting"><a href="#969-Pancake-Sorting" class="headerlink" title="969. Pancake Sorting"></a>969. Pancake Sorting</h2><p>首先想到一种暴力方法，每次把最后一个元素排好序，类似选择排序的算法。<br>即先找到最后一个元素的位置，将其flip到第一个位置，然后再flip一次，放在最后一个位置。<br>不变式为，最后一个位置之后的元素都是排好序的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; begin &lt; end; ++begin, --end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            temp = A[begin];</span><br><span class="line">            A[begin] = A[end];</span><br><span class="line">            A[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pancakeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>(); i &gt; <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] == i) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index + <span class="number">1</span> != i) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(index+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">flip</span>(A, <span class="number">0</span>, index);</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="built_in">flip</span>(A, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="971-Flip-Binary-Tree-To-Match-Preorder-Traversal"><a href="#971-Flip-Binary-Tree-To-Match-Preorder-Traversal" class="headerlink" title="971. Flip Binary Tree To Match Preorder Traversal"></a>971. Flip Binary Tree To Match Preorder Traversal</h2><p>该题也是straight forward解决即可，不断递归判断每个子树是否可以flip。由于搞错了一个参数的含义(设计的是没问题的，但实现的时候有疏忽)，voyageIndex传入的是root的位置，flip返回的是预计下一个子树的根结点在voyage中的位置。<br>导致12:19才AC，超时20min。而且还WA了4次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> voyageIndex, TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; voyage, vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> voyageIndex;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;root-&gt;val : &quot; &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (voyage[voyageIndex] != root-&gt;val) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;root-&gt;val : &quot; &lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> voyageIndexEnd;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; voyage[voyageIndex + <span class="number">1</span>] == root-&gt;left-&gt;val) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span> &amp;&amp; voyage[voyageIndex + <span class="number">1</span>] == root-&gt;right-&gt;val &amp;&amp; root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode *temp;</span><br><span class="line">            temp = root-&gt;left;</span><br><span class="line">            root-&gt;left = root-&gt;right;</span><br><span class="line">            root-&gt;right = temp;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;voyageIndex: &quot; &lt;&lt; voyageIndex &lt;&lt; &quot; &quot;&lt;&lt; root-&gt;val &lt;&lt; endl;</span></span><br><span class="line">        voyageIndexEnd = <span class="built_in">flip</span>(voyageIndex + <span class="number">1</span>, root-&gt;left, voyage, res);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;voyageIndexEnd: &quot; &lt;&lt; voyageIndexEnd &lt;&lt; endl; </span></span><br><span class="line">        <span class="keyword">if</span> (voyageIndexEnd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        voyageIndexEnd = <span class="built_in">flip</span>(voyageIndexEnd, root-&gt;right, voyage, res);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;voyageIndexEnd: &quot; &lt;&lt; voyageIndexEnd &lt;&lt; endl; </span></span><br><span class="line">        <span class="keyword">if</span> (voyageIndexEnd == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> voyageIndexEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">flipMatchVoyage</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; voyage)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; error = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">flip</span>(<span class="number">0</span>, root, voyage, res) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="972-Equal-Rational-Numbers"><a href="#972-Equal-Rational-Numbers" class="headerlink" title="972. Equal Rational Numbers"></a>972. Equal Rational Numbers</h2><p>本题并没有考察任何算法，只考察的是数据结构抽象和基础的数学知识(对有理数Rational Numbers)的理解。<br>我也是看的题解才明白如此简单的。真的是一道难者不会，会者不难的题目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> numerator, denominator;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y &gt; <span class="number">0</span> ? <span class="built_in">gcd</span>(y, x % y) : x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> d) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> g = <span class="keyword">this</span>-&gt;<span class="built_in">gcd</span>(n, d);</span><br><span class="line">        <span class="keyword">this</span>-&gt;numerator = n / g;</span><br><span class="line">        <span class="keyword">this</span>-&gt;denominator = d / g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fraction</span>(string S) &#123;</span><br><span class="line">        <span class="comment">// &lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;</span></span><br><span class="line">        <span class="keyword">auto</span> dotPosition = S.<span class="built_in">find</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="function">Fraction <span class="title">ans</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (dotPosition != string::npos) &#123;</span><br><span class="line">            <span class="function">Fraction <span class="title">integerPart</span><span class="params">(stol(S.substr(<span class="number">0</span>, dotPosition)), <span class="number">1</span>)</span></span>;</span><br><span class="line">            ans.<span class="built_in">add</span>(integerPart);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> leftParenthese = S.<span class="built_in">find</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            string nonRepeatingPartString;</span><br><span class="line">            <span class="keyword">if</span> (leftParenthese != string::npos) &#123;</span><br><span class="line">                nonRepeatingPartString = S.<span class="built_in">substr</span>(dotPosition + <span class="number">1</span>, leftParenthese - dotPosition - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">auto</span> repeatingPartString = S.<span class="built_in">substr</span>(leftParenthese + <span class="number">1</span>, S.<span class="built_in">size</span>() - leftParenthese - <span class="number">2</span>);</span><br><span class="line">                <span class="function">Fraction <span class="title">repeatingPart</span><span class="params">(stol(repeatingPartString), pow(<span class="number">10</span>, nonRepeatingPartString.size()) * (pow(<span class="number">10</span>, repeatingPartString.size()) - <span class="number">1</span>))</span></span>;</span><br><span class="line">                ans.<span class="built_in">add</span>(repeatingPart);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nonRepeatingPartString = S.<span class="built_in">substr</span>(dotPosition + <span class="number">1</span>, S.<span class="built_in">size</span>() - dotPosition - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nonRepeatingPartString.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function">Fraction <span class="title">nonRepeatingPart</span><span class="params">(stol(nonRepeatingPartString), pow(<span class="number">10</span>, nonRepeatingPartString.size()))</span></span>;</span><br><span class="line">                ans.<span class="built_in">add</span>(nonRepeatingPart);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Fraction <span class="built_in">integerPart</span>(<span class="built_in">stol</span>(S.<span class="built_in">substr</span>(<span class="number">0</span>, S.<span class="built_in">size</span>())), <span class="number">1</span>);</span><br><span class="line">            ans.<span class="built_in">add</span>(integerPart);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>-&gt;numerator = ans.numerator;</span><br><span class="line">        <span class="keyword">this</span>-&gt;denominator = ans.denominator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Fraction b)</span> </span>&#123;</span><br><span class="line">        <span class="function">Fraction <span class="title">n</span><span class="params">(<span class="keyword">this</span>-&gt;numerator * b.denominator + <span class="keyword">this</span>-&gt;denominator * b.numerator, <span class="keyword">this</span>-&gt;denominator * b.denominator)</span></span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;numerator = n.numerator;</span><br><span class="line">        <span class="keyword">this</span>-&gt;denominator = n.denominator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(Fraction b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;numerator == b.numerator &amp;&amp; <span class="keyword">this</span>-&gt;denominator == b.denominator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRationalEqual</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fraction</span>(S).<span class="built_in">equal</span>(<span class="built_in">Fraction</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main2</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="comment">// auto res = s.isRationalEqual(&quot;0.(52)&quot;, &quot;0.5(25)&quot;);</span></span><br><span class="line">    <span class="function">Fraction <span class="title">a</span><span class="params">(<span class="string">&quot;0.(52)&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.numerator &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; a.denominator &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Fraction <span class="title">b</span><span class="params">(<span class="string">&quot;0.5(25)&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; b.numerator &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; b.denominator &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Fraction <span class="title">c</span><span class="params">(<span class="string">&quot;0.52(52)&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; c.numerator &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; c.denominator &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，如果注意到对有理数的限制的话，还有更投机取巧的解法，具体可以参考<a href="https://leetcode.com/problems/equal-rational-numbers/discuss/214203/JavaC++Python-Easy-Cheat">han神的解答</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Each part consists only of digits.</span><br><span class="line">The &lt;IntegerPart&gt; will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.)</span><br><span class="line">1 &lt;= &lt;IntegerPart&gt;.length &lt;= 4</span><br><span class="line">0 &lt;= &lt;NonRepeatingPart&gt;.length &lt;= 4</span><br><span class="line">1 &lt;= &lt;RepeatingPart&gt;.length &lt;= 4</span><br></pre></td></tr></table></figure>

<p>我的代码很长。写的过程中，暴露出来对C++类的实现十分不熟悉。本来还想用运算符重载来着，后来发现自己并不会。<br>看来，我还需要把”C++ Primer”的其他部分也花时间读一下。毕竟</p>
<blockquote>
<p>工欲善其事，必先利其器.<br>– 《论语·卫灵公》</p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后附上我对“C++ Primer”的书评：</p>
<blockquote>
<p>C++入门的神书。从大一开始就被无数人推荐，然而一直懒于去看，天真地认为学校学的那些C++就够了。后来随着编程学习的继续深入，对C++的敬畏之心渐渐建立起来。原来自己一直用的C++根本就是假的，只是带类的C语言。尤其是学习cs107编程范式的时候，老师也一针见血地指出，大多数C++程序员都是这样的。听到后羞愧难当，把C++从简历里会的语言里都删去了。到了元旦假期，终于有勇气去重新入门C++了。直接上手英文版，以用C++刷LeetCode作为辅助，先看了前3章和9～12章（即基础部分、container 和 smart pointer）。看完之后真的是醍醐灌顶，后悔没有早点“学习”C++。由于本书面面俱到(实在太厚了），我短期内也没有计划全部看完。但是我认为，每读一章，都受益无穷。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 119</title>
    <url>/2019/01/13/LeetCode-weekly-contest-119/</url>
    <content><![CDATA[<p>这次contest做的比较惨，排名大致是1486 / 3845。出现的问题有：</p>
<ul>
<li>第二题，比较简单。由于是easy的题目，直接brute force了，结果TLE一次。之前由于粗心，for循环条件中的变量还写错了一次。导致2次罚时。</li>
<li>第三题，也不是很难，但最后并没有想到O(n)的解法。只想到了O(n ^ 2)的。想到了要算前缀和，也注意到了divisible这一关键词。但并没有联想到前缀和相等就可以这一关键点。</li>
<li>第四题，想到了dp。卡在了”找寻后面数组中刚刚大一点的数”这步，即没想到用<strong>TreeMap</strong>解决。归根结底是因为对基础的数据结构不熟悉。</li>
</ul>
<h2 id="973-K-Closest-Points-to-Origin"><a href="#973-K-Closest-Points-to-Origin" class="headerlink" title="973. K Closest Points to Origin"></a>973. K Closest Points to Origin</h2><p>直接用C++中的Map即可，用key进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; distance;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> point: points) &#123;</span><br><span class="line">            distance[point[<span class="number">0</span>]*point[<span class="number">0</span>] + point[<span class="number">1</span>]*point[<span class="number">1</span>]].<span class="built_in">push_back</span>(point);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; results;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> d: distance) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> point: d.second) &#123;</span><br><span class="line">                results.<span class="built_in">push_back</span>(point);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= K) &#123;</span><br><span class="line">                    <span class="keyword">return</span> results;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="976-Largest-Perimeter-Triangle"><a href="#976-Largest-Perimeter-Triangle" class="headerlink" title="976. Largest Perimeter Triangle"></a>976. Largest Perimeter Triangle</h2><p>只用找最大的3个可以组成三角形的数就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] + A[i+<span class="number">1</span>] &gt; A[i+<span class="number">2</span>]) &#123;</span><br><span class="line">                result = A[i] + A[i+<span class="number">1</span>] + A[i+<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="974-Subarray-Sums-Divisible-by-K"><a href="#974-Subarray-Sums-Divisible-by-K" class="headerlink" title="974. Subarray Sums Divisible by K"></a>974. Subarray Sums Divisible by K</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; prefix_sum;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        prefix_sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum = (sum + A[i] % K + K) % K;</span><br><span class="line">            result += prefix_sum[sum];</span><br><span class="line">            prefix_sum[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="975-Odd-Even-Jump"><a href="#975-Odd-Even-Jump" class="headerlink" title="975. Odd Even Jump"></a>975. Odd Even Jump</h2><p>C++中，map的默认实现就是Tree Map.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">oddEvenJumps</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">odd_reach</span><span class="params">(A.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">even_reach</span><span class="params">(A.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; treemap;</span><br><span class="line">        </span><br><span class="line">        odd_reach[A.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        even_reach[A.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        result++;</span><br><span class="line">        treemap[A[A.<span class="built_in">size</span>() - <span class="number">1</span>]] = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> larger = treemap.<span class="built_in">lower_bound</span>(A[i]);</span><br><span class="line">            <span class="keyword">auto</span> smaller = treemap.<span class="built_in">upper_bound</span>(A[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (larger != treemap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                odd_reach[i] = even_reach[larger-&gt;second];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (smaller != treemap.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                even_reach[i] = odd_reach[(--smaller)-&gt;second];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (odd_reach[i]) result++;</span><br><span class="line">            treemap[A[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 120</title>
    <url>/2019/01/20/LeetCode-weekly-contest-120/</url>
    <content><![CDATA[<p>本周和好友“女声男”同时参加weekly contest。有同学共同竞争还是挺有压力的。因为我练习算法题已经有半年时间了，他还是新手，如若最后还败北了，岂不丢人。不过结果还好，没有丢自己的人。我在离比赛结束还有10min时全部AC，而且所有题目都是一遍过，略胜一筹。不得不说，这次的题比往届简单不少，之前我的水平一直维持在只做出2道题目，ranking 800左右，而本次ranking 为 356 / 3870。从排名上看有所进步。</p>
<p>下面我分享一下四道题目的思路。</p>
<h2 id="977-Squares-of-a-Sorted-Array"><a href="#977-Squares-of-a-Sorted-Array" class="headerlink" title="977. Squares of a Sorted Array"></a>977. Squares of a Sorted Array</h2><p>给定一个数组，返回各个元素的平方数组，该数组是排好序的。直接brute force即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; square;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a: A) &#123;</span><br><span class="line">            square.<span class="built_in">push_back</span>(a * a);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(square.<span class="built_in">begin</span>(), square.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> square;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n log n)，因为有个排序。<br>空间复杂度：O(n)，因为要返回一个新的数组，除此之外，不实用额外空间。当然，你也可以使用传进来的数组所占的空间，更trick，但没有多大意义。</p>
<p>看过Solution后，惊奇地发现竟然还有种O(n)的解法。仔细一看，原来是自己没有注意到数组A本身是排好序的。问题可以转化为合并2个排好序的数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; square;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt; A.<span class="built_in">size</span>() &amp;&amp; A[j] &lt; <span class="number">0</span>; j++) ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i]*A[i] &lt; A[j]*A[j]) &#123;</span><br><span class="line">                square.<span class="built_in">push_back</span>(A[i]*A[i]);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                square.<span class="built_in">push_back</span>(A[j]*A[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            square.<span class="built_in">push_back</span>(A[i]*A[i]);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (j &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            square.<span class="built_in">push_back</span>(A[j]*A[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> square;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="978-Longest-Turbulent-Subarray"><a href="#978-Longest-Turbulent-Subarray" class="headerlink" title="978. Longest Turbulent Subarray"></a>978. Longest Turbulent Subarray</h2><p>给定一个数组，返回“升降子数组”的最大长度。所谓“升降子数组”，即 相邻2个元素对大小变化的符号相反，比如[1, 2, 1, 2, 1]。画在坐标图上就是波浪状。</p>
<p>思路：遍历一遍数组，如果新的元素对变化符号与前一个元素对变化符号相反，则 <code>当前升降子数组长度 += 1</code>; 否则，重置<code>当前升降子数组长度</code>为 2。遍历的同时根据 <code>当前升降子数组长度</code> 更新 <code>最长升降子数组长度</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 1 down, -1 up</span></span><br><span class="line">        <span class="keyword">int</span> last_state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current_length = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                state = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                state = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (state == -last_state &amp;&amp; state != <span class="number">0</span>) &#123;</span><br><span class="line">                current_length++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current_length = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max_length = <span class="built_in">max</span>(max_length, current_length);</span><br><span class="line">            </span><br><span class="line">            last_state = state;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度: O(n)，只需要遍历数组一遍；<br>空间复杂度: O(1), 只使用常数的额外空间。</p>
<h2 id="979-Distribute-Coins-in-Binary-Tree"><a href="#979-Distribute-Coins-in-Binary-Tree" class="headerlink" title="979. Distribute Coins in Binary Tree"></a>979. Distribute Coins in Binary Tree</h2><p>Intution: 遇到树的题目，最先先到的就是递归，dfs。无脑写dfs最难的地方在于确定参数和返回值，也就是明确子树与root之间的关系。在本题中，子树与root之间的关系就是，存在硬币的转移，从子树到root，或是从root到子树。所以只需要一个返回值，表示这一转移即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把多余的给parent，问parent要不够的, positive: surplus, negative: demand</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> surplus = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">recurse</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">recurse</span>(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        surplus = left + right + root-&gt;val - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        move += <span class="built_in">abs</span>(surplus);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> surplus;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">recurse</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> move;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n), n为node的数目。因为每个node都要没调用一次。<br>空间复杂度: 平均 O(log n), 即 树的深度。</p>
<h2 id="980-Unique-Paths-III"><a href="#980-Unique-Paths-III" class="headerlink" title="980. Unique Paths III"></a>980. Unique Paths III</h2><p>Intution: 寻找路径数目，最直接的brute force是直接dfs进行backtrack。由于题目规模比较小，<code>1 &lt;= grid.length * grid[0].length &lt;= 20</code>，所以还是可以AC的。激动人心的是在比赛结束前10min，AC掉这最后一道题目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visit, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;dfs: &quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> true_all = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> xi = <span class="number">0</span>; xi &lt; grid.<span class="built_in">size</span>(); xi++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> xj = <span class="number">0</span>; xj &lt; grid[xi].<span class="built_in">size</span>(); xj++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[xi][xj] == <span class="number">0</span> &amp;&amp; visit[xi][xj] == <span class="literal">false</span>) &#123;</span><br><span class="line">                        true_all = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">goto</span> end_of_outer_loop;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end_of_outer_loop:</span><br><span class="line">            <span class="keyword">if</span> (true_all) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;find a path!&quot; &lt;&lt; endl;</span></span><br><span class="line">                path++;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_i = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> new_j = j;</span><br><span class="line">            <span class="keyword">if</span> (visit[new_i][new_j] == <span class="literal">false</span> &amp;&amp; (grid[new_i][new_j] == <span class="number">0</span> || grid[new_i][new_j] == <span class="number">2</span>))</span><br><span class="line">                <span class="built_in">dfs</span>(grid, visit, new_i, new_j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_i = i;</span><br><span class="line">            <span class="keyword">int</span> new_j = j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (visit[new_i][new_j] == <span class="literal">false</span> &amp;&amp; (grid[new_i][new_j] == <span class="number">0</span> || grid[new_i][new_j] == <span class="number">2</span>))</span><br><span class="line">                <span class="built_in">dfs</span>(grid, visit, new_i, new_j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; grid.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_i = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> new_j = j;</span><br><span class="line">            <span class="keyword">if</span> (visit[new_i][new_j] == <span class="literal">false</span> &amp;&amp; (grid[new_i][new_j] == <span class="number">0</span> || grid[new_i][new_j] == <span class="number">2</span>))</span><br><span class="line">                <span class="built_in">dfs</span>(grid, visit, new_i, new_j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_i = i;</span><br><span class="line">            <span class="keyword">int</span> new_j = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (visit[new_i][new_j] == <span class="literal">false</span> &amp;&amp; (grid[new_i][new_j] == <span class="number">0</span> || grid[new_i][new_j] == <span class="number">2</span>))</span><br><span class="line">                <span class="built_in">dfs</span>(grid, visit, new_i, new_j);</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visit</span>(grid.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt; (grid[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> find_begin_square;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        find_begin_square:</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;begin : &quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, visit, i, j);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(4^n)，n为网格数，因为每次要向4个方向走，而且回溯必然是指数级的。<br>空间复杂度: O(n)，dfs的最深递归调用层数。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 121</title>
    <url>/2019/01/27/LeetCode-weekly-contest-121/</url>
    <content><![CDATA[<p>今天放假回家，下午3点半的火车。不过我还是百忙之中抽出时间参加了每周例行的weekly contest。 结果因为回家不够专注，效果很差，只做出一道签到题。第二题TLE(结果把一个变量改成引用就可以了，也算是吸取了教训，能用引用就用引用)，第3题没有足够的时间完成了(直到下午坐上火车，心无旁骛地终于独立完成了第三题。其实思路从一开始就是对的，只不过没有时间调试细节)。第四题干脆连题干都没有时间看完。</p>
<h2 id="984-String-Without-AAA-or-BBB"><a href="#984-String-Without-AAA-or-BBB" class="headerlink" title="984. String Without AAA or BBB"></a>984. String Without AAA or BBB</h2><p>Intution: 由于不能出现连续的a或b，我们可以试着直接构造出符合要求的字符串。多的字符出现2次，即插入一个少的字符，当剩余的2个字符一样多的时候，就一个出现一次就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">strWithout3a3b</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">char</span> large, small;</span><br><span class="line">        <span class="keyword">int</span> bigger, smaller;</span><br><span class="line">        <span class="keyword">if</span> (A &gt; B) &#123;</span><br><span class="line">            large = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            small = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            bigger = A;</span><br><span class="line">            smaller = B;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            small = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            bigger = B;</span><br><span class="line">            smaller = A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; bigger &gt; <span class="number">0</span> &amp;&amp; smaller &gt; <span class="number">0</span> &amp;&amp; bigger &gt; smaller; bigger-=<span class="number">2</span>, smaller--) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(large);</span><br><span class="line">            result.<span class="built_in">push_back</span>(large);</span><br><span class="line">            result.<span class="built_in">push_back</span>(small);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; bigger &gt; <span class="number">0</span> &amp;&amp; smaller &gt; <span class="number">0</span>; bigger--, smaller--) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(large);</span><br><span class="line">            result.<span class="built_in">push_back</span>(small);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (bigger &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(large);</span><br><span class="line">            bigger--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (smaller &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(small);</span><br><span class="line">            small--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="981-Time-Based-Key-Value-Store"><a href="#981-Time-Based-Key-Value-Store" class="headerlink" title="981. Time Based Key-Value Store"></a>981. Time Based Key-Value Store</h2><p>Intution:<br>使用hashmap存储&lt;key, vector&lt;pair&lt;int, string&gt;&gt; value&gt;,<br>每次查找到key对应的vector后，针对pair的第一个值使用二分查找upper_bound timestamp.</p>
<p>注意：用引用，千万不要用普通变量存储hashmap[key]。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** Intution:</span></span><br><span class="line"><span class="comment">        使用hashmap存储&lt;key, vector&lt;pair&lt;int, string&gt;&gt; value&gt;,</span></span><br><span class="line"><span class="comment">        每次查找到key对应的vector后，针对pair的第一个值使用二分查找upper_bound timestamp</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    unordered_map&lt;string, vector&lt;pair&lt;<span class="keyword">int</span>, string&gt;&gt;&gt; hashmap;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cmp</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="keyword">int</span>, string&gt; a, pair&lt;<span class="keyword">int</span>, string&gt; b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">TimeMap</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(string key, string value, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        hashmap[key].<span class="built_in">push_back</span>(&#123;timestamp, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(string key, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; values = hashmap[key];    <span class="comment">// 注意：用引用，千万不要用普通变量存储</span></span><br><span class="line">        <span class="keyword">if</span> (values.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">auto</span> val = <span class="built_in">upper_bound</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), <span class="built_in">make_pair</span>(timestamp, <span class="string">&quot;&quot;</span>), <span class="built_in">Cmp</span>());</span><br><span class="line">        <span class="keyword">if</span> (val == values.<span class="built_in">begin</span>()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (--val)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TimeMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TimeMap* obj = new TimeMap();</span></span><br><span class="line"><span class="comment"> * obj-&gt;set(key,value,timestamp);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;get(key,timestamp);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="983-Minimum-Cost-For-Tickets"><a href="#983-Minimum-Cost-For-Tickets" class="headerlink" title="983. Minimum Cost For Tickets"></a>983. Minimum Cost For Tickets</h2><p>Intution: 最优化问题，最优解依赖子问题的解，首先想到dp。<br>最优解结构：f(x) = min(f(x-1) + cost[0], f(x-7) + cost[1], f(x-30) + cost[2]),<br>其中，f(x)表示天数为x时的最小花费，由于x可能不存在于days中，此时，f(x)表示比x恰好大的天的最小花费。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; days, vector&lt;<span class="keyword">int</span>&gt;&amp; dp, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> result = <span class="built_in">upper_bound</span>(days.<span class="built_in">begin</span>(), days.<span class="built_in">end</span>(), day);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; day &lt;&lt; &quot; &quot; &lt;&lt; int(result - days.begin()) &lt;&lt; &quot; &quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (result == days.<span class="built_in">begin</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;return : &quot; &lt;&lt; *(result-1) &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;return : &quot; &lt;&lt; dp[0] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> dp[result - days.<span class="built_in">begin</span>() - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; days, vector&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(days.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; days.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> day = days[i];</span><br><span class="line">            dp[i] = <span class="built_in">getDp</span>(days, dp, day - <span class="number">1</span>) + costs[<span class="number">0</span>];</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="built_in">getDp</span>(days, dp, day - <span class="number">7</span>) + costs[<span class="number">1</span>]);</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], <span class="built_in">getDp</span>(days, dp, day - <span class="number">30</span>) + costs[<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;dp : &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[dp.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="983-Minimum-Cost-For-Tickets-1"><a href="#983-Minimum-Cost-For-Tickets-1" class="headerlink" title="983. Minimum Cost For Tickets"></a>983. Minimum Cost For Tickets</h2><p>暴力方法是3层循环枚举所有的组合，判断是否符合按位与为0的条件。时间复杂度: O(n^3)。<br>结果TLE。</p>
<p>可以想到的优化:</p>
<ol>
<li>先求出所有 A[i] &amp; A[j]的组合，再根据缺少的0位搜索构造出可能的A[k], 寻找A[k]是否存在。<br>时间复杂度：O(n^2 * 2^16)<br>结果TLE。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; hashtable, vector&lt;<span class="keyword">int</span>&gt;&amp; add, <span class="keyword">int</span> level, <span class="keyword">int</span> base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == add.<span class="built_in">size</span>()) <span class="keyword">return</span> hashtable[base];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(hashtable, add, level + <span class="number">1</span>, base) + <span class="built_in">search</span>(hashtable, add, level + <span class="number">1</span>, base + add[level]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getComplementCount</span><span class="params">(unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; hashtable, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; add;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!((a &gt;&gt; i) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 如果第i位为0</span></span><br><span class="line">                add.<span class="built_in">push_back</span>(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cout &lt;&lt; a &lt;&lt; &quot; : &quot;;</span></span><br><span class="line">        <span class="comment">// for (auto i: add) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(hashtable, add, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a: A) &#123;</span><br><span class="line">            hashtable[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a: A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b: A) &#123;</span><br><span class="line">                result += <span class="built_in">getComplementCount</span>(hashtable, a &amp; b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>每次寻找到可能的A[k]后保存起来，下次遇到相等的A[i] &amp; A[j]就可以直接用了。<br>时间复杂度：O(n^3)。<br>结果AC。因为A[i] &amp; A[j]重复的很多，所以实际运行时，比较接近 Omega(n^2)。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a: A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b: A) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a &amp; b;</span><br><span class="line">                <span class="keyword">if</span> (hashtable.<span class="built_in">find</span>(x) == hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> c: A) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((c &amp; x) == <span class="number">0</span>)</span><br><span class="line">                            hashtable[x]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                result += hashtable[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>结束该contest后的第二天，我在家里参加了Google的1st Phone Interview。由于保密协议的限制，并不能分享具体的题目。<br>只能再次分享一些面试的体会吧。面试题目整体不难，比较接近Medium。但45分钟要解决2道题目，从思考到讨论再到编码，而且电话面试的通话质量也很差，真的是很难的一件事情。最后结果第二题最后急匆匆写完了，也没有做到bug-free就匆忙结束了已经超时的面试。我现在在LeetCode上做算法题也有170道了，其中一半以上是Medium+难度的。但仍然不足以应对Google的面试。排除掉客观原因，我失败的主观原因有：</p>
<ul>
<li>解决问题和编码的速度不够快，没有形成基本的模式(也可以说是套路);</li>
<li>对面试的期待比较高，造成一定程度的紧张；</li>
<li>电话面试经验不足，更喜欢On site面试。</li>
</ul>
<p>我暂时想到的应对策略：</p>
<ul>
<li>以后每次做题都计时，量化 思考、编码、测试、debug的时间</li>
<li>总结算法题的类型和套路，每种套路的代码模版要非常熟练</li>
<li>以兴趣为导向（我喜欢读书），多读读和编程/算法/面试相关的书籍 充实自己</li>
<li>提高交流能力，多多练习，可以用语言、文字、图 清楚地表达自己的想法</li>
</ul>
<p>加油Forest！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 122</title>
    <url>/2019/02/04/LeetCode-weekly-contest-122/</url>
    <content><![CDATA[<p>由于宅在家里过节，竟然忘记了每天是星期几，只知道农历腊月几日。今天才发现已经到了周一了，错过了每周一度的weekly contest。在此除夕之夜，和家人一起看春晚之前，Forest携全家人一起祝大家新年快乐！快些刷完这4道比赛题目，好安心吃年夜饭。</p>
<p>由于比赛不能用官方的Notes, 写在blog上还是蛮方便的一种替代品。</p>
<h2 id="985-Sum-of-Even-Numbers-After-Queries"><a href="#985-Sum-of-Even-Numbers-After-Queries" class="headerlink" title="985. Sum of Even Numbers After Queries"></a>985. Sum of Even Numbers After Queries</h2><p>第一题直接模拟即可。每个query有2个动作：</p>
<ol>
<li>add <code>val</code> to <code>A[index]</code>;</li>
<li>sum the even values of A.</li>
</ol>
<p>模拟的时间复杂度为：<br>O(K * N)<br>其中，N为数组长度，K为queries长度。</p>
<p>因为题目中K，N都不大于10000，所以总的规模在10^8 &lt; 10^9, 是可以AC的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sumEvenAfterQueries</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; query : queries) &#123;</span><br><span class="line">            A[query[<span class="number">1</span>]] += query[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) total += a;</span><br><span class="line">            &#125;</span><br><span class="line">            results.<span class="built_in">push_back</span>(total);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不过<a href="https://leetcode.com/problems/sum-of-even-numbers-after-queries/solution/">Solution</a>中给到一种复杂度为O(N+K)的。<br>思想是：每次计算sum时，我们可以利用上一个query的结果。<br>如果add后，<br>A中数值从奇数变为偶数了，sum = last_sum + 新偶数；<br>if 偶数 -&gt; 奇数，sum = last_sum - 旧偶数;<br>if 偶数 -&gt; 偶数，sum = last_sum + 新偶数 - 旧偶数;<br>if 奇数 -&gt; 奇数，sum = last_sum.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sumEvenAfterQueries</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) total += a;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; query : queries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[query[<span class="number">1</span>]] % <span class="number">2</span> == <span class="number">0</span>) total -= A[query[<span class="number">1</span>]];</span><br><span class="line">            A[query[<span class="number">1</span>]] += query[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (A[query[<span class="number">1</span>]] % <span class="number">2</span> == <span class="number">0</span>) total += A[query[<span class="number">1</span>]];</span><br><span class="line">            results.<span class="built_in">push_back</span>(total);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="988-Smallest-String-Starting-From-Leaf"><a href="#988-Smallest-String-Starting-From-Leaf" class="headerlink" title="988. Smallest String Starting From Leaf"></a>988. Smallest String Starting From Leaf</h2><p>寻找二叉树中从叶子到根的最小字符串。<br>Intuition：递归左右子树，将根结点与更小的结合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestFromLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string left = <span class="built_in">smallestFromLeaf</span>(root-&gt;left);</span><br><span class="line">        string right = <span class="built_in">smallestFromLeaf</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (!left.<span class="built_in">empty</span>() &amp;&amp; !right.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                left.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + root-&gt;val);</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + root-&gt;val);</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!left.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            left.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="986-Interval-List-Intersections"><a href="#986-Interval-List-Intersections" class="headerlink" title="986. Interval List Intersections"></a>986. Interval List Intersections</h2><p>求2个有序区间列表的并集列表。</p>
<p>Intuition：2个指针遍历2个列表，根据不同重合程度，选择并集和指针移动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * struct Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;Interval&gt; <span class="title">intervalIntersection</span><span class="params">(vector&lt;Interval&gt;&amp; A, vector&lt;Interval&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        vector&lt;Interval&gt; results;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> a = A.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> b = B.<span class="built_in">begin</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (a != A.<span class="built_in">end</span>() &amp;&amp; b != B.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;end &lt; b-&gt;start) &#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;end &lt; a-&gt;start) &#123;</span><br><span class="line">                b++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;start &lt; b-&gt;start) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a-&gt;end &lt; b-&gt;end) &#123;</span><br><span class="line">                    Interval <span class="built_in">interval</span>(b-&gt;start, a-&gt;end);</span><br><span class="line">                    results.<span class="built_in">push_back</span>(interval);</span><br><span class="line">                    a++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    results.<span class="built_in">push_back</span>(*b);</span><br><span class="line">                    b++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;start &lt; a-&gt;start) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b-&gt;end &lt; a-&gt;end) &#123;</span><br><span class="line">                    Interval <span class="built_in">interval</span>(a-&gt;start, b-&gt;end);</span><br><span class="line">                    results.<span class="built_in">push_back</span>(interval);</span><br><span class="line">                    b++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    results.<span class="built_in">push_back</span>(*a);</span><br><span class="line">                    a++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a-&gt;end &lt;= b-&gt;end) &#123;</span><br><span class="line">                    Interval <span class="built_in">interval</span>(b-&gt;start, a-&gt;end);</span><br><span class="line">                    results.<span class="built_in">push_back</span>(interval);</span><br><span class="line">                    a++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Interval <span class="built_in">interval</span>(a-&gt;start, b-&gt;end);</span><br><span class="line">                    results.<span class="built_in">push_back</span>(interval);</span><br><span class="line">                    b++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;(&quot; &lt;&lt; a-&gt;start &lt;&lt; &quot;, &quot; &lt;&lt; a-&gt;end &lt;&lt; &quot;), &quot;;</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;(&quot; &lt;&lt; b-&gt;start &lt;&lt; &quot;, &quot; &lt;&lt; b-&gt;end &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="987-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#987-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="987. Vertical Order Traversal of a Binary Tree"></a>987. Vertical Order Traversal of a Binary Tree</h2><p>Intution: 建立一个dequeue&lt;treemap<int>&gt;, 对于每一颗子树，讲root插入当前的treemap中（使用treemap以保证同一X层内的顺序），同时递归调用左右子树，并更新当前的treemap。<br>最后再转化为vector&lt;vector<int>&gt;。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    deque&lt;multiset&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; results;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurse</span><span class="params">(TreeNode* root, deque&lt;multiset&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;::iterator current, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (current == results.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            multiset&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">            results.<span class="built_in">push_back</span>(s);</span><br><span class="line">            current = results.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current + <span class="number">1</span> == results.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            multiset&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">            results.<span class="built_in">push_front</span>(s);</span><br><span class="line">            current = results.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;<span class="built_in">insert</span>(&#123;level, root-&gt;val&#125;);</span><br><span class="line">        <span class="built_in">recurse</span>(root-&gt;left, current - <span class="number">1</span>, level + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">recurse</span>(root-&gt;right, current + <span class="number">1</span>, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">verticalTraversal</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">recurse</span>(root, results.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> multiset&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; s : results) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; num : s) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(num.second);</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>Google的电话面试的结果已经出来了。很遗憾Forest Fail掉了，没有进入下一轮面试。虽然是在情理之中的事情，但还是挺伤心的。比较了同行的实力后，我发现自己还是LeetCode刷的不够多。年初定目标竟然只定了300道，看现在程序员竞争的灿烈程度，300道估计是远远不够的。毕竟自己已经练习了有200道了，实习生的面试都应对不了。经过这次失败，我重新审视了自己的实力，决定将今年的刷题计划提高到900道，或者是把所有的可刷的题目都刷完。因为有Premium才能刷的题目，所以现在不知道能刷的有多少。把该刷的刷完，我也会买个大会员，进一步刷题的。</p>
<p>我告诉快手师兄C++是我的主语言，然后他问了我C++11的新特性“move的语义”是什么？然后我就gg了。自己对C++掌握的只是皮毛而已，还好意思说会C++。春节假期一定要把《C++ Primer》看完，否则节后都不好意思找快手师兄啦！</p>
<p>任重而道远啊！加油，Forest！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 123</title>
    <url>/2019/02/10/LeetCode-weekly-contest-123/</url>
    <content><![CDATA[<p>本次比赛是春节后的第一次。</p>
<ol start="989">
<li>Add to Array-Form of Integer</li>
</ol>
<p>思路：模拟笔算过程，一位一位地相加。（Solution中有个很形象的名字：Schoolbook Addition）<br>时间复杂度：O(max(N, M)), 其中N, M分别表示A，K的长度。<br>空间复杂度：O(M-N), 即deque所用的空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">addToArrayForm</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (K &gt; <span class="number">0</span> &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> last_digit = K % <span class="number">10</span>;</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">            A[index] += last_digit;</span><br><span class="line">            <span class="keyword">int</span> carry = A[index] / <span class="number">10</span>;</span><br><span class="line">            K += carry;</span><br><span class="line">            A[index] %= <span class="number">10</span>;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_front</span>(K % <span class="number">10</span>);</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        A.<span class="built_in">insert</span>(A.<span class="built_in">begin</span>(), result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="990-Satisfiability-of-Equality-Equations"><a href="#990-Satisfiability-of-Equality-Equations" class="headerlink" title="990. Satisfiability of Equality Equations"></a>990. Satisfiability of Equality Equations</h2><p>思路：使用并查集存储相等的关系，再遍历所有的不等关系是否在不同的集之间。</p>
<p>时间复杂度：O(N),<br>空间复杂度：O（N）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    array&lt;<span class="keyword">char</span>, 26&gt; parents;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union_variables</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a_parent = <span class="built_in">find_root</span>(a);</span><br><span class="line">        <span class="keyword">char</span> b_parent = <span class="built_in">find_root</span>(b);</span><br><span class="line">        parents[a_parent - <span class="string">&#x27;a&#x27;</span>] = b_parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">find_root</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parents[a - <span class="string">&#x27;a&#x27;</span>] != a)</span><br><span class="line">            a = parents[a - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            parents[i] = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(vector&lt;string&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> string &amp; s : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">union_variables</span>(s[<span class="number">0</span>], s[<span class="number">3</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> string &amp; s : equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">find_root</span>(s[<span class="number">0</span>]) == <span class="built_in">find_root</span>(s[<span class="number">3</span>]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="991-Broken-Calculator"><a href="#991-Broken-Calculator" class="headerlink" title="991. Broken Calculator"></a>991. Broken Calculator</h2><p>思路：一旦X大于Y，就只能通过减一的操作来达到Y。<br>如果X小于Y，则可以DOUBLE，也可以Decrement。<br>这时候如何选择呢？可以发现Double, Decrement, Decrement 和 Decrement, Double得到的结果相同。<br>这样，我们可以看出，<br>如果Y是奇数，则必须Double, Decrement才能得到。<br>如果Y是偶数，则必须Double才能得到(Decrement的操作次数更多)。</p>
<p>时间复杂度：O(log Y);<br>空间复杂度：O(log Y)，因为递归。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (X == Y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (X &gt; Y) <span class="keyword">return</span> X - Y;</span><br><span class="line">        <span class="keyword">if</span> (Y % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">brokenCalc</span>(X, Y + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">brokenCalc</span>(X, Y / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="992-Subarrays-with-K-Different-Integers"><a href="#992-Subarrays-with-K-Different-Integers" class="headerlink" title="992. Subarrays with K Different Integers"></a>992. Subarrays with K Different Integers</h2><p>最后留给最后一道题的时间是40min，争取把这道Hard题目解决。</p>
<p>思路：根据问题的时间复杂度O(n ^ 2)（我们至少需要遍历一遍所有的subarray）可知，解法的时间复杂度至少为O(n^2)。<br>用2层循环遍历所有的subarray, 如何快速地求出每个subarray的distinct number呢。<br>可以使用动态规划来缩减复杂度。<br>用每个子数组的distinct number, 我们用hashmap&lt;int, int&gt;存储，key表示distict number, value 表示该数的频数。<br>设f(i, j)为子数组[i, j]的distinct number对应的hashmap,<br>则f(i, j) =<br>f(i, j-1).insert(A[j])<br>or<br>f(i+1, j).delete(A[i])<br>new(A[i]), if i == j.<br>自底而上的构造hashmap的话，外层循环 new, 内层循环 delete。<br>结果TLE了。</p>
<p>想想有没有O(n log n)的解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; frequency; <span class="comment">// 如果没有delete的操作，使用unordered_set也是可以的</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; A.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    frequency.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                frequency.<span class="built_in">insert</span>(A[j]);</span><br><span class="line">                <span class="keyword">if</span> (K == frequency.<span class="built_in">size</span>()) result++;</span><br><span class="line">                <span class="keyword">if</span> (K &lt; frequency.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后还是没有想到进一步优化的算法。看了<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/solution/">Solution</a>，惊觉竟然有O(N)的解法。还是自己对subarray distinct number数量的性质的观察不够细致呀。</p>
<p>首先，固定右边界的话，对于2个subarray (i1, j), (i2, j), 其中i1 &lt; i2，则 f(i1, j) &lt;= f(i2, j)。<br>所以，对于每个右边界j，符合条件的subarray 的左边界在一定范围内，可以写作[left1, left2].</p>
<p>其次，我们增长右边界，如果distinct number的数量超过K了，我们需要增长left1, left2。也即left1, left2是随着右边界单调递增的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Window</span> &#123;</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            hashmap[value]++;</span><br><span class="line">            <span class="keyword">if</span> (hashmap[value] == <span class="number">1</span>) &#123;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            hashmap[value]--;</span><br><span class="line">            <span class="keyword">if</span> (hashmap[value] == <span class="number">0</span>) &#123;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Window w1, w2;</span><br><span class="line">        <span class="keyword">int</span> left1 = <span class="number">0</span>, left2 = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = A[right];</span><br><span class="line">            </span><br><span class="line">            w1.<span class="built_in">add</span>(value);</span><br><span class="line">            w2.<span class="built_in">add</span>(value);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (w1.size &gt; K) &#123;</span><br><span class="line">                w1.<span class="built_in">remove</span>(A[left1++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (w2.size &gt;= K) &#123;</span><br><span class="line">                w2.<span class="built_in">remove</span>(A[left2++]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            result += left2 - left1;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>今天是在家里呆的最后3天，果然寒假回家都虚度光阴了。还是呆在北京学校里，和志同道合的同学在一起，学习的劲头更高。竞争的压力也更大，怪不得大家都向往更好的环境，更优秀的朋友。</p>
<!-- 下学期开始，就要去商汤实习了。好好把握这样的机会吧。 -->
<p>加油，Forest！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 124</title>
    <url>/2019/02/17/LeetCode-weekly-contest-124/</url>
    <content><![CDATA[<p>今天是开工后第一次参加LeetCode weekly contest，共作出3道题目，排名为772 / 4174。看着每次排名从200+落到了700+，心情蛮失落的。我认为排名掉落的原因有：1. 排名为200是状态和运气都比较好的情况，之前大多数时候也是700左右。2. 第3题虽然为Hard，最后提交TLE了。但我认为如果再多给半个小时就可以AC了。之所以后面时间不够了，与第2、4题花了比较多时间调试直接相关。还是很多实现不够熟悉，比如bfs, backtracking，不能灵活地默写出来。甚至在做第4题的时候，还需要现场查C++的API，对语言的熟悉程度也不够。</p>
<h2 id="993-Cousins-in-Binary-Tree"><a href="#993-Cousins-in-Binary-Tree" class="headerlink" title="993. Cousins in Binary Tree"></a>993. Cousins in Binary Tree</h2><p>在一棵二叉树上找表兄弟。所谓“表兄弟”的定义为，2个节点在同一层，但父节点不同。</p>
<p>Intuition: 递归地找节点的父亲和层数，比较2个节点的父亲和层数是否相同。也即，dfs遍历2遍二叉树。</p>
<p>时间复杂度：O(N),<br>空间复杂度: 平均O(Log N)，最差O(N), 因为需要递归栈。</p>
<p>由于春节假期期间看了LeetCode上的递归专题<a href="https://leetcode.com/explore/learn/card/recursion-i/">Introduction to Algorithms - Recursion I</a>。10min搞定该签到题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// parent, depth</span></span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">findNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> value, <span class="keyword">int</span> parent, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;<span class="number">0</span>, depth + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == value) <span class="keyword">return</span> &#123;parent, depth + <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">findNode</span>(root-&gt;left, value, root-&gt;val, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">findNode</span>(root-&gt;right, value, root-&gt;val, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (left.first != <span class="number">0</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (right.first != <span class="number">0</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, depth + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> xNode = <span class="built_in">findNode</span>(root, x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> yNode = <span class="built_in">findNode</span>(root, y, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (xNode.first != yNode.first &amp;&amp; xNode.second == yNode.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="994-Rotting-Oranges"><a href="#994-Rotting-Oranges" class="headerlink" title="994. Rotting Oranges"></a>994. Rotting Oranges</h2><p>给定一个网格，每个格子有3种状态</p>
<ul>
<li>什么也没有</li>
<li>好橘子</li>
<li>坏橘子<br>每天坏橘子会将临近的好橘子变成坏橘子，求所有橘子变坏的天数。如果无穷大的话，返回-1.</li>
</ul>
<p>Intuition：</p>
<ol>
<li>从每个坏橘子开始做bfs，一次感染好橘子，并更新好橘子坏掉的天数。因为要计算好橘子距离坏橘子的最短距离，所以一定要用bfs。</li>
<li>检查所有好橘子坏掉的天数，如果有无穷大的橘子，返回-1.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;minDays, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        queue&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;i ,j, depth&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; current = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            i = get&lt;<span class="number">0</span>&gt;(current);</span><br><span class="line">            j = get&lt;<span class="number">1</span>&gt;(current);</span><br><span class="line">            depth = get&lt;<span class="number">2</span>&gt;(current);</span><br><span class="line">            </span><br><span class="line">            visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">            minDays[i][j] = <span class="built_in">min</span>(minDays[i][j], depth);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; di.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> new_i = i + di[k];</span><br><span class="line">                <span class="keyword">int</span> new_j = j + dj[k];</span><br><span class="line">                <span class="keyword">if</span> (new_i &lt; grid.<span class="built_in">size</span>() &amp;&amp; new_i &gt;= <span class="number">0</span> &amp;&amp; new_j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; new_j &gt;= <span class="number">0</span> &amp;&amp; grid[new_i][new_j] == <span class="number">1</span> &amp;&amp; visited[new_i][new_j] == <span class="literal">false</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;new_i, new_j, depth + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">minDays</span>(grid.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt; (grid[<span class="number">0</span>].<span class="built_in">size</span>(), numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>()));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">1</span>)</span><br><span class="line">                    minDays[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(grid.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt; (grid[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">                    <span class="built_in">bfs</span>(i, j, grid, visited, minDays, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                result = <span class="built_in">max</span>(result, minDays[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result == numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>() ? <span class="number">-1</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Solution中也是使用dfs的，不过trick的一点是，通过记录每个节点的深度，在搜索开始时把所有坏橘子加入队列，使得每个节点只需要遍历一遍。更清晰，时间复杂度也更低。比我写的代码要好。</p>
<h2 id="995-Minimum-Number-of-K-Consecutive-Bit-Flips"><a href="#995-Minimum-Number-of-K-Consecutive-Bit-Flips" class="headerlink" title="995. Minimum Number of K Consecutive Bit Flips"></a>995. Minimum Number of K Consecutive Bit Flips</h2><p>给定一个数组A，A中值包含0，1这两种状态。给定一个K，提供操作flip，可以将A中长度为K的子数组翻转。<br>求将A全部翻转为1所需的最小flip次数。<br>如果无法全部翻转为1，则返回-1.</p>
<p>Intution:<br>如果要最后都变为1，如果第一位是0的话，必须对从第一位开始的子数组从事flip操作。<br>这样想下去，必须从头依次翻转所有为0的子数组，如果最后K位中仍然有0，则无法全部翻转。<br>这其实是一种贪心(Greedy)的算法。</p>
<p>时间复杂度：O(N * K), 结果超时。<br>空间复杂度：O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K &gt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;flip A: &quot; &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A[i + j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        A[i + j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        A[i + j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实，仔细想想，我们并不需要实际进行翻转操作，只需要记录翻转的次数就可以了。所以时间上*K 其实不是必须的。<br>但是，不实际进行翻转的话，怎么确定一个位置上是0需要翻转，还是1需要翻转。<br>我们每次记录翻转的结束位置，在此之前的长度为K的子数组是经过flip的，2个flip操作还可以直接抵消。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">flip</span><span class="params">(A.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;   <span class="comment">// 初始情况，0该翻转</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            zero ^= flip[i];    <span class="comment">// 走出结束位置，回退翻转（相当于再次翻转）</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] == zero) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K &gt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                result++;</span><br><span class="line">                zero ^= <span class="number">1</span>;  <span class="comment">// 进入开始位置，进行翻转</span></span><br><span class="line">                <span class="keyword">if</span> (i + K &lt; A.<span class="built_in">size</span>())</span><br><span class="line">                    flip[i + K] ^= <span class="number">1</span>;   <span class="comment">// 标定结束位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="996-Number-of-Squareful-Arrays"><a href="#996-Number-of-Squareful-Arrays" class="headerlink" title="996. Number of Squareful Arrays"></a>996. Number of Squareful Arrays</h2><p>如果一个数组任意相邻的2个数的和是某个数的平方，则称这个数组为Squareful Array.<br>给定一个数组A，求出A的全排列数组中有多少Squareful Arrays。</p>
<p>Intution:<br>使用backtracking，剪枝的条件是最后相邻的2个数之和不是Perfect Square。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">      <span class="comment">// Find floating point value of  </span></span><br><span class="line">      <span class="comment">// square root of x. </span></span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">double</span> sr = <span class="built_in">sqrt</span>(x); </span><br><span class="line"></span><br><span class="line">      <span class="comment">// If square root is an integer </span></span><br><span class="line">      <span class="keyword">return</span> ((sr - <span class="built_in">floor</span>(sr)) == <span class="number">0</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; current, multiset&lt;<span class="keyword">int</span>&gt;&amp; condidates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = current.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (condidates.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = condidates.<span class="built_in">begin</span>(); i != condidates.<span class="built_in">end</span>();) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = *i;</span><br><span class="line">            <span class="keyword">int</span> sum_;</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum_ = current[n - <span class="number">1</span>] + c;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; sum_ &lt;&lt; &quot; &quot; &lt;&lt; isPerfectSquare((long double) sum_) &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isPerfectSquare</span>((<span class="keyword">long</span> <span class="keyword">double</span>) sum_)) &#123;</span><br><span class="line">                    current.<span class="built_in">push_back</span>(c);</span><br><span class="line">                    <span class="keyword">auto</span> it = condidates.<span class="built_in">find</span>(c);</span><br><span class="line">                    condidates.<span class="built_in">erase</span>(it);</span><br><span class="line">                    <span class="built_in">backtracking</span>(current, condidates);</span><br><span class="line">                    current.<span class="built_in">pop_back</span>();</span><br><span class="line">                    condidates.<span class="built_in">insert</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current.<span class="built_in">push_back</span>(c);</span><br><span class="line">                <span class="keyword">auto</span> it = condidates.<span class="built_in">find</span>(c);</span><br><span class="line">                condidates.<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="built_in">backtracking</span>(current, condidates);</span><br><span class="line">                current.<span class="built_in">pop_back</span>();</span><br><span class="line">                condidates.<span class="built_in">insert</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            i = condidates.<span class="built_in">upper_bound</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquarefulPerms</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// backtracking</span></span><br><span class="line">        <span class="comment">// 剪枝条件：相邻的pair和不是平方数</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; current;</span><br><span class="line">        multiset&lt;<span class="keyword">int</span>&gt; condidates;</span><br><span class="line">        condidates.<span class="built_in">insert</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(current, condidates);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><!-- 本周是在商汤实习的第一周。在商汤实习的强度很大，一天下来眼睛都疼的不行。以后需要注意调整节奏，注意劳逸结合。综合几段实习体验来讲，商汤的是最累的了，不过预期的收获也会比较大。商汤实习的好处有：
1. 北航的同学和学长多，技术交流氛围很融洽。很多次我遇到困难的时候，他们都跑来我的工位上帮我一起解决。我是一个脸皮比较薄的人，平时生怕被人看轻。但在这里，我渐渐学会了遇到问题就找同事，不要自己一个人死磕。这样工作和成长效率都会更高。
2. 离北航很近，在清华科技园。之前快手的同方科技园也很近，我可以每天骑车往返，遇到紧急情况还可以随时回学校。不过现在快手搬到西二旗了，要不然再去快手二进宫也是极好的。
3. 除了开发，还有一定的研究工作。这样实验室的研究可以与之结合，减轻负担。目前的研究方向在于 量化模型，我刚刚入门，以后可以投入更多的精力在上面。 -->

<p>我还没有重新进入学习状态，保持学习的习惯。重新进入一种上进的状态是很难的，我要学会珍惜再珍惜，一定不要再次回到安逸的状态。因为我知道，安逸的状态不好，重新进入上进的状态更难。<br>每天要有规律地学习和运动，完成新年目标和最初的梦想。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weeekly contest 125</title>
    <url>/2019/02/24/LeetCode-weekly-contest-125/</url>
    <content><![CDATA[<p>本周末真是忙炸，为自己的拖延和懒惰付出了代价。事情都堆在了一起，周日的deadline超级多。早上10点和老板开会，商量 怎么出本科计算机组成原理补考试题 的事儿。开完会回到实验室，contest已经开始了。在短暂犹豫是否按计划参加contest，还是先完成出补考题的任务后，我开始了本周的weekly contest。也算是自己这2个月来坚持的为数不多的事情，继续坚持下去对我来说不仅是提高算法能力的事情了，更是对掌控自己生活的信心的一种极大鼓舞。</p>
<span id="more"></span>

<p>本周的weekly contest相对还说比较简单，虽然迟到了10min，但仍然提前30min完成4道题目。尤其是第4题，虽然值8分，难度是hard，但也很快解出来了。我认为难度最多Medium。</p>
<p>结果：</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>284 / 4238</td>
<td>YoungForest</td>
<td>22</td>
<td>1:08:40</td>
<td>0:18:40</td>
<td>0:31:07  WA(1)</td>
<td>0:39:39</td>
<td>1:03:40</td>
</tr>
</tbody></table>
<h2 id="997-Find-the-Town-Judge"><a href="#997-Find-the-Town-Judge" class="headerlink" title="997. Find the Town Judge"></a>997. Find the Town Judge</h2><p>使用2个hashmap，分别记录每个person trust的人数和被多少人trust。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; vote;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; untrust;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt; &amp; p : trust) &#123;</span><br><span class="line">            vote[p[<span class="number">1</span>]]++;</span><br><span class="line">            untrust[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vote[i] == N - <span class="number">1</span> &amp;&amp; untrust[i] == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="999-Available-Captures-for-Rook"><a href="#999-Available-Captures-for-Rook" class="headerlink" title="999. Available Captures for Rook"></a>999. Available Captures for Rook</h2><p>完全符合Easy的难度，直接模拟rook(行为应该类似中国象棋里的 车)向4个方向一步一步走就可以了。<br>用discuss中的一个道友的话来说，就是 search and capture.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rock_i, rock_j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    rock_i = i;</span><br><span class="line">                    rock_j = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; di.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rock_i, j = rock_j; i &gt;= <span class="number">0</span> &amp;&amp; i &lt; board.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); i += di[k], j += dj[k]) &#123;</span><br><span class="line">                <span class="keyword">char</span> current = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="string">&#x27;R&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="998-Maximum-Binary-Tree-II"><a href="#998-Maximum-Binary-Tree-II" class="headerlink" title="998. Maximum Binary Tree II"></a>998. Maximum Binary Tree II</h2><p>本题的关键是<strong>理解所谓的Maximum Binary Tree是什么意思</strong>。<br>它本身的定义就是递归定义的，给定一个数组A，A中最大值为根节点，最大值左侧的子数组为左子树，右侧的子数组为右子树。</p>
<p>本题给定一个Maximun Binary Tree, 但不告诉你原数组是什么，再给一个数，求将此数追加到元素组后构造而成的Maximum Binary Tree。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">            TreeNode *append = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            append-&gt;left = root;</span><br><span class="line">            <span class="keyword">return</span> append;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoMaxTree</span>(root-&gt;right, val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1001-Grid-Illumination"><a href="#1001-Grid-Illumination" class="headerlink" title="1001. Grid Illumination"></a>1001. Grid Illumination</h2><p>哇！LeetCode的题号超过1000啦。虽然总的题目数还不足1k，但超过也是指日可待的事情。<br>算法题现在有949道，我只做了210道。加油啊，Forest!</p>
<p>本题的想法很直接，了解题意之后，直接搜索即可。问题的关键在于搜索的效率。<br>通过题目的数据规模:</p>
<blockquote>
<p>1 &lt;= N &lt;= 10^9</p>
<p>0 &lt;= lamps.length &lt;= 20000</p>
<p>0 &lt;= queries.length &lt;= 20000</p>
<p>lamps[i].length == queries[i].length == 2</p>
</blockquote>
<p>可知，搜索最好是用hashtable来实现，效率最高。然而，C++ 默认的pair不是hashable的，虽然可以通过自己实现hashable pair还进一步实现效率优化。但在这里我偷了个懒，直接用了<code>set</code>，而不是<code>unordered_set</code>。仍然AC啦。好开心，提前30min完成比赛，排名也再次进入前300了。再接再厉，保持排名在300以内。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">gridIllumination</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; lamps, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; lamps_on;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; lamps_x; <span class="comment">// x, count</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; lamps_y; <span class="comment">// y, count</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; lamps_x_sub_y; <span class="comment">// x - y, count</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; lamps_x_add_y; <span class="comment">// x + y, count</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;&amp; lamp : lamps) &#123;</span><br><span class="line">            lamps_on.<span class="built_in">insert</span>(&#123;lamp[<span class="number">0</span>], lamp[<span class="number">1</span>]&#125;);</span><br><span class="line">            lamps_x[lamp[<span class="number">0</span>]]++;</span><br><span class="line">            lamps_y[lamp[<span class="number">1</span>]]++;</span><br><span class="line">            lamps_x_sub_y[lamp[<span class="number">0</span>] - lamp[<span class="number">1</span>]]++;</span><br><span class="line">            lamps_x_add_y[lamp[<span class="number">0</span>] + lamp[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;&amp; q : queries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lamps_x[q[<span class="number">0</span>]] &gt; <span class="number">0</span> || lamps_y[q[<span class="number">1</span>]] &gt; <span class="number">0</span> || lamps_x_sub_y[q[<span class="number">0</span>] - q[<span class="number">1</span>]] &gt; <span class="number">0</span> || lamps_x_add_y[q[<span class="number">0</span>] + q[<span class="number">1</span>]] &gt; <span class="number">0</span>)</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : di) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j : dj) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = q[<span class="number">0</span>] + i;</span><br><span class="line">                    <span class="keyword">int</span> y = q[<span class="number">1</span>] + j;</span><br><span class="line">                    <span class="keyword">if</span> (lamps_on.<span class="built_in">find</span>(&#123;x, y&#125;) != lamps_on.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        lamps_on.<span class="built_in">erase</span>(&#123;x, y&#125;);</span><br><span class="line">                        lamps_x[x]--;</span><br><span class="line">                        lamps_y[y]--;</span><br><span class="line">                        lamps_x_sub_y[x - y]--;</span><br><span class="line">                        lamps_x_add_y[x + y]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(max(M log N, N log N)), N = lamps.size(), M = queries.size(). 如果使用hashable pair的话，复杂度可进一步降为O(max(N, M)).<br>空间复杂度：O(N)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 126</title>
    <url>/2019/03/03/LeetCode-weekly-contest-126/</url>
    <content><![CDATA[<p>今天试着边做题边录视频，由于场地的限制，无法用麦克风进行讲解，效果差强人意。虽然可以用文字注释进行一些弥补，但丧失了视频传播的最大优势。以后还是以博客为主，传播自己的思想吧。<br>尤其是本次只做出2道题目，后2道题目都有尝试，但均失败了。视频效果太差。本身大家如果在B站上看视频的话，都是为了看up主秀的。这次没秀起来，遭遇了滑铁卢，甚是尴尬。不过最后我还是打算把视频放上去。就是这么脸皮厚，不怕丢人，不怕以后被翻黑历史。</p>
<p>排名也直接飞到1500名开外，这周的ranking怕不是要跌。</p>
<p>结果：</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (9)</th>
</tr>
</thead>
<tbody><tr>
<td>1684 / 4564</td>
<td>YoungForest</td>
<td>8</td>
<td>0:38:19</td>
<td>0:16:17</td>
<td>0:33:19  WA(1)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1002-Find-Common-Characters"><a href="#1002-Find-Common-Characters" class="headerlink" title="1002. Find Common Characters"></a>1002. Find Common Characters</h2><p>因为录视频的时候把思路都写在开始部分了。就只分析一下复杂度吧。<br>Time complexity: O(N), N为A中所有字符串长度之和。<br>空间复杂度：O(1), 因为字符被限制在26个小写字母里，否则的话，是和字符数成正比的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">commonChars</span><span class="params">(vector&lt;string&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用一个vector记录出现的字母，因为只有小写，大小为26，还因为要记录出现的最小次数，所以类型为int即可</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">record</span><span class="params">(<span class="number">26</span>, numeric_limits&lt;<span class="keyword">int</span>&gt;::max())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (string &amp; s: A) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">record1String</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">                record1String[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                record[i] = <span class="built_in">min</span>(record[i], record1String[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            result.<span class="built_in">insert</span>(result.<span class="built_in">end</span>(), record[i], <span class="built_in">string</span>(<span class="number">1</span>, <span class="built_in"><span class="keyword">char</span></span>(i + <span class="string">&#x27;a&#x27;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1003-Check-If-Word-Is-Valid-After-Substitutions"><a href="#1003-Check-If-Word-Is-Valid-After-Substitutions" class="headerlink" title="1003. Check If Word Is Valid After Substitutions"></a>1003. Check If Word Is Valid After Substitutions</h2><p>Time complexity: O(N ^ 2), 因为find, 构造 nextS的操作是O(N)的，每次while循环S的长度减3, 需要 长度/3 次循环。<br>Space complexity: O(N), 因为构造了新的nextS。不过这个是可以消除的，反复利用原来的S的空间就可以。但是要写多余的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先理解valid string的定义:</span></span><br><span class="line">        <span class="comment">// 这个定义的递归的</span></span><br><span class="line">        <span class="comment">// 对于任何valid的string，把&quot;abc&quot;插入任何位置的字符串仍为valid</span></span><br><span class="line">        <span class="comment">// 初始的valid string只有&quot;abc&quot;</span></span><br><span class="line">        <span class="comment">// 所以，判断一个string是否是valid的，我们只需要不断地把&quot;abd&quot;抽掉，如果剩下&quot;abc&quot;，则true，否则false</span></span><br><span class="line">        <span class="comment">// 这个过程也可以递归进行</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归解法会stack overflow, 换迭代解法</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S == <span class="string">&quot;abc&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">auto</span> index = S.<span class="built_in">find</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == string::npos) &#123; <span class="comment">// 没找到&quot;abc&quot;字串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                string <span class="built_in">nextS</span>(S.<span class="built_in">begin</span>(), S.<span class="built_in">begin</span>() + index);</span><br><span class="line">                nextS.<span class="built_in">insert</span>(nextS.<span class="built_in">end</span>(), S.<span class="built_in">begin</span>() + index + <span class="number">3</span>, S.<span class="built_in">end</span>());</span><br><span class="line">                S = nextS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1004-Max-Consecutive-Ones-III"><a href="#1004-Max-Consecutive-Ones-III" class="headerlink" title="1004. Max Consecutive Ones III"></a>1004. Max Consecutive Ones III</h2><p>看了讨论区，才惊觉要用sliding window。其实，如果对此类问题比较熟悉的话，还是很直觉的想法。这道题也一针见血地指出了我知识的盲区。说实话，我对sliding window(或是 2 pointers)的题目还不足够熟悉。看到这道题，一直在尝试用dp和greedy做。花费很多时间，还没做出来，也不奇怪。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 知道用sliding window了，题目就很简单了。用指针left, right表示窗口的范围。如果right指向1的话，继续扩充，指向0的话，如果K还有剩余，则扩充。不能扩充的时候，收缩left。</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> remain = K;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; A.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[right] == <span class="number">1</span>) right++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (A[right] == <span class="number">0</span> &amp;&amp; remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                remain--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[left] == <span class="number">0</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                remain++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[left] == <span class="number">1</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n), 这也是sliding window的特点，只需要左右指针各走一遍就可以了。<br>空间复杂度: O(1).</p>
<p>同样是sliding window, 讨论区的lee215大佬的代码是这样的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; A.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[j] == <span class="number">0</span>) K--;</span><br><span class="line">        <span class="keyword">if</span> (K &lt; <span class="number">0</span> &amp;&amp; A[i++] == <span class="number">0</span>) K++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j - i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们要找最大的window，所以收缩窗口是没有必要的。所以大佬的代码如此简洁。</p>
<h2 id="1000-Minimum-Cost-to-Merge-Stones"><a href="#1000-Minimum-Cost-to-Merge-Stones" class="headerlink" title="1000. Minimum Cost to Merge Stones"></a>1000. Minimum Cost to Merge Stones</h2><p>LeetCode的第1k道题，果然好难。看别人的Discuss看了有1个小时才理解。<br>说实话，DP也是我的一个知识盲区，运气好能做出来，运气不好，就做不出来。就像 花花酱 所说，DP是那种你刷100道，遇到新的还是可能解不出来的类型。<br>因为Discuss太难理解了。所以我想自己理解后，博文也要写的尽可能详细才行。</p>
<p>DP问题有2个关键：</p>
<ol>
<li>最优解结构</li>
<li>重叠子问题</li>
</ol>
<p>设dp[i][j] 表示merge stone[i] ~ stone[j] 所需的最小cost。<br>这里的merge表示，把这些堆石头合并到小于K为止，此时即使想要继续merge也无能为力。可以确定的是，一旦<code>i</code>和<code>j</code>固定，merge完剩余的石头堆数是确定的，即为<code>(j - i + 1) % (k - 1)</code>。</p>
<p>此时，最优解结构为 $dp[i][j] = min(dp[i][mid] + dp[mid+1][j]) + (\sum_k^{i&lt;=k&lt;=j} stone[i] if (j - i) % (k - 1) == 0), for mid in range(i, j, k-1)$。<br><code>(j - i) % (k - 1) == 0</code>表示[i, j]的石头堆可以被merge成1，所以一定会执行合并操作，而且合并的花费为所有的石头数。而<code>mid</code>的步长为什么是<code>k</code>呢？因为只有这样dp[i][mid]剩余的石头堆数为1。</p>
<p>找到最优解结构后，下一步是确定如何bottom-to-top地计算dp[0][n-1]。<br>初始化，dp[i][i] = 0, 一堆石头是永远不需要merge的。<br>根据最优解结构，我们可以得到计算的顺序下图所示:<br>![](/images/leetcode1000 merge stone dp bottom to top computing order.png)</p>
<p>其中红线表示最外层循环，绿线表示内层循环，黄线表示最优解结构。·</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeStones</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> ((N - <span class="number">1</span>) % (K - <span class="number">1</span>) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(N)</span></span>;</span><br><span class="line">        prefix[<span class="number">0</span>] = stones[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != N; ++i) &#123;</span><br><span class="line">            prefix[i] = prefix[i<span class="number">-1</span>] + stones[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N, vector&lt;<span class="keyword">int</span>&gt;(N, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = K; m &lt;= N; m++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= N; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + m - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid = i; mid &lt; j; mid += K - <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][mid] + dp[mid+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((j - i) % (K - <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] += prefix[j] - (i == <span class="number">0</span> ? <span class="number">0</span> : prefix[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][N<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N^3 / K),<br>空间复杂度: O(N^2).</p>
<p>与该题相似的题目还有：<a href="https://leetcode.com/problems/burst-balloons/description/">312. Burst Balloons</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 127</title>
    <url>/2019/03/10/LeetCode-weekly-contest-127/</url>
    <content><![CDATA[<p>本周4道题目分数分别为4 4 5 6, 应该不是很难的，加油， Forest！</p>
<p>因为题目太简单，即使提前15min做完了，排名还是912 / 4712。这次比赛真的是简单，完全比拼的是写码的速度和熟练度。是否可以一次bug-free很重要。因为如果某个corner case错了，再去调试是很花时间的。我1，2题都是错了一次，耽误了很多时间。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>931 / 4059</td>
<td>YoungForest</td>
<td>19</td>
<td>1:24:03</td>
<td>0:24:49(1)</td>
<td>0:44:58(1)</td>
<td>1:05:12</td>
<td>1:14:03</td>
</tr>
</tbody></table>
<h2 id="1005-Maximize-Sum-Of-Array-After-K-Negations"><a href="#1005-Maximize-Sum-Of-Array-After-K-Negations" class="headerlink" title="1005. Maximize Sum Of Array After K Negations"></a>1005. Maximize Sum Of Array After K Negations</h2><p>常规签到题。</p>
<p>Intution:<br>有负数，先flip最小的负数;<br>没负数，有0。 flip 0;<br>只有正数，K为奇数，flip最小的正数;<br>…, K为偶数，不flip.</p>
<p>时间复杂度: O(N log N), 因为排序。<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() &amp;&amp; K &gt; <span class="number">0</span> &amp;&amp; A[i] &lt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            A[i] = -A[i];</span><br><span class="line">            K--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (K &gt; <span class="number">0</span> &amp;&amp; K % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; A[i<span class="number">-1</span>] &lt; A[i]) A[i<span class="number">-1</span>] = -A[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> A[i] = -A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="number">0</span>, plus&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我Wrong Answer了一次，因为flip最小的正数时，没有考虑原来是负数的更小的正数，也就是需要有<code>if (i &gt; 0 &amp;&amp; A[i-1] &lt; A[i]) A[i-1] = -A[i-1];</code>这行代码。</p>
<p>即使是签到题，在Discuss区果然还是发现了一些牛逼的代码。比如，O(N)的解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = A[high];</span><br><span class="line">        <span class="keyword">int</span> placement = low;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A[i], A[placement]);</span><br><span class="line">                placement++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(A[high], A[placement]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> placement;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            index = <span class="built_in">partition</span>(A, low, high);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; K - <span class="number">1</span>)  <span class="comment">// why not K? Think the case A.size() == K</span></span><br><span class="line">                low = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; K - <span class="number">1</span>)</span><br><span class="line">                high = index - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                A[i] = -A[i];</span><br><span class="line">                K--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="number">0</span>) - ((K%<span class="number">2</span>) == <span class="number">1</span> ? <span class="number">2</span> * *<span class="built_in">min_element</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>()) : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Time complexity: O(N) in average.<br>Space complexity: O(1).</p>
<p>如果想要worst case也是O(N)的话，可以用随机的partition.</p>
<h2 id="1006-Clumsy-Factorial"><a href="#1006-Clumsy-Factorial" class="headerlink" title="1006. Clumsy Factorial"></a>1006. Clumsy Factorial</h2><p>第一次提交由于考虑错了优先级，把‘-’的优先级降低了，写了一个智障的递归解法，结果负负得正显然不对。<br>Intution:<br>直接根据”Clumsy Factorial”的定义进行计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>*<span class="number">3</span> / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>*<span class="number">2</span> / <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> result = N * (N - <span class="number">1</span>) / (N - <span class="number">2</span>) + (N - <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">4</span>; i + <span class="number">4</span> &lt;= N; i+=<span class="number">4</span>) &#123;</span><br><span class="line">                result += - (N - i) * (N - i - <span class="number">1</span>) / (N - i - <span class="number">2</span>) + (N - i - <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (N - i == <span class="number">3</span>) result += <span class="number">-3</span>*<span class="number">2</span>/<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (N - i == <span class="number">2</span>) result += <span class="number">-2</span>*<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (N - i == <span class="number">1</span>) result += <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N),<br>空间复杂度：O(1).</p>
<p>Discuss区惊现数学优化的O(1)解法，不得不把<a href="https://leetcode.com/problems/clumsy-factorial/discuss/252279/You-never-think-of-this-amazing-O(1)-solution!!!">原地址</a>发出来。真的是太6了。</p>
<h2 id="1007-Minimum-Domino-Rotations-For-Equal-Row"><a href="#1007-Minimum-Domino-Rotations-For-Equal-Row" class="headerlink" title="1007. Minimum Domino Rotations For Equal Row"></a>1007. Minimum Domino Rotations For Equal Row</h2><p>Intution:<br>想让A或B整行相同，最后可能有12种情况，即 A 1，A 2， A 3, A 4, …, B 6。<br>过一遍dominoes，就能获得达到这12种情况需要的flip数目，用-1表示无法达到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDominoRotations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">states</span><span class="params">(<span class="number">12</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> == A[i] &amp;&amp; states[j] &gt;= <span class="number">0</span>)</span><br><span class="line">                    states[j] = states[j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span> == B[i] &amp;&amp; states[j] &gt;= <span class="number">0</span>)</span><br><span class="line">                    states[j] ++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    states[j] = <span class="number">-1</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> == B[i] &amp;&amp; states[j + <span class="number">6</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">                    states[j + <span class="number">6</span>] = states[j + <span class="number">6</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span> == A[i] &amp;&amp; states[j + <span class="number">6</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">                    states[j + <span class="number">6</span>] ++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    states[j + <span class="number">6</span>] = <span class="number">-1</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">12</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (states[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                result = result &gt;= <span class="number">0</span> ? <span class="built_in">min</span>(result, states[i]) : states[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal"></a>1008. Construct Binary Search Tree from Preorder Traversal</h2><p>Intution:<br>树的问题一般通过递归解决。此题的关键在于理解<strong>Binary Search Tree</strong>和<strong>Preorder Traversal</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (begin == end) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[begin]);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[begin]);</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span> (mid = begin + <span class="number">1</span>; mid &lt;= end &amp;&amp; preorder[mid] &lt; root-&gt;val; mid++);</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(preorder, begin + <span class="number">1</span>, mid - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(preorder, mid, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，是存在O(N)解法的，即，我们并不需要找到左右子树的分界点, 只需要不断地扩展树就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == preorder.<span class="built_in">size</span>() || preorder[i] &gt; bound) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[i++]);</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(preorder, root-&gt;val);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(preorder, bound);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(preorder, numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最近因为同时忙水科院的项目，在刷题方面有所放松。我需要检讨自己，重新认识一下现在的情况。如果去外企的话，真的, 刷题只是基本功。套用武侠小说的概念，“数据结构和算法是一个程序员的内功“。如果连这么简单的事情也坚持不了的话，人生大概率也就一事无成了。</p>
<p>计划：虽然每天晚上回来累成狗，还是要花出1个小时在刷题和计算机基础上，花出半个小时在跑步上，半个小时在英语上。我会在豆瓣上每天签到，希望各位监督。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 128</title>
    <url>/2019/03/17/LeetCode-weekly-contest-128/</url>
    <content><![CDATA[<p>前3道题比较顺利，30min内解决。最后一道hard题目，思路比较混乱，1个小时愣是没做出来。<br>Contest给我的感觉是，还是拼的熟练度。<br>因为第2、3题之前做过类似的，所以很快就做出来了。第2题甚至只用了2分钟!!!</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (2)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>348 / 5164</td>
<td>YoungForest</td>
<td>19</td>
<td>1:24:03</td>
<td>0:11:33(1)</td>
<td>0:13:42(1)</td>
<td>0:27:37</td>
<td>None</td>
</tr>
</tbody></table>
<h2 id="1012-Complement-of-Base-10-Integer"><a href="#1012-Complement-of-Base-10-Integer" class="headerlink" title="1012. Complement of Base 10 Integer"></a>1012. Complement of Base 10 Integer</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &gt; N) <span class="keyword">break</span>;</span><br><span class="line">            ret += ((N &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) ? (<span class="number">1</span> &lt;&lt; i) : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log N)，与数字的长度成正比。<br>空间复杂度: O(1).</p>
<p>由于没有注意corner case, <code>if (N == 0) return 1;</code>。wrong answer了一次。<br>我的方法是straight forward的，没有任何技巧和trick。因为是签到题嘛，而且时间复杂度足够了。<br>也有一些其他的思路：<br>比如找到最大的<code>X = 1111..11</code>使得<code>X &gt;= N</code>, <code>return X - N</code>或<code>return X^N</code>即可。</p>
<h2 id="1013-Pairs-of-Songs-With-Total-Durations-Divisible-by-60"><a href="#1013-Pairs-of-Songs-With-Total-Durations-Divisible-by-60" class="headerlink" title="1013. Pairs of Songs With Total Durations Divisible by 60"></a>1013. Pairs of Songs With Total Durations Divisible by 60</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">hashmap</span><span class="params">(<span class="number">60</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp; t : time) &#123;</span><br><span class="line">            ret += hashmap[(<span class="number">60</span> - t + <span class="number">60000</span>) % <span class="number">60</span>];</span><br><span class="line">            hashmap[t % <span class="number">60</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与著名的<code>two sum</code>思路一样，考察<code>hashmap</code>的使用。<br>为了将所有的值，包括负数，映射到60以内，我使用了<code>(60 - t + 60000) % 60</code>，其实更好的做法是<code>(60 - t % 60) % 60</code>。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="1014-Capacity-To-Ship-Packages-Within-D-Days"><a href="#1014-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="1014. Capacity To Ship Packages Within D Days"></a>1014. Capacity To Ship Packages Within D Days</h2><p>一道典型的二分题，周末帮二师兄做头条笔试题的时候也遇到了。思路很清晰，写起来也很熟练。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possible</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> capacity, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> day_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> weight_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; day_count &lt; D; day_count++) &#123;</span><br><span class="line">            <span class="keyword">int</span> hasLoadedWeight = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; weight_index &lt; weights.<span class="built_in">size</span>() &amp;&amp; hasLoadedWeight + weights[weight_index] &lt;= capacity; weight_index++) &#123;</span><br><span class="line">                hasLoadedWeight += weights[weight_index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> weight_index == weights.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// binary search，time complexity: 50000 * log(50000 * 500), Space: O(1)</span></span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">50000</span> * <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="comment">// loop invariant: possible(hi) == true</span></span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">possible</span>(weights, mid, D))</span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Time complexity: 50000 * log(50000 * 500)，<br>Space: O(1)</p>
<h2 id="1015-Numbers-With-1-Repeated-Digit"><a href="#1015-Numbers-With-1-Repeated-Digit" class="headerlink" title="1015. Numbers With 1 Repeated Digit"></a>1015. Numbers With 1 Repeated Digit</h2><p>花了一个小时，仍没有做出来。回头反思，正确的思路有：计算没有重复位的数的个数，将数集分为0、1～digit-1、digit。错误的想法有，没有使用permutation简化计算。对数字的模式分析的不够透彻，事实上只需要分为2类0~digit-1, digit即可。由于这些错误，虽然笔算可以算出数目，但代码实现过于复杂，长度也过长，很难直接写对。最后不得不放弃。</p>
<p>参考了<a href="https://leetcode.com/problems/numbers-with-1-repeated-digit/discuss/256725/JavaPython-Count-the-Number-Without-Repeated-Digit">lee215</a>和<a href="https://leetcode.com/problems/numbers-with-1-repeated-digit/discuss/256866/Python-O(logN)-solution-with-clear-explanation">heqingy</a>的解答。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">permutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ret *= m - i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDupDigitsAtMostN</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; digits;</span><br><span class="line">        <span class="comment">// transform N + 1 to list. Attention: have to be N + 1, not N</span></span><br><span class="line">        <span class="keyword">int</span> tmp = N + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digits.<span class="built_in">push_back</span>(tmp % <span class="number">10</span>);</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> len = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// the first digit is 0</span></span><br><span class="line">        <span class="comment">// take 3452 as an example</span></span><br><span class="line">        <span class="comment">// len = 4</span></span><br><span class="line">        <span class="comment">// compute ***, **, *</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            ret += <span class="number">9</span> * <span class="built_in">permutation</span>(len - i - <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the first digits is not 0</span></span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// if i == 2</span></span><br><span class="line">            <span class="comment">// compute 34**</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = ((i == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>); j &lt; digits[i]; j++) &#123;</span><br><span class="line">                <span class="comment">// if j == 2</span></span><br><span class="line">                <span class="comment">// compute 342*</span></span><br><span class="line">                <span class="keyword">if</span> (seen.<span class="built_in">find</span>(j) == seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    ret += <span class="built_in">permutation</span>(len - <span class="number">1</span> - i, <span class="number">10</span> - (i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// break if 344...</span></span><br><span class="line">            <span class="keyword">if</span> (seen.<span class="built_in">find</span>(digits[i]) != seen.<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            seen.<span class="built_in">insert</span>(digits[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> N - ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log n)，数字的长度。<br>空间复杂度: O(1).</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>现在刷了279道题了，但愿刷到后来可以达到，遇到题目就有思路，有思路就能默写下来，bug-free的境界吧。这种境界需要多少题目呢？600？900？<br>无论需要多少道题，都要做下去。<br>之前刷题一直有个误区，速度不够，每天腾出来专心做题的时间不多。只有速度快才能称之为刷不是。<br>再次明确自己的目标，用1年时间来准备面试需要的技能。数据结构与算法是其基础，剩下的语言、计算机组成、操作系统、设计模式、编译器、网络，也要慢慢补上来。明年这个时候就是真刀真枪地上战场的时候了。</p>
<p>加油，Forest!</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 129</title>
    <url>/2019/03/31/LeetCode-weekly-contest-129/</url>
    <content><![CDATA[<p>上周末由于准备 Google的kick start round A，放弃了一次LeetCode weekly contest。但当天晚上还是把LeetCode的题补完了。4题不简单，但经过思考还是独立做出来了。算是给被kick start难到自闭的我一个安慰吧。</p>
<h2 id="1020-Partition-Array-Into-Three-Parts-With-Equal-Sum"><a href="#1020-Partition-Array-Into-Three-Parts-With-Equal-Sum" class="headerlink" title="1020. Partition Array Into Three Parts With Equal Sum"></a>1020. Partition Array Into Three Parts With Equal Sum</h2><p>Intution:<br>One pass. Find the pivots which is 1/3 and 2/3.</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canThreePartsEqualSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum_all = <span class="built_in">accumulate</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum_all %<span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> sum_3 = sum_all / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> sum_prefix = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum_prefix == sum_3 &amp;&amp; sum_3 != sum_all)</span><br><span class="line">                sum_3 += sum_all / <span class="number">3</span>;</span><br><span class="line">            sum_prefix += A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_3 == sum_all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1022-Smallest-Integer-Divisible-by-K"><a href="#1022-Smallest-Integer-Divisible-by-K" class="headerlink" title="1022. Smallest Integer Divisible by K"></a>1022. Smallest Integer Divisible by K</h2><p>Intution:<br>模拟笔算过程。<br>如果个位数不为1， 3， 7，9的话，直接范围-1. 代表找不到符合条件的N。<br>之后用笔算的方法，一直凑最后一位为1，知道前面所有的位数也均为1.<br>因为一定有解，所以循环一定会结束。</p>
<p>时间复杂度: O(result.length),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">all11</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">10</span> != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestRepunitDivByK</span><span class="params">(<span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (K % <span class="number">10</span> != <span class="number">1</span> &amp;&amp; K % <span class="number">10</span> != <span class="number">3</span> &amp;&amp; K % <span class="number">10</span> != <span class="number">7</span> &amp;&amp; K % <span class="number">10</span> != <span class="number">9</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dictionary</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">gewei</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dictionary.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dictionary[i] = K * i;</span><br><span class="line">            gewei[K * i % <span class="number">10</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> remain = K;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">all11</span>(remain)) &#123;</span><br><span class="line">            <span class="keyword">int</span> last = remain % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> new_value = <span class="number">0</span>;</span><br><span class="line">            new_value = gewei[(<span class="number">11</span> - last) % <span class="number">10</span>] * K;</span><br><span class="line">            ret++;</span><br><span class="line">            remain = (new_value + remain) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain % <span class="number">10</span> != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            remain /= <span class="number">10</span>;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1021-Best-Sightseeing-Pair"><a href="#1021-Best-Sightseeing-Pair" class="headerlink" title="1021. Best Sightseeing Pair"></a>1021. Best Sightseeing Pair</h2><p>Intution:<br>动态规划。最有子结构为：<br>以第i个元素结尾的pair的最大分数 为 max(i与i-1组成pair, i与 i-1的pair 组成pair)。</p>
<p>时间复杂度: O(N), one pass.<br>空间复杂度: O(1). 虽然我下面代码的实现为O(N)，但因为dp过程只用到dp[i-1]，所以可以进一步优化到O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(A[i] + A[i - <span class="number">1</span>] - <span class="number">1</span>, dp[i - <span class="number">1</span>] - A[i - <span class="number">1</span>] + A[i] - <span class="number">1</span>);</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1023-Binary-String-With-Substrings-Representing-1-To-N"><a href="#1023-Binary-String-With-Substrings-Representing-1-To-N" class="headerlink" title="1023. Binary String With Substrings Representing 1 To N"></a>1023. Binary String With Substrings Representing 1 To N</h2><p>Intution:<br>先打表，再查表。</p>
<p>时间复杂度: O(max(S.length, N)),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">queryString</span><span class="params">(string S, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">contain</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = S[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            contain[value] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">1</span>; j &lt; <span class="number">31</span> &amp;&amp; i + j &lt; S.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                value = (value &lt;&lt; <span class="number">1</span>) + S[i + j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (value &lt;= N) contain[value] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!contain[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>Google kick start round A的题目还没有整理。3个小时的比赛事实上对于我来说只有2个小时。我做出了签到题，第二题的small test。最后一个小时实在是毫无头绪，自知再给我多少时间也不会有突破了，便直接放弃了。排名600. 好像是比赛系统的bug, 最后25min无法提交，否则我的排名还会掉。因为很多人会在比赛结束前夕提交一波代码的。</p>
<p>Kick start是1月一次的，我想下次round B也继续参加，继续受虐。据 唐老师 说，中国Google校招的话，只看round D E。自己还差的远呢！仍需继续刷题，另外补充竞赛的知识，CS的知识。即使最后进不了Google，找工作的结果也不会差。<br>加油，Forest！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 130</title>
    <url>/2019/03/31/LeetCode-weekly-contest-130/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (5)</th>
</tr>
</thead>
<tbody><tr>
<td>258 / 5236</td>
<td>YoungForest</td>
<td>19</td>
<td>0:57:19</td>
<td>0:06:23</td>
<td>0:25:41</td>
<td>0:36:25</td>
<td>0:52:19(1)</td>
</tr>
</tbody></table>
<p>本次contest比较简单，都是常规题。没有hard来区分水平，就看谁的实现的速度快了。50min内才能前200名。<br>第二题耽误了些时间，最后一题刚开始思路秀逗了，走了些弯路。</p>
<h2 id="1029-Binary-Prefix-Divisible-By-5"><a href="#1029-Binary-Prefix-Divisible-By-5" class="headerlink" title="1029. Binary Prefix Divisible By 5"></a>1029. Binary Prefix Divisible By 5</h2><p>Intution:<br>Stright forward. 循环移位，判断除5的余数。需要注意current要取模，因为A的长度会很大。<br>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">prefixesDivBy5</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">ret</span><span class="params">(A.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            current = (current &lt;&lt; <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">            current += A[i];</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || current == <span class="number">5</span>)</span><br><span class="line">                ret[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1028-Convert-to-Base-2"><a href="#1028-Convert-to-Base-2" class="headerlink" title="1028. Convert to Base -2"></a>1028. Convert to Base -2</h2><p>Intution:<br>类比2进制的解法。不断整除2.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">baseNeg2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        string ret_reverse;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 正</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ret_reverse.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    N /= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    N = (N + <span class="number">1</span>) / <span class="number">2</span>;    <span class="comment">// 此处要加一，因为最后一位的权重此时是-1. N下一步的迭代要把其补上</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret_reverse.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                N /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">reverse</span>(ret_reverse.<span class="built_in">begin</span>(), ret_reverse.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret_reverse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1030-Next-Greater-Node-In-Linked-List"><a href="#1030-Next-Greater-Node-In-Linked-List" class="headerlink" title="1030. Next Greater Node In Linked List"></a>1030. Next Greater Node In Linked List</h2><p>Intution:<br>单调栈。<br>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单调栈</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s; <span class="comment">// index, value</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; head-&gt;val &gt; s.<span class="built_in">top</span>().second) &#123;</span><br><span class="line">                <span class="keyword">auto</span> current = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                ret[current.first] = head-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            s.<span class="built_in">push</span>(&#123;index, head-&gt;val&#125;);</span><br><span class="line">            index++;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1031-Number-of-Enclaves"><a href="#1031-Number-of-Enclaves" class="headerlink" title="1031. Number of Enclaves"></a>1031. Number of Enclaves</h2><p>Intution:<br>DFS, 从边缘开始进行搜索。<br>时间复杂度: O(N^2),<br>空间复杂度: O(N^2).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i][j] == <span class="number">0</span> || A[i][j] == <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        A[i][j] = <span class="number">2</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; di &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_i = di[k] + i;</span><br><span class="line">            <span class="keyword">int</span> new_j = dj[k] + j;</span><br><span class="line">            <span class="keyword">if</span> (new_i &gt;= <span class="number">0</span> &amp;&amp; new_j &gt;= <span class="number">0</span> &amp;&amp; new_i &lt; A.<span class="built_in">size</span>() &amp;&amp; new_j &lt; A[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(A, new_i, new_j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(A, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(A, i, A[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = A[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(A, A.<span class="built_in">size</span>() - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(A, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>)</span><br><span class="line">                    ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在LeetCode上刷了有319 / 969题了，算是到达一定瓶颈了。我目前是按照通过率刷的，正常情况下，也代表着从易到难。容易的题已经做完了，之后的题目会越来越难。刚开始10min能写一道题，看到题就知道怎么做，现在需要半个小时，每道题还需要思考一段时间。<br>但这是好现象，只有做这种有一定难度，但又不超出自己能力范畴的题目，才能快速提高。</p>
<p>加油，Forest！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 131</title>
    <url>/2019/04/07/LeetCode-weekly-contest-131/</url>
    <content><![CDATA[<p>本次比赛的题号吓了我一跳. LeetCode也是任性，直接从5000+开始出题了。看来题量上涨的空间已经超乎我的想象了。</p>
<p>言归正传，本次contest也是以简单题拼速度为主。<br>| Rank |    Name |    Score |    Finish Time |     Q1 (4) |    Q2 (5) |    Q3 (5) |    Q4 (5)|<br>|–|–|–|–|–|–|–|–|<br>|323 / 4894|    YoungForest |    22 |     0:59:58     | 0:10:44 | 0:19:06(2) |    0:30:57 |0:49:58 |<br>也是大概需要50min内完成，才能进入200名内。</p>
<h2 id="1021-Remove-Outermost-Parentheses"><a href="#1021-Remove-Outermost-Parentheses" class="headerlink" title="1021. Remove Outermost Parentheses"></a>1021. Remove Outermost Parentheses</h2><p>Intution:<br>括号匹配的问题。利用栈的思维，设置一个flag表示是否是Outermost。利用状态机的思维构造返回的字符串。</p>
<p>时间复杂度: O(N)<br>空间复杂度: O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeOuterParentheses</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag != <span class="number">0</span>)</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(c);</span><br><span class="line">                flag++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag != <span class="number">1</span>)</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(c);</span><br><span class="line">                flag--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1022-Sum-of-Root-To-Leaf-Binary-Numbers"><a href="#1022-Sum-of-Root-To-Leaf-Binary-Numbers" class="headerlink" title="1022. Sum of Root To Leaf Binary Numbers"></a>1022. Sum of Root To Leaf Binary Numbers</h2><p>Intution:<br>recurse, 二进制表示的值用传值的方式进行传递。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current_value = (value &lt;&lt; <span class="number">1</span>) % mod + root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">dfs</span>(root-&gt;left, current_value);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">dfs</span>(root-&gt;right, current_value);</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            ret = (ret + current_value) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是取模的地方会有2个</p>
<ul>
<li>计算<code>current_value</code></li>
<li>累加<code>ret</code></li>
</ul>
<p>时间复杂度: O(N)，所有节点都要遍历一次。<br>空间复杂度: O(N)，树的深度，最差的情况是等于节点数。</p>
<h2 id="1023-Camelcase-Matching"><a href="#1023-Camelcase-Matching" class="headerlink" title="1023. Camelcase Matching"></a>1023. Camelcase Matching</h2><p>Intution:<br>直接比较即可。借鉴状态机的思想，不同条件下，执行的操作不同(<code>i</code>, <code>j</code>的变化)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">answer</span><span class="params">(<span class="keyword">const</span> string&amp; query, <span class="keyword">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pattern.<span class="built_in">size</span>() &amp;&amp; j &lt; query.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (query[j] == pattern[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">islower</span>(query[j])) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; query.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">islower</span>(query[j]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">camelMatch</span><span class="params">(vector&lt;string&gt;&amp; queries, string pattern)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> query : queries) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="built_in">answer</span>(query, pattern));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N * M), queries的长度，和每个query的长度。<br>空间复杂度: O(N).</p>
<h2 id="1024-Video-Stitching"><a href="#1024-Video-Stitching" class="headerlink" title="1024. Video Stitching"></a>1024. Video Stitching</h2><p>Intution:<br>贪心。每次添加的clip都使得拼接完的视频最长。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// greedy</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current_interval_right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;current_interval_right &lt; T;) &#123;</span><br><span class="line">            <span class="keyword">int</span> max_left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; clip : clips) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clip[<span class="number">0</span>] &lt;= current_interval_right)</span><br><span class="line">                    max_left = <span class="built_in">max</span>(clip[<span class="number">1</span>], max_left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current_interval_right == max_left) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current_interval_right = max_left;</span><br><span class="line">            ret ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N ^ 2).<br>空间复杂度: O(1).</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最近参加了微软的summer intern的笔试题，过了签到题，第3题有个case超时了。后来在网上查了后，才知道有种叫做order statistic tree的数据结构，可以实现O(log n)的rank、删除任意节点、删除头节点。<br>微软和Google的笔试题的难度都上升到ICPC(现在不能叫ACM了，因为ACM已经不赞助了。可能需要叫IBM-ICPC了。哈哈)了，LeetCode相比之下只能算是小弟弟。<br>暑假抽时间把之前买的 挑战程序设计竞赛 和 算法竞赛入门经典 钻研一下，一定帮助很大。<br>编程之美(甚至还是邹欣老师的亲笔签名版)到手也3年了，我竟然还没看完。</p>
<p>要说大学期间我最后悔的事情: 一是没有早点想清楚自己毕业要干什么；二是没有抱住tls的大腿入门ACM。</p>
<p>这周还干的一件挺有意义的事情是，报名参加Goolge的summer code。虽然入选的几率不大，但今年可以先试一试，为明年的在此申请做铺垫。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 132</title>
    <url>/2019/04/14/LeetCode-weekly-contest-132/</url>
    <content><![CDATA[<p>本次比赛不难，但代码实现起来不易。不容易一次写到bug-free。考察的是用编程语言处理复杂的逻辑，和各种意外情况。比如 第3题，当前一个dp为0时，长度应该更新为2，除此之外，dp+1。第四题，在各种情况下寻找分隔符时，没有找到，应该如何处理。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (5)</th>
</tr>
</thead>
<tbody><tr>
<td>388 / 4765</td>
<td>YoungForest</td>
<td>24</td>
<td>1:21:20</td>
<td>0:15:54</td>
<td>0:30:16</td>
<td>0:38:05</td>
<td>1:21:20</td>
</tr>
<tr>
<td>大概需要1个小时内做完，才能进入前200。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>第4题由于一些边界条件，我调试了不少时间。我分析花这么长时间的原因。还是写代码写的少，对变量更新的边界条件不敏感。比如string::find没有找到的时候，其他各个坐标该如何更新。我就是由于没找到的时候，返回了npos(-1), <code>current_find_index</code>此时应该等于<code>end</code>，而不是继续在-1上加分隔符的长度。</p>
<h2 id="1025-Divisor-Game"><a href="#1025-Divisor-Game" class="headerlink" title="1025. Divisor Game"></a>1025. Divisor Game</h2><p>一道找规律的题目。<br>Intution:<br>dp。 Solution(N) = true if any Solution(N’s divisor) is false, else false。<br>时间复杂度: O(N^2),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1, false</span></span><br><span class="line">        <span class="comment">// 2, 1 true</span></span><br><span class="line">        <span class="comment">// 3, false</span></span><br><span class="line">        <span class="comment">// 4, 1 true</span></span><br><span class="line">        <span class="comment">// 5, 1 false</span></span><br><span class="line">        <span class="comment">// 6. 3, true</span></span><br><span class="line">        <span class="comment">// 7, 1, false</span></span><br><span class="line">        <span class="comment">// 8, 1, true</span></span><br><span class="line">        <span class="comment">// 9, false</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1001</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span> &amp;&amp; dp[i - j] == <span class="literal">false</span>) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把1～9的结果输出之后发现了了不得的规律。试了一下，一行代码就搞定了。<br>用数学归纳法可以证明:<br>前提:<br>N 为奇数，false;<br>N 为偶数，true。</p>
<ol>
<li>如果N为偶数，取x=1，N-1为false。则N为True.</li>
<li>如果N为奇数，它所有的因子也必为奇数，即N-x一定为偶数，true. 则N为False。</li>
</ol>
<p>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1, false</span></span><br><span class="line">        <span class="comment">// 2, 1 true</span></span><br><span class="line">        <span class="comment">// 3, false</span></span><br><span class="line">        <span class="comment">// 4, 1 true</span></span><br><span class="line">        <span class="comment">// 5, 1 false</span></span><br><span class="line">        <span class="comment">// 6. 3, true</span></span><br><span class="line">        <span class="comment">// 7, 1, false</span></span><br><span class="line">        <span class="comment">// 8, 1, true</span></span><br><span class="line">        <span class="comment">// 9, false</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> != <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1026-Maximum-Difference-Between-Node-and-Ancestor"><a href="#1026-Maximum-Difference-Between-Node-and-Ancestor" class="headerlink" title="1026. Maximum Difference Between Node and Ancestor"></a>1026. Maximum Difference Between Node and Ancestor</h2><p>Intution:<br>递归。由于possible difference可能是<code>| root-&gt;val - 左子树中的最小值 |</code>或<code>| root-&gt;val - 左子树中的最大值 |</code>或 减去右子树中的最大最小值，或 左右子树中Maximun Difference中的较大者。<br>所以递归函数返回3个值，分别是Maximun Different, 树中最小值，树中最大值。</p>
<p>时间复杂度: O(N)，每个节点都会被递归调用一次。<br>空间复杂度: O(N)，树的高度，平均情况O(log N), 最差O(N)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// max_different, max, min</span></span><br><span class="line">    <span class="function">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">100001</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="built_in">max</span>(&#123;get&lt;<span class="number">0</span>&gt;(l), get&lt;<span class="number">0</span>&gt;(r), get&lt;<span class="number">1</span>&gt;(l) == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">abs</span>(root-&gt;val - get&lt;<span class="number">1</span>&gt;(l)), get&lt;<span class="number">1</span>&gt;(r) == <span class="number">-1</span> ? <span class="number">-1</span> : <span class="built_in">abs</span>(root-&gt;val - get&lt;<span class="number">1</span>&gt;(r)), get&lt;<span class="number">2</span>&gt;(l) == <span class="number">100001</span> ? <span class="number">-1</span> : <span class="built_in">abs</span>(root-&gt;val - get&lt;<span class="number">2</span>&gt;(l)), get&lt;<span class="number">2</span>&gt;(r) == <span class="number">100001</span> ? <span class="number">-1</span> : <span class="built_in">abs</span>(root-&gt;val - get&lt;<span class="number">2</span>&gt;(r))&#125;), </span><br><span class="line">            <span class="built_in">max</span>(&#123;root-&gt;val, get&lt;<span class="number">1</span>&gt;(l), get&lt;<span class="number">1</span>&gt;(r)&#125;), </span><br><span class="line">            <span class="built_in">min</span>(&#123;root-&gt;val, get&lt;<span class="number">2</span>&gt;(l), get&lt;<span class="number">2</span>&gt;(r)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> get&lt;<span class="number">0</span>&gt;(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1027-Longest-Arithmetic-Sequence"><a href="#1027-Longest-Arithmetic-Sequence" class="headerlink" title="1027. Longest Arithmetic Sequence"></a>1027. Longest Arithmetic Sequence</h2><p>Intution:<br>DP.<br>最优子结构，其中dp[a][b]表示，以坐标a结尾，且差值为b的子序列的长度。<br>dp[i][A[i] - A[j]] = dp[j][A[i] - A[j]] == 0 ? 2 : dp[j][A[i] - A[j]] + 1。</p>
<p>时间复杂度: O(N ^ 2 log N), 用unordered_map的话可以进一步降为O(N^2).<br>空间复杂度: O(N ^ 2). 最差情况下，两两差值均不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// n^2</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        vector&lt;map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(A.<span class="built_in">size</span>()); <span class="comment">// diff, length</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                dp[i][A[i] - A[j]] = dp[j][A[i] - A[j]] == <span class="number">0</span> ? <span class="number">2</span> : dp[j][A[i] - A[j]] + <span class="number">1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, dp[i][A[i] - A[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1028-Recover-a-Tree-From-Preorder-Traversal"><a href="#1028-Recover-a-Tree-From-Preorder-Traversal" class="headerlink" title="1028. Recover a Tree From Preorder Traversal"></a>1028. Recover a Tree From Preorder Traversal</h2><p>Intution:<br>递归构造Tree。难点在于字符串的处理，如何迅速并bug-free地实现。</p>
<p>时间复杂度：O(N * M), 每个节点最多遍历一次字符串；<br>空间复杂度：O(N), 需要存储最后的树，递归深度最多为N，递归函数本身内存消耗O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// [Begin, end)</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(string&amp; S, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; end &lt;&lt; &quot; &quot; &lt;&lt; depth &lt;&lt; endl;</span></span><br><span class="line">        <span class="function">string <span class="title">delimiter</span><span class="params">(depth + <span class="number">1</span>, <span class="string">&#x27;-&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> first_dash = S.<span class="built_in">find</span>(<span class="string">&#x27;-&#x27;</span>, begin);</span><br><span class="line">        <span class="keyword">int</span> val_end_index = <span class="built_in">min</span>(end, first_dash == string::npos ? numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>() : first_dash);</span><br><span class="line">        TreeNode* ret = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(S.<span class="built_in">substr</span>(begin, val_end_index - begin)));</span><br><span class="line">        <span class="comment">// 找到左右子树的分界点</span></span><br><span class="line">        <span class="keyword">int</span> left_begin = S.<span class="built_in">find</span>(delimiter, begin);</span><br><span class="line">        <span class="keyword">if</span> (left_begin == string::npos || left_begin &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> current_find_index = left_begin + delimiter.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;   &quot; &lt;&lt; current_find_index &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> left_end = S.<span class="built_in">find</span>(delimiter, current_find_index);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;   &quot; &lt;&lt; left_end &lt;&lt; endl;</span></span><br><span class="line">        current_find_index = (left_end == string::npos) ? end : left_end + delimiter.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;   &quot; &lt;&lt; current_find_index &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span> (left_end != string::npos &amp;&amp; left_end &lt; end &amp;&amp; S[current_find_index] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (S[current_find_index] == <span class="string">&#x27;-&#x27;</span>) ++current_find_index;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;   &quot; &lt;&lt; current_find_index &lt;&lt; endl;</span></span><br><span class="line">            left_end = S.<span class="built_in">find</span>(delimiter, current_find_index);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;   &quot; &lt;&lt; left_end &lt;&lt; endl;</span></span><br><span class="line">            current_find_index = (left_end == string::npos) ? end : left_end + delimiter.<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;   &quot; &lt;&lt; current_find_index &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret-&gt;left = <span class="built_in">dfs</span>(S, left_begin + delimiter.<span class="built_in">size</span>(), left_end &lt; end &amp;&amp; left_end != string::npos ? left_end : end, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> right_begin = current_find_index;</span><br><span class="line">        <span class="keyword">if</span> (right_begin &lt; end)</span><br><span class="line">            ret-&gt;right = <span class="built_in">dfs</span>(S, right_begin, end, depth + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(S, <span class="number">0</span>, S.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于自己的实现虽然想法简单，但实现不易，而且容易写错。我自己就调试了很长时间。<br>于是去评论区找到了更 优的方案，Iterative Stack.</p>
<p>时间复杂度: O(M), one pass.<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; S.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">0</span>, level = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; S.<span class="built_in">size</span>() &amp;&amp; S[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                ++level;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; S.<span class="built_in">size</span>() &amp;&amp; S[i] != <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                value = value * <span class="number">10</span> + S[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; level) &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(value);</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">empty</span>() &amp;&amp; !s.<span class="built_in">top</span>()-&gt;left) &#123;</span><br><span class="line">                s.<span class="built_in">top</span>()-&gt;left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s.<span class="built_in">top</span>()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* ret;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ret = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>每周在这里总结一下最近生活的进展吧。</p>
<ol>
<li>Google summer of code 的申请放弃了。理由是看了一些感兴趣的organization，发现proposal的要求很高。自己很多都达不到。另一方面，自己开源项目的经历确实不够。能拿出手的仅仅是去年在Apache/HAWQ上的一次Contribution。今年可以多参加一些开源活动，丰富简历。</li>
<li>微软的summer intern的笔试的后续结果还没有。Action Center的最新的更新还处于3月31号。</li>
</ol>
<p>最近在读Lippman的《Essential C++》，侯捷老师在翻译的序里有这么一段话，送给大家。</p>
<blockquote>
<p>有些人的学习，自练一身铜筋铁骨，可以在热带丛林中披襟斩棘，在莽莽草原中追奔逐北。有些人的学习，既未习惯大部头书，也未习惯严谨格调，更未习惯自修勤学，是温室里的一朵花，没有自强自立的本钱。</p>
</blockquote>
<p>不知道大家怎么样。我反思自己学习的过程，常常“趋利避害”，喜欢简单的皮毛，面对需要花费大量时间钻研的技术即浅尝辄止。而我也知道，作为一名“程序员”，真正拉开与别人距离的都是需要沉下心去钻研的。放眼其他领域，其实也是这样。由于大家都是理智的人，拥有惰性的人，简单的好事一定是趋之若鹜的，做的人多了，供需平衡一打破，门槛一定也日渐提高。<br>侯老师的话让我醍醐灌顶，自己也需每天反思自己的学习状态，即使纠正错误的思想和方法。这样才能走的更远，飞的更高。</p>
<!-- 3. 交换项目准备的材料还差成绩单，而研究生的成绩单开具需要导师的签字。一直没找到老板。
4. 商汤的实习一如既往的忙碌。学到的东西不少，但都是皮毛，没有深入的，不可替代的技术。还是自己的钻研程度不够吧。 -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 133</title>
    <url>/2019/04/21/LeetCode-weekly-contest-133/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (5)</th>
</tr>
</thead>
<tbody><tr>
<td>864 / 4860</td>
<td>YoungForest</td>
<td>14</td>
<td>1:10:35</td>
<td>0:42:32</td>
<td>0:54:38</td>
<td>1:10:35</td>
<td>null</td>
</tr>
</tbody></table>
<p>本周的题目相比前几周质量有了不少提升，水题减少，考察的算法知识也更多。即使是前2题是easy题，也考察了足够的编程能力。本次比赛由于一开始肚子疼耽误了半个小时，所以开始的比较晚。最后一题其实差一点是可以AC的。总的方向是对的，即使用<code>Trie</code>单词树。但最后10min时提交后，TLE，也没时间改了。单词树的构造方向走反了，对于匹配问题，我们可以从前向后，也可以从后向前。这道题从后向前不仅实现起来更简单，时间上也会更好些(即使最坏情况的时间复杂度是一样的)。</p>
<h2 id="1030-Matrix-Cells-in-Distance-Order"><a href="#1030-Matrix-Cells-in-Distance-Order" class="headerlink" title="1030. Matrix Cells in Distance Order"></a>1030. Matrix Cells in Distance Order</h2><p>Intuition:<br>根据距离对所有格子进行排序。<br>这里我是用了treemap，可以插入后保持有序。你也可以构造一个vector，然后再排序。<br>时间复杂度：O(R * C * log (R*C)).<br>空间复杂度：O(R * C).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">allCellsDistOrder</span>(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        multimap&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; distance;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">                distance.<span class="built_in">insert</span>(&#123;<span class="built_in">abs</span>(r0 - i) + <span class="built_in">abs</span>(c0 - j), &#123;i, j&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : distance) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt; &#123; item.second.first, item.second.second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>刚开始试图直接构造出结果，但发现不是很好写。果断放弃，不过还是耽误了些时间。<br>看了discuss后，发现主流的解法还是从构造出发的。不过用了标准的BFS，会好写的多。</p>
<h2 id="1029-Two-City-Scheduling"><a href="#1029-Two-City-Scheduling" class="headerlink" title="1029. Two City Scheduling"></a>1029. Two City Scheduling</h2><p>Intuition:<br>贪心。<br>因为每个人肯定要被派到一个城市，而且结果是求最小花费和。<br>所以以每个人的不同城市的花费之差为标准进行排序，前一半去A，后一半去B即可。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(costs.<span class="built_in">begin</span>(), costs.<span class="built_in">end</span>(), [](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; rhs) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs[<span class="number">1</span>] - lhs[<span class="number">0</span>] &gt; rhs[<span class="number">1</span>] - rhs[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> N = costs.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            ret += costs[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &lt; <span class="number">2</span>*N; ++i) &#123;</span><br><span class="line">            ret += costs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays"><a href="#1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays" class="headerlink" title="1031. Maximum Sum of Two Non-Overlapping Subarrays"></a>1031. Maximum Sum of Two Non-Overlapping Subarrays</h2><p>Intuition:<br>稍微有些暴力，计算所有长度L和M的子数组的和，然后挑出不重合的最大的一对。</p>
<p>时间复杂度: O(N ^ 2)<br>空间复杂度: O(N)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> L, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum_l</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sum_m</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> current_sum = <span class="built_in">accumulate</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">begin</span>() + L, <span class="number">0</span>);</span><br><span class="line">        sum_l.<span class="built_in">at</span>(<span class="number">0</span>) = current_sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            current_sum += A[i + L - <span class="number">1</span>] - A[i - <span class="number">1</span>];</span><br><span class="line">            sum_l.<span class="built_in">at</span>(i) = current_sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        current_sum = <span class="built_in">accumulate</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">begin</span>() + M, <span class="number">0</span>);</span><br><span class="line">        sum_m.<span class="built_in">at</span>(<span class="number">0</span>) = current_sum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - M; ++i) &#123;</span><br><span class="line">            current_sum += A[i + M - <span class="number">1</span>] - A[i - <span class="number">1</span>];</span><br><span class="line">            sum_m.<span class="built_in">at</span>(i) = current_sum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + L; j &lt;= n - M; ++j) &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, sum_l.<span class="built_in">at</span>(i) + sum_m.<span class="built_in">at</span>(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - M; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + M; j &lt;= n - L; ++j) &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, sum_m.<span class="built_in">at</span>(i) + sum_l.<span class="built_in">at</span>(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>One pass的解决方案，思想是 DP。<br>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> L, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            A[i] += A[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Lmax: 从头到当前位置再向前跳M个元素的子数组中，长度为L的子数组的最大和</span></span><br><span class="line">        <span class="comment">// Mmax: ... ... . .  .. . L ..   . . ..  . ..  .M.. ...</span></span><br><span class="line">        <span class="keyword">int</span> ret = A[L + M - <span class="number">1</span>], Lmax = A[L - <span class="number">1</span>], Mmax = A[M - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + M; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Lmax = <span class="built_in">max</span>(Lmax, A[i - M] - A[i - M - L]);</span><br><span class="line">            Mmax = <span class="built_in">max</span>(Mmax, A[i - L] - A[i - L - M]);</span><br><span class="line">            ret = <span class="built_in">max</span>(&#123;ret, A[i] - A[i - M] + Lmax, A[i] - A[i - L] + Mmax&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1032-Stream-of-Characters"><a href="#1032-Stream-of-Characters" class="headerlink" title="1032. Stream of Characters"></a>1032. Stream of Characters</h2><p>Intuition:<br>单词树可以很好的解决此类字符串匹配查询问题。<br>从后向前匹配，更符合直觉，时间上也会好一点，实现起来也更简单。</p>
<p>时间复杂度: 构造 O(words.length * word.length), 查询 O(word.length).<br>空间复杂度: 最差 O(words.length * word.length).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamChecker</span> &#123;</span></span><br><span class="line">    <span class="comment">// 单词树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">        vector&lt;shared_ptr&lt;Trie&gt;&gt; data = vector&lt;shared_ptr&lt;Trie&gt;&gt;(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    shared_ptr&lt;Trie&gt; root = make_shared&lt;Trie&gt;();</span><br><span class="line">    vector&lt;<span class="keyword">char</span>&gt; history;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StreamChecker</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            shared_ptr&lt;Trie&gt; t = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = word.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = word[i];</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;data[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">                    t-&gt;data[c - <span class="string">&#x27;a&#x27;</span>] = make_shared&lt;Trie&gt;();</span><br><span class="line">                t = t-&gt;data[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            t-&gt;value = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> letter)</span> </span>&#123;</span><br><span class="line">        history.<span class="built_in">push_back</span>(letter);</span><br><span class="line">        shared_ptr&lt;Trie&gt; current = root;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;value)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = history.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = history[i];</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;data[c - <span class="string">&#x27;a&#x27;</span>] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                current = current-&gt;data[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;value)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StreamChecker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StreamChecker* obj = new StreamChecker(words);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;query(letter);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>自从春节被快手师兄问C++新特性后，已经过去2个半月了。这期间，我看了《C++ Primer》，正在看《Effective Modern C++》，《C++ Concurrency in Action》。自信对新特性有了更多的了解，也在尝试更多地参与C++的项目，把C++当作自己的主语言来发展。希望在明年找工作的时候能有所核心竞争力。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 134</title>
    <url>/2019/04/28/LeetCode-weekly-contest-134/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (5)</th>
</tr>
</thead>
<tbody><tr>
<td>220 / 4136</td>
<td>YoungForest</td>
<td>17</td>
<td>1:45:10</td>
<td>0:14:52 (1)</td>
<td>0:33:50(1)</td>
<td>null</td>
<td>1:25:10 (2)</td>
</tr>
</tbody></table>
<p>本次比赛质量在上周的基础上继续提高。尤其是corner case，导致我有4次incorrect attempts, 也就是20min的罚时。不过我看leader board上，大家的战况也都差不多，错误尝试很多。<br>本次比赛的重点在于作出所有的题目。恰好需要4道题，才能进入前200. 因为第三题的思路问题，即使再给我半个小时，我也难以做出来。所以我输的还算心服口服。</p>
<h2 id="1033-Moving-Stones-Until-Consecutive"><a href="#1033-Moving-Stones-Until-Consecutive" class="headerlink" title="1033. Moving Stones Until Consecutive"></a>1033. Moving Stones Until Consecutive</h2><p>Intuition:<br>最小移动步数只有3种情况：<br>0: 3个坐标紧挨，<br>1: 2个紧挨 或 2个中间空一个<br>2: x, y y, z之间的间隔都大于1.<br>最大移动步数一定是 z - x - 2, 此时每次移动都只向中间移一步。</p>
<p>时间复杂度: O(1)<br>空间复杂度: O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">numMovesStones</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// greedy</span></span><br><span class="line">        <span class="keyword">int</span> minimum_moves = <span class="number">0</span>, maximum_moves;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">min</span>(&#123;a, b, c&#125;);</span><br><span class="line">        <span class="keyword">int</span> z = <span class="built_in">max</span>(&#123;a, b, c&#125;);</span><br><span class="line">        <span class="keyword">int</span> y = a + b + c - x - z;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (y - x == <span class="number">1</span> &amp;&amp; z - y == <span class="number">1</span>)</span><br><span class="line">            minimum_moves = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - x == <span class="number">1</span> || z - y == <span class="number">1</span> || y - x == <span class="number">2</span> || z - y == <span class="number">2</span>)</span><br><span class="line">            minimum_moves = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minimum_moves = <span class="number">2</span>;</span><br><span class="line">        maximum_moves = z - y - <span class="number">1</span> + y - x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;minimum_moves, maximum_moves&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1034-Coloring-A-Border"><a href="#1034-Coloring-A-Border" class="headerlink" title="1034. Coloring A Border"></a>1034. Coloring A Border</h2><p>Intuition:<br>dfs 染色。需要注意如何标注已经访问的节点，在这里我使用了负数来表示。<br>时间复杂度: O(n*m),<br>空间复杂度: O(1), in place.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">border</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> ni = r + di[k];</span><br><span class="line">            <span class="keyword">int</span> nj = c + dj[k];</span><br><span class="line">            <span class="keyword">if</span> (ni &lt; <span class="number">0</span> || ni &gt;= grid.<span class="built_in">size</span>() || nj &lt; <span class="number">0</span> || nj &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || <span class="built_in">abs</span>(grid[ni][nj]) != <span class="built_in">abs</span>(grid[r][c]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        grid[r][c] = -grid[r][c];</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> ni = r + di[k];</span><br><span class="line">            <span class="keyword">int</span> nj = c + dj[k];</span><br><span class="line">            <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; grid.<span class="built_in">size</span>() &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[ni][nj] == <span class="built_in">abs</span>(grid[r][c]))</span><br><span class="line">                <span class="built_in">dfs</span>(grid, ni, nj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">border</span>(grid, r, c))</span><br><span class="line">            grid[r][c] = -grid[r][c];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">colorBorder</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color) &#123;</span><br><span class="line">        <span class="comment">// dfs</span></span><br><span class="line">        <span class="keyword">if</span> (grid[r0][c0] == color) <span class="keyword">return</span> grid;</span><br><span class="line">        <span class="keyword">int</span> origin_color = grid[r0][c0];</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r0, c0);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : grid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; item : r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (item &lt; <span class="number">0</span>)</span><br><span class="line">                    item = color;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1035-Uncrossed-Lines"><a href="#1035-Uncrossed-Lines" class="headerlink" title="1035. Uncrossed Lines"></a>1035. Uncrossed Lines</h2><p>Intuition:<br>第一直觉是将题目转化成 二分图求最大独立集的问题。把所有的连线当作node，连线相交表示node之间的edge。在网上找了些求解二分图的算法，但都不简单，短时间内无法写出来。遂放弃了该题目，先把第四题做出来了。实际上，先去做第四题的策略是对的。事实证明，本题我的思路是走偏了。应该转化成LCS(largest common subsequence), 用dp解决。而且第四题分数更高，所以此次比赛排名反而考前。</p>
<p>LCS的dp实现起来也很简单。<br>时间复杂度: O(N<em>M).<br>空间复杂度: O(N</em>M).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>空间复杂度可以优化到N, 因为dp的子问题只用到了上一行和本行的解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = A.<span class="built_in">size</span>(), n = B.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = <span class="number">1</span> + dp[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1036-Escape-a-Large-Maze"><a href="#1036-Escape-a-Large-Maze" class="headerlink" title="1036. Escape a Large Maze"></a>1036. Escape a Large Maze</h2><p>Intuition:<br>dfs: O(n ^ 2) 10 ^ 12 TLE.<br>blocked.length 很小, 可以尝试从此做文章<br>blocked把整个区域可以划分为几个region，判断source和target是否同region即可.<br>由于blocked.length &lt;= 200, 可以算出最大的搜索空间为19900，当blocked cell与边界组成一个等腰直角三角形时。<br>不过<code>bound = 10000</code>时，dfs就stack overflow了。5000时，可以通过所有的测试点。<br>更好的实现是，使用迭代而不是递归，用栈实现dfs，或用队实现bfs都是不错的选择。</p>
<p>时间复杂度: O(blocked.length ^ 2).<br>空间复杂度: O(blocked.length ^ 2).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> bound = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> border = <span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">int</span> source_step = <span class="number">0</span>;</span><br><span class="line">    set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; source_seen, target_seen, block_set;</span><br><span class="line">    <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> target_step = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; seen, <span class="keyword">int</span>&amp; step, vector&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        seen.<span class="built_in">insert</span>(&#123;i, j&#125;);</span><br><span class="line">        ++step;</span><br><span class="line">        <span class="keyword">if</span> (i == target[<span class="number">0</span>] &amp;&amp; j == target[<span class="number">1</span>]) &#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step &gt; bound || find == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> ni = i + di[k];</span><br><span class="line">            <span class="keyword">int</span> nj = j + dj[k];</span><br><span class="line">            <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; border &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; border &amp;&amp; seen.<span class="built_in">find</span>(&#123;ni, nj&#125;) == seen.<span class="built_in">end</span>() &amp;&amp; block_set.<span class="built_in">find</span>(&#123;ni, nj&#125;) == block_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(seen, step, target, ni, nj);</span><br><span class="line">                <span class="keyword">if</span> (step &gt; bound || find == <span class="literal">true</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (step &gt; bound || find == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEscapePossible</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; blocked, vector&lt;<span class="keyword">int</span>&gt;&amp; source, vector&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; cell : blocked) &#123;</span><br><span class="line">            block_set.<span class="built_in">insert</span>(&#123;cell[<span class="number">0</span>], cell[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        find = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(source_seen, source_step, target, source[<span class="number">0</span>], source[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        find = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(target_seen, target_step, source, target[<span class="number">0</span>], target[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (find) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (target_step &gt; bound &amp;&amp; source_step &gt; bound)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 135</title>
    <url>/2019/05/05/LeetCode-weekly-contest-135/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (5)</th>
</tr>
</thead>
<tbody><tr>
<td>70 / 3635</td>
<td>YoungForest</td>
<td>15</td>
<td>1:34:07</td>
<td>0:07:28</td>
<td>0:16:45</td>
<td>null</td>
<td>1:29:07  (1)</td>
</tr>
</tbody></table>
<p>本周日是国内的工作日，参加LeetCode weekly contest的人直接少了1千，可见国内参与此比赛的热情。而且国人的实力一般也是排在世界前列的。所以我此次排名为70，首次进入前200，除了争分夺秒在结束前AC掉最后一题的功劳外，还有参赛大佬减少的原因。</p>
<h2 id="5051-Valid-Boomerang"><a href="#5051-Valid-Boomerang" class="headerlink" title="5051. Valid Boomerang"></a>5051. Valid Boomerang</h2><p>Intuition:<br>分为判断distinct和not in a straight line两部分。<br>3点共线可以用斜率直接判断。<br>时间复杂度: O(1)<br>空间复杂度: O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; x, vector&lt;<span class="keyword">int</span>&gt;&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>] == y[<span class="number">0</span>] &amp;&amp; x[<span class="number">1</span>] == y[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBoomerang</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">isSame</span>(points[<span class="number">0</span>], points[<span class="number">1</span>]) &amp;&amp; !<span class="built_in">isSame</span>(points[<span class="number">1</span>], points[<span class="number">2</span>]) &amp;&amp; !<span class="built_in">isSame</span>(points[<span class="number">2</span>], points[<span class="number">0</span>]) &amp;&amp; <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(points[<span class="number">2</span>][<span class="number">1</span>] - points[<span class="number">1</span>][<span class="number">1</span>]) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(points[<span class="number">2</span>][<span class="number">0</span>] - points[<span class="number">1</span>][<span class="number">0</span>]) != <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(points[<span class="number">1</span>][<span class="number">1</span>] - points[<span class="number">0</span>][<span class="number">1</span>]) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(points[<span class="number">1</span>][<span class="number">0</span>] - points[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>discuss内发现的技巧：</p>
<ol>
<li>可以直接用面积是否为0同时判断 distinct和贡献，面积的公式用叉乘计算。</li>
<li>判断斜率时，把除法转换成乘法会更好。此时也不需要提前判断distinct。</li>
</ol>
<p>我的解法会有除0的问题，<br>但仍然能通过<code>[[1,2],[1,1],[2,1]]</code>这样的测试用例。<br>仔细想想C++的浮点数除法，根据IEEE 754 标准，结果为+infinite。自然有不相等的结果。</p>
<h2 id="1038-Binary-Search-Tree-to-Greater-Sum-Tree"><a href="#1038-Binary-Search-Tree-to-Greater-Sum-Tree" class="headerlink" title="1038. Binary Search Tree to Greater Sum Tree"></a>1038. Binary Search Tree to Greater Sum Tree</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recurse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">recurse</span>(root-&gt;right);</span><br><span class="line">        current += root-&gt;val;</span><br><span class="line">        root-&gt;val = current;</span><br><span class="line">        <span class="built_in">recurse</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">recurse</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1039-Minimum-Score-Triangulation-of-Polygon"><a href="#1039-Minimum-Score-Triangulation-of-Polygon" class="headerlink" title="1039. Minimum Score Triangulation of Polygon"></a>1039. Minimum Score Triangulation of Polygon</h2><p><a href="https://leetcode.com/problems/minimum-score-triangulation-of-polygon/discuss/286705/JavaC++Python-DP">参考</a></p>
<p>Intuition:<br>DP.<br>对于一个n边形，可以有一条直线，将其分为k, n - k 边形。<br>这条直线肯定是三角形的一条边。<br>再枚举另一个点的位置，更新最小值。</p>
<p>时间复杂度：O(n ^ 3),<br>空间复杂度：O(n ^ 2)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span> (n, vector&lt;<span class="keyword">int</span>&gt; (n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">2</span>; d &lt; n; ++d) &#123; <span class="comment">// i, j 之间的距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + d&lt; n; ++i) &#123;   <span class="comment">// 直线的一端</span></span><br><span class="line">                <span class="keyword">int</span> j = i + d;  <span class="comment">// 直线的另一端</span></span><br><span class="line">                dp[i][j] = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123; <span class="comment">// 三角形的另一个顶点</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[k] * A[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1040-Moving-Stones-Until-Consecutive-II"><a href="#1040-Moving-Stones-Until-Consecutive-II" class="headerlink" title="1040. Moving Stones Until Consecutive II"></a>1040. Moving Stones Until Consecutive II</h2><p>时间复杂度: O(n long n), 因为有个排序。<br>空间复杂度: O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">numMovesStonesII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 贪心策略</span></span><br><span class="line">        <span class="comment">// 最小：尽可能地收缩，答案一定小于size，连续的size内有多少石头，答案即为size-这个数目</span></span><br><span class="line">        <span class="comment">// 特殊情况：这个区间涉及到头或尾，且补位的位置也是头尾，即 1 11这种情况，此时答案为2，而不是1</span></span><br><span class="line">        <span class="comment">// 最大：先排个序，最小的跳到最大的左面，或 最大的额跳到最小的右面，剩下的每次收缩1</span></span><br><span class="line">        <span class="built_in">sort</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> size = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minimum_moves = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stones[i] &gt;= stones[left] + size) &#123;</span><br><span class="line">                <span class="keyword">while</span> (stones[i] &gt;= stones[left] + size)</span><br><span class="line">                    ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            minimum_moves = <span class="built_in">max</span>(minimum_moves, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minimum_moves == size - <span class="number">1</span> &amp;&amp; (stones[<span class="number">1</span>] - stones[<span class="number">0</span>] != <span class="number">2</span> &amp;&amp; stones[size - <span class="number">1</span>] - stones[size - <span class="number">2</span>] != <span class="number">2</span>)) &#123;</span><br><span class="line">            minimum_moves = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minimum_moves = size - minimum_moves;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maximum_moves = <span class="number">0</span>;</span><br><span class="line">        maximum_moves = <span class="built_in">max</span>(stones[size - <span class="number">2</span>] - stones[<span class="number">0</span>], stones[size - <span class="number">1</span>] - stones[<span class="number">1</span>]) + <span class="number">1</span> - size + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;minimum_moves, maximum_moves&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 136</title>
    <url>/2019/05/12/LeetCode-weekly-contest-136/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>220 / 4109</td>
<td>YoungForest</td>
<td>15</td>
<td>0:59:43</td>
<td>0:17:07</td>
<td>0:29:36</td>
<td>0:54:43 (1)</td>
<td>null</td>
</tr>
</tbody></table>
<p>最近比赛的质量都还可以。即使是最简单的签到题，也是需要认真思考的。考察DP的题也是每次都有，DP算是那种你做很多，遇到新的题目还是可能写不出来的类型。<br>本次恢复了原先的水平，跌到了200+。<br>这次大概需要55分钟前3题，才能进入前200。我一是做题比较慢，二是 第3题DP有个下标问题搞错了，导致了一次罚时。所以遗憾地没有进入前200.</p>
<h2 id="1041-Robot-Bounded-In-Circle"><a href="#1041-Robot-Bounded-In-Circle" class="headerlink" title="1041. Robot Bounded In Circle"></a>1041. Robot Bounded In Circle</h2><p>Intuition:<br>执行instruction直到再此面朝北。因为只有4个方向，所以最多执行4次，也可能是2次或1次。<br>如果此时不在原点，则继续走下去一定越走越远。否则就是一个circle.<br>时间复杂度: O(instructions.length),<br>空间复杂度: O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Direction</span> &#123;</span></span><br><span class="line">        north,</span><br><span class="line">        south,</span><br><span class="line">        west,</span><br><span class="line">        east</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRobotBounded</span><span class="params">(string instructions)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只要执行完一次instructions, 面朝北，同时不在原点，就没有圈。否则有圈</span></span><br><span class="line">        Direction direction = Direction::north;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : instructions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in"><span class="keyword">switch</span></span> (direction) &#123;</span><br><span class="line">                        <span class="keyword">case</span> Direction::north:</span><br><span class="line">                            ++y;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> Direction::south:</span><br><span class="line">                            --y;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> Direction::west:</span><br><span class="line">                            --x;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> Direction::east:</span><br><span class="line">                            ++x;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in"><span class="keyword">switch</span></span> (direction) &#123;</span><br><span class="line">                        <span class="keyword">case</span> Direction::north:</span><br><span class="line">                            direction = Direction::west;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> Direction::south:</span><br><span class="line">                            direction = Direction::east;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> Direction::west:</span><br><span class="line">                            direction = Direction::south;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> Direction::east:</span><br><span class="line">                            direction = Direction::north;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in"><span class="keyword">switch</span></span> (direction) &#123;</span><br><span class="line">                        <span class="keyword">case</span> Direction::north:</span><br><span class="line">                            direction = Direction::east;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> Direction::south:</span><br><span class="line">                            direction = Direction::west;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> Direction::west:</span><br><span class="line">                            direction = Direction::north;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> Direction::east:</span><br><span class="line">                            direction = Direction::south;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(direction) &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (direction != Direction::north);</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1042-Flower-Planting-With-No-Adjacent"><a href="#1042-Flower-Planting-With-No-Adjacent" class="headerlink" title="1042. Flower Planting With No Adjacent"></a>1042. Flower Planting With No Adjacent</h2><p>Intuition:<br>染色问题。因为一定存在解，所以可以基于贪心的思路。每次取可取颜色中的任意一个。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).<br>有二维数组和2层循环，难道不是<code>N^2</code>嘛？事实上由于<code>出入度 &lt;= 3</code>, 颜色个数为4. 第二维的复杂度其实是个常数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">gardenNoAdj</span><span class="params">(<span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edges</span>(N + <span class="number">1</span>);</span><br><span class="line">        vector&lt;set&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">remain_color</span>(N + <span class="number">1</span>, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> path : paths) &#123;</span><br><span class="line">            edges[path[<span class="number">0</span>]].<span class="built_in">push_back</span>(path[<span class="number">1</span>]);</span><br><span class="line">            edges[path[<span class="number">1</span>]].<span class="built_in">push_back</span>(path[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain_color[i].<span class="built_in">begin</span>() != remain_color[i].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> color = *(remain_color[i].<span class="built_in">begin</span>());</span><br><span class="line">                ret[i - <span class="number">1</span>] = color;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> j : edges[i]) &#123;</span><br><span class="line">                    remain_color[j].<span class="built_in">erase</span>(color);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1043-Partition-Array-for-Maximum-Sum"><a href="#1043-Partition-Array-for-Maximum-Sum" class="headerlink" title="1043. Partition Array for Maximum Sum"></a>1043. Partition Array for Maximum Sum</h2><p>Intuition:<br>看到<code>Array</code> <code>Maximum</code>就可以想到动态规划了。<br>动态规划，就要寻找递归子结构和最优表达式。<br>回到本题，第i位的maxSumAfterPartitioning可以由前面的解得到。</p>
<p>时间复杂度：<code>O(A.size() * K)</code><br>空间复杂度：<code>O(A.size())</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        <span class="comment">// dp[i] 表示以第i个元素结尾的数组的结果，i已经被划分到前一个子数组</span></span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> max_value = A[i];</span><br><span class="line">            dp[i + <span class="number">1</span>] = max_value;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K &amp;&amp; i - j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">                max_value = <span class="built_in">max</span>(max_value, A[i - j]);</span><br><span class="line">                dp[i + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>], dp[i - j] + (j + <span class="number">1</span>) * max_value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; dp[i+1] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1044-Longest-Duplicate-Substring"><a href="#1044-Longest-Duplicate-Substring" class="headerlink" title="1044. Longest Duplicate Substring"></a>1044. Longest Duplicate Substring</h2><p>最后30min都在想本题，也尝试了明知会TLE的暴力解法。虽然心存侥幸，但果然超时了。<br>暴力解法的思路很简单，每次把字符串向右平移一位，然后找相同的子字符串。<br>时间复杂度: O(N ^ 2),<br>空间复杂度: O(1).<br>因为字符串的长度为<code>10^5</code>, <code>n^2</code>的算法一定超时。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDupSubstring</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暴力解法，n^2. 肯定会超时</span></span><br><span class="line">        <span class="keyword">int</span> global_max_begin = <span class="number">0</span>, global_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> shift = <span class="number">1</span>; shift &lt; S.<span class="built_in">size</span>(); ++shift) &#123;</span><br><span class="line">            <span class="keyword">int</span> max_begin = <span class="number">0</span>, max_ = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = shift; i &lt; S.<span class="built_in">size</span>() &amp;&amp; i + global_max &lt; S.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S[i] == S[i - shift]) &#123;</span><br><span class="line">                    ++max_;</span><br><span class="line">                    <span class="keyword">if</span> (max_ &gt; global_max) &#123;</span><br><span class="line">                        global_max = max_;</span><br><span class="line">                        global_max_begin = max_begin + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max_ = <span class="number">0</span>;</span><br><span class="line">                    max_begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> S.<span class="built_in">substr</span>(global_max_begin, global_max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实，这道题是经典题。什么是经典题呢？题目很明确，都是关键字，题面很短，没有一句废话。这类题目往往没有理解的困难和场景的包装，属于原始的题目。往往会就是会，不会就是不会。常常是之前做过就会，没做过就不会。</p>
<p>解法1: suffix array + LCP(longest common prefix of the suffixes ) array<br><a href="https://www.geeksforgeeks.org/%C2%AD%C2%ADkasais-algorithm-for-construction-of-lcp-array-from-suffix-array/">kasais-algorithm</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// Structure to store information of a suffix </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">suffix</span> </span></span><br><span class="line"><span class="class">    &#123;</span> </span><br><span class="line">        <span class="keyword">int</span> index; <span class="comment">// To store original index </span></span><br><span class="line">        array&lt;<span class="keyword">int</span>, 2&gt; rank; <span class="comment">// To store ranks and next rank pair </span></span><br><span class="line">    &#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// A comparison function used by sort() to compare two suffixes </span></span><br><span class="line">    <span class="comment">// Compares two pairs, returns 1 if first pair is smaller </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> suffix&amp; a, <span class="keyword">const</span> suffix&amp; b) -&gt; <span class="keyword">bool</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (a.rank[<span class="number">0</span>] == b.rank[<span class="number">0</span>])? a.rank[<span class="number">1</span>] &lt; b.rank[<span class="number">1</span>]: </span><br><span class="line">            a.rank[<span class="number">0</span>] &lt; b.rank[<span class="number">0</span>]; </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is the main function that takes a string &#x27;txt&#x27; of size n as an </span></span><br><span class="line">    <span class="comment">// argument, builds and return the suffix array for the given string </span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">buildSuffixArray</span><span class="params">(string txt)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> n = txt.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// A structure to store suffixes and their indexes </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">suffix</span> <span class="title">suffixes</span>[<span class="title">n</span>];</span> </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store suffixes and their indexes in an array of structures. </span></span><br><span class="line">        <span class="comment">// The structure is needed to sort the suffixes alphabatically </span></span><br><span class="line">        <span class="comment">// and maintain their old indexes while sorting </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            suffixes[i].index = i; </span><br><span class="line">            suffixes[i].rank[<span class="number">0</span>] = txt[i] - <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line">            suffixes[i].rank[<span class="number">1</span>] = ((i+<span class="number">1</span>) &lt; n)? (txt[i + <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>): <span class="number">-1</span>; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sort the suffixes using the comparison function </span></span><br><span class="line">        <span class="comment">// defined above. </span></span><br><span class="line">        <span class="built_in">sort</span>(suffixes, suffixes+n, cmp); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// At his point, all suffixes are sorted according to first </span></span><br><span class="line">        <span class="comment">// 2 characters. Let us sort suffixes according to first 4 </span></span><br><span class="line">        <span class="comment">// characters, then first 8 and so on </span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ind</span><span class="params">(n)</span></span>; <span class="comment">// This array is needed to get the index in suffixes[] </span></span><br><span class="line">        <span class="comment">// from original index. This mapping is needed to get </span></span><br><span class="line">        <span class="comment">// next suffix. </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">4</span>; k &lt; <span class="number">2</span>*n; k = k*<span class="number">2</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// Assigning rank and index values to first suffix </span></span><br><span class="line">            <span class="keyword">int</span> rank = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">int</span> prev_rank = suffixes[<span class="number">0</span>].rank[<span class="number">0</span>]; </span><br><span class="line">            suffixes[<span class="number">0</span>].rank[<span class="number">0</span>] = rank; </span><br><span class="line">            ind[suffixes[<span class="number">0</span>].index] = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Assigning rank to suffixes </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// If first rank and next ranks are same as that of previous </span></span><br><span class="line">                <span class="comment">// suffix in array, assign the same new rank to this suffix </span></span><br><span class="line">                <span class="keyword">if</span> (suffixes[i].rank[<span class="number">0</span>] == prev_rank &amp;&amp; </span><br><span class="line">                        suffixes[i].rank[<span class="number">1</span>] == suffixes[i<span class="number">-1</span>].rank[<span class="number">1</span>]) </span><br><span class="line">                &#123; </span><br><span class="line">                    prev_rank = suffixes[i].rank[<span class="number">0</span>]; </span><br><span class="line">                    suffixes[i].rank[<span class="number">0</span>] = rank; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// Otherwise increment rank and assign </span></span><br><span class="line">                &#123; </span><br><span class="line">                    prev_rank = suffixes[i].rank[<span class="number">0</span>]; </span><br><span class="line">                    suffixes[i].rank[<span class="number">0</span>] = ++rank; </span><br><span class="line">                &#125; </span><br><span class="line">                ind[suffixes[i].index] = i; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Assign next rank to every suffix </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">int</span> nextindex = suffixes[i].index + k/<span class="number">2</span>; </span><br><span class="line">                suffixes[i].rank[<span class="number">1</span>] = (nextindex &lt; n)? </span><br><span class="line">                                    suffixes[ind[nextindex]].rank[<span class="number">0</span>]: <span class="number">-1</span>; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sort the suffixes according to first k characters </span></span><br><span class="line">            <span class="built_in">sort</span>(suffixes, suffixes+n, cmp); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Store indexes of all sorted suffixes in the suffix array </span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;suffixArr; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            suffixArr.<span class="built_in">push_back</span>(suffixes[i].index); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the suffix array </span></span><br><span class="line">        <span class="keyword">return</span> suffixArr; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* To construct and return LCP */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kasai</span><span class="params">(string txt, vector&lt;<span class="keyword">int</span>&gt; suffixArr)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> n = suffixArr.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// To store LCP array </span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">lcp</span><span class="params">(n, <span class="number">0</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// An auxiliary array to store inverse of suffix array </span></span><br><span class="line">        <span class="comment">// elements. For example if suffixArr[0] is 5, the </span></span><br><span class="line">        <span class="comment">// invSuff[5] would store 0. This is used to get next </span></span><br><span class="line">        <span class="comment">// suffix string from suffix array. </span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">invSuff</span><span class="params">(n, <span class="number">0</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fill values in invSuff[] </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">            invSuff[suffixArr[i]] = i; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize length of previous LCP </span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process all suffixes one by one starting from </span></span><br><span class="line">        <span class="comment">// first suffix in txt[] </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">/* If the current suffix is at n-1, then we don’t </span></span><br><span class="line"><span class="comment">            have next substring to consider. So lcp is not </span></span><br><span class="line"><span class="comment">            defined for this substring, we put zero. */</span></span><br><span class="line">            <span class="keyword">if</span> (invSuff[i] == n<span class="number">-1</span>) </span><br><span class="line">            &#123; </span><br><span class="line">                k = <span class="number">0</span>; </span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* j contains index of the next substring to </span></span><br><span class="line"><span class="comment">            be considered to compare with the present </span></span><br><span class="line"><span class="comment">            substring, i.e., next string in suffix array */</span></span><br><span class="line">            <span class="keyword">int</span> j = suffixArr[invSuff[i]+<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Directly start matching from k&#x27;th index as </span></span><br><span class="line">            <span class="comment">// at-least k-1 characters will match </span></span><br><span class="line">            <span class="keyword">while</span> (i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; txt[i+k]==txt[j+k]) </span><br><span class="line">                k++; </span><br><span class="line"></span><br><span class="line">            lcp[invSuff[i]] = k; <span class="comment">// lcp for the present suffix. </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Deleting the starting character from the string. </span></span><br><span class="line">            <span class="keyword">if</span> (k&gt;<span class="number">0</span>) </span><br><span class="line">                k--; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the constructed lcp array </span></span><br><span class="line">        <span class="keyword">return</span> lcp; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDupSubstring</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> suffixArray = <span class="built_in">buildSuffixArray</span>(S);</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">kasai</span>(S, suffixArray);</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">max_element</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (*it == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> S.<span class="built_in">substr</span>(*(suffixArray.<span class="built_in">begin</span>() + <span class="built_in">distance</span>(ret.<span class="built_in">begin</span>(), it)), *it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: <code>O(N log N)</code>, <code>N = S.size()</code>.<br>空间复杂度: <code>O(N)</code>.</p>
<p>另一种解法，使用了经典的二分搜索。trick的地方在于判断是否子字符串之前见过，使用了26进制编码的hashtable。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    string ret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> prime = <span class="number">288230376151711717</span>; </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> string&amp; S, <span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[first + i] != S[second + i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>&gt; <span class="title">possible</span><span class="params">(<span class="keyword">const</span> string&amp; S, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if the duplicate substring the length of which is len exist</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int64_t</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; seen;</span><br><span class="line">        <span class="keyword">int64_t</span> hash_code = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int64_t</span> highest_weight = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            hash_code = (hash_code * <span class="number">26</span> + S[i] - <span class="string">&#x27;a&#x27;</span>) % prime;</span><br><span class="line">            highest_weight = (highest_weight * <span class="number">26</span>) % prime;</span><br><span class="line">        &#125;</span><br><span class="line">        seen[hash_code].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len &lt;= S.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            hash_code = (hash_code * <span class="number">26</span> + S[i + len - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>) % prime;</span><br><span class="line">            hash_code = (hash_code + prime - (S[i - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>)*highest_weight % prime) % prime;</span><br><span class="line">            <span class="keyword">if</span> (seen.<span class="built_in">find</span>(hash_code) != seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> begin_index : seen[hash_code]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">compare</span>(S, begin_index, i, len)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;<span class="literal">true</span>, i&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            seen[hash_code].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">false</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDupSubstring</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// true, true, true, ..., false</span></span><br><span class="line">        <span class="comment">// lo, ...,                     hi</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; mid &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">possible</span>(S, mid);</span><br><span class="line">            <span class="keyword">if</span> (r.first) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;</span></span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;</span></span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lo &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">possible</span>(S, lo - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; r.second &lt;&lt; &quot; &quot; &lt;&lt; lo - 1 &lt;&lt; &quot; &quot; &lt;&lt; S.size();</span></span><br><span class="line">        <span class="keyword">return</span> S.<span class="built_in">substr</span>(r.second, lo - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N), hashtable + return value.</p>
<p>第四题还是很难的。即使是我看discuss复现代码也用了半天时间。<br>kasai算法基本上是复制的，要自己写还是很难写对。<br>二分法，在26进制编码的时候踩了坑，忘记<code>字符 - &#39;a&#39;</code>了。之后又在二分搜索的不变式上花了不少时间。正如 编程珠玑 所说，只有10%的程序员可以将二分查找一次写对，坑太多。推荐个别人的<a href="https://www.zhihu.com/question/36132386/answer/530313852">教程</a>. 区间前闭后开，区间收缩时保持不变性，如何用<code>lower_bound</code>和<code>upper_bound</code>完成其他的二分任务，这些讲的都十分清楚。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 137</title>
    <url>/2019/05/19/LeetCode-weekly-contest-137/</url>
    <content><![CDATA[<p>本周的题目要比以往的难，也可以说恰好考到我的知识盲区，DP问题。老实的说，我对DP问题没有过深入的研究。这次DP题目尤其多，尤其是第4题，更是可以可以用经典的<strong>背包问题</strong>求解。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>576 / 4091</td>
<td>YoungForest</td>
<td>13</td>
<td>0:45:56</td>
<td>0:09:24</td>
<td>0:14:20</td>
<td>0:35:56  2</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1046-Last-Stone-Weight"><a href="#1046-Last-Stone-Weight" class="headerlink" title="1046. Last Stone Weight"></a>1046. Last Stone Weight</h2><p>Intuition：<br>本题解法不难。我首先想到了最暴力的模拟整个smash的过程的解法。因为是签到题，暴力解也够了。<br>时间复杂度: O(n^2 log n)<br>空间复杂度: O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟smash</span></span><br><span class="line">        <span class="comment">// sort</span></span><br><span class="line">        <span class="comment">// pick two heaviest</span></span><br><span class="line">        <span class="comment">// smash</span></span><br><span class="line">        <span class="comment">// n^2 log n</span></span><br><span class="line">        <span class="keyword">while</span> (stones.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">            stones[n - <span class="number">2</span>] = stones[n - <span class="number">1</span>] - stones[n - <span class="number">2</span>];</span><br><span class="line">            stones.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但事实上，同样是模拟smash的过程，找到最大的2个石头。我用的办法是sort，该操作的时间复杂度为<code>O(n log n)</code>. 大佬们就能想到优先队列(Priority Queue), 找石头的时间复杂度为<code>O(log n)</code>. 而且我的解法并没有专门处理<code>x == y</code>的情况，虽然不会出什么问题，但确实不符合模拟过程的初衷。</p>
<h3 id="Priority-queue-版本"><a href="#Priority-queue-版本" class="headerlink" title="Priority queue 版本"></a>Priority queue 版本</h3><p>时间复杂度：O(N log N)<br>空间复杂度: O(1)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="function">priority_queue&lt;<span class="keyword">int</span>&gt; <span class="title">pq</span><span class="params">(stones.begin(), stones.end())</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (y &gt; x)</span><br><span class="line">                pq.<span class="built_in">push</span>(y - x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">empty</span>() ? <span class="number">0</span> : pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="1047. Remove All Adjacent Duplicates In String"></a>1047. Remove All Adjacent Duplicates In String</h2><p>Intuition:<br>用栈来保存之前的数，依次读取下一个数，视条件进行remove操作。<br>时间复杂度: <code>O(N)</code>,<br>空间复杂度: <code>O(N)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.<span class="built_in">top</span>() == c) &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 stack 应该是该题的标准解法，大佬们也基本上都用的同样的方法。</p>
<h2 id="1048-Longest-String-Chain"><a href="#1048-Longest-String-Chain" class="headerlink" title="1048. Longest String Chain"></a>1048. Longest String Chain</h2><p>Intuition:<br>DP. 对于每个单词，遍历一遍比它短1的所有单词，更新成最大的dp+1。<br>时间复杂度: <code>O(N^2 * word.length)</code><br>空间复杂度: <code>O(N)</code>.<br>其中N为<code>words.length</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPredecessor</span><span class="params">(<span class="keyword">const</span> string&amp; last, <span class="keyword">const</span> string&amp; current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (last.<span class="built_in">size</span>() + <span class="number">1</span> != current.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last.<span class="built_in">size</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last[i] == current[i + flag]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">                ++flag;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;string, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : words) &#123;</span><br><span class="line">            dp[s.<span class="built_in">size</span>() - <span class="number">1</span>].<span class="built_in">push_back</span>(&#123;s, <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (const auto&amp; i : dp) &#123;</span></span><br><span class="line">        <span class="comment">//     for (const auto&amp; j : i) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; j.first &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> last_length = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; last_dp = dp[last_length];</span><br><span class="line">            <span class="keyword">auto</span>&amp; current_dp = dp[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; current : current_dp) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; last : last_dp) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isPredecessor</span>(last.first, current.first)) &#123;</span><br><span class="line">                        current.second = <span class="built_in">max</span>(current.second, last.second + <span class="number">1</span>);</span><br><span class="line">                        ret = <span class="built_in">max</span>(ret, current.second);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (const auto&amp; i : dp) &#123;</span></span><br><span class="line">        <span class="comment">//     for (const auto&amp; j : i) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; &quot;(&quot; &lt;&lt; j.first &lt;&lt; &quot; &quot; &lt;&lt; j.second &lt;&lt; &quot;), &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Discuss总结：大概只有2种方法，DP(bottom-top)和DFS。DFS的复杂度会更高些，需要用memoization，其实也就是top-bottom的DP。</p>
<h2 id="1049-Last-Stone-Weight-II"><a href="#1049-Last-Stone-Weight-II" class="headerlink" title="1049. Last Stone Weight II"></a>1049. Last Stone Weight II</h2><p>Intuition:<br>backtracking.<br>时间复杂度：O(N!), N = 30. 所以肯定会超时。</p>
<p>另外，我还尝试了Greedy的方法。<br>但并没有找到正确的解并证明它，试了2次，都Wrong Answer了。</p>
<p><strong>正确的思路</strong>：<br>考虑一个smash剩下的石头<code>y - x</code>，再次被smash，则有剩下的石头<code>z - (y - x) = z - y + x</code>。<br>任何一个初始的石头，如果被smash的次数是奇数，则前面是 负号，反之，正号。<br>所以，原始问题可以转化为 将所有石头分成2份，求2份石头差的绝对值的最小值。<br>该问题是经典的背包问题之一“minimum knapsack partition”。</p>
<h3 id="Solution-DP-for-classic-knapsack-problem"><a href="#Solution-DP-for-classic-knapsack-problem" class="headerlink" title="Solution: DP for classic knapsack problem"></a>Solution: DP for classic knapsack problem</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> sum_bound = <span class="number">1500</span>;</span><br><span class="line">        bitset&lt;1500 + 1&gt; dp &#123;<span class="number">1</span>&#125;; <span class="comment">// present whether the sum of group is i is possible; initial true when i == 0  </span></span><br><span class="line">        <span class="keyword">int</span> sumOfStones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> stone : stones) &#123;</span><br><span class="line">            sumOfStones += stone;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = sum_bound; i &gt;= stone; --i) &#123;  <span class="comment">// reverse traversal is needed, for a stone can be used only once</span></span><br><span class="line">                dp[i] = dp[i] + dp[i - stone];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sum_bound; ++i) &#123;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, <span class="built_in">abs</span>(sumOfStones - dp[i]*i*<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(sum_bound * stones.size())<br>空间复杂度: O(sum_bound)</p>
<p>C++ 中 Bitset 是内含bit 或 Boolean值且大小固定的array。对其不熟悉的同学，可以看看<a href="https://book.douban.com/subject/26419721/">《C++ 标准库 第二版》（C++ Standard library)</a>这本书。我最近也在看，目的是熟悉一下C++的标准库，学习其中的智慧和用法。<br>除了使用Bitset外，直接使用set</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>周五剁手买了一年的LeetCode Premium, 花了159刀，大概1000元RMB。<br>刷题走起！！！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly conteset 138</title>
    <url>/2019/05/26/LeetCode-weekly-contest-138/</url>
    <content><![CDATA[<p>本周比赛虽然题目质量还不错，但难度不高，是一场比拼速度的题目。<br>因为第二题题目比较长，所以我做题的顺序是 1-&gt;3-&gt;4-&gt;2。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>247 / 4143</td>
<td>YoungForest</td>
<td>20</td>
<td>0:57:43</td>
<td>0:11:19</td>
<td>0:52:43 (1)</td>
<td>0:27:35</td>
<td>0:36:44</td>
</tr>
</tbody></table>
<h2 id="1051-Height-Checker"><a href="#1051-Height-Checker" class="headerlink" title="1051. Height Checker"></a>1051. Height Checker</h2><p>Intuition:<br>简单的排序，然后遍历比较一遍。<br>时间复杂度: O(N log N)<br>空间复杂度: O(N)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> copy = heights;</span><br><span class="line">        <span class="built_in">sort</span>(copy.<span class="built_in">begin</span>(), copy.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy[i] != heights[i])</span><br><span class="line">                ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1052-Grumpy-Bookstore-Owner"><a href="#1052-Grumpy-Bookstore-Owner" class="headerlink" title="1052. Grumpy Bookstore Owner"></a>1052. Grumpy Bookstore Owner</h2><p>本题是最后做的，花费了不少时间。本次进不了前200的原因，首先是第一题读懂题目花了过长的时间，其次就是本题有些着急做，直接写代码，写错了思路，后来才改的。然后是本题还有一次罚时，是因为第一次忘记更新<code>max_wanhui</code>了。事实上，我刚开始是记得要更新的，但是写的时候就忘了。<br>教训就是，先把题的算法想好，确定可行在写代码；另外，需要先写test case，尤其是corner case，再想算法，再下笔。这样可以有效验证算法和代码的正确性。</p>
<p>Intuition:<br>滑动窗口。不断更新最大的挽回损失的值。</p>
<p>时间复杂度: O(N).<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; customers, vector&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = customers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> total_customers = <span class="built_in">accumulate</span>(customers.<span class="built_in">cbegin</span>(), customers.<span class="built_in">cend</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sunshi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i] == <span class="number">1</span>)</span><br><span class="line">                sunshi += customers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_wanhui = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> wanhui = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i] == <span class="number">1</span>)</span><br><span class="line">                wanhui += customers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max_wanhui = <span class="built_in">max</span>(max_wanhui, wanhui);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = X; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i] == <span class="number">1</span>)</span><br><span class="line">                wanhui += customers[i];</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i - X] == <span class="number">1</span>)</span><br><span class="line">                wanhui -= customers[i - X];</span><br><span class="line">            max_wanhui = <span class="built_in">max</span>(max_wanhui, wanhui);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; total_customers &lt;&lt; &quot; &quot; &lt;&lt; sunshi &lt;&lt; &quot; &quot; &lt;&lt; max_wanhui &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> total_customers - sunshi + max_wanhui;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1053-Previous-Permutation-With-One-Swap"><a href="#1053-Previous-Permutation-With-One-Swap" class="headerlink" title="1053. Previous Permutation With One Swap"></a>1053. Previous Permutation With One Swap</h2><p>Intuition:<br>Greedy. 我们想要找到一次交换产生的 最大的比当前小的枚举序列。<br>首先，要使枚举序列变小，必需交换一个大值和一个小值。<br>然后，为了使得交换后的序列尽可能大，大值需要尽可能靠后，小值也需尽可能靠后。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">prevPermOpt1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> larger_index = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (larger_index &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[larger_index] &gt;= A[larger_index - <span class="number">1</span>]) &#123;</span><br><span class="line">                --larger_index;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (larger_index == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        --larger_index;</span><br><span class="line">        <span class="keyword">auto</span> insert_it = <span class="built_in">lower_bound</span>(A.<span class="built_in">cbegin</span>() + larger_index + <span class="number">1</span>, A.<span class="built_in">cend</span>(), A[larger_index]);</span><br><span class="line">        <span class="keyword">int</span> swap_index = std::<span class="built_in">distance</span>(A.<span class="built_in">cbegin</span>(), insert_it) - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(A[swap_index], A[larger_index]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1054-Distant-Barcodes"><a href="#1054-Distant-Barcodes" class="headerlink" title="1054. Distant Barcodes"></a>1054. Distant Barcodes</h2><p>Intuition:<br>Greedy. 每次取频数最大的数，同时需要保证该数不是前一个数。<br>用一个 <strong>优先队列</strong> 恰好可以方便地实现取频数最大的数的需求。<br>时间复杂度: O(N log N), 优先队列的基本操作<code>push</code>的复杂度是<code>O(log N)</code>. 如果对STL里的算法和container, adapter不熟的话，我再推荐一遍<a href="https://book.douban.com/subject/26419721/">《C++ 标准库 第二版》（C++ Standard library)</a>这本书。<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rearrangeBarcodes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; barcodes)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> barcode : barcodes) &#123;</span><br><span class="line">            ++count[barcode];</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : count) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;p.second, p.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; old_top;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(t.second);</span><br><span class="line">            --t.first;</span><br><span class="line">            <span class="keyword">if</span> (old_top.first &gt; <span class="number">0</span>)</span><br><span class="line">                pq.<span class="built_in">push</span>(old_top);</span><br><span class="line">            old_top = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (old_top.first &gt; <span class="number">0</span>)</span><br><span class="line">            ret.<span class="built_in">push_back</span>(old_top.second);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 139</title>
    <url>/2019/06/03/LeetCode-weekly-contest-139/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>855 / 3985</td>
<td>YoungForest</td>
<td>10</td>
<td>1:03:50</td>
<td>0:53:00</td>
<td>1:03:50</td>
<td>赛后做出来</td>
<td>null</td>
</tr>
</tbody></table>
<p>周日起来的时候已经11点多了，算是迟到40min才参加的比赛。顺利作出了前2题，第3题开始走了些弯路，赛后才做出来。如果时间够的话，第3题作出应该没意思。</p>
<h2 id="1071-Greatest-Common-Divisor-of-Strings"><a href="#1071-Greatest-Common-Divisor-of-Strings" class="headerlink" title="1071. Greatest Common Divisor of Strings"></a>1071. Greatest Common Divisor of Strings</h2><p>Intuition:<br>此题相当于是找2个数的最大公约数。<br><code>Greatest Common Divisor</code>的长度一定等于最大公约数或0.<br>简单的证明如下：<br>设答案的长度为x, str1由x组成，所以x一定是str1.length的约数. 同样，也是str2.length。<br>假设x不是最大公约数，可以组成str1和str2。那么最大公约数也一定可以组成str1和str2。</p>
<p>时间复杂度: <code>O(log N)</code><br>空间复杂度: <code>O(N)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; a) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = b;</span><br><span class="line">            b = a % b;</span><br><span class="line">            a = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">gcdOfStrings</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = str1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> len2 = str2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> common_len = <span class="built_in">gcd</span>(len1, len2);</span><br><span class="line">        <span class="keyword">auto</span> t1 = str1.<span class="built_in">substr</span>(<span class="number">0</span>, common_len);</span><br><span class="line">        <span class="keyword">auto</span> t2 = str2.<span class="built_in">substr</span>(<span class="number">0</span>, common_len);</span><br><span class="line">        <span class="keyword">return</span> t1 == t2 ? t1 : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows"><a href="#1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows" class="headerlink" title="1072. Flip Columns For Maximum Number of Equal Rows"></a>1072. Flip Columns For Maximum Number of Equal Rows</h2><p>Intuition:<br>寻找互补的行 的最大数量。</p>
<p>时间复杂度: <code>O(matrix.length * matrix[0].length)</code><br>空间复杂度: <code>O(matrix.length * matrix[0].length)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEqualRowsAfterFlips</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; row : matrix) &#123;</span><br><span class="line">            string right, complete;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> item : row) &#123;</span><br><span class="line">                right.<span class="built_in">push_back</span>(item + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                complete.<span class="built_in">push_back</span>(((~item) &amp; <span class="number">1</span>) + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++count[right];</span><br><span class="line">            ++count[complete];</span><br><span class="line">            ret = <span class="built_in">max</span>(&#123;ret, count[right], count[complete]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1073-Adding-Two-Negabinary-Numbers"><a href="#1073-Adding-Two-Negabinary-Numbers" class="headerlink" title="1073. Adding Two Negabinary Numbers"></a>1073. Adding Two Negabinary Numbers</h2><p>Intuition:<br>模仿2进制。不同之处在于进位可能是-1，1，0。</p>
<p>时间复杂度: <code>O(max(arr.size(), arr.size()))</code><br>共建复杂度: <code>O(max(arr.size(), arr.size()))</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span>&amp; digit, <span class="keyword">int</span>&amp; carry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digit == <span class="number">-1</span>) &#123;</span><br><span class="line">            digit = <span class="number">1</span>;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (digit == <span class="number">2</span>) &#123;</span><br><span class="line">            carry = <span class="number">-1</span>;</span><br><span class="line">            digit = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (digit == <span class="number">3</span>) &#123;</span><br><span class="line">            carry = <span class="number">-1</span>;</span><br><span class="line">            digit = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">addNegabinary</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = arr1.<span class="built_in">size</span>() - <span class="number">1</span>, j = arr2.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = arr1[i] + arr2[j] + carry;</span><br><span class="line">            <span class="built_in">update</span>(digit, carry);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = arr1[i] + carry;</span><br><span class="line">            <span class="built_in">update</span>(digit, carry);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = arr2[j] + carry;</span><br><span class="line">            <span class="built_in">update</span>(digit, carry);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (carry == <span class="number">-1</span>) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            ret.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ret.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; ret.<span class="built_in">back</span>() == <span class="number">0</span>)</span><br><span class="line">            ret.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1074-Number-of-Submatrices-That-Sum-to-Target"><a href="#1074-Number-of-Submatrices-That-Sum-to-Target" class="headerlink" title="1074. Number of Submatrices That Sum to Target"></a>1074. Number of Submatrices That Sum to Target</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 140</title>
    <url>/2019/06/09/LeetCode-weekly-contest-140/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>313 / 4046</td>
<td>YoungForest</td>
<td>16</td>
<td>1:03:21</td>
<td>0:21:32 (1)</td>
<td>0:36:08</td>
<td>0:53:21 (1)</td>
<td>null</td>
</tr>
</tbody></table>
<p>本次比赛难度适中，由于<a href="https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/discuss/308196/A-leaf-is-a-node-with-no-children.">评测程序的问题</a>，很多人被第三题坑了。赛后test case修改正确了。这已经不是LeetCode第一次出现事故了。</p>
<h2 id="5083-Occurrences-After-Bigram"><a href="#5083-Occurrences-After-Bigram" class="headerlink" title="5083. Occurrences After Bigram"></a>5083. Occurrences After Bigram</h2><p>思路：<br>签到题，直接做。用一个状态机来记录当前的状态。</p>
<p>时间复杂度: O(text.size()),<br>空间复杂度: O(1). 我的实现中，为了方便将token存在一个vector中，其实是没必要的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line">        other,</span><br><span class="line">        first,</span><br><span class="line">        second</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findOcurrences</span><span class="params">(string text, string first, string second)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(text)</span></span>;</span><br><span class="line">        vector&lt;string&gt; tokens&#123;istream_iterator&lt;string&gt;&#123;iss&#125;, &#123;&#125;&#125;;</span><br><span class="line">        State state = State::other;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == State::second) &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(token);</span><br><span class="line">                state = State::other;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (token == first) &#123;</span><br><span class="line">                state = State::first;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == second &amp;&amp; state == State::first) &#123;</span><br><span class="line">                state = State::second;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = State::other;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5087-Letter-Tile-Possibilities"><a href="#5087-Letter-Tile-Possibilities" class="headerlink" title="5087. Letter Tile Possibilities"></a>5087. Letter Tile Possibilities</h2><p>由于数据规模比较小，<code>tiles.length &lt;= 7</code>, 所以直接暴力枚举所有的可能即可。<br>时间复杂度: O(N!),<br>空间复杂度: O(N!).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    set&lt;string&gt; ret;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; count, <span class="keyword">int</span> size, <span class="keyword">int</span> step, string&amp; current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (step == size) &#123;</span><br><span class="line">            ret.<span class="built_in">insert</span>(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : count) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = p.first;</span><br><span class="line">            <span class="keyword">if</span> (count[c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --count[c];</span><br><span class="line">                current.<span class="built_in">push_back</span>(c);</span><br><span class="line">                <span class="built_in">backtracking</span>(count, size, step + <span class="number">1</span>, current);</span><br><span class="line">                current.<span class="built_in">pop_back</span>();</span><br><span class="line">                ++count[c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(string tiles)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> tile : tiles) &#123;</span><br><span class="line">            ++count[tile];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = tiles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= s; ++len) &#123;</span><br><span class="line">            string current;</span><br><span class="line">            <span class="built_in">backtracking</span>(count, len, <span class="number">0</span>, current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (auto&amp; s : ret) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; s &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> ret.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5084-Insufficient-Nodes-in-Root-to-Leaf-Paths"><a href="#5084-Insufficient-Nodes-in-Root-to-Leaf-Paths" class="headerlink" title="5084. Insufficient Nodes in Root to Leaf Paths"></a>5084. Insufficient Nodes in Root to Leaf Paths</h2><p>典型的递归题目。根据题目描述删除结点即可，如果对树的递归比较熟悉的话，写起来很快。<br>需要注意的是，叶子结点的定义是左右子树均为null，而不是左子树或又子树。</p>
<p>时间复杂度: O(N), 树中每个结点要调用一次递归函数。<br>空间复杂度: O(N), 树的深度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> limit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// return: 是否删除，子树从根到叶子最大的sum</span></span><br><span class="line">    <span class="comment">// current: 从根到父节点的sum</span></span><br><span class="line">    <span class="function">pair&lt;TreeNode*, <span class="keyword">int</span>&gt; <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">recurse</span>(root-&gt;left, current + root-&gt;val);</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">recurse</span>(root-&gt;right, current + root-&gt;val);</span><br><span class="line">        TreeNode* ret_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> ret_int;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            ret_int = <span class="built_in">max</span>(l.second, r.second);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">            ret_int = l.second;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            ret_int = r.second;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 叶子结点</span></span><br><span class="line">            ret_int = <span class="number">0</span>;</span><br><span class="line">        root-&gt;left = l.first;</span><br><span class="line">        root-&gt;right = r.first;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; root-&gt;val &lt;&lt; &quot; : &quot; &lt;&lt; ret_int &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (ret_int + root-&gt;val + current &gt;= limit) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;root, ret_int + root-&gt;val&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, ret_int + root-&gt;val&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sufficientSubset</span><span class="params">(TreeNode* root, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;limit = limit;</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">recurse</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5086-Smallest-Subsequence-of-Distinct-Characters"><a href="#5086-Smallest-Subsequence-of-Distinct-Characters" class="headerlink" title="5086. Smallest Subsequence of Distinct Characters"></a>5086. Smallest Subsequence of Distinct Characters</h2><p>这道题目在赛中没有做出来。我尝试用贪心的解法，每次添加一个字符。但这种贪心其实是错误的，无法处理形如<br>“ddeeeccdce”<br>这样的输入。<br>当处理最后一个d时，”ecd”无法比”dec”大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的贪心思路</span></span><br><span class="line"><span class="comment">// 时间复杂度: O(N^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestSubsequence</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        string current;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = text.<span class="built_in">at</span>(i);</span><br><span class="line">            <span class="keyword">auto</span> index = current.<span class="built_in">find</span>(c);</span><br><span class="line">            <span class="keyword">if</span> (index == string::npos) &#123;</span><br><span class="line">                current.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                string new_current = current.<span class="built_in">substr</span>(<span class="number">0</span>, index) + current.<span class="built_in">substr</span>(index + <span class="number">1</span>);</span><br><span class="line">                new_current.<span class="built_in">push_back</span>(c);</span><br><span class="line">                <span class="keyword">if</span> (new_current &lt; current) &#123;</span><br><span class="line">                    current = std::<span class="built_in">move</span>(new_current);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>正确的思路:<br>完全相同的题目 <a href="https://leetcode.com/problems/remove-duplicate-letters">LeetCode 316</a>.<br>此题中的discuss中有很多高质量的回答。</p>
<p>对于输入的字符串，我们尝试单调递增的结果字符串。如果输入字符小于结果字符串的最后一个，并且最后的这个字符之后还会出现，则 我们从结果字符串中移除掉这个字符。<br>这其实也是贪心的思路。每次操作都会让字符串变得更小。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestSubsequence</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; used, count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : text) &#123;</span><br><span class="line">            ++count[c];</span><br><span class="line">        &#125;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : text) &#123;</span><br><span class="line">            --count[c];</span><br><span class="line">            <span class="keyword">if</span> (used[c]++ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!ret.<span class="built_in">empty</span>() &amp;&amp; ret.<span class="built_in">back</span>() &gt; c &amp;&amp; count[ret.<span class="built_in">back</span>()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                used[ret.<span class="built_in">back</span>()] = <span class="number">0</span>;</span><br><span class="line">                ret.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 141</title>
    <url>/2019/06/16/LeetCode-weekly-contest-141/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>234 / 4126</td>
<td>YoungForest</td>
<td>22</td>
<td>1:18:45</td>
<td>0:25:23  1</td>
<td>0:36:29</td>
<td>0:51:47</td>
<td>1:13:45</td>
</tr>
</tbody></table>
<p>周一自然辩证法考试，周二矩阵考试，还是强行抽出时间参加contest。本身复习就不充分，平时的学习也没有十分扎实，我也是心大。<br>200名的时间至少要在1:14:23以内。</p>
<h2 id="1089-Duplicate-Zeros"><a href="#1089-Duplicate-Zeros" class="headerlink" title="1089. Duplicate Zeros"></a>1089. Duplicate Zeros</h2><p>Intuition:<br>因为要求in-place, 一个自然的想法是从后向前更新值。<br>2次遍历，第一次正向遍历，得到结果数组最后一位的原始坐标。<br>第二次逆向遍历，更新结果数组。</p>
<p>Time complexity: O(N),<br>Space complexity: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() &amp;&amp; i + zeros &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++zeros;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j, --i) &#123;</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">0</span> &amp;&amp; (i + zeros &lt; arr.<span class="built_in">size</span>())) &#123;</span><br><span class="line">                --j;    <span class="comment">// 多减一j</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">                    arr[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为忽略 最后一个0如果位数不够的话，将不进行扩展。被罚时一次。</p>
<p>测试用例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0]</span><br><span class="line">[0,0]</span><br><span class="line">[0,0,0]</span><br><span class="line">[0,0,1]</span><br><span class="line">[8,4,5,0,0,0,0,7]</span><br><span class="line">[8,4,5,0,0,0,0,0,7]</span><br></pre></td></tr></table></figure>

<h2 id="1090-Largest-Values-From-Labels"><a href="#1090-Largest-Values-From-Labels" class="headerlink" title="1090. Largest Values From Labels"></a>1090. Largest Values From Labels</h2><p>Intuition：<br>贪心思路。总是试图加入value最大的item。<br>具体实现为 先排序，并且用一个hashtable保证不违反 use_limit的限制。</p>
<p>Time complexity: O(N log N),<br>Space complexity: O(N)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestValsFromLabels</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; values, vector&lt;<span class="keyword">int</span>&gt;&amp; labels, <span class="keyword">int</span> num_wanted, <span class="keyword">int</span> use_limit)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; items;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            items.<span class="built_in">push_back</span>(&#123;values.<span class="built_in">at</span>(i), labels.<span class="built_in">at</span>(i)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), std::greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;());</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; used;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt; num_wanted &amp;&amp; index &lt; items.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p = items.<span class="built_in">at</span>(index);</span><br><span class="line">            <span class="keyword">if</span> (used[p.second] &lt; use_limit) &#123;</span><br><span class="line">                ++used[p.second];</span><br><span class="line">                ++num;</span><br><span class="line">                ret += p.first;</span><br><span class="line">            &#125;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[5,4,3,2,1]</span><br><span class="line">[1,1,2,2,3]</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">[5,4,3,2,1]</span><br><span class="line">[1,3,3,3,2]</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">[9,8,8,7,6]</span><br><span class="line">[0,0,0,1,1]</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">[9,8,8,7,6]</span><br><span class="line">[0,0,0,1,1]</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="1091-Shortest-Path-in-Binary-Matrix"><a href="#1091-Shortest-Path-in-Binary-Matrix" class="headerlink" title="1091. Shortest Path in Binary Matrix"></a>1091. Shortest Path in Binary Matrix</h2><p>Intuition:<br>求最短路径，用DFS。</p>
<p>Time complexity: O(N^2),<br>Space complexity: O(N^2).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (current.first == n - <span class="number">1</span> &amp;&amp; current.second == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> di : &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> dj : &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;) &#123;</span><br><span class="line">                        <span class="keyword">int</span> ni = current.first + di, nj = current.second + dj;</span><br><span class="line">                        <span class="keyword">if</span> (ni == current.first &amp;&amp; nj == current.second)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (visited.<span class="built_in">find</span>(&#123;ni, nj&#125;) != visited.<span class="built_in">end</span>())</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ni &lt; <span class="number">0</span> || ni &gt;= n || nj &lt; <span class="number">0</span> || nj &gt;= n)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (grid[ni][nj] == <span class="number">1</span>)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        visited.<span class="built_in">insert</span>(&#123;ni, nj&#125;);</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;ni, nj&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我的测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[0,1],[1,0]]</span><br><span class="line">[[0,0,0],[1,1,0],[1,1,0]]</span><br><span class="line">[[0,0,0],[0,1,0],[0,1,0]]</span><br><span class="line">[[0,0,0],[0,1,1],[0,1,0]]</span><br><span class="line">[[0]]</span><br><span class="line">[[1]]</span><br><span class="line">[[0,1,0,0,0],[0,1,0,1,0],[0,1,0,1,0],[0,1,0,1,0],[0,0,0,1,0]]</span><br><span class="line">[[0,1,0,0,0],[0,1,0,1,0],[0,1,1,1,0],[0,1,0,1,0],[0,0,0,1,0]]</span><br></pre></td></tr></table></figure>

<p>期望结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">1</span><br><span class="line">-1</span><br><span class="line">13</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<h2 id="1092-Shortest-Common-Supersequence"><a href="#1092-Shortest-Common-Supersequence" class="headerlink" title="1092. Shortest Common Supersequence"></a>1092. Shortest Common Supersequence</h2><p>Intuition:<br>先求出 最长公共子序列(Longest Common Subsequence).<br>然后补齐多余的字符。<br>最长公共子序列的模版很重要，需要快速实现。</p>
<p>Time Complexity: O(str1.size() * str2.size()),<br>Space Complexity: O(str1.size() * str2.size()).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Direction</span> &#123;</span></span><br><span class="line">        left,</span><br><span class="line">        up,</span><br><span class="line">        left_up</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">shortestCommonSupersequence</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, Direction&gt;&gt;&gt; <span class="built_in">v</span>(str1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;pair&lt;<span class="keyword">int</span>, Direction&gt;&gt;(str2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        v[<span class="number">0</span>][<span class="number">0</span>] = &#123;<span class="number">0</span>, Direction::left_up&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str1.<span class="built_in">size</span>() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = &#123;<span class="number">0</span>, Direction::up&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str2.<span class="built_in">size</span>() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i] = &#123;<span class="number">0</span>, Direction::left&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str1.<span class="built_in">size</span>() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; str2.<span class="built_in">size</span>() + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str1.<span class="built_in">at</span>(i - <span class="number">1</span>) == str2.<span class="built_in">at</span>(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    v[i][j] = &#123;v[i<span class="number">-1</span>][j<span class="number">-1</span>].first + <span class="number">1</span>, Direction::left_up&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v[i][j<span class="number">-1</span>].first &gt; v[i<span class="number">-1</span>][j].first) &#123;</span><br><span class="line">                    v[i][j] = &#123;v[i][j<span class="number">-1</span>].first, Direction::left&#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v[i][j] = &#123;v[i<span class="number">-1</span>][j].first, Direction::up&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">int</span> i = str1.<span class="built_in">size</span>(), j = str2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (v[i][j].second) &#123;</span><br><span class="line">                <span class="keyword">case</span> Direction::left_up:</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(str1.<span class="built_in">at</span>(i - <span class="number">1</span>));</span><br><span class="line">                    --i;</span><br><span class="line">                    --j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Direction::up:</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(str1.<span class="built_in">at</span>(i - <span class="number">1</span>));</span><br><span class="line">                    --i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Direction::left:</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(str2.<span class="built_in">at</span>(j - <span class="number">1</span>));</span><br><span class="line">                    --j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(), ret.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我的测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;abac&quot;</span><br><span class="line">&quot;cab&quot;</span><br><span class="line">&quot;geek&quot;</span><br><span class="line">&quot;eke&quot;</span><br><span class="line">&quot;AGGTAB&quot;</span><br><span class="line">&quot;GXTXAYB&quot;</span><br></pre></td></tr></table></figure>

<p>期望结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;cabac&quot;</span><br><span class="line">&quot;gekek&quot;</span><br><span class="line">&quot;AGXGTXAYB&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 142</title>
    <url>/2019/06/23/LeetCode-weekly-contest-142/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (5)</th>
<th>Q2 (5)</th>
<th>Q3 (8)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>851 / 4504</td>
<td>YoungForest</td>
<td>13</td>
<td>1:39:38</td>
<td>null</td>
<td>1:00:12 2</td>
<td>1:19:38 2</td>
<td>null</td>
</tr>
</tbody></table>
<p>本次比赛的失误主要在于第二题sort中的cmp函数写错了，没有保证 严格有序。一直segment fault。即 a &lt; b, 必有 b !&lt; a.</p>
<h2 id="1093-Statistics-from-a-Large-Sample"><a href="#1093-Statistics-from-a-Large-Sample" class="headerlink" title="1093. Statistics from a Large Sample"></a>1093. Statistics from a Large Sample</h2><p>Intution:<br>熟悉C++和统计中的这5个统计值的意义即可。<br>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">sampleStats</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> minimum = <span class="number">255.0</span>, maximum = <span class="number">0.0</span>, mean = <span class="number">0.0</span>, median = <span class="number">0.0</span>, mode = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">auto</span> minimum_it = <span class="built_in">find_if</span>(count.<span class="built_in">cbegin</span>(), count.<span class="built_in">cend</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; a) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        minimum = minimum_it - count.<span class="built_in">cbegin</span>();</span><br><span class="line">        <span class="keyword">auto</span> max_it = <span class="built_in">find_if</span>(count.<span class="built_in">crbegin</span>(), count.<span class="built_in">crend</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; a) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        maximum = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(count.<span class="built_in">size</span>()) - (max_it - count.<span class="built_in">crbegin</span>()) - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            mean += i * count[i];</span><br><span class="line">            num += count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        mean /= num;</span><br><span class="line">        <span class="keyword">int</span> total = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            num += count[i];</span><br><span class="line">            <span class="keyword">if</span> (num * <span class="number">2</span> &gt; total) &#123;</span><br><span class="line">                <span class="keyword">if</span> (median &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    median = (median + i) / <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    median = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num * <span class="number">2</span> == total) &#123;</span><br><span class="line">                median = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> mode_it = <span class="built_in">max_element</span>(count.<span class="built_in">cbegin</span>(), count.<span class="built_in">cend</span>());</span><br><span class="line">        mode = mode_it - count.<span class="built_in">cbegin</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;minimum, maximum, mean, median, mode&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1094-Car-Pooling"><a href="#1094-Car-Pooling" class="headerlink" title="1094. Car Pooling"></a>1094. Car Pooling</h2><p>Intuition:<br>模拟整个上下车的过程。在每个站台判断是否超载。<br>时间复杂度: O(N log N)<br>空间复杂度: O(N)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; stops;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; trip : trips) &#123;</span><br><span class="line">           stops[trip[<span class="number">1</span>]] += trip[<span class="number">0</span>];</span><br><span class="line">           stops[trip[<span class="number">2</span>]] -= trip[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> passengers = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; stop : stops) &#123;</span><br><span class="line">           passengers += stop.second;</span><br><span class="line">           <span class="keyword">if</span> (passengers &gt; capacity)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1095-Find-in-Mountain-Array"><a href="#1095-Find-in-Mountain-Array" class="headerlink" title="1095. Find in Mountain Array"></a>1095. Find in Mountain Array</h2><p>本题算是一类新题型：交互式问题。<br>3次 二分搜索搞定。</p>
<p>时间复杂度: O(log N).<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the MountainArray&#x27;s API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class MountainArray &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     int get(int index);</span></span><br><span class="line"><span class="comment"> *     int length();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = mountainArr.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == mountainArr.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.<span class="built_in">get</span>(mid) &lt; mountainArr.<span class="built_in">get</span>(mid + <span class="number">1</span>))</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mountain = lo;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;mountain: &quot; &lt;&lt; mountain &lt;&lt; endl;</span></span><br><span class="line">        lo = <span class="number">0</span>, hi = mountain + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.<span class="built_in">get</span>(mid) &lt; target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;first: &quot; &lt;&lt; lo &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (mountainArr.<span class="built_in">get</span>(lo) == target)</span><br><span class="line">            <span class="keyword">return</span> lo;</span><br><span class="line">        lo = mountain, hi = mountainArr.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.<span class="built_in">get</span>(mid) &gt; target)</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;second: &quot; &lt;&lt; lo &lt;&lt; endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (lo &lt; mountainArr.<span class="built_in">length</span>() &amp;&amp; mountainArr.<span class="built_in">get</span>(lo) == target)</span><br><span class="line">            <span class="keyword">return</span> lo;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1096-Brace-Expansion-II"><a href="#1096-Brace-Expansion-II" class="headerlink" title="1096. Brace Expansion II"></a>1096. Brace Expansion II</h2><p>参考的<a href="https://leetcode.com/problems/brace-expansion-ii/discuss/317732/ChineseC++-1096.">discuss</a><br>作者用了语法分析的思路来解决这道题目。<br>二个子程序parseRule2 和 parseRule3 分别处理 并集 和 笛卡尔积 的情况。</p>
<p>时间复杂度: O(N^N), 因为 笛卡尔乘积。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">set&lt;string&gt; <span class="title">descarte</span><span class="params">(<span class="keyword">const</span> set&lt;string&gt;&amp; s1, <span class="keyword">const</span> set&lt;string&gt;&amp; s2)</span> </span>&#123;</span><br><span class="line">        set&lt;string&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a : s1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; b : s2) &#123;</span><br><span class="line">                ret.<span class="built_in">insert</span>(a + b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &#123;a,b&#125;,a,&#123;a&#125;</span></span><br><span class="line">    <span class="function">set&lt;string&gt; <span class="title">parseRule2</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        set&lt;string&gt; ret = <span class="built_in">parseRule3</span>(s, i);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ++i;    <span class="comment">// skip &#x27;,&#x27;</span></span><br><span class="line">            <span class="keyword">auto</span> temp = <span class="built_in">parseRule3</span>(s, i);</span><br><span class="line">            ret.<span class="built_in">insert</span>(std::<span class="built_in">make_move_iterator</span>(temp.<span class="built_in">begin</span>()), std::<span class="built_in">make_move_iterator</span>(temp.<span class="built_in">end</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &#123;a,b&#125;b&#123;a&#125;</span></span><br><span class="line">    <span class="function">set&lt;string&gt; <span class="title">parseRule3</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        set&lt;string&gt; ret;</span><br><span class="line">        ret.<span class="built_in">insert</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span> || s[i] == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                ++i;    <span class="comment">// skip &#x27;&#123;&#x27;</span></span><br><span class="line">                <span class="keyword">auto</span> temp = <span class="built_in">parseRule2</span>(s, i);</span><br><span class="line">                ++i;    <span class="comment">// skip &#x27;&#123;&#x27;</span></span><br><span class="line">                ret = <span class="built_in">descarte</span>(ret, temp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set&lt;string&gt; new_ret;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : ret) &#123;</span><br><span class="line">                    new_ret.<span class="built_in">insert</span>(item + s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                ret = std::<span class="built_in">move</span>(new_ret);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">braceExpansionII</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">parseRule2</span>(expression, pos);</span><br><span class="line">        ret.<span class="built_in">erase</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> vector&lt;string&gt; (std::<span class="built_in">make_move_iterator</span>(ret.<span class="built_in">begin</span>()), std::<span class="built_in">make_move_iterator</span>(ret.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 143</title>
    <url>/2019/07/01/LeetCode-weekly-contest-143/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (5)</th>
<th>Q2 (5)</th>
<th>Q3 (8)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>396 / 4272</td>
<td>YoungForest</td>
<td>14</td>
<td>1:01:14</td>
<td>0:11:38</td>
<td>0:28:38</td>
<td>0:56:14 1</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1103-Distribute-Candies-to-People"><a href="#1103-Distribute-Candies-to-People" class="headerlink" title="1103. Distribute Candies to People"></a>1103. Distribute Candies to People</h2><p>Brute force. 模拟整个分配过程。</p>
<p>时间复杂度: <code>O(sqrt(candies.size()))</code>. 因为<code>1 + 2 + ... + n = n * (n + 1) / 2 = candies.size()</code>.<br>空间复杂度: <code>O(num_people)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(num_people, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (candies &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.<span class="built_in">size</span>() &amp;&amp; candies &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">                ret[i] += <span class="built_in">min</span>(candies, row * num_people + i + <span class="number">1</span>);</span><br><span class="line">                candies -= <span class="built_in">min</span>(candies, row * num_people + i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++row;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1104-Path-In-Zigzag-Labelled-Binary-Tree"><a href="#1104-Path-In-Zigzag-Labelled-Binary-Tree" class="headerlink" title="1104. Path In Zigzag Labelled Binary Tree"></a>1104. Path In Zigzag Labelled Binary Tree</h2><p>利用2个算法</p>
<ul>
<li>如果是顺序编号的话，父节点编号为 子节点编号 / 2 向下取整。</li>
<li>反序编号，可以转成顺序编号。</li>
</ul>
<p>时间复杂度: O(log N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLevel</span><span class="params">(<span class="keyword">int</span> label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (label &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            label &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ++level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">complete</span><span class="params">(<span class="keyword">int</span> label, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;(level + <span class="number">1</span>)) - <span class="number">1</span> - label + (<span class="number">1</span>&lt;&lt;level);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pathInZigZagTree</span><span class="params">(<span class="keyword">int</span> label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">getLevel</span>(label);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> level = n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; level &lt;&lt; endl;</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(level)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> true_label = label;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            true_label = <span class="built_in">complete</span>(label, n);</span><br><span class="line">        &#125;</span><br><span class="line">        ret[n] = true_label;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            ret[i] = ret[i + <span class="number">1</span>] / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt;= n; ++i) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; ret[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                ret[i] = <span class="built_in">complete</span>(ret[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1105-Filling-Bookcase-Shelves"><a href="#1105-Filling-Bookcase-Shelves" class="headerlink" title="1105. Filling Bookcase Shelves"></a>1105. Filling Bookcase Shelves</h2><p>回溯法 + 剪枝。<br>时间复杂度: O(2^N), 实际上因为剪枝会小的多。<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; local_min;</span><br><span class="line">    <span class="keyword">int</span> global_min = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; books, <span class="keyword">const</span> <span class="keyword">int</span> shelf_width, <span class="keyword">int</span> i, <span class="keyword">int</span> current_level_height, <span class="keyword">int</span> height_before, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= books.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            global_min = <span class="built_in">min</span>(global_min, current_level_height + height_before);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current_level_height + height_before &gt;= global_min)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> w = books[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> h = books[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (local_min.<span class="built_in">at</span>(i).<span class="built_in">at</span>(width) &lt;= height_before + <span class="built_in">max</span>(current_level_height, h)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        local_min.<span class="built_in">at</span>(i).<span class="built_in">at</span>(width) = height_before + <span class="built_in">max</span>(current_level_height, h);</span><br><span class="line">        <span class="keyword">if</span> (w + width &lt;= shelf_width) &#123;</span><br><span class="line">            <span class="built_in">backtracking</span>(books, shelf_width, i + <span class="number">1</span>, <span class="built_in">max</span>(current_level_height, h), height_before, width + w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtracking</span>(books, shelf_width, i + <span class="number">1</span>, h, height_before + current_level_height, w);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minHeightShelves</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; books, <span class="keyword">int</span> shelf_width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = books.<span class="built_in">size</span>();</span><br><span class="line">        local_min = vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; (n, vector&lt;<span class="keyword">int</span>&gt; (shelf_width + <span class="number">1</span>, numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>()));</span><br><span class="line">        <span class="built_in">backtracking</span>(books, shelf_width, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> global_min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上还可以通过DP解决该问题：<a href="https://leetcode.com/problems/filling-bookcase-shelves/discuss/323368/ChineseC++-1105.-DP">Discuss</a></p>
<h2 id="1106-Parsing-A-Boolean-Expression"><a href="#1106-Parsing-A-Boolean-Expression" class="headerlink" title="1106. Parsing A Boolean Expression"></a>1106. Parsing A Boolean Expression</h2><p>词法分析。<br>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// op: o not, 1 and, 2 or</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parseNot</span><span class="params">(<span class="keyword">const</span> string&amp; expression, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;parseNot (&quot; &lt;&lt; i &lt;&lt; &quot;): &quot; &lt;&lt; expression.at(i) &lt;&lt; endl;</span></span><br><span class="line">        ++i; <span class="comment">// skip &#x27;(&#x27;</span></span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="built_in">parse</span>(expression, i);</span><br><span class="line">        ++i; <span class="comment">// skip &#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> !ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parseAnd</span><span class="params">(<span class="keyword">const</span> string&amp; expression, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;parseAnd (&quot; &lt;&lt; i &lt;&lt; &quot;): &quot; &lt;&lt; expression.at(i) &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (expression.<span class="built_in">at</span>(i) != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// skip &#x27;,&#x27; or &#x27;(&#x27;</span></span><br><span class="line">            ret = <span class="built_in">parse</span>(expression, i) &amp;&amp; ret;  <span class="comment">// Warning: ret 必需写到后面，在比赛过程中，由于我写到前面了。忽略了逻辑短路问题，一直wrong answer。功亏一篑。</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++i;    <span class="comment">// skip &#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parseOr</span><span class="params">(<span class="keyword">const</span> string&amp; expression, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;parseOr (&quot; &lt;&lt; i &lt;&lt; &quot;): &quot; &lt;&lt; expression.at(i) &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (expression.<span class="built_in">at</span>(i) != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// skip &#x27;,&#x27; or &#x27;(&#x27;</span></span><br><span class="line">            ret = <span class="built_in">parse</span>(expression, i) || ret;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;    <span class="comment">// skip &#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parse</span><span class="params">(<span class="keyword">const</span> string&amp; expression, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;parse (&quot; &lt;&lt; i &lt;&lt; &quot;): &quot; &lt;&lt; expression.at(i) &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">char</span> head = expression.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (head) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                ++i; <span class="comment">// skip &#x27;t&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">parseNot</span>(expression, i);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">parseAnd</span>(expression, i);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">parseOr</span>(expression, i);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;error: &quot;</span> &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">parseBoolExpr</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parse</span>(expression, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 144</title>
    <url>/2019/07/07/LeetCode-weekly-contest-144/</url>
    <content><![CDATA[<p>今早由于参加托福考试，无法像往常一样参加周赛。赛后补题。</p>
<h2 id="1108-Defanging-an-IP-Address"><a href="#1108-Defanging-an-IP-Address" class="headerlink" title="1108. Defanging an IP Address"></a>1108. Defanging an IP Address</h2><p>One pass. 直接替换即可。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">defangIPaddr</span><span class="params">(string address)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : address) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">                ret.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                ret.<span class="built_in">push_back</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1109-Corporate-Flight-Bookings"><a href="#1109-Corporate-Flight-Bookings" class="headerlink" title="1109. Corporate Flight Bookings"></a>1109. Corporate Flight Bookings</h2><p>Brute force. TLE.<br>时间复杂度: O(N * bookings.length);<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; booking : bookings) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = booking.<span class="built_in">at</span>(<span class="number">0</span>); i &lt;= booking.<span class="built_in">at</span>(<span class="number">1</span>); ++i) &#123;</span><br><span class="line">                ret[i - <span class="number">1</span>] += booking.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>One pass. 前些天刚做过类似的题目。站点上下车的问题。<br>时间复杂度: O(max(booking.length, N)).<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">stops</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; booking : bookings) &#123;</span><br><span class="line">            stops[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];    <span class="comment">// begin</span></span><br><span class="line">            stops[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];    <span class="comment">// end</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            total += stops[i];</span><br><span class="line">            ret[i] = total;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1110-Delete-Nodes-And-Return-Forest"><a href="#1110-Delete-Nodes-And-Return-Forest" class="headerlink" title="1110. Delete Nodes And Return Forest"></a>1110. Delete Nodes And Return Forest</h2><p>二叉树的通用解法：递归删除。</p>
<p>时间复杂度: O(N), 每个结点被递归调用一次。<br>空间复杂度: O(N). 最差情况下，返回的子树个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;TreeNode*&gt; ret;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="keyword">const</span> unordered_set&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* ret = <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">recurse</span>(root-&gt;left, to_delete);</span><br><span class="line">        root-&gt;right = <span class="built_in">recurse</span>(root-&gt;right, to_delete);</span><br><span class="line">        <span class="keyword">if</span> (to_delete.<span class="built_in">find</span>(root-&gt;val) == to_delete.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ret = root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// delete</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;ret.<span class="built_in">push_back</span>(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;ret.<span class="built_in">push_back</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="keyword">int</span>&gt; <span class="title">td</span><span class="params">(to_delete.begin(), to_delete.end())</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">recurse</span>(root, td);</span><br><span class="line">        <span class="keyword">if</span> (r) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1111-Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings"><a href="#1111-Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings" class="headerlink" title="1111. Maximum Nesting Depth of Two Valid Parentheses Strings"></a>1111. Maximum Nesting Depth of Two Valid Parentheses Strings</h2><p>理解题意时，需要注意A, B是seq的subsequence而不是subarray.<br>首先尝试贪心的思路。在遇到左括号时，分配给深度较小的序列。遇到右括号时，分配给深度较大的序列。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxDepthAfterSplit</span><span class="params">(string seq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : seq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &lt;= b) &#123;</span><br><span class="line">                    ++a;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++b;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;= b) &#123;</span><br><span class="line">                    --a;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    --b;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 145</title>
    <url>/2019/07/15/LeetCode-weekly-contest-145/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (5)</th>
<th>Q2 (5)</th>
<th>Q3 (8)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>451 / 4931</td>
<td>YoungForest</td>
<td>16</td>
<td>1:24:26</td>
<td>0:09:37</td>
<td>0:17:39</td>
<td>1:14:26 2</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1122-Relative-Sort-Array"><a href="#1122-Relative-Sort-Array" class="headerlink" title="1122. Relative Sort Array"></a>1122. Relative Sort Array</h2><p>定制排序规则。</p>
<p>时间复杂度: O(N long N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; location;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            location[arr2[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>(), [location](<span class="keyword">int</span> lhs, <span class="keyword">int</span> rhs) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (location.<span class="built_in">find</span>(lhs) != location.<span class="built_in">end</span>() &amp;&amp; location.<span class="built_in">find</span>(rhs) != location.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> location.<span class="built_in">at</span>(lhs) &lt; location.<span class="built_in">at</span>(rhs);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.<span class="built_in">find</span>(lhs) == location.<span class="built_in">end</span>() &amp;&amp; location.<span class="built_in">find</span>(rhs) != location.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.<span class="built_in">find</span>(lhs) != location.<span class="built_in">end</span>() &amp;&amp; location.<span class="built_in">find</span>(rhs) == location.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> lhs &lt; rhs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1123-Lowest-Common-Ancestor-of-Deepest-Leaves"><a href="#1123-Lowest-Common-Ancestor-of-Deepest-Leaves" class="headerlink" title="1123. Lowest Common Ancestor of Deepest Leaves"></a>1123. Lowest Common Ancestor of Deepest Leaves</h2><p>树的问题递归解决。关注需要返回给父节点的信息和传递给子节点的信息。</p>
<p>时间复杂度: O(N). 每个节点遍历一次。<br>空间复杂度: O(N). 树的最深深度，即递归的深度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, TreeNode*&gt; <span class="title">recurse</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;depth, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">recurse</span>(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">recurse</span>(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (l.first &gt; r.first) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l.first == r.first) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;l.first, root&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">recurse</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1124-Longest-Well-Performing-Interval"><a href="#1124-Longest-Well-Performing-Interval" class="headerlink" title="1124. Longest Well-Performing Interval"></a>1124. Longest Well-Performing Interval</h2><p>我们只关心元素的大小是否大于8，而不关心其绝对值。所以把大于8的元素变为1，小于等于8的元素变为0，可以将问题转化为，寻找1的个数大于0的最大子数组。<br>为了快速求解子数组中1比0多的数目，我们可以通过前缀和得出。<br>如：<br>   [9,9,6,0,6,6,9] -&gt;<br>   [1,1,0,0,0,0,1] -&gt; 前缀和<br> [0,1,2,1,0,-1,-2,-3]<br>子数组[i, j]的1比0多的数目即为<code>prefix[j] - prefix[i - 1]</code>, 数组长度为<code>j - i + 1</code>.<br>即 对于每个j, 我们想找到比<code>prefix[j]</code>小的最靠前的<code>prefix[i-1]</code>. 因为prefix是连续变化的，所以找恰好比prefix[j-1]小的，就更靠前。对于prefix[j] &gt; 0的，找0即可。<br>另一种找*比<code>prefix[j]</code>小的最靠前的<code>prefix[i-1]</code>*的方法是，维护一个递减栈，记录<code>prefix[i], i</code>, 找的时候通过二分查找，寻找合适的<code>prefix[i-1]</code>.</p>
<p>很棒的题解: <a href="https://leetcode.com/problems/longest-well-performing-interval/discuss/334897/ChineseC%2B%2B-1124.-O(n)">tiankonguse</a></p>
<p><a href="https://www.bilibili.com/video/av59225187">花花的视频讲解</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestWPI</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; hours)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo; <span class="comment">// sum, index</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hours.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hours[i] &gt; <span class="number">8</span>) &#123;</span><br><span class="line">                ++s;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (memo.<span class="built_in">find</span>(s) == memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                memo[s] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s - <span class="number">1</span> &lt;= <span class="number">0</span> &amp;&amp; memo.<span class="built_in">find</span>(s - <span class="number">1</span>) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, i - memo[s - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, i - memo[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1125-Smallest-Sufficient-Team"><a href="#1125-Smallest-Sufficient-Team" class="headerlink" title="1125. Smallest Sufficient Team"></a>1125. Smallest Sufficient Team</h2><p><a href="https://leetcode.com/problems/smallest-sufficient-team/discuss/334832/c%2B%2B-dp-bitmask-solution-with-algorithm">dp + bitmast</a><br>由于本题是NP问题。<br>时间复杂度: O(2^(req_skills.size()) * people.size() * people[i].size())<br>空间复杂度: O(2^(req_skills.size()))</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">smallestSufficientTeam</span><span class="params">(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = req_skills.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; skill2bit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; req_skills.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            skill2bit[req_skills[i]] = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        res[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p = people[i];</span><br><span class="line">            <span class="keyword">int</span> p_skill = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; skill : p) &#123;</span><br><span class="line">                p_skill |= skill2bit[skill];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = res.<span class="built_in">begin</span>(); it != res.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                <span class="keyword">int</span> combine = p_skill | it-&gt;first;</span><br><span class="line">                <span class="keyword">auto</span> comb_it = res.<span class="built_in">find</span>(combine);</span><br><span class="line">                <span class="keyword">if</span> (comb_it == res.<span class="built_in">end</span>() || it-&gt;second.<span class="built_in">size</span>() + <span class="number">1</span> &lt; comb_it-&gt;second.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    res[combine] = it-&gt;second;</span><br><span class="line">                    res[combine].<span class="built_in">push_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 146</title>
    <url>/2019/07/21/LeetCode-weekly-contest-146/</url>
    <content><![CDATA[<p>今天由于高中同学xl来北京找我聊，和hcq一起吃了午饭和晚饭，并聊了一下午。上午的contest只匆匆做了签到题。第二题因为粗心，写错了<code>red</code>变化的时机，也没有时间调试。后2题干脆没有看。<br>晚上回来9点才把题目补完，第二题的bug也调出来了。<br>不过时间上应该是超时了。<br>排名1800+。</p>
<p>总体来讲，本次题目虽然不难，但是需要花时间思考才能做出来的。这样的题目也是我喜欢的。通过自己的思考，作出一道并不是一眼看上去就知道解答的题目，是很爽的。快感可比超神和三杀。</p>
<h2 id="5130-Number-of-Equivalent-Domino-Pairs"><a href="#5130-Number-of-Equivalent-Domino-Pairs" class="headerlink" title="5130. Number of Equivalent Domino Pairs"></a>5130. Number of Equivalent Domino Pairs</h2><p>既然domino可以通过旋转相等，我们就把他们归一化(将2种domino映射成一种)。<br>然后计算组合数即可。</p>
<p>时间复杂度: O(N log N), 因为pair默认不是hashable，所以偷懒用了map。<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEquivDominoPairs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = dominoes.<span class="built_in">size</span>();</span><br><span class="line">        map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; transform;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[i][<span class="number">0</span>] &lt; dominoes[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                ++transform[<span class="built_in">make_pair</span>(dominoes[i][<span class="number">0</span>], dominoes[i][<span class="number">1</span>])];  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++transform[<span class="built_in">make_pair</span>(dominoes[i][<span class="number">1</span>], dominoes[i][<span class="number">0</span>])];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : transform) &#123;</span><br><span class="line">            ans += p.second * (p.second - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1129-Shortest-Path-with-Alternating-Colors"><a href="#1129-Shortest-Path-with-Alternating-Colors" class="headerlink" title="1129. Shortest Path with Alternating Colors"></a>1129. Shortest Path with Alternating Colors</h2><p>算最短路径，用BFS。由于需要颜色交替，代码略微有些麻烦，需要2套变量。</p>
<p>时间复杂度: O(N), 每个节点最多遍历2次。<br>空间复杂度: O(max(N, edges)).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">shortestAlternatingPaths</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; red_edges, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; blue_edges)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; red_to, blue_to;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge : red_edges) &#123;</span><br><span class="line">            red_to[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge : blue_edges) &#123;</span><br><span class="line">            blue_to[edge[<span class="number">0</span>]].<span class="built_in">push_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(n, numeric_limits&lt;<span class="keyword">int</span>&gt;::max())</span></span>;</span><br><span class="line">        ret[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">bool</span> red : &#123;<span class="literal">true</span>, <span class="literal">false</span>&#125;) &#123;</span><br><span class="line">            queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">            unordered_set&lt;<span class="keyword">int</span>&gt; seen_red, seen_blue;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">            seen_red.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">            seen_blue.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">                ++level;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> current = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    vector&lt;<span class="keyword">int</span>&gt;* edges = <span class="literal">nullptr</span>;</span><br><span class="line">                    unordered_set&lt;<span class="keyword">int</span>&gt;* seen = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">if</span> (red) &#123;</span><br><span class="line">                        edges = &amp;red_to[current];</span><br><span class="line">                        seen = &amp;seen_red;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        edges = &amp;blue_to[current];</span><br><span class="line">                        seen = &amp;seen_blue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> des : *edges) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (seen-&gt;<span class="built_in">find</span>(des) == seen-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(des);</span><br><span class="line">                            seen-&gt;<span class="built_in">insert</span>(des);</span><br><span class="line">                            ret[des] = <span class="built_in">min</span>(ret[des], level);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;            </span><br><span class="line">                red = !red;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : ret) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item == numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>())</span><br><span class="line">                item = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5131-Minimum-Cost-Tree-From-Leaf-Values"><a href="#5131-Minimum-Cost-Tree-From-Leaf-Values" class="headerlink" title="5131. Minimum Cost Tree From Leaf Values"></a>5131. Minimum Cost Tree From Leaf Values</h2><p>本题是本次比赛中最难的题目。我也是思考了很长时间才摸索出来的。</p>
<p>首先，观察有：</p>
<ul>
<li>层数和叶子数的关系。n层至少n个叶子，至多2^(n-1)个叶子。</li>
<li>叶子数确定的话，非叶子节点数目也就确定了。</li>
<li>观察小的树，可得贪心的解法。大的叶子尽量往上提，降低层数，使得影响的非叶子节点数更少，总和就最少。</li>
</ul>
<p>时间复杂度: O(n log n). 类似快排，把问题分解成2个子问题，然后还需要end - begin组合解。<br>空间复杂度: O(n), n个叶子最多n层，也就是递归深度. </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// max_leaf</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurse</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin + <span class="number">1</span> == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_index = begin;</span><br><span class="line">        <span class="keyword">int</span> max_value = arr[begin];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin + <span class="number">1</span>; i &lt; end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= max_value) &#123;</span><br><span class="line">                max_value = arr[i];</span><br><span class="line">                max_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">if</span> (max_index - begin + <span class="number">2</span> &lt;= end - max_index) &#123; <span class="comment">// 向后分</span></span><br><span class="line">            l = <span class="built_in">recurse</span>(arr, begin, max_index + <span class="number">1</span>);</span><br><span class="line">            r = <span class="built_in">recurse</span>(arr, max_index + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 向前分</span></span><br><span class="line">            l = <span class="built_in">recurse</span>(arr, begin, max_index);</span><br><span class="line">            r = <span class="built_in">recurse</span>(arr, max_index, end);</span><br><span class="line">        &#125;</span><br><span class="line">        ret += l * r;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mctFromLeafValues</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">recurse</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1131-Maximum-of-Absolute-Value-Expression"><a href="#1131-Maximum-of-Absolute-Value-Expression" class="headerlink" title="1131. Maximum of Absolute Value Expression"></a>1131. Maximum of Absolute Value Expression</h2><p>首先观察数据规模<code>40000</code>, 排除暴力解法的<code>O(N^2)</code>。<br>寻找<code>O(N)</code> 或 <code>O(N log N)</code>的解法。<br>实际上，由于绝对值的作用有2种：不变，取反。3个绝对值号，枚举2^3 = 8种组合即可。</p>
<p>时间复杂度: O(8 * N)<br>空间复杂度: O(N), 可以很轻易地缩减为O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAbsValExpr</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = arr1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k : &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n; ++l) &#123;</span><br><span class="line">                        tmp[l] = arr1[l] * i + arr2[l] * j + l * k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">auto</span> r = <span class="built_in">minmax_element</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, *r.second - *r.first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 147</title>
    <url>/2019/07/28/LeetCode-weekly-contest-147/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (2)</th>
<th>Q2 (5)</th>
<th>Q3 (7)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>175 / 4906</td>
<td>YoungForest</td>
<td>21</td>
<td>1:14:32</td>
<td>0:08:18  1</td>
<td>0:27:17  1</td>
<td>0:41:32</td>
<td>1:04:32</td>
</tr>
</tbody></table>
<p>昨天做了Biweekly contest，今天做了常规赛和 下午的Google Kick D.<br>连续3场比赛，周末很充实。</p>
<h2 id="1137-N-th-Tribonacci-Number"><a href="#1137-N-th-Tribonacci-Number" class="headerlink" title="1137. N-th Tribonacci Number"></a>1137. N-th Tribonacci Number</h2><p>和 Fibonacci 类似。相同的解法应该都可以用在这里。<br>我采用了实现起来最方便的解法。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(max(n + <span class="number">1</span>, <span class="number">3</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>] + dp[i<span class="number">-3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1138-Alphabet-Boar"><a href="#1138-Alphabet-Boar" class="headerlink" title="1138. Alphabet Boar"></a>1138. Alphabet Boar</h2><p>也是straight forward的解法。因为移动距离就是2点之间的曼哈顿距离，所以贪心地移就好了。<br>此处有坑，<code>z</code>的位置上不能向右移，<code>uvwxy</code>不能向下移。</p>
<p>时间复杂度: O(N).<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">alphabetBoardPath</span><span class="params">(string target)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">locations</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            locations[index] = &#123;index / <span class="number">5</span>, index % <span class="number">5</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; current = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">auto</span> special = locations.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : target) &#123;</span><br><span class="line">            <span class="keyword">auto</span> to = locations[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (current != special) &#123;</span><br><span class="line">                <span class="keyword">if</span> (to.second &gt; current.second) &#123;</span><br><span class="line">                    ans.<span class="built_in">append</span>(to.second - current.second, <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">append</span>(current.second - to.second, <span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (to.first &gt; current.first) &#123;</span><br><span class="line">                    ans.<span class="built_in">append</span>(to.first - current.first, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">append</span>(current.first - to.first, <span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (to.first &gt; current.first) &#123;</span><br><span class="line">                    ans.<span class="built_in">append</span>(to.first - current.first, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">append</span>(current.first - to.first, <span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (to.second &gt; current.second) &#123;</span><br><span class="line">                    ans.<span class="built_in">append</span>(to.second - current.second, <span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">append</span>(current.second - to.second, <span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">            current = to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1139-Largest-1-Bordered-Square"><a href="#1139-Largest-1-Bordered-Square" class="headerlink" title="1139. Largest 1-Bordered Square"></a>1139. Largest 1-Bordered Square</h2><p>之前做过一道类似的题目，区别在于正方形是实心的。<br>本题与之类似。枚举正方形所有的右下角，再枚举所有可能的左上角，判断是否可以组成正方形。</p>
<p>时间复杂度: O(N ^ 3)<br>空间复杂度: O(N ^ 2)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> up = grid, down = grid, left = grid, right = grid;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> R = grid.<span class="built_in">size</span>(), C = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    up[i][j] = grid[i][j] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    up[i][j] = grid[i][j] == <span class="number">1</span> ? up[i<span class="number">-1</span>][j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    left[i][j] = grid[i][j] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left[i][j] = grid[i][j] == <span class="number">1</span> ? left[i][j<span class="number">-1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = R - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = C - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == R - <span class="number">1</span>) &#123;</span><br><span class="line">                    down[i][j] = grid[i][j] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    down[i][j] = grid[i][j] == <span class="number">1</span> ? down[i+<span class="number">1</span>][j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == C - <span class="number">1</span>) &#123;</span><br><span class="line">                    right[i][j] = grid[i][j] == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right[i][j] = grid[i][j] == <span class="number">1</span> ? right[i][j+<span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="built_in">min</span>(up[i][j], left[i][j]); k &gt; ans; --k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> corner_i = i - k + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> corner_j = j - k + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (down[corner_i][corner_j] &gt;= k &amp;&amp; right[corner_i][corner_j] &gt;= k) &#123;</span><br><span class="line">                        ans = k;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1140-Stone-Game-II"><a href="#1140-Stone-Game-II" class="headerlink" title="1140. Stone Game II"></a>1140. Stone Game II</h2><p>常规思路就是一个DP。这里采用了top-down的memorization的写法，实现起来更好实现。<br>状态转移方程。<br>dp[begin][M] = max(sum of prefix + sum of suffix - dp[begin + X][max(X, M)]), for X in [1, 2 * M].</p>
<p>时间复杂度: O(N^2),<br>空间复杂度: O(N^2).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurse</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> begin, <span class="keyword">int</span> M, <span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= piles.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[player].<span class="built_in">find</span>(&#123;begin, M&#125;) != dp[player].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[player][&#123;begin, M&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> X = <span class="number">1</span>; X &lt;= <span class="number">2</span> * M &amp;&amp; begin - <span class="number">1</span> + X &lt; piles.<span class="built_in">size</span>() ; ++X) &#123;</span><br><span class="line">            add += piles[begin - <span class="number">1</span> + X];</span><br><span class="line">            dp[player][&#123;begin, M&#125;] = <span class="built_in">max</span>(dp[player][&#123;begin, M&#125;], add + s[begin + X] - <span class="built_in">recurse</span>(piles, begin + X, <span class="built_in">max</span>(M, X), <span class="number">1</span> - player));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[player][&#123;begin, M&#125;];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        dp.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">        s.<span class="built_in">resize</span>(piles.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        s.<span class="built_in">back</span>() = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = piles.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            s[i] = piles[i] + s[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recurse</span>(piles, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 148</title>
    <url>/2019/08/04/LeetCode-weekly-contest-148/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>77 / 5319</td>
<td>YoungForest</td>
<td>23</td>
<td>0:56:45</td>
<td>0:09:51</td>
<td>0:24:02</td>
<td>0:41:20</td>
<td>0:56:45</td>
</tr>
</tbody></table>
<p>本次比赛是我时隔3个月再次进入前100名，也是连续2次进入前200名，还是有些小开心的。算是一扫上周kick start 翻车的阴郁。<br>事实上，由于<a href="https://leetcode.com/problems/longest-chunked-palindrome-decomposition/discuss/350633/Wrong-problem-constraints-rejudge-all-wrong-submissions">评测机的问题</a>，我比赛刚结束时看到的排名是56名。后来官方有重新评测了最后一题，有些人的提交就可以过了，也没有罚时了。<br>本次比赛也是质量蛮高，题目不是很难，但考察的知识点很全面，难度分布也比较合理。</p>
<h2 id="1144-Decrease-Elements-To-Make-Array-Zigzag"><a href="#1144-Decrease-Elements-To-Make-Array-Zigzag" class="headerlink" title="1144. Decrease Elements To Make Array Zigzag"></a>1144. Decrease Elements To Make Array Zigzag</h2><p>因为只能减1嘛，所以是到Easy题目。如果题目改成加1或减1，会难的多。<br>只需要比较2种情况，选择小的即可。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movesToMakeZigzag</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> neighbor = INF;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                neighbor = <span class="built_in">min</span>(neighbor, nums[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                neighbor = <span class="built_in">min</span>(neighbor, nums[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (neighbor != INF &amp;&amp; neighbor &lt;= nums[i]) &#123;</span><br><span class="line">                ans1 += nums[i] - neighbor + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> neighbor = INF;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                neighbor = <span class="built_in">min</span>(neighbor, nums[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                neighbor = <span class="built_in">min</span>(neighbor, nums[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (neighbor != INF &amp;&amp; neighbor &lt;= nums[i]) &#123;</span><br><span class="line">                ans2 += nums[i] - neighbor + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(ans1, ans2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1145-Binary-Tree-Coloring-Game"><a href="#1145-Binary-Tree-Coloring-Game" class="headerlink" title="1145. Binary Tree Coloring Game"></a>1145. Binary Tree Coloring Game</h2><p>本题的难点在于理解题意。思路倒是十分直观，尽量选择最大的分支。如果大分支的数量大于一半，则必胜。<br>树的问题用递归，模版还是一个DFS。</p>
<p>时间复杂度: O(N), 遍历每个节点1次；<br>空间复杂度: O(N). 树的深度，最差为N。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="comment">// return the number of node in subtree</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">dfs</span>(root-&gt;left, x);</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">dfs</span>(root-&gt;right, x);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == x) &#123;</span><br><span class="line">            l = left;</span><br><span class="line">            r = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">btreeGameWinningMove</span><span class="params">(TreeNode* root, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, x);</span><br><span class="line">        <span class="keyword">if</span> (n == l + r + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l != r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = n - l - r - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> parent - <span class="number">1</span> &gt; l + r || l - <span class="number">1</span> &gt; r + parent || r - <span class="number">1</span> &gt; l + parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1146-Snapshot-Array"><a href="#1146-Snapshot-Array" class="headerlink" title="1146. Snapshot Array"></a>1146. Snapshot Array</h2><p>比较暴力的思路是每次snap，保存一次所有状态。<code>snap</code>函数的时间，空间上会比较大。<br>另一个比较巧妙，但也不是很难想出来的思路是，每次保存变化的内容。我采用的是这种解法。</p>
<p>时间复杂度:</p>
<ul>
<li>SnapshotArray: O(N)</li>
<li>set: O(1)</li>
<li>snap:  O(1)</li>
<li>get: O(log N)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span> &#123;</span></span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; data;</span><br><span class="line">    <span class="keyword">int</span> current_snap_id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SnapshotArray</span>(<span class="keyword">int</span> length) &#123;</span><br><span class="line">        data.<span class="built_in">resize</span>(length, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;(<span class="number">1</span>, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        data[index].<span class="built_in">push_back</span>(&#123;current_snap_id, val&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current_snap_id++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> snap_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; target = data[index];</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(target.<span class="built_in">begin</span>(), target.<span class="built_in">end</span>(), <span class="built_in">make_pair</span>(snap_id, INF));</span><br><span class="line">        --it;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SnapshotArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SnapshotArray* obj = new SnapshotArray(length);</span></span><br><span class="line"><span class="comment"> * obj-&gt;set(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;snap();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;get(index,snap_id);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1147-Longest-Chunked-Palindrome-Decomposition"><a href="#1147-Longest-Chunked-Palindrome-Decomposition" class="headerlink" title="1147. Longest Chunked Palindrome Decomposition"></a>1147. Longest Chunked Palindrome Decomposition</h2><p>Greedy。每次贪心的寻找相等的头和尾。<br>时间复杂度：O(n ^ 2),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">const</span> string&amp; text, <span class="keyword">int</span> begin1, <span class="keyword">int</span> end1, <span class="keyword">int</span> begin2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end1 - begin1 != end2 - begin2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end1 - begin1; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[begin1 + i] != text[begin2 + i]) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurse</span><span class="params">(<span class="keyword">const</span> string&amp; text, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; begin + i &lt;= end - i; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">equal</span>(text, begin, begin + i, end - i, end)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">recurse</span>(text, begin + i, end - i) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestDecomposition</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recurse</span>(text, <span class="number">0</span>, text.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 149</title>
    <url>/2019/08/11/LeetCode-weekly-contest-149/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (6)</th>
<th>Q4 (9)</th>
</tr>
</thead>
<tbody><tr>
<td>476 / 5091</td>
<td>YoungForest</td>
<td>15</td>
<td>1:00:14</td>
<td>0:10:21</td>
<td>0:42:14</td>
<td>1:00:14</td>
<td>null</td>
</tr>
</tbody></table>
<p>惭愧的排名又落到400+了。最后一题有半个小时可以解决，一直试图用线段树来做。像kick start round D一样，沉迷于线段树而翻车。获得的教训是，不要纠结与区间问题一定要用线段树做，常常还有其他更简单的做法。</p>
<h2 id="1154-Day-of-the-Year"><a href="#1154-Day-of-the-Year" class="headerlink" title="1154. Day of the Year"></a>1154. Day of the Year</h2><p>判断闰年，累加之前月份的日子。<br>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> yy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (yy % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; yy % <span class="number">100</span> != <span class="number">0</span>) || yy % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dayOfYear</span><span class="params">(string date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> yy = <span class="built_in">stoi</span>(date.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">auto</span> mm = <span class="built_in">stoi</span>(date.<span class="built_in">substr</span>(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">auto</span> dd = <span class="built_in">stoi</span>(date.<span class="built_in">substr</span>(<span class="number">8</span>, <span class="number">2</span>));</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; days = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isLeap</span>(yy)) &#123;</span><br><span class="line">            days[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans += <span class="built_in">accumulate</span>(days.<span class="built_in">cbegin</span>(), days.<span class="built_in">cbegin</span>() + mm, <span class="number">0</span>);</span><br><span class="line">        ans += dd;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1155-Number-of-Dice-Rolls-With-Target-Sum"><a href="#1155-Number-of-Dice-Rolls-With-Target-Sum" class="headerlink" title="1155. Number of Dice Rolls With Target Sum"></a>1155. Number of Dice Rolls With Target Sum</h2><p>隔板插空，经典的排列组合问题。由于2个隔板之前的间隔不能大于骰子最大的数字，所以不能直接用数学公式求解。我采用了回溯法，使用了memorization，所以也算是DP。</p>
<p>时间复杂度: O(N ^ 2),<br>空间复杂度: O(d * bar).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> f;</span><br><span class="line">    map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="comment">// [begin, end), the index of insert bar</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> bar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(&#123;begin, bar&#125;) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[&#123;begin, bar&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bar == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end - begin + <span class="number">1</span> &lt;= f)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end &amp;&amp; i - begin + <span class="number">1</span> &lt;= f; ++i) &#123;</span><br><span class="line">            <span class="comment">// insert in i</span></span><br><span class="line">            ans += <span class="built_in">backtracking</span>(i + <span class="number">1</span>, end, bar - <span class="number">1</span>);</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[&#123;begin, bar&#125;] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;f = f;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">backtracking</span>(<span class="number">0</span>, target - <span class="number">1</span>, d - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1156-Swap-For-Longest-Repeated-Character-Substring"><a href="#1156-Swap-For-Longest-Repeated-Character-Substring" class="headerlink" title="1156. Swap For Longest Repeated Character Substring"></a>1156. Swap For Longest Repeated Character Substring</h2><p>One pass, 更新可以获得的最长长度。<br>需要观察到: 最长长度的获得和中间空的字母无关，而只和前后有无需要的字母有关。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxRepOpt1</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">v</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">char</span> last = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i] == last) &#123;</span><br><span class="line">                v[text[i] - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">back</span>().second = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v[text[i] - <span class="string">&#x27;a&#x27;</span>].<span class="built_in">push_back</span>(&#123;i, i + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            last = text[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; row : v) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == row.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (row.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, row[i].second - row[i].first);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, row[i].second - row[i].first + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; a = row[i];</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b = row[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (a.second + <span class="number">1</span> == b.first) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (row.<span class="built_in">size</span>() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                            ans = <span class="built_in">max</span>(ans, a.second - a.first + b.second - b.first + <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ans = <span class="built_in">max</span>(ans, a.second - a.first + b.second - b.first);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans = <span class="built_in">max</span>(ans, a.second - a.first + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1157-Online-Majority-Element-In-Subarray"><a href="#1157-Online-Majority-Element-In-Subarray" class="headerlink" title="1157. Online Majority Element In Subarray"></a>1157. Online Majority Element In Subarray</h2><p>random pick + binary search.</p>
<p>时间复杂度: O(log N).<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MajorityChecker</span> &#123;</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; appear_index;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MajorityChecker</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            appear_index[arr[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        std::random_device dev;</span><br><span class="line">        <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(dev())</span></span>;</span><br><span class="line">        <span class="function">std::uniform_int_distribution&lt;std::mt19937::result_type&gt; <span class="title">dist6</span><span class="params">(left,right)</span></span>; <span class="comment">// distribution in range [left, right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = arr[<span class="built_in">dist6</span>(rng)];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; index = appear_index[a];</span><br><span class="line">            <span class="keyword">auto</span> l = <span class="built_in">lower_bound</span>(index.<span class="built_in">cbegin</span>(), index.<span class="built_in">cend</span>(), left);</span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">upper_bound</span>(index.<span class="built_in">cbegin</span>(), index.<span class="built_in">cend</span>(), right);</span><br><span class="line">            <span class="keyword">if</span> (r - l &gt;= threshold) &#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MajorityChecker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MajorityChecker* obj = new MajorityChecker(arr);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;query(left,right,threshold);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 150</title>
    <url>/2019/08/19/LeetCode-weekly-contest-150/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>476 / 5091</td>
<td>YoungForest</td>
<td>19</td>
<td>1:31:13</td>
<td>0:03:52</td>
<td>0:09:23</td>
<td>1:16:13  2</td>
<td>0:50:16  1</td>
</tr>
</tbody></table>
<p>本次比赛效果同样不佳，排名在400+。直接原因是第3题的搜索剪枝花费了太长时间，没有一步到位。根本原因是最近2周好不容易放假在家，放松了练习，刷题基本停止了，自然手上的功夫就荒废了。真应了那句“业精于勤荒于嬉”呀。上周的排名同样很差。</p>
<h2 id="1160-Find-Words-That-Can-Be-Formed-by-Characters"><a href="#1160-Find-Words-That-Can-Be-Formed-by-Characters" class="headerlink" title="1160. Find Words That Can Be Formed by Characters"></a>1160. Find Words That Can Be Formed by Characters</h2><p>常规的字母计数问题，用hashmap存储即可。需要注意的是，每次判断一个word的时候，需要获得一次拷贝。</p>
<p>时间复杂度: O(chars.size() + words.size() * word.size()),<br>空间复杂度: O(26)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(vector&lt;string&gt;&amp; words, string chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            ++count[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : words) &#123;</span><br><span class="line">            <span class="keyword">auto</span> count_copy = count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">                --count_copy[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span> (count_copy[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += s.<span class="built_in">size</span>();</span><br><span class="line">            next:</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1161-Maximum-Level-Sum-of-a-Binary-Tree"><a href="#1161-Maximum-Level-Sum-of-a-Binary-Tree" class="headerlink" title="1161. Maximum Level Sum of a Binary Tree"></a>1161. Maximum Level Sum of a Binary Tree</h2><p>先获得每一层的和，再取得最大值。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sum_of_level;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt; sum_of_level.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum_of_level.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sum_of_level[depth<span class="number">-1</span>] += root-&gt;val;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLevelSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sum_of_level.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum_of_level[i] &gt; sum_of_level[ans]) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1162-As-Far-from-Land-as-Possible"><a href="#1162-As-Far-from-Land-as-Possible" class="headerlink" title="1162. As Far from Land as Possible"></a>1162. As Far from Land as Possible</h2><p>从陆地出发，进行DFS。<br>剪枝条件比较复杂，需要注意：<br><code>((src_i == i &amp;&amp; src_j == j) || (direct_i == di[k]) || (direct_j == dj[k]) || (direct_i == 0 &amp;&amp; dj[k] == 0) || (direct_j == 0 &amp;&amp; di[k] == 0)) &amp;&amp; grid[ni][nj] != 1</code>。<br>分别是</p>
<ul>
<li>搜索方向与之前的一直<ul>
<li>本次出发点就在原点</li>
<li>row方向一致</li>
<li>column方向一致</li>
<li>之前没有在row方向走，现在往row方向走</li>
<li>之前没有在column方向走，现在往column方向走</li>
</ul>
</li>
<li>不是陆地</li>
</ul>
<p>时间复杂度: O((row<em>column) ^ 2),<br>空间复杂度: O(row</em>column).</p>
<p>事实上，更好的算法是使用BFS。初始点为所有的陆地。BFS可以保证每个cell只被访问一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; distance, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> depth, <span class="keyword">int</span> src_i, <span class="keyword">int</span> src_j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (distance[i][j] != <span class="number">-1</span> &amp;&amp; depth &gt;= distance[i][j]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        distance[i][j] = depth;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> ni = di[k] + i;</span><br><span class="line">            <span class="keyword">int</span> nj = dj[k] + j;</span><br><span class="line">            <span class="keyword">int</span> direct_i = (i - src_i) == <span class="number">0</span> ? <span class="number">0</span> : (i - src_i) / <span class="built_in">abs</span>(i - src_i);</span><br><span class="line">            <span class="keyword">int</span> direct_j = (j - src_j) == <span class="number">0</span> ? <span class="number">0</span> : (j - src_j) / <span class="built_in">abs</span>(j - src_j);</span><br><span class="line">            <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; grid.<span class="built_in">size</span>() &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; ((src_i == i &amp;&amp; src_j == j) || (direct_i == di[k]) || (direct_j == dj[k]) || (direct_i == <span class="number">0</span> &amp;&amp; dj[k] == <span class="number">0</span>) || (direct_j == <span class="number">0</span> &amp;&amp; di[k] == <span class="number">0</span>)) &amp;&amp; grid[ni][nj] != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, distance, ni, nj, depth + <span class="number">1</span>, src_i, src_j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> distance = grid;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distance.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            std::<span class="built_in">fill</span>(distance[i].<span class="built_in">begin</span>(), distance[i].<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, distance, i, j, <span class="number">0</span>, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distance.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; distance[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, distance[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1163-Last-Substring-in-Lexicographical-Order"><a href="#1163-Last-Substring-in-Lexicographical-Order" class="headerlink" title="1163. Last Substring in Lexicographical Order"></a>1163. Last Substring in Lexicographical Order</h2><p>答案可能是从某个字母出发，然后到字符串末尾的。<br>首字母肯定是最大的字母。<br>每次挑选出来最大的字母，然后再挑选第二个字母，依次向后找，直到剩下一个候选。<br>有剪枝的情况是’zzzz’这种情况。大家都是最大的字母，此时候选者只有第一个最大字母。</p>
<p>时间复杂度：O(N). 由于有剪枝条件，所以候选者的数量为<code>N + N / 2 + N / 4 + ... + 1 = 2 * N</code>.<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    find the first maximum char, then compare next char</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">lastSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q; <span class="comment">// begin index, compare length</span></span><br><span class="line">        <span class="keyword">char</span> maximum_char = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt; maximum_char) &#123;</span><br><span class="line">                maximum_char = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == maximum_char) &#123;</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;i, <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> mc = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; nq;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : q) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.first + p.second &lt; s.<span class="built_in">size</span>() &amp;&amp; s[p.first + p.second] &gt; mc) &#123;</span><br><span class="line">                    mc = s[p.first + p.second];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : q) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.first + p.second &lt; s.<span class="built_in">size</span>() &amp;&amp; s[p.first + p.second] == mc) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mc == maximum_char &amp;&amp; p.first &gt; <span class="number">0</span> &amp;&amp; s[p.first  - <span class="number">1</span>] == mc) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nq.<span class="built_in">push_back</span>(&#123;p.first, p.second + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(q, nq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(q.<span class="built_in">back</span>().first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>曾经在知乎上写过一个很用心的答案<a href="https://www.zhihu.com/question/280279208/answer/704774024">大家都是如何刷 LeetCode 的</a>。这几个月来不断有同学关注我，甚至评论说会进一步关注我的动向。我本不应让他们失望，收拾起慵懒的心情，以一个奋斗逼的心态去迎接新的学期吧！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 151</title>
    <url>/2019/08/31/LeetCode-weekly-contest-151/</url>
    <content><![CDATA[<p>这周去字节跳动参加夏令营了，周日还需要上课，所以就鸽了周赛。那你怎么能参加kick start呢？毕竟本月的round E是所谓的黄金轮次，对面试获取名额很重要，所以我选择翘掉夏令营。</p>
<p>夏令营结束后，按约补题。不得不说，LeetCode比Kick start的难度还是要低不少的。感觉Kick start的签到题难度是Medium，后2题是Hard。</p>
<h2 id="1169-Invalid-Transactions"><a href="#1169-Invalid-Transactions" class="headerlink" title="1169. Invalid Transactions"></a>1169. Invalid Transactions</h2><p>考察字符串处理。由于transactions.lenght &lt; 1000, 所以及时是暴力方法也是可以的。事实上，我实现的优化方法在最坏情况下，并没有变好。</p>
<p>时间复杂度: O(N^2).<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">invalidTransactions</span><span class="params">(vector&lt;string&gt;&amp; transactions)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, string&gt;&gt;&gt; name_trasactions;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : transactions) &#123;</span><br><span class="line">            <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">            string tmp;</span><br><span class="line">            vector&lt;string&gt; v;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            name_trasactions[v[<span class="number">0</span>]].<span class="built_in">push_back</span>(&#123;<span class="built_in">stoi</span>(v[<span class="number">1</span>]), <span class="built_in">stoi</span>(v[<span class="number">2</span>]), v[<span class="number">3</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : name_trasactions) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(p.second.<span class="built_in">begin</span>(), p.second.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; r &lt; p.second.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (get&lt;<span class="number">1</span>&gt;(p.second[r]) &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">insert</span>(p.first + <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(get&lt;<span class="number">0</span>&gt;(p.second[r])) + <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(get&lt;<span class="number">1</span>&gt;(p.second[r]))+ <span class="string">&quot;,&quot;</span> + get&lt;<span class="number">2</span>&gt;(p.second[r]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (get&lt;<span class="number">0</span>&gt;(p.second[r]) - get&lt;<span class="number">0</span>&gt;(p.second[l]) &gt; <span class="number">60</span>) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (get&lt;<span class="number">2</span>&gt;(p.second[r]) != get&lt;<span class="number">2</span>&gt;(p.second[i])) &#123;</span><br><span class="line">                        ans.<span class="built_in">insert</span>(p.first + <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(get&lt;<span class="number">0</span>&gt;(p.second[r])) + <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(get&lt;<span class="number">1</span>&gt;(p.second[r]))+ <span class="string">&quot;,&quot;</span> + get&lt;<span class="number">2</span>&gt;(p.second[r]));</span><br><span class="line">                        ans.<span class="built_in">insert</span>(p.first + <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(get&lt;<span class="number">0</span>&gt;(p.second[i])) + <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(get&lt;<span class="number">1</span>&gt;(p.second[i]))+ <span class="string">&quot;,&quot;</span> + get&lt;<span class="number">2</span>&gt;(p.second[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;string&gt;(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1170-Compare-Strings-by-Frequency-of-the-Smallest-Character"><a href="#1170-Compare-Strings-by-Frequency-of-the-Smallest-Character" class="headerlink" title="1170. Compare Strings by Frequency of the Smallest Character"></a>1170. Compare Strings by Frequency of the Smallest Character</h2><p>简单的二分查找。</p>
<p>时间复杂度: O(queries.length * queries[i].length * log words.length),<br>空间复杂度: O(queries.length + words.length).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> mi = <span class="string">&#x27;z&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == mi) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; mi) &#123;</span><br><span class="line">                mi = c;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">numSmallerByFrequency</span><span class="params">(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; w : words) &#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(<span class="built_in">f</span>(w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; q : queries) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="built_in">f</span>(q);</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), c);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">distance</span>(it, a.<span class="built_in">end</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List"><a href="#1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List" class="headerlink" title="1171. Remove Zero Sum Consecutive Nodes from Linked List"></a>1171. Remove Zero Sum Consecutive Nodes from Linked List</h2><p>考察链表操作。为了快速找到对应元素和删除元素，我们需要使用一个hash table来存储前缀和和节点的映射关系。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode* current = head;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, ListNode*&gt; m;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        m[<span class="number">0</span>] = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (current) &#123;</span><br><span class="line">            sum += current-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(sum) != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> delete_head = m[sum]-&gt;next;</span><br><span class="line">                m[sum]-&gt;next = current-&gt;next;</span><br><span class="line">                current-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">int</span> delete_sum = sum;</span><br><span class="line">                <span class="keyword">while</span> (delete_head) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = delete_head;</span><br><span class="line">                    delete_sum += tmp-&gt;val;</span><br><span class="line">                    <span class="keyword">if</span> (delete_sum != sum)</span><br><span class="line">                        m.<span class="built_in">erase</span>(delete_sum);</span><br><span class="line">                    delete_head = delete_head-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                current = m[sum]-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[sum] = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1172-Dinner-Plate-Stacks"><a href="#1172-Dinner-Plate-Stacks" class="headerlink" title="1172. Dinner Plate Stacks"></a>1172. Dinner Plate Stacks</h2><p>用多个栈来模拟一个栈。<br>实现不复杂，但是需要考虑比较多的边界条件。每个函数如何使栈的状态发生改变。</p>
<p>时间复杂度: O(1).<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DinnerPlates</span> &#123;</span></span><br><span class="line">    vector&lt;stack&lt;<span class="keyword">int</span>&gt;&gt; stacks;</span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; condidates;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DinnerPlates</span>(<span class="keyword">int</span> capacity_) : <span class="built_in">capacity</span>(capacity_) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (condidates.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            condidates.<span class="built_in">insert</span>(stacks.<span class="built_in">size</span>());</span><br><span class="line">            stacks.<span class="built_in">push_back</span>(stack&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = *condidates.<span class="built_in">begin</span>();</span><br><span class="line">        stacks[target].<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (stacks[target].<span class="built_in">size</span>() == capacity) &#123;</span><br><span class="line">            condidates.<span class="built_in">erase</span>(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stacks.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = stacks.<span class="built_in">back</span>().<span class="built_in">top</span>();</span><br><span class="line">        stacks.<span class="built_in">back</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!stacks.<span class="built_in">empty</span>() &amp;&amp; stacks.<span class="built_in">back</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stacks.<span class="built_in">pop_back</span>();</span><br><span class="line">            condidates.<span class="built_in">erase</span>(stacks.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stacks.<span class="built_in">empty</span>() &amp;&amp; stacks.<span class="built_in">back</span>().<span class="built_in">size</span>() &lt; capacity) &#123;</span><br><span class="line">            condidates.<span class="built_in">insert</span>(stacks.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">popAtStack</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= stacks.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (stacks[index].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == stacks.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> ret = stacks[index].<span class="built_in">top</span>();</span><br><span class="line">        stacks[index].<span class="built_in">pop</span>();</span><br><span class="line">        condidates.<span class="built_in">insert</span>(index);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your DinnerPlates object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * DinnerPlates* obj = new DinnerPlates(capacity);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;popAtStack(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 152</title>
    <url>/2019/09/01/LeetCode-weekly-contest-152/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>111 / 5333</td>
<td>YoungForest</td>
<td>18</td>
<td>1:11:49</td>
<td>0:11:56  1</td>
<td>0:21:44  1</td>
<td>0:37:27</td>
<td>1:01:49</td>
</tr>
</tbody></table>
<p>本期比赛由于粗心，第一题忘记考虑corner case，0的排列是1；第二题干脆upper lower写反了。获得2次罚时。否则应该可以进入前100的。题目比较简单，都是常规题目，之前的原题改改就行。</p>
<h2 id="1175-Prime-Arrangements"><a href="#1175-Prime-Arrangements" class="headerlink" title="1175. Prime Arrangements"></a>1175. Prime Arrangements</h2><p>筛法求素数 + 排列组合。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> modulo = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, ll&gt; memo;</span><br><span class="line">    <span class="function">ll <span class="title">A</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(x) == memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            memo[x] = (x * <span class="built_in">A</span>(x - <span class="number">1</span>)) % modulo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[x];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPrimeArrangements</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * i &lt; n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    a[j * i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">A</span>(count) * <span class="built_in">A</span>(n - count)) % modulo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1176-Diet-Plan-Performance"><a href="#1176-Diet-Plan-Performance" class="headerlink" title="1176. Diet Plan Performance"></a>1176. Diet Plan Performance</h2><p>简单的滑动窗口。竟然因为粗心错了一次。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dietPlanPerformance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; calories, <span class="keyword">int</span> k, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; calories.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(calories.<span class="built_in">begin</span>(), calories.<span class="built_in">begin</span>() + k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; upper)</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; lower)</span><br><span class="line">            --ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; calories.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            sum = sum + calories[i] - calories[i - k];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; upper)</span><br><span class="line">                ++ans;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; lower)</span><br><span class="line">                --ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5175-Can-Make-Palindrome-from-Substring"><a href="#5175-Can-Make-Palindrome-from-Substring" class="headerlink" title="5175. Can Make Palindrome from Substring"></a>5175. Can Make Palindrome from Substring</h2><p>对回文字符串要敏感。观察有：回文串只允许一个字母的数量是奇数，没多一个替换，多2个允许的单数。</p>
<p>时间复杂度：O(max(s.size(), queries.size()).<br>空间复杂度: O(max(s.size(), queries.size()).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">canMakePaliQueries</span><span class="params">(string s, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">prefix</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        prefix[<span class="number">0</span>] = count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>() + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            ++count[s[i - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            prefix[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">ans</span><span class="params">(queries.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; queries.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; query = queries[j];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; l = prefix[query[<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; r = prefix[query[<span class="number">1</span>] + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; r[i] &lt;&lt; &quot;, &quot; &lt;&lt; l[i] &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">int</span> sub = r[i] - l[i];</span><br><span class="line">                <span class="keyword">if</span> (sub % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    ++odd;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[j] = odd &lt;= <span class="number">1</span> + <span class="number">2</span> * query[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1178-Number-of-Valid-Words-for-Each-Puzzle"><a href="#1178-Number-of-Valid-Words-for-Each-Puzzle" class="headerlink" title="1178. Number of Valid Words for Each Puzzle"></a>1178. Number of Valid Words for Each Puzzle</h2><p>字典树的变种。</p>
<p>首先起码想到暴力解法，每个puzzle和每个word去匹配。时间复杂度为 O(words.length * puzzles.length), 肯定会超时。<br>优化方向是，整合word的信息，字典树是一个很好的数据结构。</p>
<p>时间复杂度: O(2^puzzles[i].length * puzzles.length, words.length * words[i].length).<br>空间复杂度: O(puzzles.length + min(2 ^ 26, words.length)).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">        shared_ptr&lt;Trie&gt; zero, one;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    shared_ptr&lt;Trie&gt; root;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">bool</span>&gt;&amp; appear, <span class="keyword">int</span> begin, shared_ptr&lt;Trie&gt; current, <span class="keyword">int</span> special)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (special == begin) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(appear, begin + <span class="number">1</span>, current-&gt;one, special) + current-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (appear[begin]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(appear, begin + <span class="number">1</span>, current-&gt;zero, special) + <span class="built_in">dfs</span>(appear, begin + <span class="number">1</span>, current-&gt;one, special) + current-&gt;value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dfs</span>(appear, begin + <span class="number">1</span>, current-&gt;zero, special) + current-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findNumOfValidWords</span><span class="params">(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles)</span> </span>&#123;</span><br><span class="line">        root = make_shared&lt;Trie&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> string&amp; w : words) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">appear</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : w) &#123;</span><br><span class="line">                appear[c - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> current = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">bool</span> b : appear) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current-&gt;one == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        current-&gt;one = make_shared&lt;Trie&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    current = current-&gt;one;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current-&gt;zero == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        current-&gt;zero = make_shared&lt;Trie&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    current = current-&gt;zero;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++current-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(puzzles.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; puzzles.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; puzzle = puzzles[i];</span><br><span class="line">            <span class="keyword">auto</span> current = root;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">appear</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : puzzle) &#123;</span><br><span class="line">                appear[c - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = <span class="built_in">dfs</span>(appear, <span class="number">0</span>, root, puzzle[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 153</title>
    <url>/2019/09/15/LeetCode-weekly-contest-153/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>392 / 6212</td>
<td>YoungForest</td>
<td>12</td>
<td>0:41:42</td>
<td>0:06:46  1</td>
<td>0:16:11</td>
<td>0:36:42</td>
<td>null</td>
</tr>
</tbody></table>
<p>本次比赛是我在国内的最后一场了。由于比利时这边时差的原因，每周的周赛是周日的早上4点半到6点。所以我并没有条件参加，只能每周日早上起来补题了。</p>
<h2 id="1184-Distance-Between-Bus-Stops"><a href="#1184-Distance-Between-Bus-Stops" class="headerlink" title="1184. Distance Between Bus Stops"></a>1184. Distance Between Bus Stops</h2><p>Two pass。正着走一遍，总共走一遍，然后总的路程减去正的路程就是反的路程。<br>这里要注意start必须在destination之前，否则要换一下位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distanceBetweenBusStops</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; distance, <span class="keyword">int</span> start, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="built_in">accumulate</span>(distance.<span class="built_in">begin</span>(), distance.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (start &gt; destination)</span><br><span class="line">            <span class="built_in">swap</span>(start, destination);</span><br><span class="line">        <span class="keyword">int</span> clockwise = <span class="built_in">accumulate</span>(distance.<span class="built_in">begin</span>() + start, distance.<span class="built_in">begin</span>() + destination, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> counterclockwise = total - clockwise;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(clockwise, counterclockwise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1185-Day-of-the-Week"><a href="#1185-Day-of-the-Week" class="headerlink" title="1185. Day of the Week"></a>1185. Day of the Week</h2><p>经典的日历问题。需要注意的点是 闰年 的处理。</p>
<p>时间复杂度: O(year * month),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">dayOfTheWeek</span><span class="params">(<span class="keyword">int</span> day, <span class="keyword">int</span> month, <span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; v = &#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; monthes = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>,<span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1971</span>; i &lt; year; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isLeap</span>(i)) &#123;</span><br><span class="line">                count += <span class="number">366</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count += <span class="number">365</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isLeap</span>(year)) &#123;</span><br><span class="line">            monthes[<span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="built_in">accumulate</span>(monthes.<span class="built_in">begin</span>(), monthes.<span class="built_in">begin</span>() + month, <span class="number">0</span>);</span><br><span class="line">        count += day;</span><br><span class="line">        count %= <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">return</span> v[count];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1186-Maximum-Subarray-Sum-with-One-Deletion"><a href="#1186-Maximum-Subarray-Sum-with-One-Deletion" class="headerlink" title="1186. Maximum Subarray Sum with One Deletion"></a>1186. Maximum Subarray Sum with One Deletion</h2><p>动态规划。<br>第i位的结果可以由第i - 1位的结果获得。<br>因为最多删除一个，所以DP需要维护2个最小值，一个是删了一个的，另一个是每删的。另外需要维护可以删除的最小值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp_delete</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">dp_nodelete</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">dp_which_min</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ret = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp_nodelete[i - <span class="number">1</span>] + arr[i - <span class="number">1</span>] &gt;= arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp_which_min[i] = <span class="built_in">min</span>(dp_which_min[i - <span class="number">1</span>], arr[i - <span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp_which_min[i] = arr[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            dp_nodelete[i] = <span class="built_in">max</span>(dp_nodelete[i - <span class="number">1</span>] + arr[i - <span class="number">1</span>], arr[i - <span class="number">1</span>]);</span><br><span class="line">            dp_delete[i] = <span class="built_in">max</span>(dp_delete[i - <span class="number">1</span>] + arr[i - <span class="number">1</span>], dp_nodelete[i - <span class="number">1</span>] + arr[i - <span class="number">1</span>] - dp_which_min[i - <span class="number">1</span>]);</span><br><span class="line">            ret = <span class="built_in">max</span>(&#123;ret, dp_nodelete[i], dp_delete[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N). 可以优化为 O(1).</p>
<h2 id="1187-Make-Array-Strictly-Increasing"><a href="#1187-Make-Array-Strictly-Increasing" class="headerlink" title="1187. Make Array Strictly Increasing"></a>1187. Make Array Strictly Increasing</h2><p>比较暴力的方法，DFS + memorization.<br>每次向下一位搜索时有替换和不替换2种选择，配合剪枝和memorization加速。<br>可以发现，最坏情况下搜索的空间只是n * m而已，因为memo。</p>
<p>时间复杂度: O(n * m * log m)，<br>空间复杂度: O(n * m)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> FAIL = <span class="number">3000</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2, <span class="keyword">int</span> i, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == arr1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">find</span>(i) != memo.<span class="built_in">end</span>() &amp;&amp; memo[i].<span class="built_in">find</span>(prev) != memo[i].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][prev];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pickarr2</span></span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>(), prev);</span><br><span class="line">        <span class="keyword">if</span> (arr1[i] &gt; prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it != arr2.<span class="built_in">end</span>() &amp;&amp; *it &lt; arr1[i])</span><br><span class="line">                <span class="keyword">return</span> memo[i][prev] = <span class="built_in">min</span>(<span class="built_in">dfs</span>(arr1, arr2, i + <span class="number">1</span>, arr1[i]), <span class="built_in">dfs</span>(arr1, arr2, i + <span class="number">1</span>, *it) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> memo[i][prev] = <span class="built_in">dfs</span>(arr1, arr2, i + <span class="number">1</span>, arr1[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (it == arr2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[i][prev] = FAIL;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[i][prev] = <span class="built_in">dfs</span>(arr1, arr2, i + <span class="number">1</span>, *it) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">makeArrayIncreasing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">dfs</span>(arr1, arr2, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= FAIL) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 154</title>
    <url>/2019/09/18/LeetCode-weekly-contest-154/</url>
    <content><![CDATA[<p>上周末在比利时，比赛时间是凌晨的4点半到6点，时间不合适，所以就没有参加。发现只有双周赛的时间是周六的下午4点半到6点，稍微合适些。ranking 2000的目标今年怕是要鸽了。最好的情况下，参与比赛的数目也只有国内的1/3.</p>
<h2 id="1189-Maximum-Number-of-Balloons"><a href="#1189-Maximum-Number-of-Balloons" class="headerlink" title="1189. Maximum Number of Balloons"></a>1189. Maximum Number of Balloons</h2><p>统计每个字母的频数即可。需要注意的是，l和o 需要2次才能组成一个ballon。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfBalloons</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> string once = <span class="string">&quot;ban&quot;</span>;</span><br><span class="line">        <span class="keyword">const</span> string twice = <span class="string">&quot;lo&quot;</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : text) &#123;</span><br><span class="line">            ++count[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : once) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, count[c - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : twice) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, count[c - <span class="string">&#x27;a&#x27;</span>] / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses"><a href="#1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses" class="headerlink" title="1190. Reverse Substrings Between Each Pair of Parentheses"></a>1190. Reverse Substrings Between Each Pair of Parentheses</h2><p>因为字符串的最大长度为2000，使用暴力法即可。用一个栈来进行括号匹配。</p>
<p>时间复杂度: O(N ^ 2),<br>空间负责度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> begin = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + begin, s.<span class="built_in">begin</span>() + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;)&#x27;</span> &amp;&amp; c != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看过discuss之后，发现时间复杂度为O(N)的Solution。<br>第一遍找到所有匹配的括号，第二遍构造结果字符串。每一个括号像一道传送门一样，改变前进方向的同时，跳到对应的括号那里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; opened, <span class="built_in">pair</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            opened.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = opened.<span class="built_in">back</span>();</span><br><span class="line">            opened.<span class="built_in">pop_back</span>();</span><br><span class="line">            pair[i] = j;</span><br><span class="line">            pair[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, d = <span class="number">1</span>; i &lt; n; i += d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            i = pair[i], d = -d;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res += s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1191-K-Concatenation-Maximum-Sum"><a href="#1191-K-Concatenation-Maximum-Sum" class="headerlink" title="1191. K-Concatenation Maximum Sum"></a>1191. K-Concatenation Maximum Sum</h2><p>子数组最大和问题。该题目的特殊之处在于数组可以重复k次。<br>仔细观察可以发现，当整个数组的和小于等于0时,根据贪心的思路，最后答案必定是数组重复2次组成的答案，即 本身的子数组，或 最大的前缀和 + 最大的后缀和。<br>当整个数组的和大于0时，答案为k-2个数组和 + 最大的前缀和 + 最大的后缀和</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kConcatenationMaxSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ll head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">        ll global_max = <span class="number">0</span>, local_max = <span class="number">0</span>;</span><br><span class="line">        ll prefix = <span class="number">0</span>, total_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] + prefix &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                prefix = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prefix = arr[i] + prefix;</span><br><span class="line">                local_max = <span class="built_in">max</span>(local_max, prefix);</span><br><span class="line">            &#125;</span><br><span class="line">            total_sum += arr[i];</span><br><span class="line">            head = <span class="built_in">max</span>(head, total_sum);</span><br><span class="line">            tail = <span class="built_in">min</span>(tail, total_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        tail = total_sum - tail;</span><br><span class="line">        tail = prefix;</span><br><span class="line">        <span class="keyword">if</span> (total_sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            global_max = tail + head + total_sum * (k - <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            global_max = head + tail;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        global_max = <span class="built_in">max</span>(global_max, local_max);</span><br><span class="line">        <span class="keyword">return</span> global_max % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1192-Critical-Connections-in-a-Network"><a href="#1192-Critical-Connections-in-a-Network" class="headerlink" title="1192. Critical Connections in a Network"></a>1192. Critical Connections in a Network</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 156</title>
    <url>/2019/10/04/LeetCode-weekly-contest-156/</url>
    <content><![CDATA[<p>赛后补题。</p>
<h2 id="1207-Unique-Number-of-Occurrences"><a href="#1207-Unique-Number-of-Occurrences" class="headerlink" title="1207. Unique Number of Occurrences"></a>1207. Unique Number of Occurrences</h2><p>Record the number of occurrences of each value by <code>unordered_map</code>.<br>Check the unique using <code>unordered_set</code>.</p>
<p>Time complexity: O(N),<br>Space complexity: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; seen;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            ++seen[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : seen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count.<span class="built_in">find</span>(p.second) != count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count.<span class="built_in">insert</span>(p.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1208-Get-Equal-Substrings-Within-Budget"><a href="#1208-Get-Equal-Substrings-Within-Budget" class="headerlink" title="1208. Get Equal Substrings Within Budget"></a>1208. Get Equal Substrings Within Budget</h2><p>Sliding window.<br>Use a sliding window to represent the available substring.</p>
<p>Time complexity: O(N),<br>space complexity: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">equalSubstring</span><span class="params">(string s, string t, <span class="keyword">const</span> <span class="keyword">int</span> maxCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// window: [left, right), length = right - left</span></span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>() &amp;&amp; cost + std::<span class="built_in">abs</span>(s[right] - t[right]) &lt;= maxCost) &#123;</span><br><span class="line">                cost += std::<span class="built_in">abs</span>(s[right] - t[right]);</span><br><span class="line">                ++right;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, right - left);</span><br><span class="line">            &#125;</span><br><span class="line">            cost -= std::<span class="built_in">abs</span>(s[left] - t[left]);</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1209-Remove-All-Adjacent-Duplicates-in-String-II"><a href="#1209-Remove-All-Adjacent-Duplicates-in-String-II" class="headerlink" title="1209. Remove All Adjacent Duplicates in String II"></a>1209. Remove All Adjacent Duplicates in String II</h2><p>One pass scan  and remove duplicates.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; accu; <span class="comment">// accumulate</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_accu;</span><br><span class="line">            <span class="keyword">if</span> (!ans.<span class="built_in">empty</span>() &amp;&amp; c == ans.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                new_accu = accu.<span class="built_in">back</span>() + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                new_accu = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (new_accu &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; new_accu - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    accu.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(c);</span><br><span class="line">                accu.<span class="built_in">push_back</span>(new_accu);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1210-Minimum-Moves-to-Reach-Target-with-Rotations"><a href="#1210-Minimum-Moves-to-Reach-Target-with-Rotations" class="headerlink" title="1210. Minimum Moves to Reach Target with Rotations"></a>1210. Minimum Moves to Reach Target with Rotations</h2><p>最小步数，而且n的大小在100以内，所以 可以用BFS解决。<br>本题的思路并不难，难点在于实现。由于不是直接的 BFS，实现 过程中 有 很多需要注意的点。</p>
<p>时间复杂度: O(N ^ 2),<br>空间复杂度: O(N ^ 2).</p>
<p>因为最近尝鲜学习了Rust这门新兴的语言，所以接下来的一些题目都会用rust而不是C++。目的是可以让自己有机会练习和熟悉这门新的语言。有时间和心情的同学也可以学一下这门新语言，如果之前的主语言是C++的话，学RUST真的很痛快。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">minimum_moves</span></span>(grid: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">let</span> n = grid.len() <span class="keyword">as</span> <span class="built_in">i32</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(n &gt;= <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">let</span> m = grid[<span class="number">0</span>].len() <span class="keyword">as</span> <span class="built_in">i32</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(n, m);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> q = VecDeque::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> seen = HashSet::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> level = <span class="number">1</span>;</span><br><span class="line">        q.push_back(((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line">        seen.insert(((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">while</span> !q.is_empty() &#123;</span><br><span class="line">            <span class="keyword">let</span> size = q.len();</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..size &#123;</span><br><span class="line">                <span class="keyword">let</span> current = q.pop_front();</span><br><span class="line">                <span class="keyword">match</span> current &#123;</span><br><span class="line">                    <span class="literal">Some</span>(value) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">let</span> next_step: [((<span class="built_in">i32</span>, <span class="built_in">i32</span>), (<span class="built_in">i32</span>, <span class="built_in">i32</span>)); <span class="number">4</span>] = [</span><br><span class="line">                            ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>)),</span><br><span class="line">                            ((<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>)),</span><br><span class="line">                            ((<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, -<span class="number">1</span>)),</span><br><span class="line">                            ((<span class="number">0</span>, <span class="number">0</span>), (-<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">                        ];</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> m = next_step[i];</span><br><span class="line">                            <span class="keyword">let</span> new_tail = (value.<span class="number">0</span> .<span class="number">0</span> + m.<span class="number">0</span> .<span class="number">0</span>, value.<span class="number">0</span> .<span class="number">1</span> + m.<span class="number">0</span> .<span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">let</span> new_head = (value.<span class="number">1</span> .<span class="number">0</span> + m.<span class="number">1</span> .<span class="number">0</span>, value.<span class="number">1</span> .<span class="number">1</span> + m.<span class="number">1</span> .<span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">if</span> new_tail.<span class="number">0</span> &lt; n</span><br><span class="line">                                &amp;&amp; new_tail.<span class="number">1</span> &lt; n</span><br><span class="line">                                &amp;&amp; new_head.<span class="number">0</span> &lt; n</span><br><span class="line">                                &amp;&amp; new_head.<span class="number">1</span> &lt; n</span><br><span class="line">                                &amp;&amp; new_tail.<span class="number">0</span> &gt;= <span class="number">0</span></span><br><span class="line">                                &amp;&amp; new_tail.<span class="number">1</span> &gt;= <span class="number">0</span></span><br><span class="line">                                &amp;&amp; new_head.<span class="number">0</span> &gt;= <span class="number">0</span></span><br><span class="line">                                &amp;&amp; new_head.<span class="number">1</span> &gt;= <span class="number">0</span></span><br><span class="line">                                &amp;&amp; grid[new_tail.<span class="number">0</span> <span class="keyword">as</span> <span class="built_in">usize</span>][new_tail.<span class="number">1</span> <span class="keyword">as</span> <span class="built_in">usize</span>] == <span class="number">0</span></span><br><span class="line">                                &amp;&amp; grid[new_head.<span class="number">0</span> <span class="keyword">as</span> <span class="built_in">usize</span>][new_head.<span class="number">1</span> <span class="keyword">as</span> <span class="built_in">usize</span>] == <span class="number">0</span></span><br><span class="line">                                &amp;&amp; !seen.contains(&amp;(new_tail, new_head))</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span> i == <span class="number">0</span></span><br><span class="line">                                    || i == <span class="number">1</span></span><br><span class="line">                                    || (value.<span class="number">0</span> .<span class="number">0</span> + <span class="number">1</span> &gt;= <span class="number">0</span> <span class="comment">// old_tail + 1 is in range</span></span><br><span class="line">                                        &amp;&amp; value.<span class="number">0</span> .<span class="number">0</span> + <span class="number">1</span> &lt; n</span><br><span class="line">                                        &amp;&amp; value.<span class="number">0</span> .<span class="number">1</span> + <span class="number">1</span> &gt;= <span class="number">0</span></span><br><span class="line">                                        &amp;&amp; value.<span class="number">0</span> .<span class="number">1</span> + <span class="number">1</span> &lt; n</span><br><span class="line">                                        &amp;&amp; grid[(value.<span class="number">0</span> .<span class="number">0</span> + <span class="number">1</span>) <span class="keyword">as</span> <span class="built_in">usize</span>]  <span class="comment">// old_tail + 1 is unblock</span></span><br><span class="line">                                            [(value.<span class="number">0</span> .<span class="number">1</span> + <span class="number">1</span>) <span class="keyword">as</span> <span class="built_in">usize</span>]</span><br><span class="line">                                            == <span class="number">0</span></span><br><span class="line">                                        &amp;&amp; ((i == <span class="number">2</span> &amp;&amp; value.<span class="number">0</span> .<span class="number">0</span> == value.<span class="number">1</span> .<span class="number">0</span>)</span><br><span class="line">                                            || (i == <span class="number">3</span> &amp;&amp; value.<span class="number">0</span> .<span class="number">1</span> == value.<span class="number">1</span> .<span class="number">1</span>)))</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">if</span> new_tail == (n - <span class="number">1</span>, n - <span class="number">2</span>) &amp;&amp; new_head == (n - <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">                                        <span class="keyword">return</span> level;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    q.push_back((new_tail, new_head));</span><br><span class="line">                                    seen.insert((new_tail, new_head));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="literal">None</span> =&gt; (),</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            level += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly  contest 158</title>
    <url>/2019/10/14/LeetCode-weekly-contest-158/</url>
    <content><![CDATA[<h2 id="1221-Split-a-String-in-Balanced-Strings"><a href="#1221-Split-a-String-in-Balanced-Strings" class="headerlink" title="1221. Split a String in Balanced Strings"></a>1221. Split a String in Balanced Strings</h2><p>理解balanced的定义，发现只需要找到 L 和 R 出现个数相等的位置即可。</p>
<p>Time complexity: O(N),<br>Space complexity: O(1).</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">balanced_string_split</span></span>(s: <span class="built_in">String</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s.chars() &#123;</span><br><span class="line">            <span class="keyword">match</span> c &#123;</span><br><span class="line">                <span class="string">&#x27;L&#x27;</span> =&gt; &#123; l += <span class="number">1</span>&#125;,</span><br><span class="line">                <span class="string">&#x27;R&#x27;</span> =&gt; &#123; r += <span class="number">1</span>&#125;,</span><br><span class="line">                _ =&gt; (),</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> l == r &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1222-Queens-That-Can-Attack-the-King"><a href="#1222-Queens-That-Can-Attack-the-King" class="headerlink" title="1222. Queens That Can Attack the King"></a>1222. Queens That Can Attack the King</h2><p>虽然理解题目稍微复杂些，但算法其实很直接，从King往外找，而不是从queue开始找。</p>
<p>时间复杂度: O(queens.len() + chessboard.len()),<br>空间复杂度: O(queens.len()).</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">queens_attackthe_king</span></span>(queens: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt;, king: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> qs: HashSet&lt;(<span class="built_in">i32</span>, <span class="built_in">i32</span>)&gt; = HashSet::new();</span><br><span class="line">    <span class="keyword">for</span> queen <span class="keyword">in</span> queens.iter() &#123;</span><br><span class="line">        qs.insert((queen[<span class="number">0</span>], queen[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ans: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">    <span class="keyword">let</span> direction = <span class="built_in">vec!</span>[</span><br><span class="line">        (<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        (<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        (<span class="number">0</span>, -<span class="number">1</span>),</span><br><span class="line">        (-<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        (-<span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        (-<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> k = (king[<span class="number">0</span>], king[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (x, y) <span class="keyword">in</span> direction.iter() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> target: (<span class="built_in">i32</span>, <span class="built_in">i32</span>) = k;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            target.<span class="number">0</span> += x;</span><br><span class="line">            target.<span class="number">1</span> += y;</span><br><span class="line">            <span class="keyword">if</span> target.<span class="number">0</span> &gt;= <span class="number">0</span> &amp;&amp; target.<span class="number">0</span> &lt; <span class="number">8</span> &amp;&amp; target.<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; target.<span class="number">1</span> &lt; <span class="number">8</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> qs.contains(&amp;target) &#123;</span><br><span class="line">                    ans.push(<span class="built_in">vec!</span>[target.<span class="number">0</span>, target.<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1223-Dice-Roll-Simulation"><a href="#1223-Dice-Roll-Simulation" class="headerlink" title="1223. Dice Roll Simulation"></a>1223. Dice Roll Simulation</h2><p>有memoization的dfs。</p>
<p>通过分析memo的最多可能，可知<br>时间复杂度: O(6 * N ^ 2),<br>空间复杂度: O(6 * N ^ 2).</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> MOD_NUMBER: <span class="built_in">i32</span> = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">answer</span></span>(</span><br><span class="line">        <span class="keyword">mut</span> memo: &amp;<span class="keyword">mut</span> HashMap&lt;(<span class="built_in">i32</span>, <span class="built_in">usize</span>, <span class="built_in">i32</span>), <span class="built_in">i32</span>&gt;,</span><br><span class="line">        roll_max: &amp;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;,</span><br><span class="line">        n: <span class="built_in">i32</span>,</span><br><span class="line">        previous_number: <span class="built_in">usize</span>,</span><br><span class="line">        previous_consecutive: <span class="built_in">i32</span>,</span><br><span class="line">    ) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">match</span> memo.get(&amp;(n, previous_number, previous_consecutive)) &#123;</span><br><span class="line">            <span class="literal">Some</span>(value) =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> *value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut</span> ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">6</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> i == previous_number &#123;</span><br><span class="line">                        <span class="keyword">if</span> previous_consecutive == roll_max[previous_number] &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            ans = (ans</span><br><span class="line">                                + Solution::answer(&amp;<span class="keyword">mut</span> memo, &amp;roll_max, n - <span class="number">1</span>, i, previous_consecutive + <span class="number">1</span>))</span><br><span class="line">                                % Solution::MOD_NUMBER;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ans = (ans + Solution::answer(&amp;<span class="keyword">mut</span> memo, &amp;roll_max, n - <span class="number">1</span>, i, <span class="number">1</span>)) % Solution::MOD_NUMBER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                memo.insert((n, previous_number, previous_consecutive), ans);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">die_simulator</span></span>(n: <span class="built_in">i32</span>, roll_max: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> memo: HashMap&lt;(<span class="built_in">i32</span>, <span class="built_in">usize</span>, <span class="built_in">i32</span>), <span class="built_in">i32</span>&gt; = HashMap::new();</span><br><span class="line">        Solution::answer(&amp;<span class="keyword">mut</span> memo, &amp;roll_max, n, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1224-Maximum-Equal-Frequency"><a href="#1224-Maximum-Equal-Frequency" class="headerlink" title="1224. Maximum Equal Frequency"></a>1224. Maximum Equal Frequency</h2><p>首先明确 <code>an array prefix of nums</code>的意义，即前缀数组。<br>再看到加粗的<code>exactly one</code>，可知符合要求的前缀数组有2种情况：</p>
<ul>
<li>出现次数最多的数的数目 - 1 = 所有其他数的出现次数的数目</li>
<li>有一个数出现次数为 1，其他数出现的次数相同<br>最后看数据规模<code>10^5</code>，基本上可以确定必须要<code>O(N * log N) 或 O(N)</code>的算法了。</li>
</ul>
<p>算法其实已经呼之欲出了，很自然地想到用 散列表 记录不同数的出现次数，用 TreeSet对出现次数进行存储，可以快速更新出现次数。然后One Pass即可。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEqualFreq</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        multiset&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; nums.<span class="built_in">size</span>(); ++x) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = nums[x];</span><br><span class="line">            <span class="keyword">if</span> (count[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = order.<span class="built_in">find</span>(count[i]);</span><br><span class="line">                order.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            ++count[i];</span><br><span class="line">            order.<span class="built_in">insert</span>(count[i]);</span><br><span class="line">            <span class="comment">// detemiate</span></span><br><span class="line">            <span class="keyword">auto</span> it1 = order.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">auto</span> it2 = order.<span class="built_in">end</span>();</span><br><span class="line">            --it2;</span><br><span class="line">            <span class="keyword">int</span> n = order.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> length = x + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (it1 == it2) &#123;</span><br><span class="line">                ans = x + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*it2) == (*it1) + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( (*it2) * <span class="number">1</span> + (*it1) * (n) == length) &#123;</span><br><span class="line">                        ans = x + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (*it1 == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (*it2 * n == length - <span class="number">1</span>) &#123;</span><br><span class="line">                        ans = x + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 159</title>
    <url>/2019/10/21/LeetCode-weekly-contest-159/</url>
    <content><![CDATA[<h2 id="1232-Check-If-It-Is-a-Straight-Line"><a href="#1232-Check-If-It-Is-a-Straight-Line" class="headerlink" title="1232. Check If It Is a Straight Line"></a>1232. Check If It Is a Straight Line</h2><p>依次检查3个点是否共线。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">right</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; p1, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; p2, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; p3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p1[<span class="number">0</span>] - p2[<span class="number">0</span>]) * (p2[<span class="number">1</span>] -  p3[<span class="number">1</span>]) == (p1[<span class="number">1</span>] - p2[<span class="number">1</span>]) * (p2[<span class="number">0</span>] - p3[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkStraightLine</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =   <span class="number">0</span>; i + <span class="number">2</span> &lt; coordinates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">right</span>(coordinates[i], coordinates[i + <span class="number">1</span>], coordinates[i + <span class="number">2</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1233-Remove-Sub-Folders-from-the-Filesystem"><a href="#1233-Remove-Sub-Folders-from-the-Filesystem" class="headerlink" title="1233. Remove Sub-Folders from the Filesystem"></a>1233. Remove Sub-Folders from the Filesystem</h2><p>用一个HashSet记录出现过的路径，再遍历所有路径，依次分解每层的父目录，判断是否再记录中即可。</p>
<p>时间复杂度: O(folder.size() * string.size()),<br>空间复杂度: O(folder.size() * string.size()).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">removeSubfolders</span><span class="params">(vector&lt;string&gt;&amp; folder)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; memo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; f : folder) &#123;</span><br><span class="line">            memo.<span class="built_in">insert</span>(f);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; f : folder) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = f.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">bool</span> appear = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; f[i] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    --i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">auto</span> head = f.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (memo.<span class="built_in">find</span>(head) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    appear = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!appear) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1234-Replace-the-Substring-for-Balanced-String"><a href="#1234-Replace-the-Substring-for-Balanced-String" class="headerlink" title="1234. Replace the Substring for Balanced String"></a>1234. Replace the Substring for Balanced String</h2><p>滑动窗口。<br>记录所有多的字母，然后设置一个窗口使得多的字母出现字数多于多的次数。然后移动该窗口，保持窗口的特性(多的字母出现字数多于多的次数)不变。记录 窗口的最小长度。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> charaters = &#123;<span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;R&#x27;</span>&#125;;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, ll&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++count[c];</span><br><span class="line">        &#125;</span><br><span class="line">        ll target = s.<span class="built_in">size</span>() / <span class="number">4</span>;</span><br><span class="line">        ll window_size = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; one;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : count) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (p.second &gt; target) &#123;</span><br><span class="line">                window_size += p.second - target;</span><br><span class="line">                one.<span class="built_in">insert</span>(p.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (window_size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll i = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, ll&gt; one_amount;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">all_of</span>(one.<span class="built_in">begin</span>(), one.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> one_amount[p] &gt;= count[p] - target;</span><br><span class="line">            &#125;)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (one.<span class="built_in">find</span>(s[i]) != one.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++one_amount[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        ll left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; s.<span class="built_in">size</span>() &amp;&amp; (one.<span class="built_in">find</span>(s[left]) != one.<span class="built_in">end</span>() &amp;&amp; one_amount[s[left]] &gt; count[s[left]] - target) || (one.<span class="built_in">find</span>(s[left]) == one.<span class="built_in">end</span>())) &#123;</span><br><span class="line">            --one_amount[s[left]];</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ret = i - left;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (one.<span class="built_in">find</span>(s[i]) != one.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++one_amount[s[i]];</span><br><span class="line">                <span class="keyword">while</span> (left &lt; s.<span class="built_in">size</span>() &amp;&amp; (one.<span class="built_in">find</span>(s[left]) != one.<span class="built_in">end</span>() &amp;&amp; one_amount[s[left]] &gt; count[s[left]] - target) || (one.<span class="built_in">find</span>(s[left]) == one.<span class="built_in">end</span>())) &#123;</span><br><span class="line">                    --one_amount[s[left]];</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1235-Maximum-Profit-in-Job-Scheduling"><a href="#1235-Maximum-Profit-in-Job-Scheduling" class="headerlink" title="1235. Maximum Profit in Job Scheduling"></a>1235. Maximum Profit in Job Scheduling</h2><p>类似背包问题。<br>先把job按照endTime排序，遍历每个job，加入或不加入，更新总的profit。<br>更新策略为：根据job的start_time 二分查找符合条件的 end_time，得到加入该job的最大收益。如果最大收益大于之前 end_time的最大收益（因为 事先已经根据end_time排好序了，所以可以保证job的end_time是获得最大收益的end_time，则更新profit。<br>最后返回最大的end_time的profit。</p>
<p>时间 复杂度: O(N log N),<br>空间 复杂度: O(N).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jobScheduling(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, vector&lt;int&gt;&amp; profit) &#123;</span><br><span class="line">        map&lt;int, int&gt; dp;</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        const int n = startTime.size();</span><br><span class="line">        vector&lt;tuple&lt;int, int, int&gt;&gt; jobs(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            jobs[i] = &#123;endTime[i], startTime[i], profit[i]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(jobs.begin(), jobs.end());</span><br><span class="line">        for (const auto&amp; job : jobs) &#123;</span><br><span class="line">            int cur = prev(dp.upper_bound(get&lt;1&gt;(job)))-&gt;second + get&lt;2&gt;(job);</span><br><span class="line">            if (cur &gt; dp.rbegin()-&gt;second) &#123;</span><br><span class="line">                dp[get&lt;0&gt;(job)] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp.rbegin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 174</title>
    <url>/2020/02/03/LeetCode-weekly-contest-174/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>459 / 6997</td>
<td>YoungForest</td>
<td>18</td>
<td>1:04:52</td>
<td>0:15:31</td>
<td>0:21:58</td>
<td>0:41:22  2</td>
<td>0:54:52</td>
</tr>
</tbody></table>
<p>终于回到亲爱的祖国啦。可以周日早上起来打LeetCode的比赛了。不得不承认，4个月没打，手生了很多。从比赛名次上就可以看出。<br>这次比赛是完全的手速场，而手速是很看状态和熟练度的。因此排名掉了我心服口服。也恰好可以督促自己投入更多的精力准备接下来谷歌的面试。</p>
<h2 id="1341-The-K-Weakest-Rows-in-a-Matrix"><a href="#1341-The-K-Weakest-Rows-in-a-Matrix" class="headerlink" title="1341. The K Weakest Rows in a Matrix"></a>1341. The K Weakest Rows in a Matrix</h2><p>二分搜索 查找每行的士兵数，排序找到前K个最少的行。</p>
<p>时间复杂度: O(m log m * log n)<br>空间复杂度: O(m)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">decide</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; row, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> row[x] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">number</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = row.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">decide</span>(row, mid)) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kWeakestRows</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            q.<span class="built_in">push_back</span>(&#123;<span class="built_in">number</span>(mat[i]), i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (auto a : q) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; a.first &lt;&lt; &quot; &quot; &lt;&lt; a.second &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.first == b.first) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.second &lt; b.second;                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// for (auto a : q) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; a.first &lt;&lt; &quot; &quot; &lt;&lt; a.second &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1342-Reduce-Array-Size-to-The-Half"><a href="#1342-Reduce-Array-Size-to-The-Half" class="headerlink" title="1342. Reduce Array Size to The Half"></a>1342. Reduce Array Size to The Half</h2><p>贪心策略。每次删除出现次数最多的数。</p>
<p>时间复杂度: O(N log N).<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSetSize</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            ++count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : count) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, target = (arr.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>, accu = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (accu &lt; target) &#123;</span><br><span class="line">            accu += v[ans];</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1343-Maximum-Product-of-Splitted-Binary-Tree"><a href="#1343-Maximum-Product-of-Splitted-Binary-Tree" class="headerlink" title="1343. Maximum Product of Splitted Binary Tree"></a>1343. Maximum Product of Splitted Binary Tree</h2><p>枚举搜索即可。尝试所有的子树组合，寻找乘积最大的。<br>在这里要注意，<code>modulo 10^9 + 7</code>的操作，我在此WA了2此。我使用<code>unsigned long long</code>，最后才<code>mod</code>。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">ll <span class="title">sumOfSubtree</span><span class="params">(TreeNode* root, <span class="keyword">const</span> ll total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll l = <span class="built_in">sumOfSubtree</span>(root-&gt;left, total);</span><br><span class="line">            ll r = <span class="built_in">sumOfSubtree</span>(root-&gt;right, total);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, l * (total - l));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, r * (total - r));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val + l + r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">sum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val + <span class="built_in">sum</span>(root-&gt;left) + <span class="built_in">sum</span>(root-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ll total = <span class="built_in">sum</span>(root);</span><br><span class="line">        <span class="built_in">sumOfSubtree</span>(root, total);</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1344-Jump-Game-V"><a href="#1344-Jump-Game-V" class="headerlink" title="1344. Jump Game V"></a>1344. Jump Game V</h2><p>自顶向下的动态规划思想。从每个index尝试向左右跳，直到遇到高度更大的。</p>
<p>时间复杂度: O(N ^ 2).<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">const</span> <span class="keyword">int</span> d, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= arr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (memo.<span class="built_in">find</span>(x) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>() &amp;&amp; i &lt;= x + d &amp;&amp; arr[i] &lt; arr[x]; ++i) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">dp</span>(arr, d, memo, i) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; i &gt;= x - d &amp;&amp; arr[i] &lt; arr[x]; --i) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">dp</span>(arr, d, memo, i) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memo[x] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxJumps</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dp</span>(arr, d, memo, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 175</title>
    <url>/2020/02/09/LeetCode-weekly-contest-175/</url>
    <content><![CDATA[<p>本周由于眼镜坏掉了，不在状态。在家吃饭也晚，所以题目并没有做完。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>1378 / 7826</td>
<td>YoungForest</td>
<td>7</td>
<td>0:11:41</td>
<td>0:06:51</td>
<td>0:11:41</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1346-Check-If-N-and-Its-Double-Exist"><a href="#1346-Check-If-N-and-Its-Double-Exist" class="headerlink" title="1346. Check If N and Its Double Exist"></a>1346. Check If N and Its Double Exist</h2><p>使用一个hashmap存储之前见到过的数即可。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfExist</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(i * <span class="number">2</span>) != s.<span class="built_in">end</span>() || (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; s.<span class="built_in">find</span>(i / <span class="number">2</span>) != s.<span class="built_in">end</span>()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            s.<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram"><a href="#1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram" class="headerlink" title="1347. Minimum Number of Steps to Make Two Strings Anagram"></a>1347. Minimum Number of Steps to Make Two Strings Anagram</h2><p>根据Anagram的定义，我们统计2个字符串中各个字符出现频数之差就可以了。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">convert</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++ans[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> count_s = <span class="built_in">convert</span>(s);</span><br><span class="line">        <span class="keyword">auto</span> <span class="keyword">count_t</span> = <span class="built_in">convert</span>(t);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count_s[i] &gt; <span class="keyword">count_t</span>[i]) &#123;</span><br><span class="line">                ans += count_s[i] - <span class="keyword">count_t</span>[i];</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1348-Tweet-Counts-Per-Frequency"><a href="#1348-Tweet-Counts-Per-Frequency" class="headerlink" title="1348. Tweet Counts Per Frequency"></a>1348. Tweet Counts Per Frequency</h2><p>使用TreeMap记录Tweet即可。<br>需要注意记录区间分割的点，根据这些分割点寻找里面的Tweet。</p>
<p>时间复杂度:</p>
<ul>
<li>recordTweet: O(log N)</li>
<li>getTweetCountsPerFrequency: O(N * log N * (endTime - startTime) / interval)<br>空间复杂度:</li>
<li>O(N)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TweetCounts</span> &#123;</span></span><br><span class="line">    unordered_map&lt;string, map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; string_map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TweetCounts</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordTweet</span><span class="params">(string tweetName, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">        ++string_map[tweetName][time];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getTweetCountsPerFrequency</span><span class="params">(string freq, string tweetName, <span class="keyword">int</span> startTime, <span class="keyword">int</span> endTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> interval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="string">&quot;hour&quot;</span>) &#123;</span><br><span class="line">            interval = <span class="number">3600</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freq == <span class="string">&quot;day&quot;</span>) &#123;</span><br><span class="line">            interval =  <span class="number">3600</span> * <span class="number">24</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            interval = <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; m = string_map[tweetName];</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> st = startTime;</span><br><span class="line">        <span class="keyword">auto</span> start_it = m.<span class="built_in">lower_bound</span>(st);</span><br><span class="line">        <span class="keyword">auto</span> end_it = m.<span class="built_in">upper_bound</span>(endTime);</span><br><span class="line">        <span class="keyword">auto</span> it = start_it;</span><br><span class="line">        <span class="keyword">while</span> (st &lt;= endTime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> next_it = m.<span class="built_in">lower_bound</span>(st + interval);</span><br><span class="line">            <span class="keyword">int</span> accu = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; it != next_it &amp;&amp; it != end_it; ++it) &#123;</span><br><span class="line">                accu += it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(accu);</span><br><span class="line">            st += interval;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TweetCounts object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TweetCounts* obj = new TweetCounts();</span></span><br><span class="line"><span class="comment"> * obj-&gt;recordTweet(tweetName,time);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1349-Maximum-Students-Taking-Exam"><a href="#1349-Maximum-Students-Taking-Exam" class="headerlink" title="1349. Maximum Students Taking Exam"></a>1349. Maximum Students Taking Exam</h2><p>一道还挺难的题目，看了<a href="https://www.bilibili.com/video/av88416735">花花酱</a>的视频后才学会正确的解法，在这里友情打一波广告。<br>动态规划 和 状态压缩。</p>
<p>这里有几个bitmask的技巧:</p>
<ul>
<li>左右不能有学生: (x &amp; (x &gt;&gt; 1)) == 0</li>
<li>左上不能有学生: (a &amp; (b &gt;&gt; 1)) == 0</li>
<li>根据座椅枚举所有的状态: state_enum = state &amp; (state_enum - 1)</li>
</ul>
<p>时间复杂度: O(m * 2 ^ n * 2 ^ n),<br>空间复杂度: O(m * 2 ^ n) -&gt; O(2 ^ n).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">left_and_right</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &amp; (a &gt;&gt; <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">left_and_right</span>(b) &amp;&amp; <span class="built_in">left_and_right</span>(b) &amp;&amp; (a &amp; (b &gt;&gt; <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (b &amp; (a &gt;&gt; <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxStudents</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = seats.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = seats[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt; (<span class="number">1</span> &lt;&lt; n));</span><br><span class="line">        <span class="keyword">int</span> last_state = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; ++row) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; last_row = dp[row];</span><br><span class="line">            <span class="keyword">auto</span>&amp; current_row = dp[row + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">                state |= seats[row][col] == <span class="string">&#x27;.&#x27;</span> ? (<span class="number">1</span> &lt;&lt; col) : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> last_state_enum = last_state; ; last_state_enum = last_state &amp; (last_state_enum - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> state_enum = state; ; state_enum = state &amp; (state_enum - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">ok</span>(last_state_enum, state_enum)) &#123;</span><br><span class="line">                        current_row[state_enum] = <span class="built_in">max</span>(current_row[state_enum], last_row[last_state_enum] +  __builtin_popcount(state_enum));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state_enum == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (last_state_enum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            last_state = state;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(<span class="built_in">begin</span>(dp[m]), <span class="built_in">end</span>(dp[m]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 176</title>
    <url>/2020/02/16/LeetCode-weekly-contest-176/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>306 / 8105</td>
<td>YoungForest</td>
<td>19</td>
<td>1:36:07</td>
<td>0:02:47</td>
<td>0:23:09</td>
<td>0:54:53  1</td>
<td>1:26:07  1</td>
</tr>
</tbody></table>
<p>本次比赛在最后关头终于AC，也是极其的惊现刺激。自从加入中国区的同学之后，我周赛的排名都很难进入前200了。比如本次就从229掉到了306。不得不承认，我国内卷之严重呀。</p>
<p>排名落后的主要原因在于第3题花费了很多时间调试和试，差点最后一题都没时间实现了。最近缺少练习也导致debug能力和一遍bug-free的能力急剧下降。</p>
<h2 id="1351-Count-Negative-Numbers-in-a-Sorted-Matrix"><a href="#1351-Count-Negative-Numbers-in-a-Sorted-Matrix" class="headerlink" title="1351. Count Negative Numbers in a Sorted Matrix"></a>1351. Count Negative Numbers in a Sorted Matrix</h2><p>利用横竖都是有序的条件，可以实现O(m + n)的计数。<br>和<a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">search-a-2d-matrix-ii</a>类似。</p>
<p>时间复杂度: O(m + n),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNegatives</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[row][col] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans += m - row;</span><br><span class="line">                --col;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++row;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1352-Product-of-the-Last-K-Numbers"><a href="#1352-Product-of-the-Last-K-Numbers" class="headerlink" title="1352. Product of the Last K Numbers"></a>1352. Product of the Last K Numbers</h2><p>记录最后0的位置和累计的乘积。判断最后K个数中是否有0，如果没有的话，借助最后的乘积除以倒数第k + 1个乘积即可。</p>
<p>时间复杂度:</p>
<ul>
<li>add: O(1)</li>
<li>getProduct: O(1)<br>空间复杂度: O(N)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductOfNumbers</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; product;</span><br><span class="line">    <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductOfNumbers</span>() &#123;</span><br><span class="line">        product.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            product.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            zeros = index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            product.<span class="built_in">push_back</span>(num * product.<span class="built_in">back</span>());</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getProduct</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = index - k;</span><br><span class="line">        <span class="keyword">int</span> e = index; <span class="comment">// [b, e)</span></span><br><span class="line">        <span class="keyword">if</span> (zeros &lt; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> product.<span class="built_in">back</span>() / product[product.<span class="built_in">size</span>() - k - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ProductOfNumbers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ProductOfNumbers* obj = new ProductOfNumbers();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(num);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;getProduct(k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1353-Maximum-Number-of-Events-That-Can-Be-Attended"><a href="#1353-Maximum-Number-of-Events-That-Can-Be-Attended" class="headerlink" title="1353. Maximum Number of Events That Can Be Attended"></a>1353. Maximum Number of Events That Can Be Attended</h2><p>贪心策略。<br>每次都做结束时间最早的事件。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEvents</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; events)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current_day = <span class="number">1</span>;</span><br><span class="line">        multiset&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">begin</span>(events), <span class="built_in">end</span>(events), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; events.<span class="built_in">size</span>() || !q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; events.<span class="built_in">size</span>() &amp;&amp; events[i][<span class="number">0</span>] &lt;= current_day) &#123;</span><br><span class="line">                q.<span class="built_in">insert</span>(events[i][<span class="number">1</span>]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; *q.<span class="built_in">begin</span>() &lt; current_day) &#123;</span><br><span class="line">                q.<span class="built_in">erase</span>(q.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; *q.<span class="built_in">begin</span>() &gt;= current_day) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; *q.begin() &lt;&lt; endl;</span></span><br><span class="line">                q.<span class="built_in">erase</span>(q.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            ++current_day;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1354-Construct-Target-Array-With-Multiple-Sums"><a href="#1354-Construct-Target-Array-With-Multiple-Sums" class="headerlink" title="1354. Construct Target Array With Multiple Sums"></a>1354. Construct Target Array With Multiple Sums</h2><p>貌似很难的题目，但一旦发现：每次replace的结果都是替换成最大的数，就可以从最后的数组倒推回初始数组。</p>
<p>时间复杂度: O(N log N max_number)<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        multimap&lt;ll, ll&gt; m;</span><br><span class="line">        ll s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            m.<span class="built_in">insert</span>(&#123;target[i], i&#125;);</span><br><span class="line">            s += target[i];</span><br><span class="line">        &#125;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">bool</span></span>()&gt; recurse = [&amp;]() -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == target.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">auto</span> max_item = m.<span class="built_in">end</span>();</span><br><span class="line">            --max_item;</span><br><span class="line">            ll left = max_item-&gt;first;</span><br><span class="line">            ll index = max_item-&gt;second;</span><br><span class="line">            ll others = s - left;</span><br><span class="line">            ll x = left - others;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; others &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            s = left;</span><br><span class="line">            m.<span class="built_in">erase</span>(max_item);</span><br><span class="line">            m.<span class="built_in">insert</span>(&#123;x, index&#125;);</span><br><span class="line">            target[index] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">recurse</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recurse</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 177</title>
    <url>/2020/02/23/LeetCode-weekly-contest-177/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>333 / 6106</td>
<td>YoungForest</td>
<td>20</td>
<td>1:04:22</td>
<td>0:25:00</td>
<td>0:33:40</td>
<td>0:43:21</td>
<td>0:59:22  1</td>
</tr>
</tbody></table>
<p>手速和bug-free的场。</p>
<h2 id="1360-Number-of-Days-Between-Two-Dates"><a href="#1360-Number-of-Days-Between-Two-Dates" class="headerlink" title="1360. Number of Days Between Two Dates"></a>1360. Number of Days Between Two Dates</h2><p>计算2个日期间的差值。本来想着手算来着，但写起来太复杂了。后来果断放弃，投机取巧用了Python日期处理的库函数。</p>
<p>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">daysBetweenDates</span>(<span class="params">self, date1: <span class="built_in">str</span>, date2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        delta = date.fromisoformat(date1) - date.fromisoformat(date2)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(delta.days)</span><br></pre></td></tr></table></figure>

<h2 id="1361-Validate-Binary-Tree-Nodes"><a href="#1361-Validate-Binary-Tree-Nodes" class="headerlink" title="1361. Validate Binary Tree Nodes"></a>1361. Validate Binary Tree Nodes</h2><p>观察有，合法的二叉树为：</p>
<ol>
<li>有且仅有一个节点没有父节点</li>
<li>剩下节点均只有一个父节点</li>
<li>没有孤儿，既没有父亲、也没有child（在节点数大于1的情况下）</li>
</ol>
<p>第3个要求比较难想到，甚至是OJ一开始也是错的。我也就将错就错通过了。感谢<a href="https://leetcode.com/problems/validate-binary-tree-nodes/discuss/517596/Count-Parents-and-Orphans-O(n)">votrubac</a>的提示。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateBinaryTreeNodes</span><span class="params">(<span class="keyword">int</span> n, vector&lt;<span class="keyword">int</span>&gt;&amp; leftChild, vector&lt;<span class="keyword">int</span>&gt;&amp; rightChild)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">parents</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">hasChild</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> fillParents = [&amp;](<span class="keyword">int</span> index, <span class="keyword">int</span> parent) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parents[index] != <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            parents[index] = parent;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : &#123;leftChild[i], rightChild[i]&#125;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">fillParents</span>(child, i) == <span class="literal">false</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hasChild[i] = leftChild[i] != <span class="number">-1</span> || rightChild[i] != <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : parents) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasChild[i] == <span class="literal">false</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1362-Closest-Divisors"><a href="#1362-Closest-Divisors" class="headerlink" title="1362. Closest Divisors"></a>1362. Closest Divisors</h2><p>使用贪心的策略。从sqrt(n)开始进行枚举，此时差就是最小的。</p>
<p>时间复杂度: O(sqrt(n)),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">current</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(n)); i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, n / i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">closestDivisors</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p1 = <span class="built_in">current</span>(num + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> p2 = <span class="built_in">current</span>(num + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(p1.first - p1.second) &lt; <span class="built_in">abs</span>(p2.second - p2.first)) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;p1.first, p1.second&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;p2.first, p2.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1363-Largest-Multiple-of-Three"><a href="#1363-Largest-Multiple-of-Three" class="headerlink" title="1363. Largest Multiple of Three"></a>1363. Largest Multiple of Three</h2><p>总体上是一个贪心的思路。<br>首先考虑一个更简单的问题：<br>如何组成最大的数组-&gt;最大的放前面。<br>在加入被3整除这一约束条件后，<br>我们有观察，剩下的数字越多越好，其次是删掉的数越小越好。<br>此时，就有了如下算法。</p>
<p>因为错将<code>multiset</code>用作<code>set</code>，导致了一次Wrong Answer. 这不是第一次犯类似的错误了。以后考虑使用<code>set</code>时，需要提前想想允不允许重复。</p>
<p>时间复杂度: O(n log n),<br>空间复杂度: O(n).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// n log n</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestMultipleOfThree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        vector&lt;multiset&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">remind</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : digits) &#123;</span><br><span class="line">            remind[i % <span class="number">3</span>].<span class="built_in">insert</span>(i);</span><br><span class="line">            all += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> remove = [&amp;](<span class="keyword">int</span> one, <span class="keyword">int</span> two) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (remind[one].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (remind[two].<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    remind[two].<span class="built_in">erase</span>(remind[two].<span class="built_in">begin</span>());</span><br><span class="line">                    remind[two].<span class="built_in">erase</span>(remind[two].<span class="built_in">begin</span>());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                remind[one].<span class="built_in">erase</span>(remind[one].<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (all % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (all % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">remove</span>(<span class="number">1</span>, <span class="number">2</span>) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">remove</span>(<span class="number">2</span>, <span class="number">1</span>) == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : remind) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : s) &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : v) &#123;</span><br><span class="line">            ans += <span class="built_in">to_string</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 179</title>
    <url>/2020/03/08/LeetCode-weekly-contest-179/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>539 / 6242</td>
<td>YoungForest</td>
<td>18</td>
<td>1:09:53</td>
<td>0:05:43</td>
<td>0:13:09</td>
<td>0:24:01</td>
<td>1:04:53  1</td>
</tr>
</tbody></table>
<h2 id="1374-Generate-a-String-With-Characters-That-Have-Odd-Counts"><a href="#1374-Generate-a-String-With-Characters-That-Have-Odd-Counts" class="headerlink" title="1374. Generate a String With Characters That Have Odd Counts"></a>1374. Generate a String With Characters That Have Odd Counts</h2><p>如果n为偶数，则一个a，剩下都为b；<br>如果n为奇数，则全为a.</p>
<p>时间复杂度: O(n),<br>空间复杂度: O(n).</p>
<p>之前写代码从来不过重注意输入的合法性检查。因为Leetcode本身对输入有限制。但是现实面试的时候，面试官有时会关注你对输入的预设和检查，毕竟实际生产过程中的输入永远是无法预料的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">generateTheString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">append</span>(n, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            ans.<span class="built_in">append</span>(n - <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1375-Bulb-Switcher-III"><a href="#1375-Bulb-Switcher-III" class="headerlink" title="1375. Bulb Switcher III"></a>1375. Bulb Switcher III</h2><p>观察有：蓝色灯永远是前连续个，意味着蓝色灯的状态可以用index最高的灯表示，同时这个index是单调非递减的。所以只需要比较它和最大亮着的灯的下标是否相同即可。且每次亮灯都试图增大这个<code>blue_index</code>。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTimesAllBlue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_turn_on_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> blue_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = light.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">turn_on</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : light) &#123;</span><br><span class="line">            turn_on[i - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            max_turn_on_index = <span class="built_in">max</span>(max_turn_on_index, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (blue_index + <span class="number">1</span> &lt; n &amp;&amp; turn_on[blue_index +  <span class="number">1</span>] == <span class="literal">true</span>) &#123;</span><br><span class="line">                ++blue_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (blue_index == max_turn_on_index)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1376-Time-Needed-to-Inform-All-Employees"><a href="#1376-Time-Needed-to-Inform-All-Employees" class="headerlink" title="1376. Time Needed to Inform All Employees"></a>1376. Time Needed to Inform All Employees</h2><p>典型的dfs，每次寻找最长时间通知完的下属。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfMinutes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> headID, vector&lt;<span class="keyword">int</span>&gt;&amp; manager, vector&lt;<span class="keyword">int</span>&gt;&amp; informTime)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; graphs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; manager.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            graphs[manager[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (graphs[<span class="number">-1</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> head = graphs[<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> index) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (graphs[index].<span class="built_in">empty</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> subordinate : graphs[index]) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(subordinate));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans + informTime[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1377-Frog-Position-After-T-Seconds"><a href="#1377-Frog-Position-After-T-Seconds" class="headerlink" title="1377. Frog Position After T Seconds"></a>1377. Frog Position After T Seconds</h2><p>同样是DFS, 需要注意的是，我们要寻找的是经过<code>t</code>秒后的位置。所以有可能跳过<code>target</code>，概率为0。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">frogPosition</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> t, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, set&lt;<span class="keyword">int</span>&gt;&gt; graphs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            graphs[e[<span class="number">0</span>]].<span class="built_in">insert</span>(e[<span class="number">1</span>]);</span><br><span class="line">            graphs[e[<span class="number">1</span>]].<span class="built_in">insert</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        graphs[<span class="number">1</span>].<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">        visited.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> index, <span class="keyword">int</span> probability, <span class="keyword">int</span> time) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            visited.<span class="built_in">insert</span>(index);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; t)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (time == t)</span><br><span class="line">                    ans = probability;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (graphs[index].<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">                        ans = probability;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ans = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; probability &lt;&lt; endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graphs[index]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited.<span class="built_in">find</span>(neighbor) == visited.<span class="built_in">end</span>())</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">dfs</span>(neighbor, probability * (graphs[index].<span class="built_in">size</span>() - <span class="number">1</span>), time + <span class="number">1</span>))</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> ans &gt; <span class="number">0</span> ? <span class="number">1.0</span> / ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 180</title>
    <url>/2020/03/15/LeetCode-weekly-contest-180/</url>
    <content><![CDATA[<p>自从LeetCode<a href="https://leetcode.com/discuss/general-discussion/518516/New-Rating-Algorithm-Details-Contest-Season-and-Absence-in-Participation">更新了周赛rating算法</a>后，结果下我一跳。Rating直接涨到2171，全球排名608/81184, 完成比赛53场。记得上周我还在期望可以近几周突破2000分的，已经1990+了。更新后的算法显示去年8月份就已经2000了。</p>
<p>本周日会村里看望奶奶，由于疫情原因，之前一家人一直未能团聚。今天好不容易，几乎所有人都到场了。周赛也是回老家参加的。由于环境不适合思考，所以结果也差强人意。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (4)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>1300 / 10047</td>
<td>YoungForest</td>
<td>11</td>
<td>0:29:31</td>
<td>0:12:20</td>
<td>0:18:26</td>
<td>0:29:31</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1380-Lucky-Numbers-in-a-Matrix"><a href="#1380-Lucky-Numbers-in-a-Matrix" class="headerlink" title="1380. Lucky Numbers in a Matrix"></a>1380. Lucky Numbers in a Matrix</h2><p>统计每行的最小值所在的列数和每列最大值所在的行数，判断是否有相等的。</p>
<p>时间复杂度: O(m * n),<br>空间复杂度: O(m + n).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">luckyNumbers</span> <span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m =  matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span>  <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">row_min_index</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">col_max_index</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row_min_index[i] == <span class="number">-1</span> || matrix[i][row_min_index[i]] &gt; matrix[i][j]) &#123;</span><br><span class="line">                    row_min_index[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (col_max_index[j] == <span class="number">-1</span> || matrix[col_max_index[j]][j] &lt; matrix[i][j]) &#123;</span><br><span class="line">                    col_max_index[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; ++row) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col_max_index[row_min_index[row]] == row) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[row][row_min_index[row]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1381-Design-a-Stack-With-Increment-Operation"><a href="#1381-Design-a-Stack-With-Increment-Operation" class="headerlink" title="1381. Design a Stack With Increment Operation"></a>1381. Design a Stack With Increment Operation</h2><p>用数组实现栈即可。</p>
<p>时间复杂度:</p>
<ul>
<li>Constructor: O(1)</li>
<li>push: O(1)</li>
<li>pop: O(1)</li>
<li>increment: O(k)<br>空间复杂度: O(maxSize)</li>
</ul>
<p>还有一种<a href="https://leetcode.com/problems/design-a-stack-with-increment-operation/discuss/539716/JavaC++Python-Lazy-increment-O(1)">Lazy Increment的算法</a>，increment时，只做一个标记，只有到pop的时候才真的增加。可以实现increment的O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> max_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CustomStack</span>(<span class="keyword">int</span> maxSize) &#123;</span><br><span class="line">        data.<span class="built_in">resize</span>(maxSize);</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        max_size = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; max_size) &#123;</span><br><span class="line">            data[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[--index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; i &lt; index; ++i) &#123;</span><br><span class="line">            data[i] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CustomStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CustomStack* obj = new CustomStack(maxSize);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * obj-&gt;increment(k,val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1382-Balance-a-Binary-Search-Tree"><a href="#1382-Balance-a-Binary-Search-Tree" class="headerlink" title="1382. Balance a Binary Search Tree"></a>1382. Balance a Binary Search Tree</h2><p>先用中序遍历将数据排序，然后再使用二分法重新建树。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(height).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; element;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*)&gt; store = [&amp;](TreeNode* root) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">store</span>(root-&gt;left);</span><br><span class="line">                element.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                <span class="built_in">store</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">store</span>(root);</span><br><span class="line">        function&lt;TreeNode*(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; build = [&amp;](<span class="keyword">int</span> begin, <span class="keyword">int</span> end) -&gt; TreeNode* &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (begin == end) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(element[begin]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">auto</span> ret = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(element[mid]);</span><br><span class="line">                ret-&gt;left = <span class="built_in">build</span>(begin, mid - <span class="number">1</span>);</span><br><span class="line">                ret-&gt;right = <span class="built_in">build</span>(mid + <span class="number">1</span>, end);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(<span class="number">0</span>, element.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1383-Maximum-Performance-of-a-Team"><a href="#1383-Maximum-Performance-of-a-Team" class="headerlink" title="1383. Maximum Performance of a Team"></a>1383. Maximum Performance of a Team</h2><p>贪心的算法。先按照efficiency从大到小排序，挑选效率最高的k个人，然后再遍历效率稍低的人，尝试把他们加入队伍(剔除掉speed最小的), 更新可能的Maximum performance.</p>
<p>时间复杂度: O(N log N + N log K),<br>空间复杂度: O(N + K).</p>
<p>相似的题目: <a href="https://leetcode.com/problems/minimum-cost-to-hire-k-workers/description/">LeetCode 857</a>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">const</span> ll INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPerformance</span><span class="params">(<span class="keyword">int</span> n, vector&lt;<span class="keyword">int</span>&gt;&amp; speed, vector&lt;<span class="keyword">int</span>&gt;&amp; efficiency, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; workers;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            workers.<span class="built_in">push_back</span>(&#123;efficiency[i], speed[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(workers.<span class="built_in">begin</span>(), workers.<span class="built_in">end</span>(), greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;());</span><br><span class="line">        ll sum_speed = <span class="number">0</span>;</span><br><span class="line">        ll min_efficiency = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            sum_speed += workers[i].second;</span><br><span class="line">            min_efficiency = workers[i].first;</span><br><span class="line">            pq.<span class="built_in">push</span>(workers[i].second);</span><br><span class="line">            ans = <span class="built_in">max</span>(sum_speed * min_efficiency, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            min_efficiency = workers[i].first;</span><br><span class="line">            <span class="keyword">if</span> (workers[i].second &gt; pq.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                sum_speed = sum_speed - t + workers[i].second;</span><br><span class="line">                pq.<span class="built_in">push</span>(workers[i].second);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, sum_speed * min_efficiency);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode  weekly contest 181</title>
    <url>/2020/03/22/LeetCode-weekly-contest-181/</url>
    <content><![CDATA[<p>自从LeetCode rating算法更新后，我的rating到达了顶峰，之后就一直向下掉。不过也是因为自己菜，每次都打的大好几百名，偶尔还上千。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>839 / 10930</td>
<td>YoungForest</td>
<td>18</td>
<td>1:31:13</td>
<td>0:04:53</td>
<td>0:14:43  1</td>
<td>0:45:27  1</td>
<td>1:16:13  1</td>
</tr>
</tbody></table>
<h2 id="1389-Create-Target-Array-in-the-Given-Order"><a href="#1389-Create-Target-Array-in-the-Given-Order" class="headerlink" title="1389. Create Target Array in the Given Order"></a>1389. Create Target Array in the Given Order</h2><p>签到题。使用vector的insert接口，缺点是效率有问题，不过对于签到题足够了。</p>
<p>时间复杂度: O(n ^ 2), 最坏情况是 每次都插到首位。<br>空间复杂度: O(n).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">createTargetArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; index)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index[i] &lt; ans.<span class="built_in">size</span>()) </span><br><span class="line">                ans.<span class="built_in">insert</span>(ans.<span class="built_in">begin</span>() + index[i], nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1390-Four-Divisors"><a href="#1390-Four-Divisors" class="headerlink" title="1390. Four Divisors"></a>1390. Four Divisors</h2><p>Brute force. 计算每个数的因数。</p>
<p>时间复杂度: O(sqrt(nums[i]) * nums.length),<br>空间复杂的: O(nums.length) -&gt; O(1) without memo.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; sumDivisors;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divisors</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo.<span class="built_in">find</span>(x) == memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">1</span> + x;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                        ans += (i * i == x) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">                        sum += (i * i == x) ? i : i + x / i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ans &gt; <span class="number">4</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ans == <span class="number">4</span>) &#123;</span><br><span class="line">                    sumDivisors[x] = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> memo[x] = ans;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumFourDivisors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">divisors</span>(i) == <span class="number">4</span>)</span><br><span class="line">                ans += sumDivisors[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1391-Check-if-There-is-a-Valid-Path-in-a-Grid"><a href="#1391-Check-if-There-is-a-Valid-Path-in-a-Grid" class="headerlink" title="1391. Check if There is a Valid Path in a Grid"></a>1391. Check if There is a Valid Path in a Grid</h2><p>算法不是很难的一道题目，一遍搜索即可。难点在于实现，对复杂问题进行抽象。我在这里使用了多个hashmap来解决方位的抽象。</p>
<p>时间复杂度: O(row * col),<br>空间复杂度: O(1).</p>
<p>本题也可以用 “<a href="https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/discuss/547229/Python-Union-Find">并查集</a>“解决，实现起来更简单些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; directions = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;up&quot;</span>, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;down&quot;</span>, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;left&quot;</span>, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;right&quot;</span>, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, unordered_map&lt;string, string&gt;&gt; mm = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, &#123;&#123;<span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>&#125;, &#123;<span class="string">&quot;right&quot;</span>, <span class="string">&quot;left&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, &#123;&#123;<span class="string">&quot;up&quot;</span>, <span class="string">&quot;down&quot;</span>&#125;, &#123;<span class="string">&quot;down&quot;</span>, <span class="string">&quot;up&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, &#123;&#123;<span class="string">&quot;left&quot;</span>, <span class="string">&quot;down&quot;</span>&#125;, &#123;<span class="string">&quot;down&quot;</span>, <span class="string">&quot;left&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, &#123;&#123;<span class="string">&quot;down&quot;</span>, <span class="string">&quot;right&quot;</span>&#125;, &#123;<span class="string">&quot;right&quot;</span>, <span class="string">&quot;down&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, &#123;&#123;<span class="string">&quot;left&quot;</span>, <span class="string">&quot;up&quot;</span>&#125;, &#123;<span class="string">&quot;up&quot;</span>, <span class="string">&quot;left&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>, &#123;&#123;<span class="string">&quot;up&quot;</span>, <span class="string">&quot;right&quot;</span>&#125;, &#123;<span class="string">&quot;right&quot;</span>, <span class="string">&quot;up&quot;</span>&#125;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        unordered_map&lt;string, string&gt; reversed = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;left&quot;</span>, <span class="string">&quot;right&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;right&quot;</span>, <span class="string">&quot;left&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;up&quot;</span>, <span class="string">&quot;down&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;down&quot;</span>, <span class="string">&quot;up&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;string&gt;&gt; start_direction = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, &#123;<span class="string">&quot;left&quot;</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, &#123;<span class="string">&quot;up&quot;</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, &#123;<span class="string">&quot;left&quot;</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, &#123;<span class="string">&quot;down&quot;</span>, <span class="string">&quot;right&quot;</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, &#123;&#125;&#125;,</span><br><span class="line">            &#123;<span class="number">6</span>, &#123;<span class="string">&quot;up&quot;</span>&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (string d : start_direction[grid[<span class="number">0</span>][<span class="number">0</span>]]) &#123;</span><br><span class="line">            <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                d = mm[grid[row][col]][d];</span><br><span class="line">                row += directions[d].first;</span><br><span class="line">                col += directions[d].second;</span><br><span class="line">                d = reversed[d];</span><br><span class="line">                <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n || mm[grid[row][col]].<span class="built_in">find</span>(d) == mm[grid[row][col]].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row == m - <span class="number">1</span> &amp;&amp; col == n - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1392-Longest-Happy-Prefix"><a href="#1392-Longest-Happy-Prefix" class="headerlink" title="1392. Longest Happy Prefix"></a>1392. Longest Happy Prefix</h2><p>参考的是<a href="https://www.geeksforgeeks.org/longest-prefix-also-suffix/">geekforgeek</a>上的代码，并不难找，Google “longest prefix suffix”就能出来。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPrefix</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(); </span><br><span class="line">  </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">lps</span><span class="params">(n)</span></span>; </span><br><span class="line">        lps[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// lps[0] is always 0 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// length of the previous </span></span><br><span class="line">        <span class="comment">// longest prefix suffix </span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// the loop calculates lps[i] </span></span><br><span class="line">        <span class="comment">// for i = 1 to n-1 </span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[len]) </span><br><span class="line">            &#123; </span><br><span class="line">                len++; </span><br><span class="line">                lps[i] = len; </span><br><span class="line">                i++; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// (pat[i] != pat[len]) </span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (len != <span class="number">0</span>) </span><br><span class="line">                &#123; </span><br><span class="line">                    len = lps[len<span class="number">-1</span>]; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// if (len == 0) </span></span><br><span class="line">                &#123; </span><br><span class="line">                    lps[i] = <span class="number">0</span>; </span><br><span class="line">                    i++; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> res = lps[n<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(<span class="number">0</span>, res); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 182</title>
    <url>/2020/03/29/LeetCode-weekly-contest-182/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (8)</th>
</tr>
</thead>
<tbody><tr>
<td>727 / 11694</td>
<td>YoungForest</td>
<td>12</td>
<td>0:22:50</td>
<td>0:03:13</td>
<td>0:14:04</td>
<td>0:22:50</td>
<td>null</td>
</tr>
</tbody></table>
<p>这周一加了一个LeetCode每日打卡和周赛群。每周出排名，末位发红包；每天做道指定题目，连续2天没做发红包，极其惊现刺激。<a href="https://wisdompeak.github.io/lc-score-board/">赛事排行榜</a>。<br>本次比赛是入群以来的第一次，由于第四题太难了，总共也就一百人做出来。群里也只有5个人AC</p>
<h2 id="1394-Find-Lucky-Integer-in-an-Array"><a href="#1394-Find-Lucky-Integer-in-an-Array" class="headerlink" title="1394. Find Lucky Integer in an Array"></a>1394. Find Lucky Integer in an Array</h2><p>签到题。注意数据范围，统计frequency即可。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLucky</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">501</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            ++count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">500</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] == i)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1395-Count-Number-of-Teams"><a href="#1395-Count-Number-of-Teams" class="headerlink" title="1395. Count Number of Teams"></a>1395. Count Number of Teams</h2><p>由于数据规模很小，所以即使是枚举所有3元组的N^3的解法也能过。<br>在这里，我使用了DP, N^2复杂度的解法。如果使用order statistic tree的话，可以近一步降为N log N.</p>
<p>时间复杂度: O(N ^ 2),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; rating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> f = [&amp;](function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; op) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> n = rating.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">large</span>(<span class="number">3</span>, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> echo = <span class="number">1</span>; echo &lt;= <span class="number">2</span>; ++echo) &#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    large[echo][i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">op</span>(rating[i], rating[j])) &#123;</span><br><span class="line">                            large[echo][i] += large[echo<span class="number">-1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += large[echo][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(greater&lt;<span class="keyword">int</span>&gt;()) + <span class="built_in">f</span>(less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1396-Design-Underground-System"><a href="#1396-Design-Underground-System" class="headerlink" title="1396. Design Underground System"></a>1396. Design Underground System</h2><p>straight forward.<br>用map记录每个站对的进出站总时间和人数。</p>
<p>时间复杂度：</p>
<ul>
<li>checkIn: O(1),</li>
<li>checkOut: O(1 + log N),</li>
<li>getAverageTime: O(log N).<br>空间复杂度: O(user.size() + station.size() ^ 2).</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span> &#123;</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, pair&lt;string, <span class="keyword">int</span>&gt;&gt; user_checkin_time;    <span class="comment">// 记录进站信息</span></span><br><span class="line">    map&lt;pair&lt;string, string&gt;, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; interval_total_time_person_count; <span class="comment">// 记录2站之间流量的信息，总时间、人数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UndergroundSystem</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">(<span class="keyword">int</span> id, string stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        user_checkin_time[id] = &#123;stationName, t&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">(<span class="keyword">int</span> id, string stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> in = user_checkin_time[id];</span><br><span class="line">        <span class="keyword">auto</span>&amp; interval = interval_total_time_person_count[&#123;in.first, stationName&#125;];</span><br><span class="line">        interval.first += t - in.second;</span><br><span class="line">        ++interval.second;</span><br><span class="line">        user_checkin_time.<span class="built_in">erase</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAverageTime</span><span class="params">(string startStation, string endStation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = interval_total_time_person_count.<span class="built_in">find</span>(&#123;startStation, endStation&#125;);</span><br><span class="line">        <span class="keyword">if</span> (it == interval_total_time_person_count.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(it-&gt;second.first) / it-&gt;second.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * UndergroundSystem* obj = new UndergroundSystem();</span></span><br><span class="line"><span class="comment"> * obj-&gt;checkIn(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * obj-&gt;checkOut(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * double param_3 = obj-&gt;getAverageTime(startStation,endStation);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1397-Find-All-Good-Strings"><a href="#1397-Find-All-Good-Strings" class="headerlink" title="1397. Find All Good Strings"></a>1397. Find All Good Strings</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 183</title>
    <url>/2020/04/07/LeetCode-weekly-contest-183/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>91 / 12542</td>
<td>YoungForest</td>
<td>21</td>
<td>0:39:07</td>
<td>0:09:24</td>
<td>0:15:33</td>
<td>0:29:53</td>
<td>0:39:07</td>
</tr>
</tbody></table>
<p>本周又是手速场，足足有800人AK。可能是由于疫情的原因，程序员都wfh（work from home），每次周赛的参加人数都稳步上涨，比我刚回国的时候已经增加一个一倍了。rating掉了有一个月了，这周终于涨上来了，2187，恢复到了最高点。</p>
<h2 id="1403-Minimum-Subsequence-in-Non-Increasing-Order"><a href="#1403-Minimum-Subsequence-in-Non-Increasing-Order" class="headerlink" title="1403. Minimum Subsequence in Non-Increasing Order"></a>1403. Minimum Subsequence in Non-Increasing Order</h2><p>贪心。先排序，试图选大的值，直到累计和超过一半。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minSubsequence</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">int</span> sumAll = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> sumCurrent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            sumCurrent += i;</span><br><span class="line">            <span class="keyword">if</span> (sumCurrent &gt; sumAll / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One"><a href="#1404-Number-of-Steps-to-Reduce-a-Number-in-Binary-Representation-to-One" class="headerlink" title="1404. Number of Steps to Reduce a Number in Binary Representation to One"></a>1404. Number of Steps to Reduce a Number in Binary Representation to One</h2><p>用字符串模拟“加一”操作，直到为1.<br>这里我用了一个list来存字符，以方便进位操作。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSteps</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">list&lt;<span class="keyword">char</span>&gt; <span class="title">l</span><span class="params">(s.begin(), s.end())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l.<span class="built_in">back</span>() == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = l.<span class="built_in">rbegin</span>();</span><br><span class="line">                <span class="keyword">for</span> (;it != l.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (*it == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                        *it = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                        <span class="keyword">goto</span> endIf;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        *it = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                l.<span class="built_in">push_front</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">                endIf: ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1405-Longest-Happy-String"><a href="#1405-Longest-Happy-String" class="headerlink" title="1405. Longest Happy String"></a>1405. Longest Happy String</h2><p>贪心。每次试图用剩余最多的字符。</p>
<p>时间复杂度: O(a + b + c),<br>空间复杂度: O(a + b + c).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// greedy</span></span><br><span class="line">        string ans;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; count = &#123;a, b, c&#125;;</span><br><span class="line">        <span class="keyword">auto</span> maxChar = [&amp;](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; mask) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask[i] == <span class="number">0</span> &amp;&amp; (ans == <span class="number">-1</span> || count[i] &gt; count[ans])) &#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span> (count[<span class="number">0</span>] &gt; <span class="number">0</span> || count[<span class="number">1</span>] &gt; <span class="number">0</span> || count[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextChar = <span class="number">-1</span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mask</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() &gt;= <span class="number">2</span> &amp;&amp; ans[ans.<span class="built_in">size</span>() - <span class="number">1</span>] == ans[ans.<span class="built_in">size</span>() - <span class="number">2</span>]) &#123;</span><br><span class="line">                mask[ans[ans.<span class="built_in">size</span>() - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">                nextChar = <span class="built_in">maxChar</span>(mask);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextChar = <span class="built_in">maxChar</span>(mask);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count[nextChar] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + nextChar);</span><br><span class="line">            --count[nextChar];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1406-Stone-Game-III"><a href="#1406-Stone-Game-III" class="headerlink" title="1406. Stone Game III"></a>1406. Stone Game III</h2><p>DP。<br>f(x): 以x开头，先手最优情况下获得的分数。<br>因为2个人都以最优策略执行, 所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f(x) = max(剩余所有和 - f(x + 1),</span><br><span class="line">剩余所有和 - f(x + 2),</span><br><span class="line">剩余所有和 - f(x + 3)).</span><br></pre></td></tr></table></figure>
<p>Alice获得的最大分数为<code>f(0)</code>.</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGameIII</span>(<span class="params">self, stoneValue: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">suffixFunction</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == <span class="built_in">len</span>(stoneValue):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> stoneValue[x] + suffixFunction(x + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x &gt;= <span class="built_in">len</span>(stoneValue):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                suffix = suffixFunction(x)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(suffix - f(x + <span class="number">1</span>), suffix - f(x + <span class="number">2</span>), suffix - f(x + <span class="number">3</span>))</span><br><span class="line">        alice = f(<span class="number">0</span>)</span><br><span class="line">        bob = suffixFunction(<span class="number">0</span>) - alice</span><br><span class="line">        <span class="keyword">if</span> alice == bob:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Tie&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> alice &gt; bob:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>今天翻到很久之前写的contest的博客，大概一年多前准备Google电话面试的时候。当时还是很菜的，一般能做出2题就差不多了。谷歌的面试也挂在了第一轮，就问了个加油站问题 和 最近公共祖先问题。都答的不是很好。现在看来都是不难的题目。遗憾当时准备不足，水平也有限。一年过后，同样面对Google的面试，虽回答的不完美，但也通过了第一轮面试。我从18年底开始大量刷题，现在做了有900+道了，contest也参加了50+，算法水平还是有可见的进步的。虽然离大佬的差距依旧很大。<br>不过由于疫情的原因，application并没有继续进行下去。HR只说是招聘流程有变化。和残酷刷题群的群友交流，美国那边很多New Graduate和intern的招聘都停了，原来发的offer很多也收回了，或者work from home。谷歌中国不会也这样吧。<br>之前只知道就业形势一年不如一年，没想到今年这么糟糕呀。实习、毕业都成问题。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 184</title>
    <url>/2020/04/12/LeetCode-weekly-contest-184/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>589 / 9816</td>
<td>YoungForest</td>
<td>19</td>
<td>0:55:30</td>
<td>0:07:04</td>
<td>0:15:05</td>
<td>0:37:18  1</td>
<td>0:50:30</td>
</tr>
</tbody></table>
<p>今天又是一轮手速场。Python告诉我们，“人生苦短，我用Python”。我有2题用Python实现，1和4。事实上，对于第3题，直接调用Python Str API更是如鱼得水，不过我当时选择了用Trie+自动机的方式实现，也活该名次掉下来。</p>
<h2 id="1408-String-Matching-in-an-Array"><a href="#1408-String-Matching-in-an-Array" class="headerlink" title="1408. String Matching in an Array"></a>1408. String Matching in an Array</h2><p>签到题。使用Python Str的find函数确定是否是子字符串即可。</p>
<p>时间复杂度: O(words.length ^ 2 * words[i].length),<br>空间复杂度: O(words.length * words[i].length).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stringMatching</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        n = <span class="built_in">len</span>(words)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> words[i].find(words[j]) != -<span class="number">1</span>:</span><br><span class="line">                    ans.add(words[j])</span><br><span class="line">                <span class="keyword">if</span> words[j].find(words[i]) != -<span class="number">1</span>:</span><br><span class="line">                    ans.add(words[i])</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> ans]</span><br></pre></td></tr></table></figure>

<h2 id="1409-Queries-on-a-Permutation-With-Key"><a href="#1409-Queries-on-a-Permutation-With-Key" class="headerlink" title="1409. Queries on a Permutation With Key"></a>1409. Queries on a Permutation With Key</h2><p>用List模拟Permutation的变化。<br>寻找位置时使用顺序查找。</p>
<p>时间复杂度: O(m + queries.length * m),<br>空间复杂度: O(m + queries.length).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">processQueries</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; queries, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        list&lt;<span class="keyword">int</span>&gt; P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            P.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(queries.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = P.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (it != P.<span class="built_in">end</span>() &amp;&amp; *it != queries[i]) &#123;</span><br><span class="line">                ++it;</span><br><span class="line">                ++position;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = position;</span><br><span class="line">            P.<span class="built_in">push_front</span>(*it);</span><br><span class="line">            P.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Discuss中提供了一种<a href="https://leetcode.com/problems/queries-on-a-permutation-with-key/discuss/575019/Python-Fenwick-tree-O(n-log-n)">Fenwick Tree的解法</a>，时间复杂度: O(queries.length * log m + m * log m).</p>
<h2 id="1410-HTML-Entity-Parser"><a href="#1410-HTML-Entity-Parser" class="headerlink" title="1410. HTML Entity Parser"></a>1410. HTML Entity Parser</h2><p>自动机，用Trie维护自动机的状态转移。</p>
<p>时间复杂度: O(text.length),<br>空间复杂度: O(text.length + 1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, shared_ptr&lt;Trie&gt;&gt; children;</span><br><span class="line">        <span class="keyword">char</span> replace;</span><br><span class="line">        <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">char</span> c, <span class="keyword">int</span> index = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                valid = <span class="literal">true</span>;</span><br><span class="line">                replace = c;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (children[s[index]] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                children[s[index]] = make_shared&lt;Trie&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            children[s[index]]-&gt;<span class="built_in">add</span>(s, c, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">entityParser</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        shared_ptr&lt;Trie&gt; root = make_shared&lt;Trie&gt;();</span><br><span class="line">        root-&gt;<span class="built_in">add</span>(<span class="string">&quot;&amp;quot;&quot;</span>, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">        root-&gt;<span class="built_in">add</span>(<span class="string">&quot;&amp;apos;&quot;</span>, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">        root-&gt;<span class="built_in">add</span>(<span class="string">&quot;&amp;amp;&quot;</span>, <span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">        root-&gt;<span class="built_in">add</span>(<span class="string">&quot;&amp;gt;&quot;</span>, <span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">        root-&gt;<span class="built_in">add</span>(<span class="string">&quot;&amp;lt;&quot;</span>, <span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        root-&gt;<span class="built_in">add</span>(<span class="string">&quot;&amp;frasl;&quot;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">int</span>  i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; text.<span class="built_in">size</span>())  &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i] == <span class="string">&#x27;&amp;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">auto</span> current = root;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; text.<span class="built_in">size</span>() &amp;&amp; current-&gt;children[text[j]] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    current = current-&gt;children[text[j++]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;valid) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(current-&gt;replace);</span><br><span class="line">                    i = j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(text[i++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(text[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1411-Number-of-Ways-to-Paint-N-×-3-Grid"><a href="#1411-Number-of-Ways-to-Paint-N-×-3-Grid" class="headerlink" title="1411. Number of Ways to Paint N × 3 Grid"></a>1411. Number of Ways to Paint N × 3 Grid</h2><p>递归解法，一行一行地确定Paint数目。明确本行可行和上行兼容的表示方法即可。</p>
<p>时间复杂度: O(n),<br>空间复杂度: O(n) -&gt; O(1). 最多只需要保存2行的状态即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfWays</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">        @functools.lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">unzip</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">            a = x // (<span class="number">3</span>*<span class="number">3</span>)</span><br><span class="line">            b = (x // (<span class="number">3</span>)) % <span class="number">3</span></span><br><span class="line">            c = x % <span class="number">3</span></span><br><span class="line">            <span class="keyword">return</span> [a, b, c]</span><br><span class="line"><span class="meta">        @functools.lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">row_not_valid</span>(<span class="params">state: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            a, b, c = unzip(state)</span><br><span class="line">            <span class="keyword">return</span> a == b <span class="keyword">or</span> b == c</span><br><span class="line"><span class="meta">        @functools.lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">between_row_valid</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            al = unzip(a)</span><br><span class="line">            bl = unzip(b)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">all</span>(al[i] != bl[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line">            </span><br><span class="line"><span class="meta">        @functools.lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">n: <span class="built_in">int</span>, state: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> row_not_valid(state):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>**<span class="number">3</span>):</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> row_not_valid(i) <span class="keyword">and</span> between_row_valid(state, i):</span><br><span class="line">                            ans += dp(n-<span class="number">1</span>, i)</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>**<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> row_not_valid(i):</span><br><span class="line">                ans += dp(n-<span class="number">1</span>, i)</span><br><span class="line">        <span class="keyword">return</span> ans % (<span class="number">1000000000</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 185</title>
    <url>/2020/04/20/LeetCode-weekly-contest-185/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>703 / 9206</td>
<td>YoungForest</td>
<td>12</td>
<td>0:36:35</td>
<td>0:10:24</td>
<td>0:22:03</td>
<td>0:31:35  1</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1417-Reformat-The-String"><a href="#1417-Reformat-The-String" class="headerlink" title="1417. Reformat The String"></a>1417. Reformat The String</h2><p>分别统计数字和字母的个数。如果相差个数不大于1，则可以reformat。<br>先选多的那类。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N). 可以用双指针的方法，节省存储数字和字母的string的空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">string <span class="title">compose</span><span class="params">(<span class="keyword">const</span> string&amp; a, <span class="keyword">const</span> string&amp; b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">int</span> ai = <span class="number">0</span>, bi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>())</span><br><span class="line">            ans.<span class="built_in">push_back</span>(a[ai++]);</span><br><span class="line">        <span class="keyword">while</span> (ai &lt; a.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(b[bi++]);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(a[ai++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reformat</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string digit, alpha;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                digit.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alpha.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digit.<span class="built_in">size</span>() == alpha.<span class="built_in">size</span>() || digit.<span class="built_in">size</span>() + <span class="number">1</span> == alpha.<span class="built_in">size</span>() || alpha.<span class="built_in">size</span>() + <span class="number">1</span> == digit.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digit.<span class="built_in">size</span>() &gt;= alpha.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">compose</span>(digit, alpha);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">compose</span>(alpha, digit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1418-Display-Table-of-Food-Orders-in-a-Restaurant"><a href="#1418-Display-Table-of-Food-Orders-in-a-Restaurant" class="headerlink" title="1418. Display Table of Food Orders in a Restaurant"></a>1418. Display Table of Food Orders in a Restaurant</h2><p>考察数据结构的使用。遍历orders，将其转换成dish-&gt;table的hashmap，同时用set存储table编号。</p>
<p>时间复杂度: O(orders.length * orders[i].length),<br>空间复杂度: O(tables.length * dishes.length).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">displayTable</span>(vector&lt;vector&lt;string&gt;&gt;&amp; orders) &#123;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; tables;</span><br><span class="line">        map&lt;string, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : orders) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> table_number = <span class="built_in">stoi</span>(p[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; dish = p[<span class="number">2</span>];</span><br><span class="line">            ++count[dish][table_number];</span><br><span class="line">            tables.<span class="built_in">insert</span>(table_number);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        vector&lt;string&gt; first_row = &#123;<span class="string">&quot;Table&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : count) &#123;</span><br><span class="line">            first_row.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="built_in">move</span>(first_row));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : tables) &#123;</span><br><span class="line">            vector&lt;string&gt; row;</span><br><span class="line">            row.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : count) &#123;</span><br><span class="line">                row.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(p.second[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">move</span>(row));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1419-Minimum-Number-of-Frogs-Croaking"><a href="#1419-Minimum-Number-of-Frogs-Croaking" class="headerlink" title="1419. Minimum Number of Frogs Croaking"></a>1419. Minimum Number of Frogs Croaking</h2><p>有限状态机，记录处于不同位置青蛙的个数。模拟整个叫声。</p>
<p>时间复杂度: O(croakOfFrogs.length),<br>时间复杂度: O(croak.length).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberOfFrogs</span><span class="params">(string croakOfFrogs)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">state_count</span><span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; position = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;c&#x27;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;o&#x27;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;k&#x27;</span>, <span class="number">4</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : croakOfFrogs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (position[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state_count[<span class="number">4</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --state_count[<span class="number">4</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                ++state_count[position[c]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++state_count[position[c]];</span><br><span class="line">                <span class="keyword">if</span> (state_count[position[c]<span class="number">-1</span>] &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                --state_count[position[c]<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">all_of</span>(state_count.<span class="built_in">begin</span>(), state_count.<span class="built_in">begin</span>() + <span class="number">4</span>, [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a == <span class="number">0</span>;</span><br><span class="line">        &#125;))</span><br><span class="line">            <span class="keyword">return</span> state_count[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1420-Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons"><a href="#1420-Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons" class="headerlink" title="1420. Build Array Where You Can Find The Maximum Exactly K Comparisons"></a>1420. Build Array Where You Can Find The Maximum Exactly K Comparisons</h2><p>最近做DP的题目虽然做了很多，但遇到新的问题还是不一定能做出来。遇到的困难主要有：</p>
<ul>
<li>确定dp的定义。一般情况下照搬目标就可以了，但有些题目不是。</li>
<li>确定边界条件。递归退出的条件。</li>
<li>状态转移方程，和dp的定义紧密相连。</li>
</ul>
<p>本题中dp[i][currentMaxValue][cost]表示长度为i的数组，且数组中最大值为currentMaxValue, 递增子序列长度为cost 的数组个数。</p>
<p>状态转移方程 有2类：<br>一是i-1数组的最大值已经是currentMaxValue了。这时，我们可以在第i个位置加上[1, currentMaxValue], 而cost不变。<br>二是i-1数组的最大值小于currentMaxValue。此时，第i个位置必须是currentMaxValue。且之前的cost为cost-1. 需要注意的是，前面的最大值最小是cost-1，递增序列为1, …, cost-1.</p>
<p>时间复杂度: O(n * m * k * (m - k)),<br>空间复杂度: O(n * m * k).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfArrays</span>(<span class="params">self, n: <span class="built_in">int</span>, m: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i, currentMaxValue, cost</span>):</span></span><br><span class="line">            <span class="keyword">if</span> cost == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> currentMaxValue**i</span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="comment"># arr[i] &lt;= currentMaxValue</span></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &gt; cost:</span><br><span class="line">                ans += dp(i-<span class="number">1</span>, currentMaxValue, cost) * currentMaxValue</span><br><span class="line">            <span class="comment"># arr[i] == currentMaxValue</span></span><br><span class="line">            ans += <span class="built_in">sum</span>(dp(i-<span class="number">1</span>, x, cost - <span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(cost - <span class="number">1</span>, currentMaxValue))</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(dp(n - <span class="number">1</span>, x, k) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(k, m+<span class="number">1</span>)) % mod</span><br><span class="line">        <span class="comment"># return sum(dp(length, k, x) * (x ** (n - length)) for x in range(1, m + 1) for length in range(1, n+1))</span></span><br></pre></td></tr></table></figure>

<h2 id="美团笔试中的一道DP题目"><a href="#美团笔试中的一道DP题目" class="headerlink" title="美团笔试中的一道DP题目"></a>美团笔试中的一道DP题目</h2><p>周四参加美团暑期实习招聘的笔试，最后一道也是DP，但当时没做出来, 其实也就那么回事。</p>
<blockquote>
<p>给2个字符串S, T. 求S的子串等于T的子序列的个数。注意，即使子串相同，但位置不同，算2种。<br>S，T的长度最大为5000.</p>
</blockquote>
<p>时间复杂度: (len(S) * (len(T) ^ 2)),<br>空间复杂度: (len(S) * len(T)).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">S = <span class="built_in">input</span>()</span><br><span class="line">T = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i, j</span>):</span></span><br><span class="line">    <span class="comment"># S[x:i], 以s[i]结尾的子串，T[:j]中子串匹配到的数目</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">if</span> S[i] == T[x] <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, j + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> S[i] == T[<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> T[<span class="number">0</span>] == S[i]:</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, j+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> T[x] == S[i]:</span><br><span class="line">            ans += dp(i-<span class="number">1</span>, x-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">mod = <span class="number">1000000000</span> + <span class="number">7</span></span><br><span class="line">ans = <span class="built_in">sum</span>(dp(x, <span class="built_in">len</span>(T)-<span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(S))) % mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weeekly contest 186</title>
    <url>/2020/04/26/LeetCode-weekly-contest-186/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (4)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>113 / 11684</td>
<td>YoungForest</td>
<td>18</td>
<td>0:34:17</td>
<td>0:04:32</td>
<td>0:10:54</td>
<td>0:18:49</td>
<td>0:34:17</td>
</tr>
</tbody></table>
<p>手速场。换成Python后，手速场很轻松。真的是人生苦短，我用Python。不过在用Python刷题的过程中，我也发现了一些问题。</p>
<ul>
<li>API不熟悉。比如sorted会返回一个排好序的list，而不是in-place sort.</li>
<li>数据结构不全。如没有treemap，priority_queue只能用heap，代替。最小堆需要把所有数*-1，使用这种丑陋的实现方式。</li>
<li>runtime error。在一些手误情况下，会有错误的提交。这时候很考验你的测试用例了，是否覆盖所有的情况和边界条件。</li>
</ul>
<h2 id="1422-Maximum-Score-After-Splitting-a-String"><a href="#1422-Maximum-Score-After-Splitting-a-String" class="headerlink" title="1422. Maximum Score After Splitting a String"></a>1422. Maximum Score After Splitting a String</h2><p>brute-force. <code>2 &lt;= s.length &lt;= 500</code>.</p>
<p>时间复杂度: O(N ^ 2),<br>空间复杂度: O(1).</p>
<p>另外，如果采取Presum的方式的话，时间复杂度可以降为<code>O(N)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">s, c</span>):</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> i == c:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(count(s[:x], <span class="string">&#x27;0&#x27;</span>) + count(s[x:], <span class="string">&#x27;1&#x27;</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s)))</span><br></pre></td></tr></table></figure>

<h2 id="1423-Maximum-Points-You-Can-Obtain-from-Cards"><a href="#1423-Maximum-Points-You-Can-Obtain-from-Cards" class="headerlink" title="1423. Maximum Points You Can Obtain from Cards"></a>1423. Maximum Points You Can Obtain from Cards</h2><p>问题可以转化为：从头取x个，从尾取k-x个 和最大。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span>(<span class="params">self, cardPoints: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(cardPoints)</span><br><span class="line">        presum = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        suffixsum = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            presum[i] = presum[i-<span class="number">1</span>] + cardPoints[i-<span class="number">1</span>]</span><br><span class="line">            suffixsum[i] = suffixsum[i-<span class="number">1</span>] + cardPoints[n-i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(presum[x] + suffixsum[k-x] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)) <span class="comment"># take x from head, k - x from tail</span></span><br></pre></td></tr></table></figure>

<p>评论区还有一种主流方法。将问题转化为 寻找和最小的大小为<code>num.size()-k</code>的子数组。使用滑动窗口的方法，时间复杂度: O(N), 空间复杂度: O(1).</p>
<h2 id="1424-Diagonal-Traverse-II"><a href="#1424-Diagonal-Traverse-II" class="headerlink" title="1424. Diagonal Traverse II"></a>1424. Diagonal Traverse II</h2><p>遍历一遍，把元素放入适当的对角线上。对角线用一个dict存储，每条对角线是个list.<br>需要注意的是，python中dict是hashmap，3.7后保证遍历时的顺序和插入的顺序一致。所以在这里我们可以直接遍历对角线字典。</p>
<p>时间复杂度: O(the number of elements),<br>空间复杂度: O(the number of elements).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        line = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums[start])):</span><br><span class="line">                line[start + i].append(nums[start][i])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">while</span> line[i]:</span><br><span class="line">                ans.append(line[i].pop())</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="1425-Constrained-Subset-Sum"><a href="#1425-Constrained-Subset-Sum" class="headerlink" title="1425. Constrained Subset Sum"></a>1425. Constrained Subset Sum</h2><p>动态规划。dp[i]表示以第i个元素结尾，的最大子集和。<br>dp[i] = max(dp[j] + nums[i] for i - j &gt;= k).<br>观察有，当遇到非负数时，可以提前跳出。因为子集中肯定尽量加正数（非负数）。</p>
<p>时间复杂度: O(n * k),<br>空间复杂度: O(n).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constrainedSubsetSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = nums[:]</span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                index = i - <span class="number">1</span> - j</span><br><span class="line">                <span class="keyword">if</span> index &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[index] + nums[i])</span><br><span class="line">                <span class="keyword">if</span> nums[index] &gt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/constrained-subset-sum/discuss/597693/PythonC%2B%2B-DP-with-decreasing-deque">评论区</a>中有正确的O(N)的解法。利用单调递减deque，可以在O(1)的时间里维护<code>max(dp[j] + nums[i] for i - j &gt;= k)</code>.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 187</title>
    <url>/2020/05/04/LeetCode-weekly-contest-187/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>301 / 12353</td>
<td>YoungForest</td>
<td>19</td>
<td>1:03:24</td>
<td>0:06:34</td>
<td>0:03:07</td>
<td>0:17:30</td>
<td>1:03:24</td>
</tr>
</tbody></table>
<h2 id="1436-Destination-City"><a href="#1436-Destination-City" class="headerlink" title="1436. Destination City"></a>1436. Destination City</h2><p>遍历每条边，统计各个点的出度。</p>
<p>时间复杂度: O(path.length * city[i].length),<br>空间复杂度: O(city.length * city[i].length).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">destCity</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; outgoing;</span><br><span class="line">        unordered_set&lt;string&gt; seen;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : paths) &#123;</span><br><span class="line">            ++outgoing[v[<span class="number">0</span>]];</span><br><span class="line">            seen.<span class="built_in">insert</span>(v[<span class="number">0</span>]);</span><br><span class="line">            seen.<span class="built_in">insert</span>(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s : seen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outgoing[s] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away"><a href="#1437-Check-If-All-1’s-Are-at-Least-Length-K-Places-Away" class="headerlink" title="1437. Check If All 1’s Are at Least Length K Places Away"></a>1437. Check If All 1’s Are at Least Length K Places Away</h2><p>One pass. 记录上一个1出现的位置。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">kLengthApart</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last_one = -INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - last_one - <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                    last_one = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit"><a href="#1438-Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit" class="headerlink" title="1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"></a>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit</h2><p>双指针，用一个multiset维护子数组中的元素，由于treemap的特点，可以快速地锁定子数组中的最大最小值。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        multiset&lt;<span class="keyword">int</span>&gt; subarray;</span><br><span class="line">        <span class="keyword">size_t</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, l = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!subarray.<span class="built_in">empty</span>() &amp;&amp; nums[r] - *subarray.<span class="built_in">begin</span>() &gt; limit) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = subarray.<span class="built_in">find</span>(nums[l++]);</span><br><span class="line">                subarray.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!subarray.<span class="built_in">empty</span>() &amp;&amp; *subarray.<span class="built_in">rbegin</span>() - nums[r] &gt; limit) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = subarray.<span class="built_in">find</span>(nums[l++]);</span><br><span class="line">                subarray.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            subarray.<span class="built_in">insert</span>(nums[r]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, subarray.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1439-Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows"><a href="#1439-Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows" class="headerlink" title="1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows"></a>1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows</h2><p>优先队列记录所有的候选者，从中选出sum最小的组合，并将变化后的可能加入优先队列。<br>需要注意的是，相同的候选者可能从不同的状态产生（如 001, 010 -&gt; 011)，这里我用了一个set和字符串变化以去重。</p>
<p>时间复杂度: O(k * m * m * log (nm)),<br>空间复杂度: O(n * m * m).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">string <span class="title">encode</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : v) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> rank = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt;,std::vector&lt;pair&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;&gt;&gt;, std::greater&lt;pair&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;&gt;&gt;&gt; pq; <span class="comment">// difference, row_index</span></span><br><span class="line">        unordered_set&lt;string&gt; seen;</span><br><span class="line">        <span class="keyword">int</span> current_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            current_sum += mat[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">index</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;current_sum, index&#125;);</span><br><span class="line">            seen.<span class="built_in">insert</span>(<span class="built_in">encode</span>(index));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (rank &lt; k &amp;&amp; !pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            current_sum = t.first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                ++t.second[i];</span><br><span class="line">                string x = <span class="built_in">encode</span>(t.second);</span><br><span class="line">                <span class="keyword">if</span> (t.second[i] &lt; n &amp;&amp; seen.<span class="built_in">find</span>(x) == seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;current_sum + mat[i][t.second[i]] - mat[i][t.second[i]<span class="number">-1</span>], t.second&#125;);</span><br><span class="line">                    seen.<span class="built_in">insert</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">                --t.second[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ++rank;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 188</title>
    <url>/2020/05/10/LeetCode-weekly-contest-188/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>445 / 12715</td>
<td>YoungForest</td>
<td>19</td>
<td>1:14:29</td>
<td>0:07:04</td>
<td>0:17:33</td>
<td>0:56:49</td>
<td>1:14:29</td>
</tr>
</tbody></table>
<p>Rating 稳定在2200+2周了，虽然本周的rating还没有更新，但根据排名应该是会继续升的。争取早日到达2300+的分数线。最近刷题遇到了瓶颈，很多hard的题目还是不会做，也没有总结出自己刷题的模版和类别。我发现很多大佬之所以很强，是因为看到题目描述，可以很快地发现该题目属于具体的哪类，迅速和之前做过的题目建立联系，才能又快又bug free的AC。</p>
<h2 id="1441-Build-an-Array-With-Stack-Operations"><a href="#1441-Build-an-Array-With-Stack-Operations" class="headerlink" title="1441. Build an Array With Stack Operations"></a>1441. Build an Array With Stack Operations</h2><p>One pass. 2个下标分别指向target的位置和n中的位置。</p>
<p>时间复杂度: O(max(N, target.size())),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">buildArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= n &amp;&amp; index &lt; target.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target[index] == i) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">                ++index;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&quot;Push&quot;</span>);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&quot;Pop&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR"><a href="#1442-Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR" class="headerlink" title="1442. Count Triplets That Can Form Two Arrays of Equal XOR"></a>1442. Count Triplets That Can Form Two Arrays of Equal XOR</h2><p>本题需要利用 异或 的一个性质。<code>a ^ a = 0</code>, <code>a ^ b = b ^ a</code>, <code>(a ^ b) ^ c = a ^ (b ^ c)</code>. 即 自反律，交换律，结合律。<br>所以可以根据类似 presum 的操作在O(1)的时间里算出整个区间的异或值。<br>然后枚举 所有三元组，找到符合条件的。</p>
<p>时间复杂度: O(N ^ 3),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Time: O(n ^ 3)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">prexor</span><span class="params">(arr.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        prexor[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// prexor[i]: arr[0] ^ ... ^ arr[i-1]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            prexor[i+<span class="number">1</span>] = prexor[i] ^ arr[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [i, j)</span></span><br><span class="line">        <span class="keyword">auto</span> xorquick = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> prexor[j] ^ prexor[i];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; arr.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">xorquick</span>(i, j) == <span class="built_in">xorquick</span>(j, k + <span class="number">1</span>)) &#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;a&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;,&quot; &lt;&lt; k &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Discuss里有寒神给出的<br><a href="https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/discuss/623747/JavaC%2B%2BPython-One-Pass-O(N4)-to-O(N)">O(N^2)的算法和O(N)的算法</a>.</p>
<h2 id="1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree"><a href="#1443-Minimum-Time-to-Collect-All-Apples-in-a-Tree" class="headerlink" title="1443. Minimum Time to Collect All Apples in a Tree"></a>1443. Minimum Time to Collect All Apples in a Tree</h2><p>树状DP。首先，递归搜索所有子树是否有苹果。然后，递归收集子树重的苹果。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<p>一开始看错了题目，忽略了还必须回到根节点，所以写了更复杂度的树状DP。增加了一个条件，是否需要回来。耽误了半个小时，否则我的本次周赛的排名还可以再提高点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">children</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : edges) &#123;</span><br><span class="line">            children[v[<span class="number">0</span>]].<span class="built_in">push_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">            children[v[<span class="number">1</span>]].<span class="built_in">push_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        children[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">hasAppleInChildTree</span><span class="params">(n)</span></span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; recurse = [&amp;](<span class="keyword">int</span> root, <span class="keyword">int</span> parent) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> ans = hasApple[root];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children[root]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child != parent) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">recurse</span>(child, root)) &#123;</span><br><span class="line">                        ans = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hasAppleInChildTree[root] = ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">recurse</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; dp = [&amp;](<span class="keyword">int</span> root, <span class="keyword">int</span> parent) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">           <span class="comment">// return step need to collect all apple int subtree root</span></span><br><span class="line">            <span class="keyword">if</span> (children[root].<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children[root]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child != parent &amp;&amp; hasAppleInChildTree[child] == <span class="literal">true</span>) &#123;</span><br><span class="line">                    ans += <span class="built_in">dp</span>(child, root) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1444-Number-of-Ways-of-Cutting-a-Pizza"><a href="#1444-Number-of-Ways-of-Cutting-a-Pizza" class="headerlink" title="1444. Number of Ways of Cutting a Pizza"></a>1444. Number of Ways of Cutting a Pizza</h2><p>一道典型的DP问题。<br>每步DP切一刀。</p>
<p>时间复杂度: O(rows * cols * k * (rows + cols)^2),<br>空间复杂度: O(rows * cols * k).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(vector&lt;string&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> rows = pizza.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> cols = pizza[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> containApple = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> r, <span class="keyword">int</span> c) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; x + r; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + c; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pizza[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        map&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">        <span class="comment">// time: rows * cols * k * (rows + cols)^2</span></span><br><span class="line">        function&lt;<span class="built_in">ll</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dp = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> remainCut) -&gt; ll &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = memo.<span class="built_in">find</span>(&#123;x, y, remainCut&#125;);</span><br><span class="line">            <span class="keyword">if</span> (it != memo.<span class="built_in">end</span>()) <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ll ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (remainCut == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = <span class="built_in">containApple</span>(x, y, rows - x, cols - y) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> cutx = x + <span class="number">1</span>; cutx &lt; rows; ++cutx) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">containApple</span>(x, y, cutx - x, cols - y)) &#123;</span><br><span class="line">                            ans += <span class="built_in">dp</span>(cutx, y, remainCut - <span class="number">1</span>);</span><br><span class="line">                            ans %= MOD;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> cuty = y + <span class="number">1</span>; cuty &lt; cols; ++cuty) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">containApple</span>(x, y, rows - x, cuty - y)) &#123;</span><br><span class="line">                            ans += <span class="built_in">dp</span>(x, cuty, remainCut - <span class="number">1</span>);</span><br><span class="line">                            ans %= MOD;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> memo[&#123;x, y, remainCut&#125;] = ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(<span class="number">0</span>, <span class="number">0</span>, k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在残酷刷题群的这一个半月里，我跟随每日打卡，做了很多比较难的DP问题。周赛的进步也是明显的。群排名也从刚开始的30，进步为15. 我入群时人数170，现在只有146了。所以我怀疑是有很多大佬退群，我的群排名才更好看了。不过群友和群主都鼓励我说，“是你变强了”。我觉得确实有这部分因素。<br>纵观自己的研究生生涯，科研每做好，题倒是刷了不少。这周正式突破1000+题了。<br>遥想<a href="https://youngforest.github.io/2019/03/03/LeetCode-weekly-contest-126/">我当年看到LeetCode的题目超过1000时</a>还很感叹，怎么可能做的完。现在LeetCode有1400+题目，我也做了1000+。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 189</title>
    <url>/2020/05/17/LeetCode-weekly-contest-189/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>484 / 13036</td>
<td>YoungForest</td>
<td>19</td>
<td>1:27:45</td>
<td>0:11:20</td>
<td>0:19:20  1</td>
<td>0:08:48</td>
<td>1:22:45</td>
</tr>
</tbody></table>
<p>本周的最后一题是一个经典的计算几何问题，并不好写。不过通过率还是很高的，可能是test case比较弱的原因。</p>
<p>在残酷群的排名降到了32名，跌幅达100%。之前感觉自己变强了错觉，是由于3周前的186周赛取得了113的好成绩，所以按照群排名算法，之后3周的排名都比较高。最好的一次成绩过去后，排名就恢复了本来的水平。30左右。并不是自己变强了，而是运气好而已。而且186正好用的python，python确实对手速场有优势。</p>
<h2 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time"></a>1450. Number of Students Doing Homework at a Given Time</h2><p>签到题，One Pass.</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; startTime, vector&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startTime.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (startTime[i] &lt;= queryTime &amp;&amp; queryTime &lt;= endTime[i]) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1451-Rearrange-Words-in-a-Sentence"><a href="#1451-Rearrange-Words-in-a-Sentence" class="headerlink" title="1451. Rearrange Words in a Sentence"></a>1451. Rearrange Words in a Sentence</h2><p>利用C++ STL提供的排序函数。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;pair&lt;string,<span class="keyword">int</span>&gt;&gt; <span class="built_in">splitSentence</span>(<span class="keyword">const</span> string&amp; text) &#123;</span><br><span class="line">        string tmp;</span><br><span class="line">        vector&lt;pair&lt;string,<span class="keyword">int</span>&gt;&gt; stk;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,tmp,<span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">islower</span>(tmp[<span class="number">0</span>])) tmp[<span class="number">0</span>] = <span class="built_in">tolower</span>(tmp[<span class="number">0</span>]);</span><br><span class="line">            stk.<span class="built_in">push_back</span>(&#123;tmp, position&#125;);</span><br><span class="line">            ++position;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">arrangeWords</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> split = <span class="built_in">splitSentence</span>(text);</span><br><span class="line">        <span class="built_in">sort</span>(split.<span class="built_in">begin</span>(), split.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.first.<span class="built_in">size</span>() == b.first.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.first.<span class="built_in">size</span>() &lt; b.first.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; word : split) &#123;</span><br><span class="line">            ans += word.first;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="built_in">toupper</span>(ans[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List"><a href="#1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List" class="headerlink" title="1452. People Whose List of Favorite Companies Is Not a Subset of Another List"></a>1452. People Whose List of Favorite Companies Is Not a Subset of Another List</h2><p>brute force. 对于每个人，判断是否被另外一个人所包含。N^2.<br>判断包含时，可以将公司先排序，再顺序比较。O(m * log m + m).<br>N为人数，M为公司数。</p>
<p>时间复杂度: O(N^2 * M log M),<br>空间复杂度: O(N).</p>
<p>其中，利用了STL algorithm里的includes函数，可以判断2个排序区间是否包含。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">peopleIndexes</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; favoriteCompanies)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : favoriteCompanies) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = favoriteCompanies.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> remove = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">includes</span>(favoriteCompanies[j].<span class="built_in">begin</span>(), favoriteCompanies[j].<span class="built_in">end</span>(), favoriteCompanies[i].<span class="built_in">begin</span>(), favoriteCompanies[i].<span class="built_in">end</span>())) &#123;</span><br><span class="line">                    remove = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!remove) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard"><a href="#1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard" class="headerlink" title="1453. Maximum Number of Darts Inside of a Circular Dartboard"></a>1453. Maximum Number of Darts Inside of a Circular Dartboard</h2><p>一道经典的题目：disk partial covering problem。<br>在网上随便一搜就有，原理参考<a href="https://www.geeksforgeeks.org/angular-sweep-maximum-points-can-enclosed-circle-given-radius/">geekforgeek</a>, <a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/discuss/636416/c%2B%2B-O(n2logn)-angular-sweep-(with-picture)">discuss</a>, 即著名的augular sweep.</p>
<p>时间复杂度: O(n^2 log n)<br>空间复杂度: O(n ^ 2).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> Point = complex&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line">    <span class="comment">// angular sweep</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPointsInside</span><span class="params">(<span class="keyword">const</span> vector&lt;Point&gt;&amp; arr, <span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt;&amp; dis, <span class="keyword">int</span> i, <span class="keyword">double</span> r, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">bool</span>&gt; &gt; angles; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (i != j &amp;&amp; dis[i][j] &lt;= <span class="number">2</span>*r) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">double</span> B =  <span class="built_in">acos</span>(dis[i][j]/(<span class="number">2</span>*r)); </span><br><span class="line">                <span class="keyword">double</span> A = <span class="built_in">arg</span>(arr[j]-arr[i]); </span><br><span class="line">                <span class="keyword">double</span> alpha = A-B; </span><br><span class="line">                <span class="keyword">double</span> beta = A+B; </span><br><span class="line">                angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(alpha, <span class="literal">false</span>)); </span><br><span class="line">                angles.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(beta, <span class="literal">true</span>)); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">sort</span>(angles.<span class="built_in">begin</span>(), angles.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, res = <span class="number">1</span>; </span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">double</span>, <span class="keyword">bool</span>&gt; &gt;::iterator it; </span><br><span class="line">        <span class="keyword">for</span> (it=angles.<span class="built_in">begin</span>(); it!=angles.<span class="built_in">end</span>(); ++it) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">if</span> (!(*it).second) </span><br><span class="line">                count++; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count--; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; res) </span><br><span class="line">                res = count; </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;Point&gt; arr;</span><br><span class="line">        arr.<span class="built_in">reserve</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : points) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt; <span class="built_in">dis</span>(n, vector&lt;<span class="keyword">double</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++) </span><br><span class="line">                dis[i][j] = dis[j][i] = <span class="built_in">abs</span>(arr[i]-arr[j]); </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) </span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">getPointsInside</span>(arr, dis, i, r, n));</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 190</title>
    <url>/2020/05/24/LeetCode-weekly-contest-190/</url>
    <content><![CDATA[<p>昨晚老爸帮我掏耳朵，一不小心掏出了血。今天一大早就去地区医院检查，还好并无大碍，只损伤了外耳道，休息一周，自然痊愈就好了。只要不感染，就没问题。开了些阿姆西林吃了。<br>所以鸽了周赛，赛后补题。</p>
<h2 id="1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence"><a href="#1455-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence" class="headerlink" title="1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence"></a>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence</h2><p>C++没有自带的切割字符串的方法，不过可以用自己的模版。通过stringstream实现分割，O(N)的复杂度.</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">splitSentence</span><span class="params">(<span class="keyword">const</span> string&amp; text)</span> </span>&#123;</span><br><span class="line">        string tmp;</span><br><span class="line">        vector&lt;string&gt; stk;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,tmp,<span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isPrefixOfWord</span><span class="params">(string sentence, string searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> words = <span class="built_in">splitSentence</span>(sentence);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].<span class="built_in">find</span>(searchWord) == <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length"><a href="#1456-Maximum-Number-of-Vowels-in-a-Substring-of-Given-Length" class="headerlink" title="1456. Maximum Number of Vowels in a Substring of Given Length"></a>1456. Maximum Number of Vowels in a Substring of Given Length</h2><p>滑动窗口。窗口大小为k，统计窗口内的vowels。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; vowels = &#123;</span><br><span class="line">            <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vowels.<span class="built_in">find</span>(s[i]) != vowels.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vowels.<span class="built_in">find</span>(s[i]) != vowels.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vowels.<span class="built_in">find</span>(s[i-k]) != vowels.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree"><a href="#1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree" class="headerlink" title="1457. Pseudo-Palindromic Paths in a Binary Tree"></a>1457. Pseudo-Palindromic Paths in a Binary Tree</h2><p>根据字母出现频数为奇数的字母个数是否 &lt;= 判断是否回文。<br>采用dfs搜索路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindromicPath</span><span class="params">(<span class="keyword">const</span> unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                ++odd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> odd &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*)&gt; dfs = [&amp;](TreeNode* root) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root) &#123;</span><br><span class="line">                ++path[root-&gt;val];</span><br><span class="line">                <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; <span class="comment">// leaf</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isPalindromicPath</span>(path)) &#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">                <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">                --path[root-&gt;val];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1458-Max-Dot-Product-of-Two-Subsequences"><a href="#1458-Max-Dot-Product-of-Two-Subsequences" class="headerlink" title="1458. Max Dot Product of Two Subsequences"></a>1458. Max Dot Product of Two Subsequences</h2><p>DP。dp[i][j] 表示nums1[:i+1], nums2[:j+1]的max dot product.</p>
<p><code>dp[i][j] = max(&#123;dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i]*nums2[j], nums1[i]*nums2[j]&#125;);</code></p>
<p>需要注意的是，并不允许空的subsequence。</p>
<p>时间复杂度: O(nums1.size() * nums2.size()),<br>空间复杂度: O(nums1.size() * nums2.size()).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// nums[i], nums[j], max dot product</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(&#123;dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + nums1[i]*nums2[j], nums1[i]*nums2[j]&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = nums1[i]*nums2[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(&#123;dp[i][j<span class="number">-1</span>], nums1[i]*nums2[j]&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(&#123;dp[i<span class="number">-1</span>][j], nums1[i]*nums2[j]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 191</title>
    <url>/2020/05/31/LeetCode-weekly-contest-191/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>765 / 13283</td>
<td>YoungForest</td>
<td>12</td>
<td>0:27:19</td>
<td>0:02:16</td>
<td>0:12:53</td>
<td>0:27:19</td>
<td>null</td>
</tr>
</tbody></table>
<p>本周最后一题着实比较难，涉及概率和组合数学等知识。恰好触及到我的知识盲区，所以没有做出来。对于数学好的同学应该会好很多。</p>
<h2 id="1464-Maximum-Product-of-Two-Elements-in-an-Array"><a href="#1464-Maximum-Product-of-Two-Elements-in-an-Array" class="headerlink" title="1464. Maximum Product of Two Elements in an Array"></a>1464. Maximum Product of Two Elements in an Array</h2><p>签到题。由于<code>nums.size()</code>比较小，所以暴力即可。</p>
<p>时间复杂度: O(N^2),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = -INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (nums[i] - <span class="number">1</span>) * (nums[j] - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts"><a href="#1465-Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts" class="headerlink" title="1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts"></a>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</h2><p>分别找出最大的horizontal和vertical间隔，相乘即可。需要注意，把边界也当作cut处理。<br>数据类型最好使用<code>long long</code>，因为会有<code>int32</code>的溢出问题。</p>
<p>时间复杂度: O(horizontalCuts.size() * log + verticalCuts.size() * log),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, vector&lt;<span class="keyword">int</span>&gt;&amp; horizontalCuts, vector&lt;<span class="keyword">int</span>&gt;&amp; verticalCuts)</span> </span>&#123;</span><br><span class="line">        horizontalCuts.<span class="built_in">insert</span>(horizontalCuts.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        horizontalCuts.<span class="built_in">push_back</span>(h);</span><br><span class="line">        verticalCuts.<span class="built_in">insert</span>(verticalCuts.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        verticalCuts.<span class="built_in">push_back</span>(w);</span><br><span class="line">        <span class="built_in">sort</span> (<span class="built_in">begin</span>(horizontalCuts), <span class="built_in">end</span>(horizontalCuts));</span><br><span class="line">        <span class="built_in">sort</span> (<span class="built_in">begin</span>(verticalCuts), <span class="built_in">end</span>(verticalCuts));</span><br><span class="line">        <span class="keyword">int</span> maxH = <span class="number">0</span>, maxW = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; horizontalCuts.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            maxH = <span class="built_in">max</span>(maxH, horizontalCuts[i] - horizontalCuts[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; verticalCuts.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            maxW = <span class="built_in">max</span>(maxW, verticalCuts[j] - verticalCuts[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll mxh = maxH;</span><br><span class="line">        ll mxw = maxW;</span><br><span class="line">        <span class="keyword">return</span> (mxh * mxw) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero"><a href="#1466-Reorder-Routes-to-Make-All-Paths-Lead-to-the-City-Zero" class="headerlink" title="1466. Reorder Routes to Make All Paths Lead to the City Zero"></a>1466. Reorder Routes to Make All Paths Lead to the City Zero</h2><p>由于无向图本身是一棵树，每个节点通向0的路径有且仅有一条。所以用dfs从0搜索一遍，把反向的边调整过来即可。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N) -&gt; 通过记录父节点，可以不用seen，将空间降到O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minReorder</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; in, out;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">seen</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : connections) &#123;</span><br><span class="line">            in[v[<span class="number">1</span>]].<span class="built_in">push_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">            out[v[<span class="number">0</span>]].<span class="built_in">push_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> root) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen[root]) <span class="keyword">return</span>;</span><br><span class="line">            seen[root] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : in[root]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : out[root]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!seen[neighbor]) &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    <span class="built_in">dfs</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1467-Probability-of-a-Two-Boxes-Having-The-Same-Number-of-Distinct-Balls"><a href="#1467-Probability-of-a-Two-Boxes-Having-The-Same-Number-of-Distinct-Balls" class="headerlink" title="1467. Probability of a Two Boxes Having The Same Number of Distinct Balls"></a>1467. Probability of a Two Boxes Having The Same Number of Distinct Balls</h2><p>概率问题。由于数据范围比较小，可以用回溯法枚举每个颜色的球在2个盒子里的数目。终点时，需要判断合法的permutation的数目，即 2个盒子中的球的数目相等。然后，如果颜色数量相等，也需要记录。<br>这里需要些组合数学的知识，x个球，然后每种颜色的数目为A_i.<br>则permutation的数目为: </p>
<p>$$ x! / \sum{A_i} $$</p>
<p>时间复杂度: O(balls[i]^balls.size() * balls.size() * sum_balls) = O(6 ^ 8 * 8 * 48) = O(644972544).<br>空间复杂度: O(balls.size()).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getProbability</span>(<span class="params">self, balls: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        self.<span class="built_in">all</span> = <span class="number">0</span></span><br><span class="line">        self.good = <span class="number">0</span></span><br><span class="line">        self.firstHalf = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        self.secondHalf = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">validKeys</span>(<span class="params">m</span>):</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">                <span class="keyword">if</span> m[i] &gt; <span class="number">0</span>: ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">permutationUnder</span>(<span class="params">count</span>):</span></span><br><span class="line">            under = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> count.values():</span><br><span class="line">                under *= math.factorial(k)</span><br><span class="line">            <span class="keyword">return</span> under</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(balls):</span><br><span class="line">                s1 = <span class="built_in">sum</span>(self.firstHalf.values())</span><br><span class="line">                s2 = <span class="built_in">sum</span>(self.secondHalf.values())</span><br><span class="line">                <span class="keyword">if</span> s1 != s2: <span class="keyword">return</span></span><br><span class="line">                add = math.factorial(s1) * math.factorial(s2) / (permutationUnder(self.firstHalf) * permutationUnder(self.secondHalf))</span><br><span class="line">                self.<span class="built_in">all</span> += add</span><br><span class="line">                <span class="keyword">if</span> validKeys(self.firstHalf) == validKeys(self.secondHalf): self.good += add</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, balls[i] + <span class="number">1</span>):</span><br><span class="line">                    self.firstHalf[i] = x</span><br><span class="line">                    self.secondHalf[i] = balls[i] - x</span><br><span class="line">                    dfs(i+<span class="number">1</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.good / self.<span class="built_in">all</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 192</title>
    <url>/2020/06/07/LeetCode-weekly-contest-192/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>374 / 13805</td>
<td>YoungForest</td>
<td>18</td>
<td>0:53:48</td>
<td>0:07:19</td>
<td>0:07:35</td>
<td>0:15:00</td>
<td>0:43:48 2</td>
</tr>
</tbody></table>
<p>本周的题目不算难，3456手速场，最后1k人AK。<br>前3题自己手速还算快，最后一题花了比较长的时间，还因为实现问题TLE了2发。本来觉得自己做的还不错，后来看到排名才发现，大家都很强。还需继续努力呀。争取rating进入世界前500.</p>
<h2 id="1470-Shuffle-the-Array"><a href="#1470-Shuffle-the-Array" class="headerlink" title="1470. Shuffle the Array"></a>1470. Shuffle the Array</h2><p>使用辅助数组，straight forward.</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">shuffle</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans[i*<span class="number">2</span>] = nums[i];</span><br><span class="line">            ans[i*<span class="number">2</span> + <span class="number">1</span>] = nums[n + i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1471-The-k-Strongest-Values-in-an-Array"><a href="#1471-The-k-Strongest-Values-in-an-Array" class="headerlink" title="1471. The k Strongest Values in an Array"></a>1471. The k Strongest Values in an Array</h2><p>把stronger作为排序函数，对整个arr进行排序即可。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getStrongest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = arr[((n - <span class="number">1</span>) / <span class="number">2</span>)];</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a - m) == <span class="built_in">abs</span>(b - m)) &#123;</span><br><span class="line">                <span class="keyword">return</span> a &gt; b;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">abs</span>(a - m) &gt; <span class="built_in">abs</span>(b - m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        arr.<span class="built_in">erase</span>(arr.<span class="built_in">begin</span>() + k, arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1472-Design-Browser-History"><a href="#1472-Design-Browser-History" class="headerlink" title="1472. Design Browser History"></a>1472. Design Browser History</h2><p>模拟整个过程。用一个数组存history，2个下标表示当前位置和最新的位置。</p>
<p>时间复杂度: O(1),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span> &#123;</span></span><br><span class="line">    vector&lt;string&gt; history;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BrowserHistory</span>(string homepage) &#123;</span><br><span class="line">        history.<span class="built_in">resize</span>(<span class="number">5000</span>);</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        history[<span class="number">0</span>] = <span class="built_in">move</span>(homepage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(string url)</span> </span>&#123;</span><br><span class="line">        ++index;</span><br><span class="line">        history[index] = url;</span><br><span class="line">        last = index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">back</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= steps) &#123;</span><br><span class="line">            index = index - steps;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> history[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">forward</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index + steps &lt;= last) &#123;</span><br><span class="line">            index = index + steps;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> history[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BrowserHistory object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BrowserHistory* obj = new BrowserHistory(homepage);</span></span><br><span class="line"><span class="comment"> * obj-&gt;visit(url);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;back(steps);</span></span><br><span class="line"><span class="comment"> * string param_3 = obj-&gt;forward(steps);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="1473-Paint-House-III"><a href="#1473-Paint-House-III" class="headerlink" title="1473. Paint House III"></a>1473. Paint House III</h2><p>DP.<br>dp[i][t][lastColor]: paint [1:] 的房子，把他们分成t个group，而且前一个颜色是lastColor（避免同颜色，合并group）所需的最小的cost.</p>
<p>状态转移方程: dp[i][t][lastColor] = min(paint cost [i:j) use color + dp[j][t-1][color]) for j in range(i,m+1) for color in range(1,n+1).<br>需要注意一些剪枝和paint函数的有效实现，因为此TLE2发。</p>
<p>时间复杂度: O(m * target * n * m * n),<br>空间复杂度: O(m * target * n).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCost</span>(<span class="params">self, houses: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">paint</span>(<span class="params">i, j, color</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> houses[i] == color:</span><br><span class="line">                    <span class="keyword">return</span> paint(i+<span class="number">1</span>, j, color)</span><br><span class="line">                <span class="keyword">elif</span> houses[i] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> paint(i+<span class="number">1</span>, j, color) + cost[i][color-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i: <span class="built_in">int</span>, t: <span class="built_in">int</span>, lastColor: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">1</span>:</span><br><span class="line">                ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> color <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> color == lastColor: <span class="keyword">continue</span></span><br><span class="line">                    pre = paint(i, m, color)</span><br><span class="line">                    ans = <span class="built_in">min</span>(ans, pre)</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">                seenColors = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, m):</span><br><span class="line">                    <span class="keyword">if</span> houses[j-<span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> seenColors != <span class="number">0</span> <span class="keyword">and</span> seenColors != houses[j-<span class="number">1</span>]:</span><br><span class="line">                            <span class="keyword">return</span> ans</span><br><span class="line">                        seenColors = houses[j-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> seenColors == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">for</span> color <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                            <span class="keyword">if</span> color == lastColor: <span class="keyword">continue</span></span><br><span class="line">                            pre = paint(i, j, color)</span><br><span class="line">                            <span class="keyword">if</span> pre &lt; ans:</span><br><span class="line">                                ans = <span class="built_in">min</span>(ans, pre + dp(j, t-<span class="number">1</span>, color))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        color = seenColors</span><br><span class="line">                        <span class="keyword">if</span> color != lastColor: </span><br><span class="line">                            pre = paint(i, j, color)</span><br><span class="line">                            <span class="keyword">if</span> pre &lt; ans:</span><br><span class="line">                                ans = <span class="built_in">min</span>(ans, pre + dp(j, t-<span class="number">1</span>, color))</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        ans = dp(<span class="number">0</span>, target, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 193</title>
    <url>/2020/06/15/LeetCode-weekly-contest-193/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>1854 / 13794</td>
<td>YoungForest</td>
<td>12</td>
<td>1:18:35</td>
<td>0:15:31</td>
<td>0:12:31</td>
<td>1:18:35</td>
<td>null</td>
</tr>
</tbody></table>
<p>最近比赛能力有所下降，昨晚的双周赛也是有一道第3题没做出来，现在更是最后一题没做出来。对Q4的树上倍增算法不了解。</p>
<h2 id="1480-Running-Sum-of-1d-Array"><a href="#1480-Running-Sum-of-1d-Array" class="headerlink" title="1480. Running Sum of 1d Array"></a>1480. Running Sum of 1d Array</h2><p>签到题，一遍presum求和。<br>也可以使用STL 中的<a href="https://leetcode.com/problems/running-sum-of-1d-array/discuss/686276/C++-partial_sum">partial_sum</a>，达到相同的效果。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">runningSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; presum;</span><br><span class="line">        presum.<span class="built_in">reserve</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">        presum.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            presum.<span class="built_in">push_back</span>(presum.<span class="built_in">back</span>() + i);</span><br><span class="line">        &#125;</span><br><span class="line">        presum.<span class="built_in">erase</span>(presum.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> presum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1481-Least-Number-of-Unique-Integers-after-K-Removals"><a href="#1481-Least-Number-of-Unique-Integers-after-K-Removals" class="headerlink" title="1481. Least Number of Unique Integers after K Removals"></a>1481. Least Number of Unique Integers after K Removals</h2><p>贪心。<br>按照频数从小到大排序，先删除小的。</p>
<p>时间复杂度: O(N + N log N + K),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            ++count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; frequence;</span><br><span class="line">        frequence.<span class="built_in">reserve</span>(count.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : count) &#123;</span><br><span class="line">            frequence.<span class="built_in">push_back</span>(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(frequence.<span class="built_in">begin</span>(), frequence.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = frequence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (i == k) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; frequence.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            i += frequence[j];</span><br><span class="line">            <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> n - j - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; k) &#123;</span><br><span class="line">                <span class="keyword">return</span> n - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1482-Minimum-Number-of-Days-to-Make-m-Bouquets"><a href="#1482-Minimum-Number-of-Days-to-Make-m-Bouquets" class="headerlink" title="1482. Minimum Number of Days to Make m Bouquets"></a>1482. Minimum Number of Days to Make m Bouquets</h2><p>将最优化问题转换成二分判定问题。<br>寻找一个临界点，临界点前判定问题均为false, 之后均为true.</p>
<p>时间复杂度: O(log 1e9 * N),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> determine = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : bloomDay) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= x) &#123;</span><br><span class="line">                    ++sub;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans += sub / k;</span><br><span class="line">                    sub = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += sub / k;</span><br><span class="line">            <span class="keyword">return</span> ans &gt;= m;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">determine</span>(mid)) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo &gt; <span class="number">1e9</span> ? <span class="number">-1</span> : lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1483-Kth-Ancestor-of-a-Tree-Node"><a href="#1483-Kth-Ancestor-of-a-Tree-Node" class="headerlink" title="1483. Kth Ancestor of a Tree Node"></a>1483. Kth Ancestor of a Tree Node</h2><p>类似<a href="https://cp-algorithms.com/graph/lca_binary_lifting.html">树上倍增 LCA</a>问题。用时间换空间。</p>
<p>时间复杂度: O(N * log N),<br>空间复杂度: O(N * log N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeAncestor</span> &#123;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ancestors;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TreeAncestor</span>(<span class="keyword">int</span> n, vector&lt;<span class="keyword">int</span>&gt;&amp; parent) &#123;</span><br><span class="line">        <span class="comment">// time: N * log N</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">children</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            children[parent[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        ancestors.<span class="built_in">resize</span>(n);</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;&amp;)&gt; dfs = [&amp;](<span class="keyword">int</span> root, vector&lt;<span class="keyword">int</span>&gt;&amp; path) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> depth = path.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; depth - (<span class="number">1</span> &lt;&lt; i) &gt;= <span class="number">0</span>; ++i) &#123;</span><br><span class="line">                ancestors[root].<span class="built_in">push_back</span>(path[depth - (<span class="number">1</span> &lt;&lt; i)]);</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(root);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children[root]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(child, path);</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        path.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthAncestor</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// time: log K</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; node != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; ancestors[node].<span class="built_in">size</span>())</span><br><span class="line">                    node = ancestors[node][i];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = <span class="number">-1</span>;</span><br><span class="line">                k -= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TreeAncestor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TreeAncestor* obj = new TreeAncestor(n, parent);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getKthAncestor(node,k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 208</title>
    <url>/2020/09/30/LeetCode-weekly-contest-208/</url>
    <content><![CDATA[<p>距上次写周赛总结已经过去3个半月了。坚持了半年的写周赛题解中断确实挺可惜的，但却是当时的不得已之举。7月份一直在忙小论文的事儿，8月份接着就是开题和中期，9月份正式开学，并且从7月初就在Amazon开始了暑期实习。任务确实比之前要多，当时因为事务压身，感觉精力不足以把所有事都做好。因为每次周赛写题解都要花大半天的时间，再加上打周赛，基本1天时间。打比赛和写题解对精力的损耗也是不言而喻的。虽然这3个月题解断更了，但比赛还是在照常的打，毕竟加入了残酷刷题群，有更多的人一起打周赛，每周打比赛的反馈和热爱也更强了。<br>这3个月，我残酷群的排名也是起起落落落落落…最好时有15名，最差已经90名了。总的感觉是，自己更擅长常规不难的题目。遇到之前没见过或做的不多的就很容易最后一题做不出来。</p>
<p>昨天和Amazon的manager确认了转正事宜，之后基本上只用走流程了。有了理想offer后，秋招不知所措的弦终于可以放松下来了。有心情花时间做自己想做的事情了，读几本之前一直想看的书，认真打几场比赛，恢复写题解的习惯。当然实习和毕设大论文才是当前的主要任务，需要投入大部分时间。但终于有精力happy了。</p>
<p>这3个月来，因为国服赞助商礼物比较丰富，我比赛已经从美服转战国服了。效果还不错，除了coins奖励更容易拿到外，实体奖励也是很香的。有幸2次进入前50名，拿到一个帆布包和一个小米无线鼠标。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>392 / 11499</td>
<td>YoungForest</td>
<td>18</td>
<td>1:04:46</td>
<td>0:28:38</td>
<td>0:40:28</td>
<td>1:04:46</td>
<td>0:55:59</td>
</tr>
</tbody></table>
<p>事实上，由于要处理突发的培养方案问题，我还迟到了25min，否则成绩会更好看。</p>
<p>本次比赛被大家吐槽为阅读理解，读题难、题目描述迷惑。确实如此。</p>
<h2 id="1598-Crawler-Log-Folder"><a href="#1598-Crawler-Log-Folder" class="headerlink" title="1598. Crawler Log Folder"></a>1598. Crawler Log Folder</h2><p>签到题。只需要关心向下一层和向上一层即可。可以用一个变量维护，在比赛中，我是用了一个栈去做，实际上是大材小用了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : logs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="string">&quot;../&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="string">&quot;./&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">pop_back</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="1599-Maximum-Profit-of-Operating-a-Centennial-Wheel"><a href="#1599-Maximum-Profit-of-Operating-a-Centennial-Wheel" class="headerlink" title="1599. Maximum Profit of Operating a Centennial Wheel"></a>1599. Maximum Profit of Operating a Centennial Wheel</h2><p>Straight forward. 千万不要多想，直接模拟，一下一下地转，得到最大收益。特别需要注意的是，当你停止运行后，之后再转就不需要cost了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperationsMaxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="keyword">int</span> boardingCost, <span class="keyword">int</span> runningCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> waitCustomer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> getBoard = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.<span class="built_in">size</span>() || waitCustomer &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; customers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                waitCustomer += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (waitCustomer &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">                waitCustomer -= <span class="number">4</span>;</span><br><span class="line">                getBoard += <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                getBoard += waitCustomer;</span><br><span class="line">                waitCustomer = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> profit = getBoard * boardingCost - runningCost * (i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; profit &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (profit &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = profit;</span><br><span class="line">                ans = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxProfit &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(customers.size() + sum(customers) / 4),<br>空间复杂度: O(1).</p>
<h2 id="1600-Throne-Inheritance"><a href="#1600-Throne-Inheritance" class="headerlink" title="1600. Throne Inheritance"></a>1600. Throne Inheritance</h2><p>别看描述的这么复杂，其实就是一个深度优先搜索/前序遍历。前面的问题描述，尤其是<code>Successor</code>函数的定义会让人十分迷惑，其实就是嫡长子继承制。直接看example会更好理解。我也是做完第四题才返回来看的第三题，确实太难理解题意了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThroneInheritance</span> &#123;</span></span><br><span class="line">    unordered_set&lt;string&gt; dead;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; children;</span><br><span class="line">    string root;</span><br><span class="line">    <span class="comment">// dfs</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThroneInheritance</span>(string kingName) &#123;</span><br><span class="line">        root = kingName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">birth</span><span class="params">(string parentName, string childName)</span> </span>&#123;</span><br><span class="line">        children[parentName].<span class="built_in">push_back</span>(childName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">death</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">        dead.<span class="built_in">insert</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getInheritanceOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> string&amp;)&gt; dfs = [&amp;](<span class="keyword">const</span> string&amp; r) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (dead.<span class="built_in">find</span>(r) == dead.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> string&amp; child : children[r]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ThroneInheritance object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ThroneInheritance* obj = new ThroneInheritance(kingName);</span></span><br><span class="line"><span class="comment"> * obj-&gt;birth(parentName,childName);</span></span><br><span class="line"><span class="comment"> * obj-&gt;death(name);</span></span><br><span class="line"><span class="comment"> * vector&lt;string&gt; param_3 = obj-&gt;getInheritanceOrder();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1601-Maximum-Number-of-Achievable-Transfer-Requests"><a href="#1601-Maximum-Number-of-Achievable-Transfer-Requests" class="headerlink" title="1601. Maximum Number of Achievable Transfer Requests"></a>1601. Maximum Number of Achievable Transfer Requests</h2><p>题目相比二三题好理解的多。由于<code>request.length</code>本身比较小，所以我们可以直接暴力解法，枚举所有<code>requests</code>的子集，判断是否合法(每个building入度出度相等)，找到最大的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumRequests</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; requests)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2 ^ 16 * 16</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> rl = requests.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> verify  = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> mask) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">in</span>(n, <span class="number">0</span>);</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">out</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rl; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    ++in[requests[i][<span class="number">1</span>]];</span><br><span class="line">                    ++out[requests[i][<span class="number">0</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (in[i] != out[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; rl) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">verify</span>(i)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, __builtin_popcount(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>m: <code>requests.length</code>,<br>时间复杂度: O(2 ^ m * (m + n)),<br>空间复杂度: O(n).</p>
<p>当然也有多项式时间复杂度的解法：<a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/solution/zui-xiao-fei-yong-zui-da-liu-onm2-c-by-heltion/">O((n+m)m)</a>.<br>用到了费用流，这已经超出我的知识范围了，有兴趣的同学可以学习下。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>经过3年的准备，我的秋招基本结束了。已经决定留在亚马逊了，再过3个月就要成为社畜了。算是比较理想的offer了。<br>最理想的Dream company当然是Google，无奈好不容易通过了实习一面，谷歌今年的实习项目因为疫情原因取消了。秋招也相比往年晚了很多，最近才有一些推送的消息。本身HC也十分稀少，机会难得。<br>其他心仪的外企 Hulu 通过一面，在等待二面；微软找zenian内推却一直没有笔试或面试的消息，应该是由于投的北京的STCA，HC少而且基本上都被实习生占了，之前还收到是否同意可能调剂到苏州的问卷，难呀；Intel基本上是稳了，不过那边薪资待遇比起亚麻都要差很多，已经不考虑了；还投了小厂HotStar，有口头的offer，但本身就是我用来拿个大package再和大厂compete的，基本上不考虑去。<br>国内互联网企业这边，拿了蚂蚁金服和猿辅导的offer，评级还都不错，蚂蚁还是A+。蚂蚁那边由于运气好，笔试拿了满分，师兄和lead还一直挺想让我去的。提前批6月份投了vivo，本身就是去试水的。结果因为overqualify被拒了，明明笔试全A，面试谈笑风声，有不要太优秀的要求就直说，别浪费的大家的时间。8月份还投了京东，面试很水，offer薪资也极其没诚意，属于劝退，我直接给拒了。百度提前批面完了，说是会给我offer，但一直没有消息。腾讯实习生面伤了，本身在北京也没好的岗位，秋招就没投。没想到还是被捞起来面了一次，后续无消息。字节一直被拒，反复捞起反复拒，真是八字不合。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 209</title>
    <url>/2020/10/07/LeetCode-weekly-contest-209/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>522 / 12138</td>
<td>YoungForest</td>
<td>12</td>
<td>0:49:07</td>
<td>0:05:12</td>
<td>0:11:28</td>
<td>0:39:07 2</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1608-Special-Array-With-X-Elements-Greater-Than-or-Equal-X"><a href="#1608-Special-Array-With-X-Elements-Greater-Than-or-Equal-X" class="headerlink" title="1608. Special Array With X Elements Greater Than or Equal X"></a>1608. Special Array With X Elements Greater Than or Equal X</h2><p>签到题。从小到大枚举可能的答案，进行检查。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">specialArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), i);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> d = <span class="built_in">distance</span>(nums.<span class="built_in">begin</span>(), it);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> le = n - d;</span><br><span class="line">            <span class="keyword">return</span> le == i;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N * log N),</p>
<h2 id="1609-Even-Odd-Tree"><a href="#1609-Even-Odd-Tree" class="headerlink" title="1609. Even Odd Tree"></a>1609. Even Odd Tree</h2><p>二叉树的层序遍历。使用广度优先搜索（BFS），记录层数和前一个元素即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEvenOddTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> last;</span><br><span class="line">            <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) last = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> last = <span class="number">1&#x27;000&#x27;006</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> current = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current-&gt;val % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (current-&gt;val &lt;= last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (current-&gt;val % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (current-&gt;val &gt;= last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = current-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;left) q.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;right) q.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="1610-Maximum-Number-of-Visible-Points"><a href="#1610-Maximum-Number-of-Visible-Points" class="headerlink" title="1610. Maximum Number of Visible Points"></a>1610. Maximum Number of Visible Points</h2><p>滑动窗口。这里有2个技巧：</p>
<ol>
<li>使用复数及其方法处理几何问题。可以快速计算向量的夹角。</li>
<li>把所有点 + 360度 遍历2次。以处理跨0问题。</li>
</ol>
<p>还有一个需要注意的点是：当点和观察点重合时需要特殊处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; out, <span class="keyword">const</span> vector&lt;T&gt;&amp; a) &#123;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;[&quot;</span>; <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : a) &#123; out &lt;&lt; (first ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>); out &lt;&lt; v; first = <span class="number">0</span>;&#125; out &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> Point = complex&lt;<span class="keyword">double</span>&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">visiblePoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> a, vector&lt;<span class="keyword">int</span>&gt;&amp; location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> angle = a;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        Point me &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(location[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(location[<span class="number">1</span>])&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; ps;</span><br><span class="line">        ps.<span class="built_in">reserve</span>(<span class="number">2</span> * points.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> same = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; v : points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == location) &#123;</span><br><span class="line">                ++same;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Point x &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(v[<span class="number">0</span>]), <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(v[<span class="number">1</span>])&#125;;</span><br><span class="line">            ps.<span class="built_in">push_back</span>(<span class="built_in">arg</span>(x - me)*(<span class="number">180</span>/M_PI));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> s = ps.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">            ps.<span class="built_in">push_back</span>(ps[i] + <span class="number">360</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ps.<span class="built_in">begin</span>(), ps.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// cout &lt;&lt; ps &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> error = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; ps.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ps[r] - ps[l] &gt; angle + error) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(ans, n) + same;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<h2 id="1611-Minimum-One-Bit-Operations-to-Make-Integers-Zero"><a href="#1611-Minimum-One-Bit-Operations-to-Make-Integers-Zero" class="headerlink" title="1611. Minimum One Bit Operations to Make Integers Zero"></a>1611. Minimum One Bit Operations to Make Integers Zero</h2><p>参考<a href="https://www.youtube.com/watch?v=8MdutrMAwY4">群主的视频</a>写的代码。比赛时没做出来，赛后看lee215的discuss也是讲的比较简单和跳跃。还是群主的视频好，把你当傻逼一样讲，速度还慢。虽然时长挺长的，但对于这种比较难的题目还是十分有效的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestBit</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b &lt;= n) &#123;</span><br><span class="line">            b = (b &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        b = (b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// xxxx -&gt; 1000</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; b) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1xxx -&gt; 1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">minimumOneBitOperations</span>(n ^ b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 0xxx -&gt; 0100 -&gt; 1100 -&gt; 1000</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">helper</span>(n, b &gt;&gt; <span class="number">1</span>) + <span class="number">1</span> + <span class="built_in">minimumOneBitOperations</span>(b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOneBitOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(n) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (n &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="built_in">largestBit</span>(n);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">helper</span>(b ^ n, b &gt;&gt; <span class="number">1</span>) + <span class="number">1</span> + <span class="built_in">minimumOneBitOperations</span>(b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log N),<br>空间复杂度: O(log N).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 210</title>
    <url>/2020/10/11/LeetCode-weekly-contest-210/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>94 / 11792</td>
<td>YoungForest</td>
<td>18</td>
<td>0:51:30</td>
<td>0:03:13</td>
<td>0:08:36</td>
<td>0:21:59</td>
<td>0:51:30</td>
</tr>
</tbody></table>
<p>本场比赛都是常规题目，我没有遇到困难，久违地进入了前100名。太难了，残酷群排名也因此上升到25名。</p>
<h2 id="5535-Maximum-Nesting-Depth-of-the-Parentheses"><a href="#5535-Maximum-Nesting-Depth-of-the-Parentheses" class="headerlink" title="5535. Maximum Nesting Depth of the Parentheses"></a>5535. Maximum Nesting Depth of the Parentheses</h2><p>签到题。括号嵌套层数，用栈的思路即可。左括号入栈，右括号出栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="5536-Maximal-Network-Rank"><a href="#5536-Maximal-Network-Rank" class="headerlink" title="5536. Maximal Network Rank"></a>5536. Maximal Network Rank</h2><p>暴力法。枚举所有的城市对，计算network rank。有个技巧是先统计单个城市的度，如果2城市间存在道路则减一。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalNetworkRank</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        set&lt;pii&gt; roadmap;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; r : roads) &#123;</span><br><span class="line">            roadmap.<span class="built_in">insert</span>(&#123;r[<span class="number">0</span>], r[<span class="number">1</span>]&#125;);</span><br><span class="line">            ++cnt[r[<span class="number">0</span>]];</span><br><span class="line">            ++cnt[r[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> sub = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (roadmap.<span class="built_in">find</span>(&#123;i, j&#125;) != roadmap.<span class="built_in">end</span>() || roadmap.<span class="built_in">find</span>(&#123;j, i&#125;) != roadmap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    ++sub;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cnt[i] + cnt[j] - sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n^2 * log m + m log m),<br>空间复杂度: O(n + m).</p>
<p>评论区中有<a href="https://leetcode-cn.com/problems/maximal-network-rank/solution/onm-mei-ju-fa-by-zerotrac2/">一神 O(n + m)</a> 的解法，太强了。大意是，只需要知道度最大的城市和第二大的即可。</p>
<h2 id="1616-Split-Two-Strings-to-Make-Palindrome"><a href="#1616-Split-Two-Strings-to-Make-Palindrome" class="headerlink" title="1616. Split Two Strings to Make Palindrome"></a>1616. Split Two Strings to Make Palindrome</h2><p>观察有，答案只有可能2中：<br>a_prefix + a_mid + b_suffix,<br>a_prefix + b_mid + b_suffix,<br>b_prefix + a_mid + a_suffix,<br>b_prefix + b_mid + a_suffix.</p>
<p>计算a_prefix与b_suffix匹配的最长长度，和a_mid/b_mid的最长长度，看是否相交。<br>同理，b_prefix 与 a_suffix匹配的最长长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> head2 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> string&amp; a, <span class="keyword">const</span> string&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            left = (n - <span class="number">1</span>)  / <span class="number">2</span>;</span><br><span class="line">            right = n / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">            left = mid - <span class="number">1</span>;</span><br><span class="line">            right = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; a[left] == a[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> length = right - left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> head1 &gt; left || head2 &gt; left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkPalindromeFormation</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (head1 &lt; n &amp;&amp; a[head1] == b[n - <span class="number">1</span> - head1]) &#123;</span><br><span class="line">            ++head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head2 &lt; n &amp;&amp; b[head2] == a[n - <span class="number">1</span> - head2]) &#123;</span><br><span class="line">            ++head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(a, b) || <span class="built_in">check</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="5538-Count-Subtrees-With-Max-Distance-Between-Cities"><a href="#5538-Count-Subtrees-With-Max-Distance-Between-Cities" class="headerlink" title="5538. Count Subtrees With Max Distance Between Cities"></a>5538. Count Subtrees With Max Distance Between Cities</h2><p>暴力法，写了近100行代码。先枚举所有的点组合，判断是否是subtree，如果是的话，计算最大距离。</p>
<p>判断是否subtree，我使用了用 并查集 判断是否全部联通的方法。<br>最大距离d，我采用了多次DFS的方式，时间复杂度 n^2. 赛后得知有O(n) <a href="https://oi-wiki.org/graph/tree-diameter/">2次dfs的方法计算树的直径</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="built_in">UF</span>(<span class="keyword">int</span> n) : <span class="built_in">parent</span>(n), <span class="built_in">count</span>(n) &#123;</span><br><span class="line">            <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A utility function to find the subset of an element i  </span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> x == parent[x] ? x : parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// A utility function to do union of two subsets  </span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">int</span> xset = <span class="built_in">find</span>(x);  </span><br><span class="line">            <span class="keyword">int</span> yset = <span class="built_in">find</span>(y);  </span><br><span class="line">            <span class="keyword">if</span>(xset != yset) </span><br><span class="line">            &#123;  </span><br><span class="line">                parent[xset] = yset;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">countSubgraphsForEachDiameter</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// time: (n ^ 2 * 2 ^ n)</span></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : edges) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> a = v[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> b = v[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            graph[a].<span class="built_in">insert</span>(b);</span><br><span class="line">            graph[b].<span class="built_in">insert</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dist</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> root, <span class="keyword">const</span> <span class="keyword">int</span> current, <span class="keyword">const</span> <span class="keyword">int</span> parent, <span class="keyword">const</span> <span class="keyword">int</span> depth) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            dist[root][current] = depth;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : graph[current]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child == parent) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(root, child, current, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i, i, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> getnodes = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> mask) -&gt; vector&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mask &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> checksubtree = [&amp;](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nodes) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes.<span class="built_in">empty</span>() || nodes.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="function">UF <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nodes.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> a = nodes[i], b = nodes[j];</span><br><span class="line">                    <span class="keyword">if</span> (graph[a].<span class="built_in">find</span>(b) != graph[a].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        uf.<span class="built_in">unite</span>(a, b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a : nodes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root == <span class="number">-1</span>) &#123;</span><br><span class="line">                    root = uf.<span class="built_in">find</span>(a);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (root != uf.<span class="built_in">find</span>(a)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> distance = [&amp;](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nodes) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nodes.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> a = nodes[i], b = nodes[j];</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dist[a][b]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// d = 1...n-1        </span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span> <span class="params">(n - <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> upper = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; upper; ++mask) &#123;</span><br><span class="line">            <span class="keyword">auto</span> nodes = <span class="built_in">getnodes</span>(mask);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">checksubtree</span>(nodes)) <span class="keyword">continue</span>;</span><br><span class="line">            ++ans[<span class="built_in">distance</span>(nodes) - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n ^ 2 * 2 ^ n),<br>空间复杂度: O(n ^ 2).</p>
<p>由于<code>n &lt;= 15</code>, 所以指数级的还是可以过的。</p>
<p>评论区也有 <a href="https://leetcode-cn.com/problems/count-subtrees-with-max-distance-between-cities/solution/python3-shu-xing-dp-by-simpleson/"><code>O(n ^ 5)</code>的解法</a>。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 211</title>
    <url>/2020/10/19/LeetCode-weekly-contest-211/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>224 / 11960</td>
<td>YoungForest</td>
<td>18</td>
<td>1:23:45</td>
<td>0:03:19</td>
<td>0:31:37</td>
<td>1:00:04</td>
<td>1:18:45 1</td>
</tr>
</tbody></table>
<p>本周题目质量还不错，而且自己排名也不错。提前10分钟AC，就是喜欢这种紧张刺激感。而像上周那样提前40minAC反而没今天这么开心。<br>因为连续2次周赛排名都很靠前，我残酷群的排名也上升到15名了。久违的最高位置，继续保持。</p>
<h2 id="1624-Largest-Substring-Between-Two-Equal-Characters"><a href="#1624-Largest-Substring-Between-Two-Equal-Characters" class="headerlink" title="1624. Largest Substring Between Two Equal Characters"></a>1624. Largest Substring Between Two Equal Characters</h2><p>签到题。记录每个字符的首次出现下标和最后出现下标，遍历做差即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxLengthBetweenEqualCharacters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="function">vector&lt;pii&gt; <span class="title">index</span><span class="params">(<span class="number">26</span>, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> idx = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (index[idx].first == <span class="number">-1</span>) &#123;</span><br><span class="line">                index[idx].first = i;</span><br><span class="line">            &#125;</span><br><span class="line">            index[idx].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : index) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p.second - p.first - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(s.size()),<br>空间复杂度: O(1).</p>
<h2 id="1625-Lexicographically-Smallest-String-After-Applying-Operations"><a href="#1625-Lexicographically-Smallest-String-After-Applying-Operations" class="headerlink" title="1625. Lexicographically Smallest String After Applying Operations"></a>1625. Lexicographically Smallest String After Applying Operations</h2><p>第二题挺恶心，暴力就行，但实现起来还是比较复杂度的。写了50行代码，没成想竟然一次bug-free。<br>因为数据规模很小，100，brute force搞起.</p>
<p>先找到所有通过shift可以作为开头的下标。shift最为一个子问题也是LeetCode的原题，通过3次<code>reverse</code>可以方便的实现。<br>然后就不需要考虑shift操作了，只需要考虑增加操作。贪心即可。这时根据b是奇偶，可能有2或1位要增加。<br>最后找到所有下标可以达到的最小值即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">findLexSmallestString</span><span class="params">(string s, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; head;</span><br><span class="line">        <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> condidate = ((n - i * b) % n + n) % n;</span><br><span class="line">            <span class="keyword">if</span> (condidate == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line">                first = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head.<span class="built_in">push_back</span>(condidate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">ans</span><span class="params">(n, <span class="string">&#x27;9&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> shiftK = [&amp;](string&amp; a, <span class="keyword">const</span> <span class="keyword">int</span> k) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="comment">// shift left k unit</span></span><br><span class="line">            <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">auto</span> it = a.<span class="built_in">begin</span>() + k;</span><br><span class="line">            <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), it);</span><br><span class="line">            <span class="built_in">reverse</span>(it, a.<span class="built_in">end</span>());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> minIncrease = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> x) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; reach;</span><br><span class="line">            <span class="keyword">int</span> i = x;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (reach.<span class="built_in">find</span>(i) == reach.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                reach[i] = ans;</span><br><span class="line">                i = (i + a) % <span class="number">10</span>;</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> reach.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> fixHead = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> d) -&gt; string &#123;</span><br><span class="line">            string ans = s;</span><br><span class="line">            <span class="built_in">shiftK</span>(ans, d);</span><br><span class="line">            <span class="keyword">if</span> (b % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> increase = <span class="built_in">minIncrease</span>(ans[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                    ans[i] = <span class="string">&#x27;0&#x27;</span> + ((ans[i] - <span class="string">&#x27;0&#x27;</span> + increase) % <span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> increase = <span class="built_in">minIncrease</span>(ans[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                ans[i] = <span class="string">&#x27;0&#x27;</span> + ((ans[i] - <span class="string">&#x27;0&#x27;</span> + increase) % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> d : head) &#123;</span><br><span class="line">            <span class="keyword">const</span> string x = <span class="built_in">fixHead</span>(d);</span><br><span class="line">            <span class="keyword">if</span> (x &lt; ans) &#123;</span><br><span class="line">                ans = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n * n * 10),<br>空间复杂度: O(n).</p>
<h2 id="1626-Best-Team-With-No-Conflicts"><a href="#1626-Best-Team-With-No-Conflicts" class="headerlink" title="1626. Best Team With No Conflicts"></a>1626. Best Team With No Conflicts</h2><p>动态规划。<br>先按年龄和分数排序。<br><code>dp[i][j] = max(dp[i-1][x] for x &lt;= j)</code><br>其中，<code>i</code>表示年龄位置，<code>j</code>表示当前最高分数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bestTeamScore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; scores, vector&lt;<span class="keyword">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, multiset&lt;<span class="keyword">int</span>&gt;&gt; players;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = scores.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            players[ages[i]].<span class="built_in">insert</span>(scores[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;    <span class="comment">// maxScore, max_sum_score</span></span><br><span class="line">        m[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : players) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">int</span> maxScore = it-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : p.second) &#123;</span><br><span class="line">                <span class="keyword">while</span> (it != m.<span class="built_in">end</span>() &amp;&amp; it-&gt;first &lt;= x) &#123;</span><br><span class="line">                    maxScore = <span class="built_in">max</span>(maxScore, it-&gt;second);</span><br><span class="line">                    ++it;</span><br><span class="line">                &#125;</span><br><span class="line">                m[x] = maxScore + x;</span><br><span class="line">                maxScore += x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp;  p : m) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N ^ 2),<br>空间复杂度: O(N).</p>
<h2 id="1627-Graph-Connectivity-With-Threshold"><a href="#1627-Graph-Connectivity-With-Threshold" class="headerlink" title="1627. Graph Connectivity With Threshold"></a>1627. Graph Connectivity With Threshold</h2><p>被国服的翻译坑了。query是询问2个节点是否联通，而不是直接相连。国服一开始翻译成直接相连了，还专门强调一下子。我每次打比赛的习惯是一开始就打开所有的题目。之后除了遇到难题会刷新看提交和通过人数外，几乎不会刷新。所以当题目有问题时，及时之后更新了，我也不知道。力扣并没有类似codeforces的通知机制。幸亏残酷群里有同学也遇到相同的问题，WA了，但就是不明白expected answer怎么对。</p>
<p>本题只有6分，名副其实，属于我恰好能做出来的Hard题目。<br>联通用并查集可以快速实现，模版拿来。<br>然后就是最大公因数联通。最笨的方法是两两判断，用gcd。时间复杂度是N^N，肯定TLE了。<br>比较取巧的方法是枚举公因数（这里并不需要最大），然后连接公因数和倍数就可以了。这里并没有实现题目中的直接相连这一概念，而是间接相连。直接相连并不需要，因为我们最后需要的也是间接相连。</p>
<p>这里时间复杂度不容易判断，需要一个知识:<br>1 + 1/2 + 1/3 + … + 1/n ~ log n.</p>
<p>即调和级数求和复杂度约等于对数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="built_in">UF</span>(<span class="keyword">int</span> n) : <span class="built_in">parent</span>(n), <span class="built_in">count</span>(n) &#123;</span><br><span class="line">            <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A utility function to find the subset of an element i  </span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> x == parent[x] ? x : parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// A utility function to do union of two subsets  </span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">int</span> xset = <span class="built_in">find</span>(x);  </span><br><span class="line">            <span class="keyword">int</span> yset = <span class="built_in">find</span>(y);  </span><br><span class="line">            <span class="keyword">if</span>(xset != yset) </span><br><span class="line">            &#123;  </span><br><span class="line">                parent[xset] = yset;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">areConnected</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> threshold, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// n * log n + queries.size();</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> q = queries.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; ans;</span><br><span class="line">        ans.<span class="built_in">reserve</span>(q);</span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = threshold + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) &#123;</span><br><span class="line">                uf.<span class="built_in">unite</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> uf.<span class="built_in">find</span>(a) == uf.<span class="built_in">find</span>(b);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : queries) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">check</span>(x[<span class="number">0</span>], x[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n log n + queries.length),<br>空间复杂度: O(n).</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本周忙于实习转正需要发的CR和UT，以及28号就要交的大论文初稿。连续加班，估计需要2周时间，一周后交了论文才有机会休息。加油，YoungForest!</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 211</title>
    <url>/2020/10/26/LeetCode-weekly-contest-212/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>103 / 10984</td>
<td>YoungForest</td>
<td>19</td>
<td>1:19:51</td>
<td>0:06:36</td>
<td>0:12:02</td>
<td>0:39:44 2</td>
<td>1:09:51</td>
</tr>
</tbody></table>
<p>本周周赛继续高歌猛进，排名也很靠前。加上上周的名次，我在残酷群里的排名也上升到了新高，第11名。</p>
<h2 id="1629-Slowest-Key"><a href="#1629-Slowest-Key" class="headerlink" title="1629. Slowest Key"></a>1629. Slowest Key</h2><p>一次遍历。使用一个变量维护上次按键的时刻。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">slowestKey</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; releaseTimes, string keysPressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n =  releaseTimes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxDuration = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ans = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> duration = releaseTimes[i] - last;</span><br><span class="line">            <span class="keyword">if</span> (duration &gt; maxDuration || (duration == maxDuration &amp;&amp; keysPressed[i] &gt; ans)) &#123;</span><br><span class="line">                maxDuration = duration;</span><br><span class="line">                ans = keysPressed[i];</span><br><span class="line">            &#125;</span><br><span class="line">            last = releaseTimes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>空间复杂度: O(1),<br>时间复杂度: O(n).</p>
<h2 id="1630-Arithmetic-Subarrays"><a href="#1630-Arithmetic-Subarrays" class="headerlink" title="1630. Arithmetic Subarrays"></a>1630. Arithmetic Subarrays</h2><p>对于每个子数组，排序判断是否为等差数列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> diff = x[<span class="number">1</span>] - x[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; x.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[i] - x[i - <span class="number">1</span>] != diff) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">checkArithmeticSubarrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; l, vector&lt;<span class="keyword">int</span>&gt;&amp; r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// time: m * n * n log n</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = l.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; cp;</span><br><span class="line">            cp.<span class="built_in">reserve</span>(r[i] - l[i] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = l[i]; j &lt;= r[i]; ++j) &#123;</span><br><span class="line">                cp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(cp.<span class="built_in">begin</span>(), cp.<span class="built_in">end</span>());</span><br><span class="line">            ans[i] = <span class="built_in">check</span>(cp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(m * n * n log n),<br>空间复杂度: O(m).</p>
<h2 id="1631-Path-With-Minimum-Effort"><a href="#1631-Path-With-Minimum-Effort" class="headerlink" title="1631. Path With Minimum Effort"></a>1631. Path With Minimum Effort</h2><p>BFS。从头开始搜索，用dp进行剪枝。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> rows = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> cols = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(rows, vector&lt;<span class="keyword">int</span>&gt;(cols, INF));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> vector&lt;pii&gt; neighbor = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        queue&lt;pii&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [di, dj] : neighbor) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> ni = i + di, nj = j + dj;</span><br><span class="line">                <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; rows &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; cols &amp;&amp; dp[ni][nj] &gt; <span class="built_in">max</span>(dp[i][j], <span class="built_in">abs</span>(heights[i][j] - heights[ni][nj]))) &#123;</span><br><span class="line">                    dp[ni][nj] = <span class="built_in">max</span>(dp[i][j], <span class="built_in">abs</span>(heights[i][j] - heights[ni][nj]));</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;ni, nj&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(rows * cols),<br>空间复杂度: O(rows * cols).</p>
<h2 id="1632-Rank-Transform-of-a-Matrix"><a href="#1632-Rank-Transform-of-a-Matrix" class="headerlink" title="1632. Rank Transform of a Matrix"></a>1632. Rank Transform of a Matrix</h2><p>从小到大处理数字，每次处理相同的数字。<br>相同的数字需要根据行列判断联通（使用并查集），同一联通图中的数字需要取最大的rank，这时才满足answer最小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="built_in">UF</span>(<span class="keyword">int</span> n) : <span class="built_in">parent</span>(n), <span class="built_in">count</span>(n) &#123;</span><br><span class="line">            <span class="built_in">iota</span>(parent.<span class="built_in">begin</span>(), parent.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A utility function to find the subset of an element i  </span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> x == parent[x] ? x : parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// A utility function to do union of two subsets  </span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">int</span> xset = <span class="built_in">find</span>(x);  </span><br><span class="line">            <span class="keyword">int</span> yset = <span class="built_in">find</span>(y);  </span><br><span class="line">            <span class="keyword">if</span>(xset != yset) </span><br><span class="line">            &#123;  </span><br><span class="line">                parent[xset] = yset;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">matrixRankTransform</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rowsRank</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">colsRank</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, vector&lt;pii&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                arr[matrix[i][j]].<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; p : arr) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp; v = p.second;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> vsize = v.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">UF <span class="title">uf</span><span class="params">(vsize)</span></span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rowsIndex</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">colsIndex</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vsize; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = v[i];</span><br><span class="line">                <span class="keyword">if</span> (rowsIndex[x] == <span class="number">-1</span> &amp;&amp; colsIndex[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    rowsIndex[x] = i;</span><br><span class="line">                    colsIndex[y] = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowsIndex[x] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    rowsIndex[x] = i;</span><br><span class="line">                    uf.<span class="built_in">unite</span>(i, colsIndex[y]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colsIndex[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    colsIndex[y] = i;</span><br><span class="line">                    uf.<span class="built_in">unite</span>(i, rowsIndex[x]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    uf.<span class="built_in">unite</span>(i, rowsIndex[x]);</span><br><span class="line">                    uf.<span class="built_in">unite</span>(i, colsIndex[y]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; cluster;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vsize; ++i) &#123;</span><br><span class="line">                cluster[uf.<span class="built_in">find</span>(i)].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : cluster) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; vec = p.second;</span><br><span class="line">                <span class="keyword">int</span> maxRank = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : vec) &#123;</span><br><span class="line">                    maxRank = <span class="built_in">max</span>(rowsRank[v[i].first] + <span class="number">1</span>, maxRank);</span><br><span class="line">                    maxRank = <span class="built_in">max</span>(colsRank[v[i].second] + <span class="number">1</span>, maxRank);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : vec) &#123;</span><br><span class="line">                    rowsRank[v[i].first] = maxRank;</span><br><span class="line">                    colsRank[v[i].second] = maxRank;</span><br><span class="line">                    ans[v[i].first][v[i].second] = maxRank;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(m * n * log mn),<br>空间复杂度: O(m * n).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 213</title>
    <url>/2020/11/01/LeetCode-weekly-contest-213/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>139 / 10630</td>
<td>YoungForest</td>
<td>18</td>
<td>0:39:13</td>
<td>0:06:26</td>
<td>0:14:56</td>
<td>0:22:59</td>
<td>0:39:13</td>
</tr>
</tbody></table>
<p>周赛已经连续4周表现良好了，开心。群排名也稳定在了15名，终究还是无法进入前10.不过我已经满意了。</p>
<h2 id="5554-Check-Array-Formation-Through-Concatenation"><a href="#5554-Check-Array-Formation-Through-Concatenation" class="headerlink" title="5554. Check Array Formation Through Concatenation"></a>5554. Check Array Formation Through Concatenation</h2><p>签到题。需要注意<code>arr</code>和<code>pieces</code>都是 distinct （互不相同）的。<br>所以，我们只需要记录pieces的开头元素对应的数组就可以了，直接找，然后匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFormArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; pieces)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; num2indexInPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pieces.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; v = pieces[i];</span><br><span class="line">            num2indexInPieces[v[<span class="number">0</span>]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = num2indexInPieces.<span class="built_in">find</span>(arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (it == num2indexInPieces.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> j = it-&gt;second;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> oldi = i;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; arr.<span class="built_in">size</span>() &amp;&amp; i - oldi &lt; pieces[j].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] != pieces[j][i - oldi]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(arr.size() + pieces.size()),<br>空间复杂度: O(pieces.size()).</p>
<h2 id="5555-Count-Sorted-Vowel-Strings"><a href="#5555-Count-Sorted-Vowel-Strings" class="headerlink" title="5555. Count Sorted Vowel Strings"></a>5555. Count Sorted Vowel Strings</h2><p>DP. 定义<code>dp(n, i)</code>为长度为n，开头是第i大的字母所对应的字符串的数量。<br><code>dp(n, i) = sum(dp(n-1, j) for j in range(i, 0, -1))</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countVowelStrings</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">n, i</span>):</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sum</span>(dp(n-<span class="number">1</span>, j) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> dp(n, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n * 5 * 5),<br>空间复杂度: O(n * 5).</p>
<p>当然，评论区里还有<a href="https://leetcode-cn.com/problems/count-sorted-vowel-strings/solution/tong-ji-zi-dian-xu-yuan-yin-zi-fu-chuan-de-shu-mu-/">零神的O(1)解法</a>. tql，反正我是没看懂。</p>
<h2 id="5556-Furthest-Building-You-Can-Reach"><a href="#5556-Furthest-Building-You-Can-Reach" class="headerlink" title="5556. Furthest Building You Can Reach"></a>5556. Furthest Building You Can Reach</h2><p>贪心。尽量把梯子用到高度差最大的地方。<br>这里需要用<code>priority_queue</code>来维护之前最大的高度差。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">furthestBuilding</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights, <span class="keyword">int</span> bricks, <span class="keyword">int</span> ladders)</span> </span>&#123;</span><br><span class="line">        std::priority_queue&lt;<span class="keyword">int</span>, std::vector&lt;<span class="keyword">int</span>&gt;, std::greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">int</span> lasth = heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; lasth) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> diff = heights[i] - lasth;</span><br><span class="line">                q.<span class="built_in">push</span>(diff);</span><br><span class="line">                <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; ladders) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    bricks -= t;</span><br><span class="line">                    <span class="keyword">if</span> (bricks &lt; <span class="number">0</span>) <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lasth = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heights.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5600-Kth-Smallest-Instructions"><a href="#5600-Kth-Smallest-Instructions" class="headerlink" title="5600. Kth Smallest Instructions"></a>5600. Kth Smallest Instructions</h2><p>上上周hulu面试刚问了一个找二叉搜索数中第k大的数的算法，而这又是我最早在《算法第4版》中看到的一个实现。在平时解题时，也经常用到需要这种带rank的数据结构。</p>
<p>这道题和求rank的思路十分相似，都是维护一个子树的size，然后根据“左子树（向右走）”的size和rank的相对大小，选择走的决策。不同的是，本题中子树的size是总共可以走的路径的方案数，也就是一个组合数。</p>
<p>本题中用到了零神用杨辉三角求组合数的方法，相比阶乘算法，可以支持取模。也防止了溢出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll MOD = <span class="number">1e18</span> + <span class="number">7</span>;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; c;</span><br><span class="line">    <span class="function">ll <span class="title">C</span><span class="params">(ll m, ll n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">kthSmallestPath</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; destination, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> rows = destination[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> cols = destination[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span>  <span class="keyword">int</span> n = rows + cols + <span class="number">1</span>;</span><br><span class="line">        c.<span class="built_in">resize</span>(n + <span class="number">1</span>, vector&lt;ll&gt;(n + <span class="number">1</span>));</span><br><span class="line">        c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (c[i][j] &gt;= MOD) &#123;</span><br><span class="line">                    c[i][j] -= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        pii start = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> r = rows, c = cols;</span><br><span class="line">        <span class="keyword">while</span> (ans.<span class="built_in">size</span>() &lt; rows + cols) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">                --c;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&#x27;V&#x27;</span>);</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> ll right = <span class="built_in">C</span>(r + c - <span class="number">1</span>, c - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (right &gt;= k) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">                    --c;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;V&#x27;</span>);</span><br><span class="line">                    --r;</span><br><span class="line">                    k -= right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((rows + cols) * cols),<br>空间复杂度: O((rows + cols) * cols).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 214</title>
    <url>/2020/11/08/LeetCode-weekly-contest-214/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>393 / 9769</td>
<td>YoungForest</td>
<td>18</td>
<td>1:36:40</td>
<td>0:05:13</td>
<td>0:11:24</td>
<td>0:44:59</td>
<td>1:26:40  2</td>
</tr>
</tbody></table>
<p>残酷群排名维持在14名了，看来这就是我的水平收敛的位置了。最近由于写毕业大论文比较忙，另一方面秋招也结束了，打卡题都没打了。11月才恢复开始打美服和国服每日一题，拿积分换衣服。残酷群由于基本可以免打卡，就一个月都没打了。</p>
<h2 id="5561-Get-Maximum-in-Generated-Array"><a href="#5561-Get-Maximum-in-Generated-Array" class="headerlink" title="5561. Get Maximum in Generated Array"></a>5561. Get Maximum in Generated Array</h2><p>签到题。按照递推公式填写每一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumGenerated</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = nums[i / <span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = nums[i / <span class="number">2</span>] + nums[i / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="5562-Minimum-Deletions-to-Make-Character-Frequencies-Unique"><a href="#5562-Minimum-Deletions-to-Make-Character-Frequencies-Unique" class="headerlink" title="5562. Minimum Deletions to Make Character Frequencies Unique"></a>5562. Minimum Deletions to Make Character Frequencies Unique</h2><p>贪心。不断删除字符，直到有空缺的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDeletions</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++cnt[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (a != <span class="number">0</span> &amp;&amp; count.<span class="built_in">find</span>(a) != count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    --a;</span><br><span class="line">                &#125;</span><br><span class="line">                count.<span class="built_in">insert</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(26).</p>
<h2 id="5563-Sell-Diminishing-Valued-Colored-Balls"><a href="#5563-Sell-Diminishing-Valued-Colored-Balls" class="headerlink" title="5563. Sell Diminishing-Valued Colored Balls"></a>5563. Sell Diminishing-Valued Colored Balls</h2><p>贪心。每次都试图先拿球数最多的颜色。拿的过程中并不是要一个一个拿，而是可以一次拿尽可能多的。<br>用一个优先队列维护最多的颜色数目，用等差数列求和求解拿的cost。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inventory, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        ll orders = o;</span><br><span class="line">        <span class="comment">// greedy</span></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        map&lt;ll, ll, greater&lt;ll&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (ll i : inventory) &#123;</span><br><span class="line">            ++cnt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (orders &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> first = *cnt.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (first.first == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">auto</span> second = *<span class="built_in">next</span>(cnt.<span class="built_in">begin</span>());</span><br><span class="line">            cnt.<span class="built_in">erase</span>(cnt.<span class="built_in">begin</span>());</span><br><span class="line">            cnt.<span class="built_in">erase</span>(cnt.<span class="built_in">begin</span>());</span><br><span class="line">            ll balls = (first.first - second.first) * first.second;</span><br><span class="line">            pii newSecond = &#123;second.first, second.second + first.second&#125;;</span><br><span class="line">            ll reduce = <span class="built_in">min</span>(orders, balls);</span><br><span class="line">            orders -= reduce;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; first.first &lt;&lt; &quot; &quot; &lt;&lt; first.second &lt;&lt; &quot; &quot; &lt;&lt; reduce &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">const</span> ll batch = reduce / first.second;</span><br><span class="line">            <span class="keyword">const</span> ll remain = reduce % first.second;</span><br><span class="line">            ans = (ans + (first.first * batch - batch*(batch<span class="number">-1</span>) / <span class="number">2</span>) * first.second) % MOD;</span><br><span class="line">            ans = (ans + (first.first - batch) * remain) % MOD;</span><br><span class="line">            <span class="comment">// for (int i = 0; i * first.second &lt; reduce; ++i) &#123;</span></span><br><span class="line">            <span class="comment">//     // cout &lt;&lt;  min(first.second, reduce - i) &lt;&lt; &quot; &quot; &lt;&lt;  (first.first - i) &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//     ans = (ans + min(first.second, reduce - i * first.second) * (first.first - i)) % MOD;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            cnt.<span class="built_in">insert</span>(newSecond);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N), N = inventory.size()<br>空间复杂度: O(N).</p>
<p>时间复杂度并不是那么明显，可以考虑cnt的size每次减一这个事实。所以while循环最多被执行N次。</p>
<h2 id="5564-Create-Sorted-Array-through-Instructions"><a href="#5564-Create-Sorted-Array-through-Instructions" class="headerlink" title="5564. Create Sorted Array through Instructions"></a>5564. Create Sorted Array through Instructions</h2><p>核心在于需要这样一个数据结构，可以求解一定范围的元素的数量。可以使用 线段树、树状数组（BIT）、rank tree 等。比赛时我首先使用了GNU pbds实现的rank tree的板子，但是超时了。按理说复杂度是没问题的。<br>然后，其实<a href="https://leetcode-cn.com/problems/count-of-range-sum/solution/qu-jian-he-de-ge-shu-by-leetcode-solution/">国服前一天的每日一题</a>也用到同样的数据结构，去抄了treap的板子。由于不了解接口，光调试就花了半个小时。所幸最后5分钟AC了，这周又可以不用打卡残酷群了（已经一个月没打了）。<br>需要注意板子接口中<code>rank</code>是1开头索引的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalancedTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BalancedNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> seed;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        BalancedNode* left;</span><br><span class="line">        BalancedNode* right;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BalancedNode</span>(<span class="keyword">long</span> <span class="keyword">long</span> _val, <span class="keyword">long</span> <span class="keyword">long</span> _seed): <span class="built_in">val</span>(_val), <span class="built_in">seed</span>(_seed), <span class="built_in">count</span>(<span class="number">1</span>), <span class="built_in">size</span>(<span class="number">1</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">BalancedNode* <span class="title">left_rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> prev_size = size;</span><br><span class="line">            <span class="keyword">int</span> curr_size = (left ? left-&gt;size : <span class="number">0</span>) + (right-&gt;left ? right-&gt;left-&gt;size : <span class="number">0</span>) + count;</span><br><span class="line">            BalancedNode* root = right;</span><br><span class="line">            right = root-&gt;left;</span><br><span class="line">            root-&gt;left = <span class="keyword">this</span>;</span><br><span class="line">            root-&gt;size = prev_size;</span><br><span class="line">            size = curr_size;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">BalancedNode* <span class="title">right_rotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> prev_size = size;</span><br><span class="line">            <span class="keyword">int</span> curr_size = (right ? right-&gt;size : <span class="number">0</span>) + (left-&gt;right ? left-&gt;right-&gt;size : <span class="number">0</span>) + count;</span><br><span class="line">            BalancedNode* root = left;</span><br><span class="line">            left = root-&gt;right;</span><br><span class="line">            root-&gt;right = <span class="keyword">this</span>;</span><br><span class="line">            root-&gt;size = prev_size;</span><br><span class="line">            size = curr_size;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BalancedNode* root;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    mt19937 gen;</span><br><span class="line">    uniform_int_distribution&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">BalancedNode* <span class="title">insert</span><span class="params">(BalancedNode* node, <span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BalancedNode</span>(x, <span class="built_in">dis</span>(gen));</span><br><span class="line">        &#125;</span><br><span class="line">        ++node-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; node-&gt;val) &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">insert</span>(node-&gt;left, x);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left-&gt;seed &gt; node-&gt;seed) &#123;</span><br><span class="line">                node = node-&gt;<span class="built_in">right_rotate</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; node-&gt;val) &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">insert</span>(node-&gt;right, x);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right-&gt;seed &gt; node-&gt;seed) &#123;</span><br><span class="line">                node = node-&gt;<span class="built_in">left_rotate</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++node-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BalancedTree</span>(): <span class="built_in">root</span>(<span class="literal">nullptr</span>), <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">gen</span>(random_device&#123;&#125;()), <span class="built_in">dis</span>(LLONG_MIN, LLONG_MAX) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        ++size;</span><br><span class="line">        root = <span class="built_in">insert</span>(root, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        BalancedNode* node = root;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = LLONG_MAX;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == node-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; node-&gt;val) &#123;</span><br><span class="line">                ans = node-&gt;val;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        BalancedNode* node = root;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = LLONG_MAX;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; node-&gt;val) &#123;</span><br><span class="line">                ans = node-&gt;val;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">rank</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        BalancedNode* node = root;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; node-&gt;val) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += (node-&gt;left ? node-&gt;left-&gt;size : <span class="number">0</span>) + node-&gt;count;</span><br><span class="line">                <span class="keyword">if</span> (x == node-&gt;val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;ans - node-&gt;count + <span class="number">1</span>, ans&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;INT_MIN, INT_MAX&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">createSortedArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; instructions)</span> </span>&#123;</span><br><span class="line">        BalancedTree* treap = <span class="keyword">new</span> <span class="built_in">BalancedTree</span>();</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i: instructions) &#123;</span><br><span class="line">            <span class="comment">// numLeft is the smallest &gt;= i</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> numLeft = treap-&gt;<span class="built_in">lower_bound</span>(i);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;numLeft: &quot; &lt;&lt; numLeft &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// rankLeft is the rank of numLeft, starting from 0</span></span><br><span class="line">            ll rankLeft = (numLeft == LLONG_MAX ? treap-&gt;<span class="built_in">get_size</span>(): treap-&gt;<span class="built_in">rank</span>(numLeft).first - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// numRight is the smallest &gt; i</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> numRight = treap-&gt;<span class="built_in">upper_bound</span>(i);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;numRight: &quot; &lt;&lt; numRight &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// rankLeft is the rank of numLeft, starting from 0</span></span><br><span class="line">            ll rankRight = (numRight == LLONG_MAX ? treap-&gt;<span class="built_in">get_size</span>(): treap-&gt;<span class="built_in">rank</span>(numRight).first - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; rankLeft - 1 &lt;&lt; &quot; &quot; &lt;&lt; treap-&gt;get_size() - rankRight &lt;&lt; endl;</span></span><br><span class="line">            ret = (ret + <span class="built_in">min</span>(treap-&gt;<span class="built_in">get_size</span>() - rankRight, rankLeft)) % MOD;</span><br><span class="line">            treap-&gt;<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 215</title>
    <url>/2020/11/15/LeetCode-weekly-contest-215/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>362 / 9683</td>
<td>YoungForest</td>
<td>12</td>
<td>0:35:02</td>
<td>0:04:21</td>
<td>0:13:42</td>
<td>0:30:02  1</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="5601-Design-an-Ordered-Stream"><a href="#5601-Design-an-Ordered-Stream" class="headerlink" title="5601. Design an Ordered Stream"></a>5601. Design an Ordered Stream</h2><p>签到题。按照题目要求，用一个数组和指针实现接口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedStream</span> &#123;</span></span><br><span class="line">    vector&lt;string&gt; data;</span><br><span class="line">    <span class="keyword">int</span> ptr;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrderedStream</span>(<span class="keyword">int</span> _n) &#123;</span><br><span class="line">        data.<span class="built_in">resize</span>(_n);</span><br><span class="line">        ptr = <span class="number">1</span>;</span><br><span class="line">        n = _n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">insert</span><span class="params">(<span class="keyword">int</span> id, string value)</span> </span>&#123;</span><br><span class="line">        data[id<span class="number">-1</span>] = <span class="built_in">move</span>(value);</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt;= n &amp;&amp; !data[ptr<span class="number">-1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(data[ptr<span class="number">-1</span>]);</span><br><span class="line">            ++ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your OrderedStream object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * OrderedStream* obj = new OrderedStream(n);</span></span><br><span class="line"><span class="comment"> * vector&lt;string&gt; param_1 = obj-&gt;insert(id,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n),<br>空间复杂度: O(n).</p>
<h2 id="5603-Determine-if-Two-Strings-Are-Close"><a href="#5603-Determine-if-Two-Strings-Are-Close" class="headerlink" title="5603. Determine if Two Strings Are Close"></a>5603. Determine if Two Strings Are Close</h2><p>观察2个字符串接近的操作，发现其充分必要条件为：<br>组成字符相同，字符的个数排列相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="keyword">const</span> string &amp;a)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : a) &#123;</span><br><span class="line">            ++ans[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">appear</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != <span class="number">0</span>) ans.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">frequency</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != <span class="number">0</span>) ans.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">closeStrings</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1.<span class="built_in">size</span>() != word2.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> cnt1 = <span class="built_in">cnt</span>(word1);</span><br><span class="line">        <span class="keyword">auto</span> cnt2 = <span class="built_in">cnt</span>(word2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">appear</span>(cnt1) == <span class="built_in">appear</span>(cnt2) &amp;&amp; <span class="built_in">frequency</span>(cnt1) == <span class="built_in">frequency</span>(cnt2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="5602-Minimum-Operations-to-Reduce-X-to-Zero"><a href="#5602-Minimum-Operations-to-Reduce-X-to-Zero" class="headerlink" title="5602. Minimum Operations to Reduce X to Zero"></a>5602. Minimum Operations to Reduce X to Zero</h2><p>观察：</p>
<ol>
<li>取头和取尾操作，其实是和顺序无关的，只和头尾各多少有关。</li>
<li>头尾相加为x，可以转换成中间剩特定的值，找到最长的中间。</li>
</ol>
<p>所以我们枚举每个中间的尾部即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; presum;</span><br><span class="line">        presum[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxJSubI = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">            s += nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (presum.<span class="built_in">find</span>(s) == presum.<span class="built_in">end</span>())  &#123;</span><br><span class="line">                presum[s] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it = presum.<span class="built_in">find</span>(s - (total - x));</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; s - (total - x) &lt;&lt; endl;;</span></span><br><span class="line">            <span class="keyword">if</span> (it != presum.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> current = i - it-&gt;second;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span></span><br><span class="line">                maxJSubI = <span class="built_in">max</span>(maxJSubI, current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxJSubI == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> n - maxJSubI;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="5604-Maximize-Grid-Happiness"><a href="#5604-Maximize-Grid-Happiness" class="headerlink" title="5604. Maximize Grid Happiness"></a>5604. Maximize Grid Happiness</h2><p>轮廓线DP。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 216</title>
    <url>/2020/11/22/LeetCode-weekly-contest-216/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>862 / 9573</td>
<td>YoungForest</td>
<td>18</td>
<td>0:58:34</td>
<td>0:12:47</td>
<td>0:23:33</td>
<td>0:33:14</td>
<td>0:58:34</td>
</tr>
</tbody></table>
<p>之前连续5周免残酷群打卡，着实爽了一个月。上周虽然在前500，但只做出3题。本周虽然做出了4题，但出了前500. 又要打一周卡了。残酷群排名也降到了38名，不再15名的巅峰时光了。<br>自从秋招结束后，再加上实习/大论文特别忙，就没时间刷题了。甚至之前交大论文形式审查最忙的时候，一道题都不刷。11月份以来，恢复了刷国服/美服每日一题的习惯。主要是这2题一般比较简单，花的时间少。另外是想打卡赚积分，争取毕业前可以换2套衣服。<br>3道打卡题的难度基本上是 <code>残酷 &gt; 国服 &gt;= 美服</code>。</p>
<h2 id="1662-Check-If-Two-String-Arrays-are-Equivalent"><a href="#1662-Check-If-Two-String-Arrays-are-Equivalent" class="headerlink" title="1662. Check If Two String Arrays are Equivalent"></a>1662. Check If Two String Arrays are Equivalent</h2><p>签到题。把列表字符串拼接起来然后再比较即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">string <span class="title">concat</span><span class="params">(vector&lt;string&gt;&amp; w)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : w) &#123;</span><br><span class="line">            ans += <span class="built_in">move</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">arrayStringsAreEqual</span><span class="params">(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">concat</span>(word1) == <span class="built_in">concat</span>(word2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(sum(word1[i].length) + sum(word2[i].length)),<br>空间复杂度: O(sum(word1[i].length) + sum(word2[i].length)).</p>
<h2 id="1663-Smallest-String-With-A-Given-Numeric-Value"><a href="#1663-Smallest-String-With-A-Given-Numeric-Value" class="headerlink" title="1663. Smallest String With A Given Numeric Value"></a>1663. Smallest String With A Given Numeric Value</h2><p>贪心。每次都尽量增加最后一位数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getSmallestString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">string <span class="title">ans</span><span class="params">(n, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">        k -= n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> thisDigit = <span class="built_in">min</span>(k, <span class="number">25</span>);</span><br><span class="line">            ans[i] += thisDigit;</span><br><span class="line">            k -= thisDigit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="1664-Ways-to-Make-a-Fair-Array"><a href="#1664-Ways-to-Make-a-Fair-Array" class="headerlink" title="1664. Ways to Make a Fair Array"></a>1664. Ways to Make a Fair Array</h2><p>使用类似 前缀和数组 的 前缀偶数和 和 前缀奇数和，同样 后缀偶数和 和 后缀奇数和。<br>然后就可以快速计算删掉某个位置后的 奇数下标元素的和与偶数下标元素的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToMakeFair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftOdd</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftEven</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightOdd</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightEven</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        leftEven[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                leftOdd[i] = leftOdd[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">                leftEven[i] = leftEven[i - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftEven[i] = leftEven[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">                leftOdd[i] = leftOdd[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((n - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            rightEven[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightOdd[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                rightOdd[i] = rightOdd[i + <span class="number">1</span>] + nums[i];</span><br><span class="line">                rightEven[i] = rightEven[i + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightEven[i] = rightEven[i + <span class="number">1</span>] + nums[i];</span><br><span class="line">                rightOdd[i] = rightOdd[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> odd = <span class="number">0</span>, even = <span class="number">0</span>;</span><br><span class="line">            odd += i &gt; <span class="number">0</span> ? leftOdd[i - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            even += i &gt; <span class="number">0</span> ? leftEven[i - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            odd += i &lt; n - <span class="number">1</span> ? rightEven[i + <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            even += i &lt; n - <span class="number">1</span> ? rightOdd[i + <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (odd == even) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="1665-Minimum-Initial-Energy-to-Finish-Tasks"><a href="#1665-Minimum-Initial-Energy-to-Finish-Tasks" class="headerlink" title="1665. Minimum Initial Energy to Finish Tasks"></a>1665. Minimum Initial Energy to Finish Tasks</h2><p>参见<a href="https://leetcode-cn.com/problems/minimum-initial-energy-to-finish-tasks/solution/wan-cheng-suo-you-ren-wu-de-zui-shao-chu-shi-neng-/">零神的帖子</a>。<br>本题我在比赛时用了不正确地贪心也过了。即找到最小的差值<code>|minimum_i - actual_i|</code>，作为剩下的值；比较这个值和最大的<code>minimum_i</code>。<br>正确的解法对于6分题实在是太难了，应该7/8分。很多人即使猜对了，也不会证明正确性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffort</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(tasks.<span class="built_in">begin</span>(), tasks.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; u, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">0</span>] - u[<span class="number">1</span>] &lt; v[<span class="number">0</span>] - v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> suma = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; task: tasks) &#123;</span><br><span class="line">            p = <span class="built_in">max</span>(p, suma + task[<span class="number">1</span>]);</span><br><span class="line">            suma += task[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 217</title>
    <url>/2020/11/29/LeetCode-weekly-contest-217/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>356 / 9462</td>
<td>YoungForest</td>
<td>13</td>
<td>1:24:07</td>
<td>0:03:55</td>
<td>0:20:14</td>
<td>1:09:07  3</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1672-Richest-Customer-Wealth"><a href="#1672-Richest-Customer-Wealth" class="headerlink" title="1672. Richest Customer Wealth"></a>1672. Richest Customer Wealth</h2><p>签到题。数组求和, C++ accumulate 一行搞定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumWealth</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; v : accounts) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1673-Find-the-Most-Competitive-Subsequence"><a href="#1673-Find-the-Most-Competitive-Subsequence" class="headerlink" title="1673. Find the Most Competitive Subsequence"></a>1673. Find the Most Competitive Subsequence</h2><p>类似 <a href="https://leetcode-cn.com/problems/remove-k-digits/">402. Remove K Digits</a>，采用贪心的思路，尽量删除大的数。标准做法是使用单调栈。</p>
<p>比赛时我采用的是 优先队列维护要删除的最大数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mostCompetitive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](pii a, pii b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.first != b.first) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">m</span>(cmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            m.<span class="built_in">push</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = m.<span class="built_in">top</span>();</span><br><span class="line">            m.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span> (p.second &lt; begin &amp;&amp; !m.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                p = m.<span class="built_in">top</span>();</span><br><span class="line">                m.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            begin = p.second;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            --k;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            m.<span class="built_in">push</span>(&#123;nums[nums.<span class="built_in">size</span>() - k], nums.<span class="built_in">size</span>() - k&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<h2 id="1674-Minimum-Moves-to-Make-Array-Complementary"><a href="#1674-Minimum-Moves-to-Make-Array-Complementary" class="headerlink" title="1674. Minimum Moves to Make Array Complementary"></a>1674. Minimum Moves to Make Array Complementary</h2><p>我在注释中记录了我比赛时的思路。最后灵感乍现，确定每组数一次变化的范围，然后枚举每个可能的目标数，可以快速O(log N)计算出需要的变数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> open[MAX], close[MAX], dot[MAX];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计和的最大众数，变其他。但是有的需要大于limit (x)</span></span><br><span class="line">        <span class="comment">// 二分，快速求判定问题？</span></span><br><span class="line">        <span class="comment">// 暴力，枚举互补数，遍历一遍再。O(n * n)</span></span><br><span class="line">        <span class="comment">// a + b = 互补数，0</span></span><br><span class="line">        <span class="comment">// a + b 变 互补数： 1， 2</span></span><br><span class="line">        <span class="comment">// 0次变 是一个数</span></span><br><span class="line">        <span class="comment">// 一次变最大，一次变最小 是一个范围</span></span><br><span class="line">        <span class="comment">// 出了范围就需要2次变</span></span><br><span class="line">        <span class="comment">// 确定互补数，可以遍历一遍确定变数</span></span><br><span class="line">        <span class="comment">// 确定变数呢？</span></span><br><span class="line">        <span class="comment">// ｜  .  ｜</span></span><br><span class="line">        <span class="comment">// open - close: in range</span></span><br><span class="line">        <span class="comment">// close + total - open: out range</span></span><br><span class="line">        <span class="comment">// dtop: 0</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> - i; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = nums[i];</span><br><span class="line">            <span class="keyword">int</span> b = nums[n - <span class="number">1</span> - i];</span><br><span class="line">            <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">            <span class="comment">// a &lt;= b</span></span><br><span class="line">            <span class="keyword">int</span> lower = a + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> upper = b + limit;</span><br><span class="line">            dot[i] = a + b;</span><br><span class="line">            open[i] = lower;</span><br><span class="line">            close[i] = upper;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> size = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> openEnd = <span class="built_in">begin</span>(open) + size;</span><br><span class="line">        <span class="keyword">auto</span> closeEnd = <span class="built_in">begin</span>(close) + size;</span><br><span class="line">        <span class="keyword">auto</span> dotEnd = <span class="built_in">begin</span>(dot) + size;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">begin</span>(open), openEnd);</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">begin</span>(close), closeEnd);</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">begin</span>(dot), dotEnd);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> need = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> line) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> itOpen = <span class="built_in">upper_bound</span>(<span class="built_in">begin</span>(open), openEnd, line);</span><br><span class="line">            <span class="keyword">auto</span> itClose = <span class="built_in">lower_bound</span>(<span class="built_in">begin</span>(close), closeEnd, line);</span><br><span class="line">            <span class="keyword">auto</span> itDot = <span class="built_in">lower_bound</span>(<span class="built_in">begin</span>(dot), dotEnd, line);</span><br><span class="line">            <span class="keyword">auto</span> itDot2 = <span class="built_in">upper_bound</span>(itDot, dotEnd, line);</span><br><span class="line">            <span class="keyword">int</span> dotNumber = <span class="built_in">distance</span>(itDot, itDot2);</span><br><span class="line">            <span class="keyword">int</span> outRange = <span class="number">0</span>;</span><br><span class="line">            outRange += <span class="built_in">distance</span>(<span class="built_in">begin</span>(close), itClose);</span><br><span class="line">            outRange += <span class="built_in">distance</span>(itOpen, openEnd);</span><br><span class="line">            <span class="keyword">int</span> inRange = n / <span class="number">2</span> - dotNumber - outRange;</span><br><span class="line">            <span class="keyword">return</span> inRange + <span class="number">2</span> * outRange;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> line = <span class="number">2</span>; line &lt;= limit * <span class="number">2</span>; ++line) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> condidate = <span class="built_in">need</span>(line);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; line &lt;&lt; &quot;: &quot; &lt;&lt; condidate &lt;&lt; endl;</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, condidate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(limit * log N),<br>空间复杂度: O(N).</p>
<p>在比赛时，C++ 被卡常数了。需要讲数组改成全局数组才能AC。<br>我本身平时更习惯使用局部vector，可读性和可维护性都更高。</p>
<p>使用差分数组可以避免二分搜索，具体见<a href="https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/solution/shi-shu-zu-hu-bu-de-zui-shao-cao-zuo-ci-shu-by-zer/">零神的题解</a>. 我也是头一次接触差分数组这一概念。</p>
<h2 id="1675-Minimize-Deviation-in-Array"><a href="#1675-Minimize-Deviation-in-Array" class="headerlink" title="1675. Minimize Deviation in Array"></a>1675. Minimize Deviation in Array</h2><p>基于2个操作，可以将问题很轻松地转为LC之前地一个题：<br><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">632. Smallest Range Covering Elements from K Lists</a>。<br>然后使用优先队列或Tree解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDeviation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        multiset&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) ms.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="keyword">else</span> ms.<span class="built_in">insert</span>(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, *ms.<span class="built_in">rbegin</span>() - *ms.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> maxValue = *ms.<span class="built_in">rbegin</span>();</span><br><span class="line">            ms.<span class="built_in">erase</span>(<span class="built_in">prev</span>(ms.<span class="built_in">end</span>()));</span><br><span class="line">            <span class="keyword">if</span> (maxValue % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            ms.<span class="built_in">insert</span>(maxValue / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 218</title>
    <url>/2020/12/06/LeetCode-weekly-contest-218/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>71 / 9827</td>
<td>YoungForest</td>
<td>18</td>
<td>0:48:21</td>
<td>0:03:32</td>
<td>0:05:23</td>
<td>0:12:14</td>
<td>0:43:21  1</td>
</tr>
</tbody></table>
<h2 id="1678-Goal-Parser-Interpretation"><a href="#1678-Goal-Parser-Interpretation" class="headerlink" title="1678. Goal Parser Interpretation"></a>1678. Goal Parser Interpretation</h2><p>签到题。字符串解释，通用的做法是先做词法分析得到token，然后在依次翻译。由于本题的token比较少，设定也简单，所以可以一次遍历，向前看以确定token。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">interpret</span><span class="params">(string command)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; command.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (command[i] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (command[i + <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">                    i += <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<p>据说Python 选手都是一行代码搞定。</p>
<h2 id="1679-Max-Number-of-K-Sum-Pairs"><a href="#1679-Max-Number-of-K-Sum-Pairs" class="headerlink" title="1679. Max Number of K-Sum Pairs"></a>1679. Max Number of K-Sum Pairs</h2><p>贪心。对于每个数，找到它对应的数，然后remove掉即可。使用一个哈希表存储之前见到的数，然后找的花费就是O(1)了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxOperations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[k - i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                --count[k - i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++count[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N), 代码中的排序其实是不需要的，比赛时没注意就先排序了。<br>空间复杂度: O(N).</p>
<h2 id="1680-Concatenation-of-Consecutive-Binary-Numbers"><a href="#1680-Concatenation-of-Consecutive-Binary-Numbers" class="headerlink" title="1680. Concatenation of Consecutive Binary Numbers"></a>1680. Concatenation of Consecutive Binary Numbers</h2><p>Straight forward。用乘法和加法模拟拼接操作。</p>
<p>需要注意的是，左移操作是否可以直接取模。答案是可以的，加减乘都可以直接取模，但除法不行。<br>左移相当于是乘法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function">ll <span class="title">bits</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">concatenatedBinary</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ans = ((ans &lt;&lt; <span class="built_in">bits</span>(i)) + i) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N * log N),<br>空间复杂度: O(1).</p>
<h2 id="1681-Minimum-Incompatibility"><a href="#1681-Minimum-Incompatibility" class="headerlink" title="1681. Minimum Incompatibility"></a>1681. Minimum Incompatibility</h2><p>本题标的是medium，但有6分，确实不大容易。<br>正确的做法是状态压缩DP，详见评论区。但比赛中还是有很多人AC了，包括我，都使用的是暴力的backtracking解法。因为回溯+剪枝的时间复杂度往往不好分析，所以即使通过了，心里也是没有底的。<br>尤其是LeetCode周赛最近加了rejudge的机制，比赛时通过并不意味着成功，所以更心虚。</p>
<p>我首先使用一个贪心的思路（每次都试图找最小的数加入集合）得到一个可能的解。<br>此时，这个解不一定是最小解，但可以用来后面的剪枝。<br>之后会有回溯搜索所有的解空间，构建解集合，得到最小解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumIncompatibility</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> s = n / k;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            ++count[i];</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; k) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> greedy = [&amp;]() -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="function">multiset&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> setIdx = <span class="number">0</span>; setIdx &lt; k; ++setIdx) &#123;</span><br><span class="line">                <span class="keyword">int</span> minValue = *s.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">int</span> maxValue = minValue;</span><br><span class="line">                <span class="keyword">int</span> current = minValue;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n / k) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> it = s.<span class="built_in">upper_bound</span>(current);</span><br><span class="line">                    <span class="keyword">if</span> (it == s.<span class="built_in">end</span>()) <span class="keyword">return</span> numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">                    current = *it;</span><br><span class="line">                    s.<span class="built_in">erase</span>(it);</span><br><span class="line">                    maxValue = current;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += maxValue - minValue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">greedy</span>();</span><br><span class="line">        <span class="comment">// if (ans != -1) return ans;</span></span><br><span class="line">        vector&lt;set&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">results</span>(k);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">uncomp</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span>)&gt; backtracking = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> condidate) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (condidate &gt; ans) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, condidate);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> x = nums[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (results[j].<span class="built_in">size</span>() &lt; s) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; results[j - <span class="number">1</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span> (results[j].<span class="built_in">find</span>(x) == results[j].<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            <span class="keyword">const</span> <span class="keyword">int</span> tmpuncomp = uncomp[j];</span><br><span class="line">                            results[j].<span class="built_in">insert</span>(x);</span><br><span class="line">                            uncomp[j] = *results[j].<span class="built_in">rbegin</span>() - *results[j].<span class="built_in">begin</span>();</span><br><span class="line">                            <span class="built_in">backtracking</span>(i + <span class="number">1</span>, condidate + uncomp[j] - tmpuncomp);</span><br><span class="line">                            results[j].<span class="built_in">erase</span>(x);</span><br><span class="line">                            uncomp[j] = tmpuncomp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">backtracking</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans == numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O((k * log (n / k)) ^ N), 因为剪枝的存在，实际上运行会快些，但真正的时间复杂度不好分析。<br>空间复杂度: O(N).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 221</title>
    <url>/2020/12/27/LeetCode-weekly-contest-221/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>231 / 8838</td>
<td>YoungForest</td>
<td>18</td>
<td>1:24:39</td>
<td>0:03:55</td>
<td>0:21:00</td>
<td>0:30:16</td>
<td>1:09:39  3</td>
</tr>
</tbody></table>
<h2 id="5637-Determine-if-String-Halves-Are-Alike"><a href="#5637-Determine-if-String-Halves-Are-Alike" class="headerlink" title="5637. Determine if String Halves Are Alike"></a>5637. Determine if String Halves Are Alike</h2><p>签到题。使用set记录元音，然后挨个统计即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">halvesAreAlike</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; yuan = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>,</span><br><span class="line">                                    <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (yuan.<span class="built_in">find</span>(s[i]) != yuan.<span class="built_in">end</span>()) ++first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (yuan.<span class="built_in">find</span>(s[i]) != yuan.<span class="built_in">end</span>()) ++last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first == last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="5638-Maximum-Number-of-Eaten-Apples"><a href="#5638-Maximum-Number-of-Eaten-Apples" class="headerlink" title="5638. Maximum Number of Eaten Apples"></a>5638. Maximum Number of Eaten Apples</h2><p>贪心。先吃快过期的苹果。<br>使用TreeMap维护过期时间，二分搜索寻找过期时间最近的苹果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eatenApples</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; apples, vector&lt;<span class="keyword">int</span>&gt;&amp; days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = apples.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxDay = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            maxDay = <span class="built_in">max</span>(maxDay, i + days[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rust;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;maxDay: &quot; &lt;&lt; maxDay &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDay; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n &amp;&amp; apples[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                rust[i + days[i] - <span class="number">1</span>] += apples[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it = rust.<span class="built_in">lower_bound</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (it != rust.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">                ++ans;</span><br><span class="line">                --it-&gt;second;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">                    rust.<span class="built_in">erase</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="1706-Where-Will-the-Ball-Fall"><a href="#1706-Where-Will-the-Ball-Fall" class="headerlink" title="1706. Where Will the Ball Fall"></a>1706. Where Will the Ball Fall</h2><p>由于m, n规模较小，所以可以尝试暴力的dfs解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findBall</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> row, <span class="keyword">const</span> <span class="keyword">int</span> col) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (row == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[row][col] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (col == n - <span class="number">1</span> || grid[row][col + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">dfs</span>(row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (col == <span class="number">0</span> || grid[row][col - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">dfs</span>(row + <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans[i] = <span class="built_in">dfs</span>(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n * m).</p>
<h2 id="5640-Maximum-XOR-With-an-Element-From-Array"><a href="#5640-Maximum-XOR-With-an-Element-From-Array" class="headerlink" title="5640. Maximum XOR With an Element From Array"></a>5640. Maximum XOR With an Element From Array</h2><p>经典0-1 Trie。</p>
<p>最后一题被智能指针<code>shared_ptr</code>坑了 3次TLE，换成裸指针就过了。虽然智能指针花费较小，但<code>shared_ptr</code>也不是zero-overhead的。即使这样，被LeetCode卡常数还是好气呀！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode* zero = <span class="literal">nullptr</span>;</span><br><span class="line">        TrieNode* one = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode* root, <span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        ++root-&gt;count;</span><br><span class="line">        root-&gt;minValue = <span class="built_in">min</span>(root-&gt;minValue, num);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;one == <span class="literal">nullptr</span>) root-&gt;one = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;one, i - <span class="number">1</span>, num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;zero == <span class="literal">nullptr</span>) root-&gt;zero = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                <span class="built_in">insert</span>(root-&gt;zero, i - <span class="number">1</span>, num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recurseQuery</span><span class="params">(TrieNode* root, <span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">const</span> <span class="keyword">int</span> limit, <span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;level: &quot; &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i)) &#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;zero &amp;&amp; root-&gt;zero-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;zero&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">recurseQuery</span>(root-&gt;zero, x, limit, i - <span class="number">1</span>, ans | (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;one &amp;&amp; root-&gt;one-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;one&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">recurseQuery</span>(root-&gt;one, x, limit, i - <span class="number">1</span>, ans);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 0</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;one &amp;&amp; root-&gt;one-&gt;count &gt; <span class="number">0</span> &amp;&amp; root-&gt;one-&gt;minValue &lt;= limit) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;root-&gt;one-&gt;minValue &quot; &lt;&lt; root-&gt;one-&gt;minValue &lt;&lt; &quot; &quot; &lt;&lt; limit &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;one&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">recurseQuery</span>(root-&gt;one, x, limit, i - <span class="number">1</span>, ans | (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;zero &amp;&amp; root-&gt;zero-&gt;count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot;zero&quot; &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">recurseQuery</span>(root-&gt;zero, x, limit, i - <span class="number">1</span>, ans);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maximizeXor</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> maxDigit = <span class="number">29</span>;</span><br><span class="line">        TrieNode* root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(root, maxDigit, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> q = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(q, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> x = queries[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> m = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;minValue &gt; m) &#123;</span><br><span class="line">                ans[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = <span class="built_in">recurseQuery</span>(root, x, m, maxDigit, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(29 * N),<br>空间复杂度: O(29 * N).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 222</title>
    <url>/2021/01/03/LeetCode-weekly-contest-222/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>331 / 9692</td>
<td>YoungForest</td>
<td>18</td>
<td>2:02:29</td>
<td>0:05:32</td>
<td>0:13:55  2</td>
<td>0:54:53  2</td>
<td>1:17:29  5</td>
</tr>
</tbody></table>
<h2 id="5641-Maximum-Units-on-a-Truck"><a href="#5641-Maximum-Units-on-a-Truck" class="headerlink" title="5641. Maximum Units on a Truck"></a>5641. Maximum Units on a Truck</h2><p>贪心。按盒子容量从大到小排序后先用大的盒子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumUnits</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; boxTypes, <span class="keyword">int</span> truckSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// greedy, put larger boxes first</span></span><br><span class="line">        <span class="built_in">sort</span>(boxTypes.<span class="built_in">begin</span>(), boxTypes.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (truckSize &gt; <span class="number">0</span> &amp;&amp; i &lt; boxTypes.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> put = <span class="built_in">min</span>(truckSize, boxTypes[i][<span class="number">0</span>]);</span><br><span class="line">            truckSize -= put;</span><br><span class="line">            ans += boxTypes[i][<span class="number">1</span>] * put;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n log n), <code>n = boxTypes.size()</code><br>空间复杂度: O(log n). 快排内部的递归消耗。</p>
<h2 id="5642-Count-Good-Meals"><a href="#5642-Count-Good-Meals" class="headerlink" title="5642. Count Good Meals"></a>5642. Count Good Meals</h2><p>类似two-sum。使用hashtable维护之前见过的数，只是target数目编程了22.<br>从<code>2^0</code> 到 最大的<code>2^21</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxBit = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; deliciousness)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">target</span><span class="params">(maxBit)</span></span>;</span><br><span class="line">        target[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxBit; ++i) &#123;</span><br><span class="line">            target[i] = target[i<span class="number">-1</span>] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;ll, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i : deliciousness) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; maxBit; ++j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = count.<span class="built_in">find</span>(target[j] - i);</span><br><span class="line">                <span class="keyword">if</span> (it != count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    ans = (ans + it-&gt;second) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(22n),<br>空间复杂度: O(n).</p>
<p>比赛过程中，由于错误估计了最大的幂数。<code>2^20 + 2^20 = 2^21</code>, 错估计成了<code>2^40</code>。导致2次超时罚时。</p>
<h2 id="5643-Ways-to-Split-Array-Into-Three-Subarrays"><a href="#5643-Ways-to-Split-Array-Into-Three-Subarrays" class="headerlink" title="5643. Ways to Split Array Into Three Subarrays"></a>5643. Ways to Split Array Into Three Subarrays</h2><p>枚举每个左子数组。然后利用前缀和和二分确定中间数组的大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToSplit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        presum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            presum[i+<span class="number">1</span>] = presum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> binarySearchRightLessThanMid = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="comment">// [lo, hi)</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> begin = lo;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="comment">// [begin, mid), [mid, end)</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> rightSum = presum[n] - presum[mid];</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> midSum = presum[mid] - presum[begin];</span><br><span class="line">                <span class="keyword">if</span> (rightSum &lt; midSum) &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// rightSum &gt;= midSum</span></span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lo;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> binarySearchFirstLargeEqualThan = [&amp;](<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">const</span> <span class="keyword">int</span> leftSum) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="comment">// [lo, hi)</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> begin = lo;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="comment">// [begin, mid)</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> midSum = presum[mid] - presum[begin];</span><br><span class="line">                <span class="keyword">if</span> (midSum &gt;= leftSum) &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// rightSum &lt; midSum</span></span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lo;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">1</span>; left &lt;= n - <span class="number">2</span>; ++left) &#123;</span><br><span class="line">            <span class="comment">// [0, left)</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> leftSum = presum[left];</span><br><span class="line">            <span class="comment">// [left, mid)</span></span><br><span class="line">            <span class="keyword">int</span> midLeft = <span class="built_in">binarySearchFirstLargeEqualThan</span>(left, n, leftSum);</span><br><span class="line">            <span class="keyword">if</span> (midLeft == left) midLeft = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> midRight = <span class="built_in">binarySearchRightLessThanMid</span>(left, n);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; leftSum &lt;&lt; &quot; &quot; &lt;&lt; midLeft &lt;&lt; &quot; &quot; &lt;&lt; midRight &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (midRight &gt; midLeft)</span><br><span class="line">                ans = (ans + (midRight - midLeft)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n log n),<br>空间复杂度: O(n).</p>
<p>比赛中因为边界问题（corner case）WA了2次。</p>
<ul>
<li>左数组和是0时，此时中数组需不为空。</li>
<li>数组全为9时，此时右数组不为空。</li>
</ul>
<p>事实上，由于<code>midRight</code>和<code>midleft</code>是单调递增的，可以采用<a href="https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/solution/cong-shuang-zhi-zhen-dao-san-zhi-zhen-by-klrb/">三指针的方法</a>进一步将时间复杂度降到O(n).</p>
<h2 id="5644-Minimum-Operations-to-Make-a-Subsequence"><a href="#5644-Minimum-Operations-to-Make-a-Subsequence" class="headerlink" title="5644. Minimum Operations to Make a Subsequence"></a>5644. Minimum Operations to Make a Subsequence</h2><p>本题大家都是比赛现场学，现场抄的。之所以这样讲，是因为本题可以转化成其他经典题目。</p>
<p>首先，观察有，<code>arr</code>中不出现在<code>target</code>中的数是没用的，可以直接删掉。<br>删掉后的<code>arr</code>是一个<code>target</code>的组合（也不完全是，区别在于<code>arr</code>中有些可能是重复的数）。<br>我们只需要求2者的最长公共子序列(Longest Common Subquence, LCS)的长度，然后补齐其余即可。<br>然而LCS的时间复杂度是O(mn)的，显然超时。<br>此时就需要利用组合这一条件了，我谷歌<code>全排列 最长公共子序列</code>。在第三条找到了解法<a href="https://www.cnblogs.com/Jackpei/p/10356999.html">最长公共子序列 和其变形</a>.<br>具体而言，对于这种组合的LCS的特例，可以将其转化成最长上升子序列（Longest Increasing Subsequence, LIS)的问题。LIS又有巧妙的O(n log n)的解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">100005</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>(), nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it==res.<span class="built_in">end</span>()) res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> *it = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; target, vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// n log n</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : target) &#123;</span><br><span class="line">            m[i] = cnt;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                nums[x++] = it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lcs = <span class="built_in">lengthOfLIS</span>(x);</span><br><span class="line">        <span class="keyword">return</span> target.<span class="built_in">size</span>() - lcs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n log n), <code>n = target.size()</code><br>空间复杂度: O(target.size()).</p>
<p>因为抄错LIS的模版，TLE了3次。因为一开始只用了朴素的LCS的O(mn)解法又TLE了2次。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>今天是2021年的第一场周赛，比往常的更难一些。<br>北京的冬天真是太冷了，起床已经变的十分困难了，对生活的热情也十分不足，状态有些消极和悲伤。<br>我想要重新振作和积极起来，开始奋斗的Forest。<br>打工人，打工魂，打工才是人上人。<br>加油Forest！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 225</title>
    <url>/2021/01/24/LeetCode-weekly-contest-225/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>299 / 11282</td>
<td>YoungForest</td>
<td>18</td>
<td>1:16:19</td>
<td>0:05:09</td>
<td>0:18:06</td>
<td>0:29:04</td>
<td>1:11:19  1</td>
</tr>
</tbody></table>
<h2 id="1736-Latest-Time-by-Replacing-Hidden-Digits"><a href="#1736-Latest-Time-by-Replacing-Hidden-Digits" class="headerlink" title="1736. Latest Time by Replacing Hidden Digits"></a>1736. Latest Time by Replacing Hidden Digits</h2><p>贪心。分析每位的情况，<code>if-else</code>解决。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">maximumTime</span><span class="params">(string time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time[<span class="number">4</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            time[<span class="number">4</span>] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (time[<span class="number">3</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            time[<span class="number">3</span>] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (time[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (time[<span class="number">0</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                time[<span class="number">0</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                time[<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (time[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                time[<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                time[<span class="number">1</span>] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time[<span class="number">0</span>] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (time[<span class="number">1</span>] &lt; <span class="string">&#x27;4&#x27;</span>) &#123;</span><br><span class="line">                    time[<span class="number">0</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    time[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<h2 id="1737-Change-Minimum-Characters-to-Satisfy-One-of-Three-Conditions"><a href="#1737-Change-Minimum-Characters-to-Satisfy-One-of-Three-Conditions" class="headerlink" title="1737. Change Minimum Characters to Satisfy One of Three Conditions"></a>1737. Change Minimum Characters to Satisfy One of Three Conditions</h2><p>计算每种目标情况。<br>1，2: 枚举分割点，变换超过分割点的不合适字符。<br>3: 找到众数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCharacters</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> calculatePresum = [&amp;](<span class="keyword">const</span> string&amp; x) -&gt; vector&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">ans</span>(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : x) &#123;</span><br><span class="line">                ++ans[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> op12 = [&amp;](<span class="keyword">const</span> string&amp; a, <span class="keyword">const</span> string&amp; b) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="comment">// 26 * (a.size() + b.size())</span></span><br><span class="line">            <span class="keyword">auto</span> presumA = <span class="built_in">calculatePresum</span>(a);</span><br><span class="line">            <span class="keyword">auto</span> presumB = <span class="built_in">calculatePresum</span>(b);</span><br><span class="line">            <span class="comment">// b &gt;= splitPoint, a &lt; splitPoint</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> splitPoint = <span class="number">1</span>; splitPoint &lt; <span class="number">26</span>; ++splitPoint) &#123;</span><br><span class="line">                <span class="keyword">int</span> need = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// a need</span></span><br><span class="line">                need += a.<span class="built_in">size</span>() - presumA[splitPoint - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// b need</span></span><br><span class="line">                need += presumB[splitPoint - <span class="number">1</span>];</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, need);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 1, 2</span></span><br><span class="line">        <span class="built_in">op12</span>(a, b);</span><br><span class="line">        <span class="built_in">op12</span>(b, a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// size 和 - 众数</span></span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : a) &#123;</span><br><span class="line">                ++cnt[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : b) &#123;</span><br><span class="line">                ++cnt[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> p : cnt) &#123;</span><br><span class="line">                maxCnt = <span class="built_in">max</span>(maxCnt, p.second);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>()) - maxCnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n + 26),<br>空间复杂度: O(26).</p>
<h2 id="1738-Find-Kth-Largest-XOR-Coordinate-Value"><a href="#1738-Find-Kth-Largest-XOR-Coordinate-Value" class="headerlink" title="1738. Find Kth Largest XOR Coordinate Value"></a>1738. Find Kth Largest XOR Coordinate Value</h2><p>动态规划。<br>事实上，比赛时算复杂了。用了3个DP数组，分别表示矩形异或值，行异或值，列异或值。<br>不过根据异或的性质，交换律和抵消律，只需要维护一个矩形异或值就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthLargestValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> rows = matrix;</span><br><span class="line">        <span class="keyword">auto</span> cols = matrix;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        nums.<span class="built_in">reserve</span>(m * n);</span><br><span class="line">        nums.<span class="built_in">push_back</span>(matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            cols[i][<span class="number">0</span>] = cols[i<span class="number">-1</span>][<span class="number">0</span>] ^ matrix[i][<span class="number">0</span>];</span><br><span class="line">            matrix[i][<span class="number">0</span>] ^= matrix[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            nums.<span class="built_in">push_back</span>(matrix[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            rows[<span class="number">0</span>][j] = rows[<span class="number">0</span>][j<span class="number">-1</span>] ^ matrix[<span class="number">0</span>][j];</span><br><span class="line">            matrix[<span class="number">0</span>][j] ^= matrix[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">            nums.<span class="built_in">push_back</span>(matrix[<span class="number">0</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                rows[i][j] = rows[i][j<span class="number">-1</span>] ^ matrix[i][j];</span><br><span class="line">                cols[i][j] = cols[i<span class="number">-1</span>][j] ^ matrix[i][j];</span><br><span class="line">                matrix[i][j] ^= matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] ^ rows[i][j<span class="number">-1</span>] ^ cols[i<span class="number">-1</span>][j];</span><br><span class="line">                nums.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(m * n),<br>空间复杂度: O(1), 不需要<code>rows</code>, <code>cols</code>如果复用<code>matrix</code>的话。</p>
<h2 id="1739-Building-Boxes"><a href="#1739-Building-Boxes" class="headerlink" title="1739. Building Boxes"></a>1739. Building Boxes</h2><p>二分查找。<br>确定最下一层盒子数，计算其最多可以摆多少盒子。<br>根据贪心的思路，每一层都要尽量挤到角角上，是一个等差数列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumBoxes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// time: log n * log n * log n</span></span><br><span class="line">        <span class="comment">// 1 + 3 + 6</span></span><br><span class="line">        <span class="comment">// level(x) = level(x-1) + x, level(1) = 1</span></span><br><span class="line">        <span class="comment">// level(2) = 3</span></span><br><span class="line">        <span class="comment">// level(3) = 6</span></span><br><span class="line">        <span class="comment">// binary_search</span></span><br><span class="line">        <span class="comment">// maxBoxesCount(x) = </span></span><br><span class="line">        <span class="keyword">const</span> ll MAX = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> binary = [&amp;](ll lo, ll hi, function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">const</span> ll)&gt; predicate) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                ll mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">predicate</span>(mid)) &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lo;</span><br><span class="line">        &#125;;</span><br><span class="line">        function&lt;<span class="built_in">ll</span>(<span class="keyword">const</span> ll)&gt; maxBoxesCouldHoldByLastLevel = [&amp;](<span class="keyword">const</span> ll x) -&gt; ll &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ll k = <span class="built_in">binary</span>(<span class="number">0</span>, MAX, [&amp;](<span class="keyword">const</span> ll k) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> k * (k + <span class="number">1</span>) / <span class="number">2</span> &gt; x;</span><br><span class="line">            &#125;) - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// if (x &lt; 5) cout &lt;&lt; &quot;maxBoxesCouldHoldByLastLevel: &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">const</span> ll y = x - (k * (k + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">const</span> ll couldNotPut = y + (k) - (y == <span class="number">0</span> ? y : (y - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">const</span> ll nextLevel = x - couldNotPut;</span><br><span class="line">            <span class="keyword">return</span> x + <span class="built_in">maxBoxesCouldHoldByLastLevel</span>(nextLevel);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binary</span>(<span class="number">0</span>, MAX, [&amp;](<span class="keyword">const</span> ll x) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">maxBoxesCouldHoldByLastLevel</span>(x) &gt;= n;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log n * log n * sqrt n), sqrt n 为 <code>maxBoxesCouldHoldByLastLevel</code>的递归层数，<br>空间复杂度: O(sqrt n).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 230</title>
    <url>/2021/03/01/LeetCode-weekly-contest-230/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>314 / 11654</td>
<td>YoungForest</td>
<td>12</td>
<td>0:27:36</td>
<td>0:04:00</td>
<td>0:14:38</td>
<td>0:27:36</td>
<td>null</td>
</tr>
</tbody></table>
<p>自从秋招结束后，刷题和比赛的热情与日俱减。<br>之前每日三题（国服、美服、残酷），现在每日0题。当然偶尔因为周赛成绩不足以免打卡，也需每日一题。<br>相反，比赛的反馈还是挺强的。长期有rating和排名的增长激励，短期有残酷排名和每次排名的激励，还有额外积分的奖励。另外每周比赛完还可以在残酷群里领红包，给自己加个鸡腿。</p>
<h2 id="1773-Count-Items-Matching-a-Rule"><a href="#1773-Count-Items-Matching-a-Rule" class="headerlink" title="1773. Count Items Matching a Rule"></a>1773. Count Items Matching a Rule</h2><p>签到题。按照题目描述便利一遍即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMatches</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ruleKey == <span class="string">&quot;type&quot;</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ruleKey == <span class="string">&quot;color&quot;</span>) &#123;</span><br><span class="line">            index = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[index] == ruleValue) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1774-Closest-Dessert-Cost"><a href="#1774-Closest-Dessert-Cost" class="headerlink" title="1774. Closest Dessert Cost"></a>1774. Closest Dessert Cost</h2><p>Brute force 暴力枚举即可。观察题目的数据规模，<code>n</code> 和 <code>m</code>都比较小，指数级的暴力搜索就可以过。<br>可以只用<code>回溯(backtracking)</code>，也可以使用3进制<code>bitmask</code>做枚举。<br>我比赛时采用了回溯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestCost</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; baseCosts, vector&lt;<span class="keyword">int</span>&gt;&amp; toppingCosts, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// time: n * (3 ^ m)</span></span><br><span class="line">        <span class="comment">// 10 * 3 ^ 10 59049</span></span><br><span class="line">        <span class="comment">// max: 10^4 + 2 * 10 * 10^4</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; candidates;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = toppingCosts.<span class="built_in">size</span>();</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span>)&gt; backtracking = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> now) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">                candidates.<span class="built_in">push_back</span>(now);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                    <span class="built_in">backtracking</span>(i + <span class="number">1</span>, now + toppingCosts[i] * j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> base : baseCosts) &#123;</span><br><span class="line">            <span class="built_in">backtracking</span>(<span class="number">0</span>, base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>, diff = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : candidates) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> diffI = <span class="built_in">abs</span>(i - target);</span><br><span class="line">            <span class="keyword">if</span> (diffI &lt; diff) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                diff = diffI;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diffI == diff &amp;&amp; i &lt; ans) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n * 3 ^ m),<br>空间复杂度: O(n * 3 ^ m).</p>
<h2 id="1775-Equal-Sum-Arrays-With-Minimum-Number-of-Operations"><a href="#1775-Equal-Sum-Arrays-With-Minimum-Number-of-Operations" class="headerlink" title="1775. Equal Sum Arrays With Minimum Number of Operations"></a>1775. Equal Sum Arrays With Minimum Number of Operations</h2><p>贪心。优先进行变化最大的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Content</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> sumOfAll = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">Content</span>() &#123;</span><br><span class="line">            nums.<span class="built_in">resize</span>(<span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Content <span class="title">preprocess</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        Content ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            ans.sumOfAll += i;</span><br><span class="line">            ++ans.nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 -&gt; 6 6 -&gt; 1 5</span></span><br><span class="line">        <span class="comment">// 2 -&gt; 6 5 -&gt; 1 4</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">auto</span> c1 = <span class="built_in">preprocess</span>(nums1);</span><br><span class="line">        <span class="keyword">auto</span> c2 = <span class="built_in">preprocess</span>(nums2);</span><br><span class="line">        <span class="keyword">if</span> (c1.sumOfAll &gt; c2.sumOfAll) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c1 &lt; c2</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">7</span> - i;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> cost = <span class="number">6</span> - i;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> need = c2.sumOfAll - c1.sumOfAll;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> needStep = need / cost + ((need % cost == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 3 2 -&gt; 2</span></span><br><span class="line">            <span class="comment">// 4 2 -&gt; 2</span></span><br><span class="line">            <span class="comment">// 2 2 -&gt; 1</span></span><br><span class="line">            <span class="keyword">if</span> (needStep &lt;= c1.nums[i] + c2.nums[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans + needStep;</span><br><span class="line">            &#125;</span><br><span class="line">            c1.sumOfAll += c1.nums[i] * cost;</span><br><span class="line">            c2.sumOfAll -= c2.nums[j] * cost;</span><br><span class="line">            ans += c1.nums[i] + c2.nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(nums1.size() + nums2.size()),<br>空间复杂度: O(1).</p>
<h2 id="1776-Car-Fleet-II"><a href="#1776-Car-Fleet-II" class="headerlink" title="1776. Car Fleet II"></a>1776. Car Fleet II</h2><p>比较难的一道题目。比赛时没做出来，但是有一定的想法。可以先判断最后会分成几个车队。从后向前通过判断是否可以追上<code>not meeting: speed[i] &gt; min of speed [i+1:]</code>，把问题先分成若干个子问题。然后在每个子问题中，通过维护一个碰撞时间的优先队列，更新汽车的状态和新的碰撞事件。时间复杂度为 O(N log N).<br>后来证明这个想法实现过于繁琐和容易出错。</p>
<p>虽然用优先队列记录碰撞事件可以做，但实现起来，尤其是更新碰撞特别繁琐。<br>优雅的做法是单调栈。详情参考<a href="https://www.bilibili.com/video/BV1DK4y1S743/">群主的视频</a>.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 231</title>
    <url>/2021/03/07/LeetCode-weekly-contest-231/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>221 / 12900</td>
<td>YoungForest</td>
<td>13</td>
<td>0:26:48</td>
<td>0:03:30</td>
<td>0:08:23  1</td>
<td>0:21:48</td>
<td>null</td>
</tr>
</tbody></table>
<p>3题选手, again。sad.</p>
<span id="more"></span>

<h2 id="1784-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones"><a href="#1784-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones" class="headerlink" title="1784. Check if Binary String Has at Most One Segment of Ones"></a>1784. Check if Binary String Has at Most One Segment of Ones</h2><p>签到题。有限状态机。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOnesSegment</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0: not see 1</span></span><br><span class="line">        <span class="comment">// 1: see 1 and now 1</span></span><br><span class="line">        <span class="comment">// 2: see 1 but now 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                    state = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">1</span>) &#123;</span><br><span class="line">                    state = <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    state = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// c == &#x27;1&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                    state = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">1</span>) &#123;</span><br><span class="line">                    state = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1785-Minimum-Elements-to-Add-to-Form-a-Given-Sum"><a href="#1785-Minimum-Elements-to-Add-to-Form-a-Given-Sum" class="headerlink" title="1785. Minimum Elements to Add to Form a Given Sum"></a>1785. Minimum Elements to Add to Form a Given Sum</h2><p>贪心。每次都加减limit/-limit，以最大步长，以得到最小步数。<br>注意: 这里题目数据范围故意挖了坑，用<code>int</code>求和<code>nums</code>会溢出。当然<code>Python</code>没有这种问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, ll limit, ll goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ll current = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">if</span> (current &gt; goal) &#123;</span><br><span class="line">            <span class="keyword">return</span> (current - goal) / limit + (((current - goal) % limit == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == goal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (goal - current) / limit + (((goal - current) % limit == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1786-Number-of-Restricted-Paths-From-First-to-Last-Node"><a href="#1786-Number-of-Restricted-Paths-From-First-to-Last-Node" class="headerlink" title="1786. Number of Restricted Paths From First to Last Node"></a>1786. Number of Restricted Paths From First to Last Node</h2><p>题目比较难理解，但其实不难。<br>用<code>Dijistra</code>求解<code>distanceToLastNode(x)</code>，然后记忆化<code>dfs</code>就OK了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRestrictedPaths</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dijistra: E log E + V</span></span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">neighbors</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            neighbors[e[<span class="number">0</span>]].<span class="built_in">push_back</span>(&#123;e[<span class="number">1</span>], e[<span class="number">2</span>]&#125;);</span><br><span class="line">            neighbors[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(&#123;e[<span class="number">0</span>], e[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">distance</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, n&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [d, current] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!visited[current]) &#123;</span><br><span class="line">                visited[current] = <span class="literal">true</span>;</span><br><span class="line">                distance[current] = d;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> neighbor : neighbors[current]) &#123;</span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123;d + neighbor.second, neighbor.first&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> current) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (current == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[current] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (memo[current] != <span class="number">-1</span>) <span class="keyword">return</span> memo[current];</span><br><span class="line">                <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> neighbor : neighbors[current]) &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> node = neighbor.first;</span><br><span class="line">                    <span class="keyword">if</span> (distance[node] &lt; distance[current]) &#123;</span><br><span class="line">                        ans = (ans + <span class="built_in">dfs</span>(node)) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> memo[current] = ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(E log E + V + E),<br>空间复杂度: O(V + E).</p>
<h2 id="1787-Make-the-XOR-of-All-Segments-Equal-to-Zero-中文"><a href="#1787-Make-the-XOR-of-All-Segments-Equal-to-Zero-中文" class="headerlink" title="1787. Make the XOR of All Segments Equal to Zero 中文"></a><a href="https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero/">1787. Make the XOR of All Segments Equal to Zero</a> <a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/">中文</a></h2><p>说实话本题想了半天没思路，我还去Google了半天，感觉可能会是一道原题。然而没找到。<br>赛后群友发出来链接，果然是原题：<br><a href="https://stackoverflow.com/questions/64186699/minimum-changes-so-the-xor-of-every-k-consecutive-elements-is-0">原题链接</a>。<br>看来搜题也是一门技术呀。有的人能搜到抄代码也算是他的本事。</p>
<p>我是参考<a href="https://www.bilibili.com/video/BV1vz4y1175J/">群主的题解</a>。</p>
<p>首先可以观察到 最后的状态中，每<code>k</code>个数是重复出现的。所以可以判定，我们只需要计算头<code>k</code>个数<code>XOR</code>为0即可。当然，算<code>cost</code>时，需要考虑后面的。</p>
<p>然后根据数据返回，猜测是时间复杂度为O(1024*n)的DP。然后再构造状态转移方程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_NUMS = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minChanges</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the total size of Set[i]</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">totalCost</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="comment">// cnt[i][j]: the count of j in Set[i]</span></span><br><span class="line">        vector&lt;unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">cnt</span>(k);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++totalCost[i % k];</span><br><span class="line">            ++cnt[i%k][nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the cost to set Set[i] to v</span></span><br><span class="line">        <span class="keyword">auto</span> cost = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> v) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> totalCost[i] - cnt[i][v];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[i][d]: the minimum cost to make first i XOR equal to d</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(k, vector&lt;<span class="keyword">int</span>&gt; (MAX_NUMS, numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>()));</span><br><span class="line">        <span class="keyword">int</span> minLastDp = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAX_NUMS; ++d) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][d] = totalCost[<span class="number">0</span>] - cnt[<span class="number">0</span>][d];</span><br><span class="line">            minLastDp = <span class="built_in">min</span>(minLastDp, dp[<span class="number">0</span>][d]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minDp = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>(); </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; MAX_NUMS; ++d) &#123;</span><br><span class="line">                dp[i][d] = minLastDp + totalCost[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j += k) &#123;</span><br><span class="line">                    dp[i][d] = <span class="built_in">min</span>(dp[i][d], </span><br><span class="line">                                  dp[i<span class="number">-1</span>][d^nums[j]] + <span class="built_in">cost</span>(i, nums[j]));</span><br><span class="line">                &#125;</span><br><span class="line">                minDp = <span class="built_in">min</span>(minDp, dp[i][d]);</span><br><span class="line">            &#125;</span><br><span class="line">            minLastDp = minDp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(k * 1024 * n / k) = O(1024 * n),<br>空间复杂度: O(k * 1024).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 232</title>
    <url>/2021/03/14/LeetCode-weekly-contest-232/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>807 / 12541</td>
<td>YoungForest</td>
<td>17</td>
<td>1:06:39</td>
<td>0:03:24</td>
<td>0:06:02</td>
<td>0:38:44</td>
<td>1:01:39  1</td>
</tr>
</tbody></table>
<p>昨天出去修Mac，因为屏幕一直闪。果然卖Apple的产品Apple Care是必须的。上次修了键盘，这次修屏幕，4个面都换新的了。在外面跑了一天，特别累。今早起来晚，一起来就开始比赛了，一口水一口饭都没吃。<br>继连续2周3题后，终于4题了。一开始我还挺得意，觉得这周应该不用打卡了。后来发现小丑竟然是我自己。其他选手竟然认为本场是手速场。我T3 T4想复杂了，速度慢了些，没进前500. 残酷名次也从10+退到了40+。下周rating要掉了。没想到3题涨分，4题掉分。</p>
<span id="more"></span>

<h2 id="1790-Check-if-One-String-Swap-Can-Make-Strings-Equal"><a href="#1790-Check-if-One-String-Swap-Can-Make-Strings-Equal" class="headerlink" title="1790. Check if One String Swap Can Make Strings Equal"></a>1790. Check if One String Swap Can Make Strings Equal</h2><p>签到题。完全相等特殊判断，枚举所有的交换看是否可行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areAlmostEqual</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s1.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(s1[i], s1[j]);</span><br><span class="line">                <span class="keyword">if</span> (s1 == s2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">swap</span>(s1[i], s1[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N^2),<br>空间复杂度: O(1).</p>
<p>当然，本题也有O(N)的做法。比如，可以找到2个字符串不一样的2个位置，再交换。<br>由于题目数据范围较小，比赛时重点比拼手速，所以我选择了复杂度更高，但想起来和写起来更简单的解法。</p>
<h2 id="1791-Find-Center-of-Star-Graph"><a href="#1791-Find-Center-of-Star-Graph" class="headerlink" title="1791. Find Center of Star Graph"></a>1791. Find Center of Star Graph</h2><p>计算所有节点的度。度为<code>n-1</code>的节电即为中心节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCenter</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = edges.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            ++degree[e[<span class="number">0</span>]];</span><br><span class="line">            ++degree[e[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<p>当然，本题也有时间和空间复杂度 O(1)的解法。比如，前2个边的共同节点即为中心节点。</p>
<h2 id="1792-Maximum-Average-Pass-Ratio"><a href="#1792-Maximum-Average-Pass-Ratio" class="headerlink" title="1792. Maximum Average Pass Ratio"></a>1792. Maximum Average Pass Ratio</h2><p>贪心 + 优先队列。<br>每个聪明学生都优先被加入到可以使得通过率增加最多的班级。<br>用优先队列维护这种贪心思想。<code>pair&lt;double, int&gt;</code> 表示 增加的通过率 和 对应的班级编号。</p>
<p>具体贪心正确性的证明可参考<a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/solution/zui-da-ping-jun-tong-guo-lu-by-zerotrac2-84br/">零神的题解</a>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">div</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> a, <span class="keyword">const</span> <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxAverageRatio</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; classes, <span class="keyword">int</span> extraStudents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = classes.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pii&gt; pq;</span><br><span class="line">        <span class="keyword">auto</span> change = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> more) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> next = <span class="built_in">div</span>(classes[i][<span class="number">0</span>] + more, classes[i][<span class="number">1</span>] + more);</span><br><span class="line">            <span class="keyword">double</span> now = <span class="built_in">div</span>(classes[i][<span class="number">0</span>], classes[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> next - now;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;<span class="built_in">change</span>(i, <span class="number">1</span>), i&#125;);</span><br><span class="line">            ans += <span class="built_in">div</span>(classes[i][<span class="number">0</span>], classes[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; extraStudents; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [c, index] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            ans += c;</span><br><span class="line">            classes[index][<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">            classes[index][<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;<span class="built_in">change</span>(index, <span class="number">1</span>), index&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">div</span>(ans, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n * log n),<br>空间复杂度: O(n).</p>
<h2 id="1793-Maximum-Score-of-a-Good-Subarray"><a href="#1793-Maximum-Score-of-a-Good-Subarray" class="headerlink" title="1793. Maximum Score of a Good Subarray"></a>1793. Maximum Score of a Good Subarray</h2><p>根据数据规模，解法的时间复杂度很可能是O(N)的双指针 或是 O(N log N)的最优化问题转判定问题的二分.<br>再看i 和 j 的变化趋势，基本可以判定是采用双指针解法。两边看谁变的更大，就变它。同时，还需维护单调减的性质，即略过那些会变大的数。</p>
<p>在比赛中我的实现是，先用单调减性计算出变化的位置：<code>construct</code>.<br>再在变化位置上移动双指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">vector&lt;pii&gt; <span class="title">construct</span><span class="params">(T begin, T end)</span> </span>&#123;</span><br><span class="line">        vector&lt;pii&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> currentMin = *begin;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">next</span>(begin); it != end; ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it &lt; currentMin) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;currentMin, <span class="built_in">distance</span>(begin, it)&#125;);</span><br><span class="line">                currentMin = *it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;currentMin, <span class="built_in">distance</span>(begin, end)&#125;);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">construct</span>(nums.<span class="built_in">begin</span>() + k, nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">construct</span>(nums.<span class="built_in">rbegin</span>() + n - k - <span class="number">1</span>, nums.<span class="built_in">rend</span>());</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">min</span>(left[l].first, right[r].first) * (left[l].second + right[r].second - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; left.<span class="built_in">size</span>() || r + <span class="number">1</span> &lt; right.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l + <span class="number">1</span> &lt; left.<span class="built_in">size</span>() &amp;&amp; r + <span class="number">1</span> &lt; right.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left[l + <span class="number">1</span>].first &gt; right[r + <span class="number">1</span>].first) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l + <span class="number">1</span> &lt; left.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(left[l].first, right[r].first) * (left[l].second + right[r].second - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(nums.size()),<br>空间复杂度: O(nums[i]) = O(2 * 10^4).</p>
<p>其实，我对单调递减<code>construct</code>的函数实现是多余的。这种单调递减完全可以再双指针移动的过程中实现，此时，可以将空间复杂度降低到<code>O(1)</code>.</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 233</title>
    <url>/2021/03/25/LeetCode-weekly-contest-233/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (5)</th>
<th>Q4 (7)</th>
</tr>
</thead>
<tbody><tr>
<td>923 / 12037</td>
<td>YoungForest</td>
<td>13</td>
<td>1:13:09</td>
<td>0:29:59</td>
<td>0:50:24</td>
<td>1:13:09</td>
<td>null</td>
</tr>
</tbody></table>
<p>周末和女朋友KFC，整整耽误了3场比赛。<br>双周赛没参加，周赛迟到半小时，紧接着参加KickStart，人已经废了。<br>以后打比赛还是要养精蓄锐，好好打才行。</p>
<p>第四题我最后其实是有思路的，无奈时间不够了。之前做过类似用Trie处理异或问题的题目，印象还挺深刻的。</p>
<span id="more"></span>

<h2 id="1800-Maximum-Ascending-Subarray-Sum"><a href="#1800-Maximum-Ascending-Subarray-Sum" class="headerlink" title="1800. Maximum Ascending Subarray Sum"></a>1800. Maximum Ascending Subarray Sum</h2><p>签到题。2个变量分别记录当前符合递增条件的累加值和上一个元素的值，更新最大累加值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAscendingSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; last) &#123;</span><br><span class="line">                current += i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, current);</span><br><span class="line">            last = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1801-Number-of-Orders-in-the-Backlog"><a href="#1801-Number-of-Orders-in-the-Backlog" class="headerlink" title="1801. Number of Orders in the Backlog"></a>1801. Number of Orders in the Backlog</h2><p>用<code>TreeMap</code>维护price和数量的 key, value. 按照题意进行更新即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; out, <span class="keyword">const</span> pair&lt;A, B&gt;&amp; a) &#123;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; a.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.second &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">Cmp</span>&gt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; out, <span class="keyword">const</span> map&lt;U, T, Cmp&gt;&amp; a) &#123;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;&#123;&quot;</span>; <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : a) &#123; out &lt;&lt; (first ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>); out &lt;&lt; p.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; p.second; first = <span class="number">0</span>;&#125; out &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfBacklogOrders</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; orders)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0 buy 1 sell</span></span><br><span class="line">        map&lt;<span class="keyword">int</span>, ll&gt; buy, sell;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; v : orders) &#123;</span><br><span class="line">            <span class="keyword">int</span> price = v[<span class="number">0</span>], amount = v[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (v[<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// buy</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : sell) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span> || p.first &gt; price) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (p.second &gt;= amount) &#123;</span><br><span class="line">                        p.second -= amount;</span><br><span class="line">                        amount = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        amount -= p.second;</span><br><span class="line">                        p.second = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!sell.<span class="built_in">empty</span>() &amp;&amp; sell.<span class="built_in">begin</span>()-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">                    sell.<span class="built_in">erase</span>(sell.<span class="built_in">begin</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buy[price] += amount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// sell</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it = buy.<span class="built_in">rbegin</span>(); it != buy.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">                    <span class="keyword">auto</span>&amp; p = *it;</span><br><span class="line">                    <span class="keyword">if</span> (amount &lt;= <span class="number">0</span> || p.first &lt; price) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (p.second &gt;= amount) &#123;</span><br><span class="line">                        p.second -= amount;</span><br><span class="line">                        amount = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        amount -= p.second;</span><br><span class="line">                        p.second = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!buy.<span class="built_in">empty</span>() &amp;&amp; buy.<span class="built_in">rbegin</span>()-&gt;second == <span class="number">0</span>) &#123;</span><br><span class="line">                    buy.<span class="built_in">erase</span>(<span class="built_in">prev</span>(buy.<span class="built_in">end</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sell[price] += amount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; buy &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; sell &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : buy) &#123;</span><br><span class="line">            ans = (ans + p.second) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : sell) &#123;</span><br><span class="line">            ans = (ans + p.second) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(orders.length * log orders.length),<br>空间复杂度: o(orders.length).</p>
<h2 id="1802-Maximum-Value-at-a-Given-Index-in-a-Bounded-Array"><a href="#1802-Maximum-Value-at-a-Given-Index-in-a-Bounded-Array" class="headerlink" title="1802. Maximum Value at a Given Index in a Bounded Array"></a>1802. Maximum Value at a Given Index in a Bounded Array</h2><p>二分搜索。将最优化问题转化成判定问题。<br>限定最大值后，使用等差数列求和计算总和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> maxSum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// peek, peek - 1, ..., 1</span></span><br><span class="line">        <span class="comment">// Sn=n*a1+n(n-1)d/2</span></span><br><span class="line">        <span class="comment">// Sn=n(a1+an)/2</span></span><br><span class="line">        <span class="keyword">auto</span> oneSide = [&amp;](<span class="keyword">const</span> ll peek, <span class="keyword">const</span> ll index) -&gt; ll &#123;</span><br><span class="line">            <span class="keyword">if</span> (index + <span class="number">1</span> &gt;= peek) &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">return</span></span> ((peek) * (peek + <span class="number">1</span>) / <span class="number">2</span>) + index + <span class="number">1</span> - peek;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">return</span></span> (index + <span class="number">1</span>) * peek + (index + <span class="number">1</span>) * (index) * (<span class="number">-1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 0 1 2 3 4 5</span></span><br><span class="line">        <span class="comment">// n = 6</span></span><br><span class="line">        <span class="comment">// index = 2</span></span><br><span class="line">        <span class="keyword">auto</span> sumOf = [&amp;](<span class="keyword">const</span> ll peek) -&gt; ll &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;oneSide &quot; &lt;&lt; oneSide(peek, index) &lt;&lt; &quot; &quot; &lt;&lt; oneSide(peek, n - index - 1) &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">oneSide</span>(peek, index) + <span class="built_in">oneSide</span>(peek, n - index - <span class="number">1</span>) - peek;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// first true</span></span><br><span class="line">        <span class="keyword">auto</span> binary = [&amp;](ll lo, ll hi, function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">const</span> ll)&gt; predicate) -&gt; ll &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                ll mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">predicate</span>(mid)) &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lo;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// f f f t t t</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; sumOf(3) &lt;&lt; &quot; &quot;&lt;&lt; sumOf(2) &lt;&lt; &quot; &quot; &lt;&lt; sumOf(1) &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binary</span>(<span class="number">1</span>, <span class="number">1e9</span> + <span class="number">7</span>, [&amp;](<span class="keyword">const</span> ll x) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sumOf</span>(x) &gt; maxSum;</span><br><span class="line">        &#125;) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log maxSum),<br>空间复杂度: O(1).</p>
<h2 id="1803-Count-Pairs-With-XOR-in-a-Range"><a href="#1803-Count-Pairs-With-XOR-in-a-Range" class="headerlink" title="1803. Count Pairs With XOR in a Range"></a>1803. Count Pairs With XOR in a Range</h2><p>类似的题目 LC 421 1707.<br>使用Trie以解决XOR异或问题。时间复杂度一般为 O(31 * N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">        array&lt;Trie*, 2&gt; children;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_BIT = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        Trie *root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> current = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = MAX_BIT; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;children[(i &gt;&gt; k) &amp; <span class="number">1</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    current-&gt;children[(i &gt;&gt; k) &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                current = current-&gt;children[(i &gt;&gt; k) &amp; <span class="number">1</span>];</span><br><span class="line">                current-&gt;count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> countLessThan = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> target) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">                <span class="keyword">auto</span> current = root;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = MAX_BIT; k &gt;= <span class="number">0</span> &amp;&amp; current; --k) &#123;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> x = (i &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> y = (target &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (y == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (current-&gt;children[x]) &#123;</span><br><span class="line">                            ans += current-&gt;children[x]-&gt;count;     <span class="comment">// take all xor = zero</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        current = current-&gt;children[<span class="number">1</span> - x];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        current = current-&gt;children[x];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">countLessThan</span>(high + <span class="number">1</span>) - <span class="built_in">countLessThan</span>(low)) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(16 N),<br>空间复杂度: O(16 N).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 234</title>
    <url>/2021/03/28/LeetCode-weekly-contest-234/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>672 / 12421</td>
<td>YoungForest</td>
<td>19</td>
<td>1:19:08</td>
<td>0:12:04  2</td>
<td>0:23:51</td>
<td>0:29:26</td>
<td>0:54:08  3</td>
</tr>
</tbody></table>
<p>又要打卡了，已经连续5周残酷打卡了。而且确实自己本次做题没觉得多简单，WA5次，心态爆炸，但是排名却不理想。感觉还是LeetCode越来越卷了。</p>
<span id="more"></span>

<h2 id="1805-Number-of-Different-Integers-in-a-String"><a href="#1805-Number-of-Different-Integers-in-a-String" class="headerlink" title="1805. Number of Different Integers in a String"></a>1805. Number of Different Integers in a String</h2><p>本题其实用Python做会好很多，实现起来更快。Python对字符串和大整数的优势还是无可比拟的。<br>我还是坚持用C++ 完成，各种字符串不熟悉和不方便的操作。WA了2发。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDifferentIntegers</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                c = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!word.<span class="built_in">empty</span>() &amp;&amp; word.<span class="built_in">back</span>() == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            word.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (word.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">std::istringstream <span class="title">is</span><span class="params">(word)</span></span>;</span><br><span class="line">        unordered_set&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (is)</span><br><span class="line">        &#123;</span><br><span class="line">            string s;</span><br><span class="line">            is &gt;&gt; s;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; s.<span class="built_in">back</span>() == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                s.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;xx : &quot; &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            ans.<span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="1806-Minimum-Number-of-Operations-to-Reinitialize-a-Permutation"><a href="#1806-Minimum-Number-of-Operations-to-Reinitialize-a-Permutation" class="headerlink" title="1806. Minimum Number of Operations to Reinitialize a Permutation"></a>1806. Minimum Number of Operations to Reinitialize a Permutation</h2><p>本题我是倒着思考的，<br>操作的拟操作是 技术位置到后半段，偶数位置到前半段。<br>而且观察变化的过程，只需要关注一个数，如果他回到原位置，剩下所有的数都会回到原位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// operation: odd to half second, even to half first</span></span><br><span class="line">    <span class="comment">// [0 1 2 3 4 5] 4</span></span><br><span class="line">    <span class="comment">// [0 2 4 1 3 5] 3</span></span><br><span class="line">    <span class="comment">// [0 4 3 2 1 5] 2</span></span><br><span class="line">    <span class="comment">// [0 3 1 4 2 5] 1</span></span><br><span class="line">    <span class="comment">// [0 1 2 3 4 5] 0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reinitializePermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index1 % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                index1 = n / <span class="number">2</span> + index1 / <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                index1 = index1 / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125; <span class="keyword">while</span> (index1 != <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1807-Evaluate-the-Bracket-Pairs-of-a-String"><a href="#1807-Evaluate-the-Bracket-Pairs-of-a-String" class="headerlink" title="1807. Evaluate the Bracket Pairs of a String"></a>1807. Evaluate the Bracket Pairs of a String</h2><p>说实话，本题作为第3题，并没有相应的难度。完全可以作为签到题。<br>直接做即可。<br>知识点：字符串处理 + 字典/Map.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">evaluate</span><span class="params">(string s, vector&lt;vector&lt;string&gt;&gt;&amp; knowledge)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, string&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : knowledge) &#123;</span><br><span class="line">            m[v[<span class="number">0</span>]] = v[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">bool</span> left = <span class="literal">false</span>;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                left = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                left = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(word);</span><br><span class="line">                <span class="keyword">if</span> (it == m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">append</span>(it-&gt;second);</span><br><span class="line">                &#125;</span><br><span class="line">                word.<span class="built_in">clear</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (left) &#123;</span><br><span class="line">                    word.<span class="built_in">push_back</span>(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(s.size() + knowledge.size() * (knowledge[i][0].size() + knowledge[i][1].size())),<br>空间复杂度: O(s.size() + knowledge.size() * (knowledge[i][0].size() + knowledge[i][1].size())).</p>
<h2 id="1808-Maximize-Number-of-Nice-Divisors"><a href="#1808-Maximize-Number-of-Nice-Divisors" class="headerlink" title="1808. Maximize Number of Nice Divisors"></a>1808. Maximize Number of Nice Divisors</h2><p>问题可以转换成 确定和，最大化乘积。</p>
<p>sum 确定是primeFactors。然后好因子的数目就是乘积，也就是题目里最大化的目标。<br>因为你观察好因子其实是每个质因数数目的乘积。</p>
<p>在Google上搜索<code>fix sum max multiplication</code>，第3条就有Geekforgeek的一个类似问题<a href="https://www.geeksforgeeks.org/breaking-integer-to-get-maximum-product/">Breaking an Integer to get Maximum Product</a>. 其实LeetCode上也有原题<a href="https://leetcode-cn.com/problems/integer-break/">343</a>.<br>我试图照搬它的代码，然而有2个地方不同：</p>
<ul>
<li>geekforgeek上必须break，不能作为一个整体。而本题是可以不break的。这个涉及到特殊case, 即primeFactors = 2 或 3时，应改为返回 n.</li>
<li>geekforgeek上的代码采用一个for loop * 3. 时间复杂度是 O(n / 3). 在本题会超时。我自己写了<code>pow</code>以更快的方式*3，时间复杂度是 O(log n)。其实是<a href="https://leetcode-cn.com/problems/powx-n/">LeetCode 50 Pow(x, n)</a>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="comment">// https://www.geeksforgeeks.org/breaking-integer-to-get-maximum-product/</span></span><br><span class="line">    <span class="comment">/* The main function that returns the max possible product */</span></span><br><span class="line">    <span class="function">ll <span class="title">mypow</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// a ^ b</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">mypow</span>(a, b - <span class="number">1</span>) * a) % MOD;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> x = <span class="built_in">mypow</span>(a, b/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> (x * x) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProd</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">// n equals to 2 or 3 must be handled explicitly</span></span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Keep removing parts of size 3 while n is greater than 4</span></span><br><span class="line">       ll res = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// while (n &gt; 4)</span></span><br><span class="line">       <span class="comment">// &#123;</span></span><br><span class="line">       <span class="comment">//     n -= 3;</span></span><br><span class="line">       <span class="comment">//     res = (res * 3) % MOD; // Keep multiplying 3 to res</span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 4 0</span></span><br><span class="line">        <span class="comment">// 5 1</span></span><br><span class="line">        <span class="comment">// 6 1</span></span><br><span class="line">        <span class="comment">// 7 1</span></span><br><span class="line">        <span class="comment">// 8 2</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> step = ((n - <span class="number">5</span>) / <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">mypow</span>(<span class="number">3</span>, step);</span><br><span class="line">            n -= step * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> (n * res) % MOD; <span class="comment">// The last part multiplied by previous parts</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNiceDivisors</span><span class="params">(<span class="keyword">int</span> primeFactors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxProd</span>(primeFactors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log n),<br>空间复杂度: O(1).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 235</title>
    <url>/2021/04/05/LeetCode-weekly-contest-235/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>889 / 11443</td>
<td>YoungForest</td>
<td>12</td>
<td>0:27:18</td>
<td>0:01:52</td>
<td>0:07:49</td>
<td>0:27:18</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1816-Truncate-Sentence"><a href="#1816-Truncate-Sentence" class="headerlink" title="1816. Truncate Sentence"></a>1816. Truncate Sentence</h2><p>签到题。再次强调一遍，字符串问题适合用Python做，真的只需要描述题目就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">truncateSentence</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(s.split(<span class="string">&#x27; &#x27;</span>)[:k])</span><br></pre></td></tr></table></figure>
<p>时间复杂度: O(s.length),<br>空间复杂度: O(s.length).</p>
<h2 id="1817-Finding-the-Users-Active-Minutes"><a href="#1817-Finding-the-Users-Active-Minutes" class="headerlink" title="1817. Finding the Users Active Minutes"></a>1817. Finding the Users Active Minutes</h2><p>暴力。以ID为统计每个用户的动作时间序列，然后排序去重。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findingUsersActiveMinutes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; logs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// brute-force:</span></span><br><span class="line">        <span class="comment">// logs.length + k</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; actions; <span class="comment">// userId -&gt; actionMinute</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : logs) &#123;</span><br><span class="line">            actions[v[<span class="number">0</span>]].<span class="built_in">push_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : actions) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; v = p.second;</span><br><span class="line">            <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> d = <span class="built_in">distance</span>(v.<span class="built_in">begin</span>(), it);</span><br><span class="line">            <span class="keyword">if</span> (d &gt;= <span class="number">1</span> &amp;&amp; d &lt;= k) ++ans[d - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(logs.length * log(logs.length) + k),<br>空间复杂度: O(logs.length + k).</p>
<h2 id="1818-Minimum-Absolute-Sum-Difference"><a href="#1818-Minimum-Absolute-Sum-Difference" class="headerlink" title="1818. Minimum Absolute Sum Difference"></a>1818. Minimum Absolute Sum Difference</h2><p>贪心 + 二分搜索。 Greedy + Binary Search.</p>
<p>对于每一个位置，试图换它以达到最小Diff. 使用二分搜索找到最近的可选值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAbsoluteSumDiff</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        ll sumNums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sumNums += <span class="built_in">abs</span>(nums1[i] - nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = sumNums;</span><br><span class="line">        <span class="keyword">auto</span> sortNums1 = nums1;</span><br><span class="line">        <span class="built_in">sort</span>(sortNums1.<span class="built_in">begin</span>(), sortNums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(sortNums1.<span class="built_in">begin</span>(), sortNums1.<span class="built_in">end</span>(), nums2[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != sortNums1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, sumNums - <span class="keyword">static_cast</span>&lt;ll&gt;(<span class="built_in">abs</span>(nums1[i] - nums2[i])) + <span class="keyword">static_cast</span>&lt;ll&gt;(<span class="built_in">abs</span>(*it - nums2[i])));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it != sortNums1.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                it = <span class="built_in">prev</span>(it);</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, sumNums - <span class="keyword">static_cast</span>&lt;ll&gt;(<span class="built_in">abs</span>(nums1[i] - nums2[i])) + <span class="keyword">static_cast</span>&lt;ll&gt;(<span class="built_in">abs</span>(*it - nums2[i])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(nums.length * log nums.length),<br>空间复杂度: O(nums.length).</p>
<h2 id="1819-Number-of-Different-Subsequences-GCDs"><a href="#1819-Number-of-Different-Subsequences-GCDs" class="headerlink" title="1819. Number of Different Subsequences GCDs"></a>1819. Number of Different Subsequences GCDs</h2><p>比赛时TLE，没想出高效的算法。<br>暴力DP，维护当前数组的子数组的所有子序列的GCD在一个Set中。</p>
<p>时间复杂度: O(N ^ 2), N = nums.length,<br>空间复杂度: O(max(nums[i])). gcd的数量，最多有这么多种可能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDifferentSubsequenceGCDs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            unordered_set&lt;<span class="keyword">int</span>&gt; newDp;</span><br><span class="line">            newDp.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a : dp) &#123;</span><br><span class="line">                newDp.<span class="built_in">insert</span>(__gcd(a, x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x : newDp) &#123;</span><br><span class="line">                dp.<span class="built_in">insert</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其他 GCD类似的题目，大家感兴趣可以一做：</p>
<ul>
<li><a href="https://atcoder.jp/contests/abc191/tasks/abc191_f">https://atcoder.jp/contests/abc191/tasks/abc191_f</a></li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 236</title>
    <url>/2021/04/11/LeetCode-weekly-contest-236/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>1513 / 12115</td>
<td>YoungForest</td>
<td>12</td>
<td>0:45:18</td>
<td>0:02:57</td>
<td>0:08:59</td>
<td>0:40:18  1</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="1822-Sign-of-the-Product-of-an-Array"><a href="#1822-Sign-of-the-Product-of-an-Array" class="headerlink" title="1822. Sign of the Product of an Array"></a>1822. Sign of the Product of an Array</h2><p>签到题。多少负数，是否有0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arraySign</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            x *= i</span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1823-Find-the-Winner-of-the-Circular-Game"><a href="#1823-Find-the-Winner-of-the-Circular-Game" class="headerlink" title="1823. Find the Winner of the Circular Game"></a>1823. Find the Winner of the Circular Game</h2><p>经典的约瑟夫环问题。随便Google了一个: <a href="https://blog.csdn.net/u011500062/article/details/72855826">约瑟夫环——公式法</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cir</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p=(p+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheWinner</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cir</span>(n, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1824-Minimum-Sideway-Jumps"><a href="#1824-Minimum-Sideway-Jumps" class="headerlink" title="1824. Minimum Sideway Jumps"></a>1824. Minimum Sideway Jumps</h2><p>动态规划。</p>
<p>dp[i][j] 表示从i的位置，第j个lane 到末尾需要的最小side jumps.<br>需要注意的是 本题<code>N &lt;= 5 * 10^5</code>，Python TOP-BOTTOM的DP会爆栈。<br>因此比赛时Runtime Error一次，加了<br><code>sys.setrecursionlimit(110000)</code>仍然不行，遂改成了Bottom-Up 的DP。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSideJumps</span>(<span class="params">self, obstacles: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(obstacles) - <span class="number">1</span></span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * <span class="number">4</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[n][<span class="number">1</span>] = dp[n][<span class="number">2</span>] = dp[n][<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> obstacles[i+<span class="number">1</span>] != j:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i+<span class="number">1</span>][j])</span><br><span class="line">                <span class="keyword">for</span> nj <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">if</span> j == nj: <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> obstacles[i] != nj <span class="keyword">and</span> obstacles[i+<span class="number">1</span>] != nj:</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i+<span class="number">1</span>][nj] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1825-Finding-MK-Average"><a href="#1825-Finding-MK-Average" class="headerlink" title="1825. Finding MK Average"></a>1825. Finding MK Average</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 237</title>
    <url>/2021/04/18/LeetCode-weekly-contest-237/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>345 / 11446</td>
<td>YoungForest</td>
<td>18</td>
<td>0:40:04</td>
<td>0:03:21</td>
<td>0:05:10</td>
<td>0:25:30</td>
<td>0:35:04  1</td>
</tr>
</tbody></table>
<p>久违的四题并进入前500名。终于可以免打卡了。<br>已经连续打卡7周了，快要遭不住了呀。最近LeetCode难度提升不小，大佬入场也很多。要同时达到4题和前500属实不易。<br>今天手速也算正常发挥.</p>
<h2 id="1832-Check-if-the-Sentence-Is-Pangram"><a href="#1832-Check-if-the-Sentence-Is-Pangram" class="headerlink" title="1832. Check if the Sentence Is Pangram"></a>1832. Check if the Sentence Is Pangram</h2><p>签到题。<br>统计每个单词出现的次数，判断是否都大于0.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIfPangram</span><span class="params">(string sentence)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : sentence) &#123;</span><br><span class="line">            ++cnt[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1833-Maximum-Ice-Cream-Bars"><a href="#1833-Maximum-Ice-Cream-Bars" class="headerlink" title="1833. Maximum Ice Cream Bars"></a>1833. Maximum Ice Cream Bars</h2><p>贪心。优先买便宜的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">begin</span>(costs), <span class="built_in">end</span>(costs));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : costs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins &gt;= i) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                coins -= i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(costs.length * log cost.length),<br>空间复杂度: O(log cost.length).</p>
<h2 id="1834-Single-Threaded-CPU"><a href="#1834-Single-Threaded-CPU" class="headerlink" title="1834. Single-Threaded CPU"></a>1834. Single-Threaded CPU</h2><p>使用优先队列选择执行任务，根据题目要求，需要按<code>processTime, index</code>的顺序取。<br>另外，任务还需要按照<code>enqueueTime</code>排序，加入到等待的优先队列中。</p>
<p>此题C++是有坑的。<br><code>tasks.length == n</code><br><code>1 &lt;= n &lt;= 10^5</code><br><code>1 &lt;= enqueueTimei, processingTimei &lt;= 10^9</code>,<br>因此，时间最后会超出<code>int</code>范围，需要使用<code>long long</code>解决。<br>当然, 选择<code>Python</code>就没这个问题了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;ll, <span class="keyword">int</span>&gt;; <span class="comment">// processTime, index</span></span><br><span class="line">        <span class="comment">// events</span></span><br><span class="line">        <span class="keyword">using</span> tii = tuple&lt;ll, ll, ll&gt;;  <span class="comment">// enqueueTime, processTime, index</span></span><br><span class="line">        vector&lt;tii&gt; events;</span><br><span class="line">        events.<span class="built_in">reserve</span>(tasks.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            events.<span class="built_in">push_back</span>(&#123;tasks[i][<span class="number">0</span>], tasks[i][<span class="number">1</span>], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">begin</span>(events), <span class="built_in">end</span>(events));</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.<span class="built_in">reserve</span>(tasks.<span class="built_in">size</span>());</span><br><span class="line">        ll now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; wait; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; events.<span class="built_in">size</span>() || !wait.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; events.<span class="built_in">size</span>() &amp;&amp; get&lt;<span class="number">0</span>&gt;(events[i]) &lt;= now) &#123;</span><br><span class="line">                wait.<span class="built_in">push</span>(&#123;get&lt;<span class="number">1</span>&gt;(events[i]), get&lt;<span class="number">2</span>&gt;(events[i])&#125;);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (wait.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                wait.<span class="built_in">push</span>(&#123;get&lt;<span class="number">1</span>&gt;(events[i]), get&lt;<span class="number">2</span>&gt;(events[i])&#125;);</span><br><span class="line">                now = get&lt;<span class="number">0</span>&gt;(events[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> run = wait.<span class="built_in">top</span>();</span><br><span class="line">            wait.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(run.second);</span><br><span class="line">            now += run.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N), N = tasks.length,<br>空间复杂度: O(N).</p>
<h2 id="1835-Find-XOR-Sum-of-All-Pairs-Bitwise-AND"><a href="#1835-Find-XOR-Sum-of-All-Pairs-Bitwise-AND" class="headerlink" title="1835. Find XOR Sum of All Pairs Bitwise AND"></a>1835. Find XOR Sum of All Pairs Bitwise AND</h2><p>问题咋一看无从下手，只想到暴力方法，枚举所有的pair，时间复杂度显然不够：<code>arr1.length * arr2.length = 10^10</code>。<br>但其实细想，对于这种位操作来说，每一位之间都是相互独立的。我们可以把问题简化成针对特定位的。只关注一个位的话，解法就呼之欲出了。<br>我们只需要统计<code>arr1</code>和<code>arr2</code>中0 和 1的数目。<br>假设<code>arr1</code>有<code>x</code>个0、<code>y</code>个1，<code>arr2</code>有<code>a</code>个0，<code>b</code>个1。<br>AND 为 1的数目即为<code>b*y</code>，为0的数目为<code>ax + ay + bx</code>。<br>再异或的话，只需要判断1的个数，即<code>b*y</code>，是不是奇数就OK了。<br>这里C++又有一个坑，因为<code>arr.length</code>最大为 10^ 5, <code>b*y</code>是可以<code>int</code>溢出的。LeetCode因为编译器开了溢出检查，因此会报类似下面的错误。我也因此罚时一次。<br>解决方案是要么用<code>long long</code>，要么 分别判断 <code>(b % 2 == 1) &amp;&amp; (y % 2 == 1)</code>.</p>
<blockquote>
<p>Line 24: Char 26: runtime error: signed integer overflow: 100000 * 100000 cannot be represented in type ‘int’ (solution.cpp)<br>SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:26</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">extract</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">const</span> <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &amp; (<span class="number">1</span> &lt;&lt; i)) ++y;</span><br><span class="line">            <span class="keyword">else</span> ++x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getXORSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr1, vector&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// brute-force: arr1.length * arr2.length = 10^10</span></span><br><span class="line">        <span class="comment">// smart: 32 * (arr1.length + arr2.length)</span></span><br><span class="line">        <span class="comment">// x0 y1</span></span><br><span class="line">        <span class="comment">// a0 b1</span></span><br><span class="line">        <span class="comment">// AND 0 = (ax + ay + bx)</span></span><br><span class="line">        <span class="comment">// AND 1 = (by)</span></span><br><span class="line">        <span class="comment">// if AND 1 % 2 == 1:</span></span><br><span class="line">        <span class="comment">//     k += (1 &lt;&lt; i)</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = <span class="built_in">extract</span>(arr1, i);</span><br><span class="line">            <span class="keyword">auto</span> [a, b] = <span class="built_in">extract</span>(arr2, i);</span><br><span class="line">            <span class="keyword">if</span> ((b % <span class="number">2</span> == <span class="number">1</span>) &amp;&amp; (y % <span class="number">2</span> == <span class="number">1</span>)) &#123;</span><br><span class="line">                ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 238</title>
    <url>/2021/04/25/LeetCode-weekly-contest-238/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>383 / 11635</td>
<td>YoungForest</td>
<td>18</td>
<td>1:53:50</td>
<td>0:01:05</td>
<td>0:13:02</td>
<td>0:20:59</td>
<td>1:28:50 5</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="1837-Sum-of-Digits-in-Base-K"><a href="#1837-Sum-of-Digits-in-Base-K" class="headerlink" title="1837. Sum of Digits in Base K"></a>1837. Sum of Digits in Base K</h2><p>签到题。10进制转6进制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumBase</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            ans += n % k</span><br><span class="line">            n //= k</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log_k n),<br>空间复杂度: O(1).</p>
<h2 id="1838-Frequency-of-the-Most-Frequent-Element"><a href="#1838-Frequency-of-the-Most-Frequent-Element" class="headerlink" title="1838. Frequency of the Most Frequent Element"></a>1838. Frequency of the Most Frequent Element</h2><p>本周周赛Q2 Q3都是滑动窗口题。事实上，从零宝大数据来看，Q2难度还是比Q3大的。</p>
<p>首先想出暴力解法，尝试每个元素，试图把比它小的元素增至它，看最多有多少个。<br>时间复杂度: O(N ^ 2), 估计会TLE。<br>Q2 通常情况下还是可以暴力解的，虽然本题不可以。</p>
<p>在暴力解的基础上，尝试优化。观察到，“试图把比它小的元素增至它”这个操作或许可以在O(1)的情况下完成，而不需要暴力尝试每个比它小的元素。因为那些元素已经被升至上一个尝试元素了。</p>
<p>先排序。然后，从小到大尝试把所有值都增至<code>nums[r]</code>。<br>窗口<code>[l:r]</code>维护这些被增至目标值<code>nums[r]</code>的元素。<br>当<code>r</code>右移时，把窗口里的元素都从上个值更新到<code>nums[r]</code>。<br>如果用了过多的增操作，则增加<code>l</code>，释放增操作。<br>取窗口最宽值作为答案。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxFrequency</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># brute force: N ^ 2</span></span><br><span class="line">        <span class="comment"># for each element, try to make it most frequency</span></span><br><span class="line">        <span class="comment"># sliding window</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> r &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># make all increment to nums[r]</span></span><br><span class="line">                k -= (nums[r] - nums[r-<span class="number">1</span>]) * (r - l)</span><br><span class="line">            <span class="keyword">while</span> k &lt; <span class="number">0</span>:</span><br><span class="line">                k += nums[r] - nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(r - l + <span class="number">1</span>, ans)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n log n + n),<br>空间复杂度: O(1).</p>
<h2 id="1839-Longest-Substring-Of-All-Vowels-in-Order"><a href="#1839-Longest-Substring-Of-All-Vowels-in-Order" class="headerlink" title="1839. Longest Substring Of All Vowels in Order"></a>1839. Longest Substring Of All Vowels in Order</h2><p>相比上题，本题更是明显的滑动窗口题。<br>窗口<code>[l:r]</code>的不变量是字串递增。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestBeautifulSubstring</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># brute force: N^3, enumerate all substring * check each substring</span></span><br><span class="line">        <span class="comment"># sliding window: N</span></span><br><span class="line">        <span class="comment"># at least once, incresing</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(word)</span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>():</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&#x27;aeiou&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> cnt[<span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] &lt;= <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            cnt[<span class="built_in">ord</span>(word[r]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r &gt; <span class="number">0</span> <span class="keyword">and</span> word[r] &lt; word[r-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    cnt[<span class="built_in">ord</span>(word[l]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> check():</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>)</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(word.length),<br>空间复杂度: O(1).</p>
<h2 id="1840-Maximum-Building-Height"><a href="#1840-Maximum-Building-Height" class="headerlink" title="1840. Maximum Building Height"></a>1840. Maximum Building Height</h2><p>还是挺难的一道Hard题。<br>相邻差值为1. 一开始想到用BFS，从高度限制小的开始遍历，更新周围的高度。也算是经典算法。<br>然后TLE后，才注意到<code>n &lt;= 10^9</code>这个限制。O(N)的算法也肯定超时。<br>注意<code>restrictions.length &lt;= 10^5</code>这一限制，大概率是要从这里下手的。<br>因此，BFS时只更新被限制的块，块中间再用二分搜索找最高点（其实可以用O(1)的数学解法的，比赛时没好想法就二分暴力了）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxBuilding</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; restrictions)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rtxMap;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; seen;</span><br><span class="line">        seen.<span class="built_in">reserve</span>(restrictions.<span class="built_in">size</span>() + <span class="number">2</span>);</span><br><span class="line">        rtxMap[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        rtxMap[n<span class="number">-1</span>] = INF;</span><br><span class="line">        seen[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        seen[n<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// bfs: O(N), TLE</span></span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : restrictions) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;v[<span class="number">1</span>], v[<span class="number">0</span>] - <span class="number">1</span>&#125;);</span><br><span class="line">            rtxMap[v[<span class="number">0</span>] - <span class="number">1</span>] = v[<span class="number">1</span>];</span><br><span class="line">            seen[v[<span class="number">0</span>] - <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [height, idx] = pq.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">// cout &lt;&lt; height &lt;&lt; &quot;, &quot; &lt;&lt; idx &lt;&lt; endl;</span></span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (seen[idx]) <span class="keyword">continue</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, height);</span><br><span class="line">            seen[idx] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> j : &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> next = idx + j;</span><br><span class="line">                <span class="keyword">if</span> (next &gt;= n || next &lt; <span class="number">0</span> || seen[next]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> it = rtxMap.<span class="built_in">lower_bound</span>(next);</span><br><span class="line">                    <span class="keyword">if</span> (it != rtxMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">int</span> x = it-&gt;first;</span><br><span class="line">                        it-&gt;second = <span class="built_in">min</span>(it-&gt;second, height + x - idx);</span><br><span class="line">                        pq.<span class="built_in">push</span>(&#123;it-&gt;second, x&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">auto</span> it = rtxMap.<span class="built_in">lower_bound</span>(idx);</span><br><span class="line">                    <span class="comment">// 2 5</span></span><br><span class="line">                    <span class="comment">// next = 4</span></span><br><span class="line">                    <span class="keyword">if</span> (it != rtxMap.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                        --it;</span><br><span class="line">                        <span class="keyword">const</span> <span class="keyword">int</span> x = it-&gt;first;</span><br><span class="line">                        it-&gt;second = <span class="built_in">min</span>(it-&gt;second, height + idx - x);</span><br><span class="line">                        pq.<span class="built_in">push</span>(&#123;it-&gt;second, x&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = rtxMap.<span class="built_in">begin</span>(); <span class="built_in">next</span>(it) != rtxMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> leftIdx = it-&gt;first, leftHeight = it-&gt;second;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> rightIdx = <span class="built_in">next</span>(it)-&gt;first, rightHeight = <span class="built_in">next</span>(it)-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (leftIdx + <span class="number">1</span> == rightIdx) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; leftIdx &lt;&lt; &quot;, &quot; &lt;&lt; leftHeight &lt;&lt; &quot;, &quot; &lt;&lt; rightIdx &lt;&lt; &quot;, &quot; &lt;&lt; rightHeight &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> lo = <span class="built_in">min</span>(leftHeight, rightHeight), hi = <span class="built_in">min</span>(leftHeight + rightIdx - leftIdx, rightHeight + rightIdx - leftIdx);</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">bool</span> deter = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (mid - leftHeight &lt; rightIdx - leftIdx <span class="keyword">and</span> mid - rightHeight &lt; rightIdx - leftIdx <span class="keyword">and</span> mid - leftHeight + mid - rightHeight - <span class="number">1</span> &lt; rightIdx - leftIdx) deter = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (deter) &#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// t, t, t, f, f</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, lo - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>m = restrictions.length</code><br>时间复杂度: O(m log m),<br>空间复杂度: O(m).</p>
<p><a href="https://leetcode-cn.com/problems/maximum-building-height/solution/zui-gao-jian-zhu-gao-du-by-leetcode-solu-axbb/910208">零神题解</a>里有2次扫描的算法。虽然时间复杂度是一样的，但实现比较简单，常数上会更好些。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 239</title>
    <url>/2021/05/02/LeetCode-weekly-contest-239/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>78 / 10870</td>
<td>YoungForest</td>
<td>18</td>
<td>0:52:57</td>
<td>0:02:22</td>
<td>0:09:37</td>
<td>0:27:13</td>
<td>0:47:57  1</td>
</tr>
</tbody></table>
<p>连续3周免打卡了，昨晚双周赛也做的不错手速场。<br>最近的周赛确实难度有所降低，看来我还是适合做简单题目。Hard+还是不大行。</p>
<span id="more"></span>

<h2 id="1848-Minimum-Distance-to-the-Target-Element"><a href="#1848-Minimum-Distance-to-the-Target-Element" class="headerlink" title="1848. Minimum Distance to the Target Element"></a>1848. Minimum Distance to the Target Element</h2><p>签到题。<br>One pass，记录最优答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinDistance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = -INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(i - start) &lt; <span class="built_in">abs</span>(ans - start)) &#123;</span><br><span class="line">                    ans = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(ans - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1849-Splitting-a-String-Into-Descending-Consecutive-Values"><a href="#1849-Splitting-a-String-Into-Descending-Consecutive-Values" class="headerlink" title="1849. Splitting a String Into Descending Consecutive Values"></a>1849. Splitting a String Into Descending Consecutive Values</h2><p>Backtracking, 搜索可能的分割点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i: <span class="built_in">int</span>, last: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= n: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                final = <span class="built_in">int</span>(s[i:])</span><br><span class="line">                <span class="keyword">if</span> final &lt; last <span class="keyword">and</span> last - final == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                new = <span class="built_in">int</span>(s[i:j])</span><br><span class="line">                <span class="keyword">if</span> new &lt; last <span class="keyword">and</span> (i == <span class="number">0</span> <span class="keyword">or</span> last - new == <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> dfs(j, new): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N^2),<br>空间复杂度: O(N).</p>
<p>虽然我们使用了backtracking，看起来好想时间复杂度很高，O(N ^ N), 但其实在<code>dfs</code>中的<code>for</code>循环中，符合条件可以<code>dfs</code>到下一层的可能路径只有1条。<br>参考<a href="https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/discuss/1186795/C%2B%2B-Backtracking-solution.-O(N-2)-and-time-complexity-analytics">这个题解的分析</a>.</p>
<h2 id="1850-Minimum-Adjacent-Swaps-to-Reach-the-Kth-Smallest-Number"><a href="#1850-Minimum-Adjacent-Swaps-to-Reach-the-Kth-Smallest-Number" class="headerlink" title="1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number"></a>1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number</h2><p>首先，我们需要复习一下<a href="https://leetcode.com/problems/next-permutation/">LC 31. Next Permutation</a>. 学习一下求解下一个枚举排列的方法。幸运的是，C++ STL 里已经提供了<code>std::next_permutation</code>函数可以直接用，均摊时间复杂度为<strong>O(1)</strong>.<br>使用<code>k</code>次<code>next_permutation</code>找到the Kth Smallest Number<br>后，只需要采用贪心的思路就可以找到最小交换次数。<br>即发现一个不相等的位置，就在后面找到一个最近的相等的数，通过交换挪的当前位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinSwaps</span><span class="params">(string num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> s = num;</span><br><span class="line">        <span class="keyword">while</span>(std::<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()) &amp;&amp; k - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; s &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] == s[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// find next digit and swap it here</span></span><br><span class="line">            <span class="keyword">int</span> i = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n <span class="keyword">and</span> num[i] != s[j]; ++i);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">            ans += i - j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i; x &gt; j; --x) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(num[x], num[x - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(k + n^2),<br>空间复杂度: O(n).</p>
<h2 id="1851-Minimum-Interval-to-Include-Each-Query"><a href="#1851-Minimum-Interval-to-Include-Each-Query" class="headerlink" title="1851. Minimum Interval to Include Each Query"></a>1851. Minimum Interval to Include Each Query</h2><p>本题和<a href="https://youngforest.github.io/2021/05/02/LeetCode-biweekly-contest-51/#1847-Closest-Room">昨晚双周赛的最后一题</a>有些像，需要用到离线计算的技术。<br>intervals按照size从小到大排序，没新增一个interval，更新可以覆盖到的query的答案。<br>这里需要用<code>multimap</code>维护待解决的<code>queries</code>。因为支持二分查找和删除，以及重复的query.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minInterval</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="keyword">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// brute-foce: queries.length * intervals.length</span></span><br><span class="line">        <span class="comment">// smarter: queries.length * log + intervals.length * log</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>(), m = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// sort interval by size less&lt;&gt;, find new queries</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        multimap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indexQueries;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            indexQueries.<span class="built_in">insert</span>(&#123;queries[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lhs, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; rhs) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs[<span class="number">1</span>] - lhs[<span class="number">0</span>] &lt; rhs[<span class="number">1</span>] - rhs[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : intervals) &#123;</span><br><span class="line">            size = v[<span class="number">1</span>] - v[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">auto</span> left = indexQueries.<span class="built_in">lower_bound</span>(v[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">auto</span> right = indexQueries.<span class="built_in">upper_bound</span>(v[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = left; it != right; ++it) &#123;</span><br><span class="line">                ans[it-&gt;second] = size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = left; it != right;) &#123;</span><br><span class="line">                <span class="keyword">auto</span> nit = <span class="built_in">next</span>(it);</span><br><span class="line">                indexQueries.<span class="built_in">erase</span>(it);</span><br><span class="line">                it = nit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>n = intervals.length, m = queries.length<br>时间复杂度: O(n log n + m log m + n log m),<br>空间复杂度: O(m).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 240</title>
    <url>/2021/05/09/LeetCode-weekly-contest-240/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>272 / 11577</td>
<td>YoungForest</td>
<td>18</td>
<td>1:15:29</td>
<td>0:04:46</td>
<td>0:14:19</td>
<td>0:47:06</td>
<td>1:10:29  1</td>
</tr>
</tbody></table>
<p>这周五一假期+大论文查重。心情被大论文折麽的十分焦虑，再坚持2周，挺过答辩就好了。<br>等过了答辩，让我干啥都行。</p>
<p>前几周因为国服自己的rating太高，不敢打了，怕掉分。转战了美服，现在把美服也打到2350了。rating也过高了。之后打算再次转战国服，因为最近新一年的招聘迫近，国服赞助商礼物比较丰厚。虽然去年只有几次排名足够靠前，拿到奖品，但好歹有个奖励，有比较小的期望。</p>
<span id="more"></span>

<h2 id="1854-Maximum-Population-Year"><a href="#1854-Maximum-Population-Year" class="headerlink" title="1854. Maximum Population Year"></a>1854. Maximum Population Year</h2><p>签到题。暴力枚举每个可能的年份。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumPopulation</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : logs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = v[<span class="number">0</span>]; i &lt; v[<span class="number">1</span>]; ++i) &#123;</span><br><span class="line">                ++cnt[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxYear = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second &gt; maxValue) &#123;</span><br><span class="line">                maxYear = p.first;</span><br><span class="line">                maxValue = p.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxYear;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(logs.length * MAX(death_i - birth_i)) = O(100 * 100),<br>空间复杂度: O(MAX(death_i - birth_i)).</p>
<h2 id="1855-Maximum-Distance-Between-a-Pair-of-Values"><a href="#1855-Maximum-Distance-Between-a-Pair-of-Values" class="headerlink" title="1855. Maximum Distance Between a Pair of Values"></a>1855. Maximum Distance Between a Pair of Values</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(nums2.<span class="built_in">begin</span>() + i, nums2.<span class="built_in">end</span>(), nums1[i], greater&lt;&gt;());</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">distance</span>(nums2.<span class="built_in">begin</span>() + i, <span class="built_in">prev</span>(it))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(nums1.length * log nums2.length),<br>空间复杂度: O(1).</p>
<p>本题也可以用双指针做，i 指向nums1的位置，j 指向nums2的位置。<br>向右遍历 i，更新j。不变量是 j &gt;= i &amp;&amp; nums[j] &lt; nums[i].<br>时间复杂度是 O(nums1.length + nums2.length).<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; nums2.<span class="built_in">size</span>() &amp;&amp; (j &lt; i || nums2[j] &gt;= nums1[i])) ++j;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, j - <span class="number">1</span> - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1856-Maximum-Subarray-Min-Product"><a href="#1856-Maximum-Subarray-Min-Product" class="headerlink" title="1856. Maximum Subarray Min-Product"></a>1856. Maximum Subarray Min-Product</h2><p>类似BFS，从数值大的元素开始遍历，尝试合并左右区间。<br>具体实现需要 维护区间左右边界、最小值、区间和。可以采用类似并查集的思路。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumMinProduct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// iterate from max to min</span></span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">s</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">minV</span><span class="params">(n, INF)</span></span>;</span><br><span class="line">        multimap&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, greater&lt;&gt;&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            index.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">            minV[i] = nums[i];</span><br><span class="line">            left[i] = i;</span><br><span class="line">            right[i] = i;</span><br><span class="line">            s[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : index) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> i = p.second;</span><br><span class="line">            <span class="keyword">const</span> ll minValue = p.first;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; minV[i<span class="number">-1</span>] &gt;= minValue) &#123;</span><br><span class="line">                left[i] = left[i<span class="number">-1</span>];</span><br><span class="line">                s[i] += s[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; minV[i+<span class="number">1</span>] &gt; minValue) &#123;</span><br><span class="line">                right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">                s[i] += s[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            minV[right[i]] = minValue;</span><br><span class="line">            minV[left[i]] = minValue;</span><br><span class="line">            right[left[i]] = right[i];</span><br><span class="line">            left[right[i]] = left[i];</span><br><span class="line">            s[left[i]] = s[i];</span><br><span class="line">            s[right[i]] = s[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, s[i] * minValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n * log n),<br>空间复杂度: O(n).</p>
<p>赛后经残酷群友讨论，<br>类似的题目有：<br><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LC 84. Largest Rectangle in Histogram</a>. 区别在于 84 是 最小值*子数组长度。本题是 最小值*子数组和。</p>
<h2 id="1857-Largest-Color-Value-in-a-Directed-Graph"><a href="#1857-Largest-Color-Value-in-a-Directed-Graph" class="headerlink" title="1857. Largest Color Value in a Directed Graph"></a>1857. Largest Color Value in a Directed Graph</h2><p>拓扑排序。同时 遍历到每一个节点时，更新能到它的路径中每种颜色最大的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestPathValue</span>(<span class="params">self, colors: <span class="built_in">str</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(colors)</span><br><span class="line">        m = <span class="built_in">len</span>(edges)</span><br><span class="line">        indegree = [<span class="number">0</span>] * n</span><br><span class="line">        graph = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edges:</span><br><span class="line">            indegree[e[<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">            graph[e[<span class="number">0</span>]].append(e[<span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># topo sort</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            ans = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">            ans[<span class="built_in">ord</span>(colors[root]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> graph[root]:</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">in</span> path: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                x = dfs(n, path)</span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                    ans[i] += x[i]</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        seen = <span class="number">0</span></span><br><span class="line">        cnt = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> indegree[i] == <span class="number">0</span>:</span><br><span class="line">                cnt[i][<span class="built_in">ord</span>(colors[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">                q.append(i)</span><br><span class="line">                seen += <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(cnt[i]))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            front = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[front]:</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                    cnt[i][x] = <span class="built_in">max</span>(cnt[i][x], cnt[front][x])</span><br><span class="line">                indegree[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indegree[i] == <span class="number">0</span>:</span><br><span class="line">                    q.append(i)</span><br><span class="line">                    cnt[i][<span class="built_in">ord</span>(colors[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(cnt[i]))</span><br><span class="line">                    seen += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> seen == n: <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n + m),<br>空间复杂度: O(n + m).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 241</title>
    <url>/2021/05/16/LeetCode-weekly-contest-241/</url>
    <content><![CDATA[<p>本周周赛和双周赛都翻车了，开始残酷打卡之旅。</p>
<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>717 / 11572</td>
<td>YoungForest</td>
<td>12</td>
<td>0:23:51</td>
<td>0:05:35</td>
<td>0:17:33</td>
<td>0:23:51</td>
<td>null</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="1863-Sum-of-All-Subset-XOR-Totals"><a href="#1863-Sum-of-All-Subset-XOR-Totals" class="headerlink" title="1863. Sum of All Subset XOR Totals"></a>1863. Sum of All Subset XOR Totals</h2><p>签到题。暴力回溯，枚举所有的子集。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subsetXORSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span>)&gt; backtracking = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> current) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ans += current;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// use this</span></span><br><span class="line">                <span class="built_in">backtracking</span>(i + <span class="number">1</span>, current ^ nums[i]);</span><br><span class="line">                <span class="comment">// not use this</span></span><br><span class="line">                <span class="built_in">backtracking</span>(i + <span class="number">1</span>, current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">backtracking</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(2^n),<br>空间复杂度: O(n).</p>
<h2 id="1864-Minimum-Number-of-Swaps-to-Make-the-Binary-String-Alternating"><a href="#1864-Minimum-Number-of-Swaps-to-Make-the-Binary-String-Alternating" class="headerlink" title="1864. Minimum Number of Swaps to Make the Binary String Alternating"></a>1864. Minimum Number of Swaps to Make the Binary String Alternating</h2><p>首先统计’0/1’的数目，看是否可以形成交替。<br>再尝试2种交替方式，1在前/0在前。<br>重点在于只需要关心不符合的数量即可，不需要考虑具体怎么交换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++cnt[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(cnt[<span class="number">0</span>] - cnt[<span class="number">1</span>]) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> first : <span class="string">&quot;01&quot;</span>s) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">at</span>(first - <span class="string">&#x27;0&#x27;</span>) + <span class="number">1</span> == cnt.<span class="built_in">at</span>(<span class="string">&#x27;1&#x27;</span> - first)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != first) &#123;</span><br><span class="line">                    ++current;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(s.length),<br>空间复杂度: O(1).</p>
<p>需要注意的是, </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> first : <span class="string">&quot;01&quot;</span>s)</span><br></pre></td></tr></table></figure>
<p>一定不能写成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> first : <span class="string">&quot;01&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>因为前者是 字符串常量（string literal），后者是C语言里的静态字符串，会有<code>\n</code>结尾的。</p>
<h2 id="1865-Finding-Pairs-With-a-Certain-Sum"><a href="#1865-Finding-Pairs-With-a-Certain-Sum" class="headerlink" title="1865. Finding Pairs With a Certain Sum"></a>1865. Finding Pairs With a Certain Sum</h2><p>首先观察数据规模，发现<code>nums1.length</code>小，但<code>nums2.length</code>大。考虑对小的做遍历，大的<code>hash</code>优化。<br>使用一个反向hashtable记录<code>nums2</code> 值-&gt;index 的映射。</p>
<p>时间复杂度:</p>
<ul>
<li>构造: O(nums2.length),</li>
<li>add: O(1),</li>
<li>count: O(nums1.length).<br>空间复杂度: O(nums2.length).</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindSumPairs</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums1, nums2;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, unordered_set&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FindSumPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; _nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; _nums2): <span class="built_in">nums1</span>(<span class="built_in">move</span>(_nums1)), <span class="built_in">nums2</span>(<span class="built_in">move</span>(_nums2)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            m[nums2[i]].<span class="built_in">insert</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(1)</span></span><br><span class="line">        m[nums2[index]].<span class="built_in">erase</span>(index);</span><br><span class="line">        nums2[index] += val;</span><br><span class="line">        m[nums2[index]].<span class="built_in">insert</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(nums1.length)</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(tot - i);</span><br><span class="line">            <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans += it-&gt;second.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindSumPairs object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindSumPairs* obj = new FindSumPairs(nums1, nums2);</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;count(tot);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="1866-Number-of-Ways-to-Rearrange-Sticks-With-K-Sticks-Visible"><a href="#1866-Number-of-Ways-to-Rearrange-Sticks-With-K-Sticks-Visible" class="headerlink" title="1866. Number of Ways to Rearrange Sticks With K Sticks Visible"></a>1866. Number of Ways to Rearrange Sticks With K Sticks Visible</h2><p>本题我只想到了N^3的解法。<br>使用动态规划，状态转移方程为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>, i):</span><br><span class="line">    ans = (ans + dp(j, k - <span class="number">1</span>) * f2(i-<span class="number">1</span>, j)) % MOD</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>即从高向低考虑，因为最高的一定可以被看见。枚举第i个木棍放的位置，剩下i-1个木棍需要抽一些放在i之后，之后的是一个枚举数。<br>从时间复杂度上一定会超时，事实上果然如此，尽管我试图尽力从常数上优化。<br>下面给出我最后超时的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"><span class="meta">@cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> (i * f(i - <span class="number">1</span>)) % MOD</span><br><span class="line"><span class="meta">@cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a == b: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> (a * f2(a - <span class="number">1</span>, b)) % MOD</span><br><span class="line"><span class="meta">@cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    <span class="comment"># [1:i], see k woods</span></span><br><span class="line">    <span class="comment"># print(i, k)</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; k: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> i == k: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> k == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># put i first and other after</span></span><br><span class="line">        <span class="keyword">return</span> f(i - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>, i):</span><br><span class="line">            <span class="comment"># put i first and [j+1, i-1] after</span></span><br><span class="line">            <span class="comment"># pick num woods before</span></span><br><span class="line">            <span class="comment"># num = i - 1 - (j + 1) + 1</span></span><br><span class="line">            <span class="comment"># C_i^num * num!</span></span><br><span class="line">            <span class="comment"># C(n,m)=n!/((n-m)!*m!)（m≤n）</span></span><br><span class="line">            <span class="comment"># print(&#x27;add&#x27;, dp(j, k - 1), (factorial(i) // factorial(i - num)))</span></span><br><span class="line">            ans = (ans + dp(j, k - <span class="number">1</span>) * f2(i-<span class="number">1</span>, j)) % MOD</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rearrangeSticks</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> dp(n, k)</span><br></pre></td></tr></table></figure>

<p>我参考了一些题解，确实是递推公式有问题。<br>其实从不同的角度都可以得到这个公式。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/solution/qia-you-k-gen-mu-gun-ke-yi-kan-dao-de-pa-0c3g/">能不能看到最后一根木棍</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/solution/zhuan-huan-cheng-di-yi-lei-si-te-lin-shu-2y1k/">第一类斯特林数</a></li>
</ul>
<p>小修我TLE的代码就OK了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rearrangeSticks</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">            <span class="comment"># [1:i], see k woods</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; k: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> i == k: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> k == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># last wood can be seen, it must be `i`. dp(i-1, k - 1)</span></span><br><span class="line">                <span class="comment"># last wood can not be seen, (i - 1) * dp(i - 1, k)</span></span><br><span class="line">                <span class="keyword">return</span> (dp(i-<span class="number">1</span>, k - <span class="number">1</span>) + (i - <span class="number">1</span>) * dp(i - <span class="number">1</span>, k)) % MOD</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp(n, k)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 242</title>
    <url>/2021/05/23/LeetCode-weekly-contest-242/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>165 / 12400</td>
<td>YoungForest</td>
<td>18</td>
<td>1:07:14</td>
<td>0:03:22 🐞1</td>
<td>0:16:01 🐞1</td>
<td>0:27:41  🐞1</td>
<td>0:52:14</td>
</tr>
</tbody></table>
<p>提前40min AK。虽然因为粗心大意，前三题每题WA一次，导致15min罚时，但好的一点是这周应该不用每天残酷打卡了。正好全力以赴，准备周三的硕士论文答辩。<br>三年的硕士生涯全靠周三一天了，毕其功于一役，加油，Forest！</p>
<h2 id="1869-Longer-Contiguous-Segments-of-Ones-than-Zeros"><a href="#1869-Longer-Contiguous-Segments-of-Ones-than-Zeros" class="headerlink" title="1869. Longer Contiguous Segments of Ones than Zeros"></a>1869. Longer Contiguous Segments of Ones than Zeros</h2><p>签到题。统计连续字串的长度，更新最长长度即可。</p>
<p>因为更新最长长度的代码写错位置，写到了if的分支里，WA了一次。应该无论如何都要更新，所以要写在外面。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkZeroOnes</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">longest</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> last = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != last) &#123;</span><br><span class="line">                last = c;</span><br><span class="line">                length = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++length;</span><br><span class="line">            &#125;</span><br><span class="line">            longest[c - <span class="string">&#x27;0&#x27;</span>] = <span class="built_in">max</span>(longest[c - <span class="string">&#x27;0&#x27;</span>], length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest[<span class="number">1</span>] &gt; longest[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1870-Minimum-Speed-to-Arrive-on-Time"><a href="#1870-Minimum-Speed-to-Arrive-on-Time" class="headerlink" title="1870. Minimum Speed to Arrive on Time"></a>1870. Minimum Speed to Arrive on Time</h2><p>直接暴力二分怼。之前总结的binary search模版很好用。基本只需要改几行代码就行了。</p>
<p>因为浮点数精度WA了一次。<code>10^-5</code> 不够小，建议以后都用<code>10^-9</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSpeedOnTime</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; dist, <span class="keyword">double</span> hour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">1e7</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// f f f t t t</span></span><br><span class="line">        <span class="keyword">auto</span> binary = [&amp;](ll lo, ll hi, function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">const</span> ll)&gt; predicate) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="comment">// return first true</span></span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                ll mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">predicate</span>(mid)) &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lo;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> pred = [&amp;](<span class="keyword">const</span> ll x) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">1</span> &lt; dist.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                ans += (dist[i] + x - <span class="number">1</span>) / x;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += dist[i] / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> ans &lt;= hour + <span class="number">1e-9</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        ll ans = <span class="built_in">binary</span>(lo, hi, pred);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= hi) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log dist[i] * dist.length) = log 10^5 * 10^5,<br>空间复杂度: O(1).</p>
<h2 id="1871-Jump-Game-VII"><a href="#1871-Jump-Game-VII" class="headerlink" title="1871. Jump Game VII"></a>1871. Jump Game VII</h2><p>很容易想到暴力的N^2解法。<br>从头开始遍历，如果是0的话，更新之后所有可以到达的位置。<br>时间复杂度为: s.length * (maxJump - minJump) = 10% * 10^5.</p>
<p>优化的方向是“更新之后所有可以到达的位置”。显然，这步更新因为有很多重复的更新，因此花费很多。但是，我们考虑每次其实是更新一个区间（range），而且区间的大小相等，而且区间总是向右移动的。因此，我们发现，更新区间并不需要遍历minJump…maxJump，只需要从maxJump向前开始遍历，如果和之前已经更新过的区间重合了，就直接break结束更新就好了。因为每个位置最多被更新一次，因此时间复杂度是 s.length.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canReach</span><span class="params">(string s, <span class="keyword">int</span> minJump, <span class="keyword">int</span> maxJump)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// brute-force: s.length * (maxJump - minJump) = 10^5 * 10^5</span></span><br><span class="line">        <span class="comment">// better: s.length * 1</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">reachable</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        reachable[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// &lt;= reach</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reachable[i]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">min</span>(maxJump, n - <span class="number">1</span> - i); j &gt;= minJump; --j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (reachable[i + j]) <span class="keyword">break</span>;</span><br><span class="line">                        reachable[i + j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[n<span class="number">-1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; reachable[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(s.length),<br>空间复杂度: O(s.length).</p>
<h2 id="1872-Stone-Game-VIII"><a href="#1872-Stone-Game-VIII" class="headerlink" title="1872. Stone Game VIII"></a>1872. Stone Game VIII</h2><p>类似之前的Stone Game，这种最优玩法的题目大多数属于 动态规划问题。<br>即通过搜索所有可能的选择，找到最优结果。过程中有很多重复子问题，因此需要使用动态规划。</p>
<p>最优化目标是(Alice’s score - Bob’s score)，Alice想要最大化，Bob想要最小化。其实都是最大化（我的分数 - 对方的分数）。<br>另外，观察到操作的结果其实是石头的和，因此需要提前计算前缀和数组。<br>问题转化成，从前缀和[i:]中挑一个数，使得的分数差最大；之后的后手只能从被挑的位置之后挑。<br>定义<br>dp(i) 为从前缀和[i:]中挑一个数的最大分数差，<br>则状态转移方程为：<br>dp(i) = max(presum[j] + dp(j + 1) for j in range(i,)).<br>时间复杂度为 O(N^2), 显然超时。</p>
<p>然而，在状态转移方程中其实还有重叠子问题, for loop max可以只计算一次，因此可以进一步优化到 O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameVIII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// presum</span></span><br><span class="line">        <span class="comment">// i = 0</span></span><br><span class="line">        <span class="comment">// pick i, ..., n - 1</span></span><br><span class="line">        <span class="comment">// time: n ^ 2</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">presum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        presum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            presum[i+<span class="number">1</span>] = presum[i] + stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxDp = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; --i) &#123; <span class="comment">// 这里需要注意结束条件，因为第一次挑选不能不合并或只合并第一个，因此presum[0],presum[1]是没用的。</span></span><br><span class="line">            maxDp = <span class="built_in">max</span>(maxDp, presum[i] - dp[i + <span class="number">1</span>]);</span><br><span class="line">            dp[i] = maxDp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 243</title>
    <url>/2021/05/30/LeetCode-weekly-contest-243/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>95 / 12835</td>
<td>YoungForest</td>
<td>18</td>
<td>1:19:18</td>
<td>0:02:50</td>
<td>0:11:21</td>
<td>0:36:27  🐞1</td>
<td>1:04:18 🐞2</td>
</tr>
</tbody></table>
<p>零神大数据：<br>1880,Check if Word Equals Summation of Two Words,check-if-word-equals-summation-of-two-words,1187.1641565458<br>1881,Maximum Value after Insertion,maximum-value-after-insertion,1381.2168789318<br>1882,Process Tasks Using Servers,process-tasks-using-servers,1979.1112273597<br>1883,Minimum Skips to Arrive at Meeting On Time,minimum-skips-to-arrive-at-meeting-on-time,2587.8725248485</p>
<span id="more"></span>

<h2 id="1880-Check-if-Word-Equals-Summation-of-Two-Words"><a href="#1880-Check-if-Word-Equals-Summation-of-Two-Words" class="headerlink" title="1880. Check if Word Equals Summation of Two Words"></a>1880. Check if Word Equals Summation of Two Words</h2><p>签到题。按题目要求转换字符串到数字，再进行判断。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSumEqual</span>(<span class="params">self, firstWord: <span class="built_in">str</span>, secondWord: <span class="built_in">str</span>, targetWord: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">toDigit</span>(<span class="params">w</span>):</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> w:</span><br><span class="line">                ans = ans * <span class="number">10</span> + <span class="built_in">ord</span>(i) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> toDigit(firstWord) + toDigit(secondWord) == toDigit(targetWord)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="1881-Maximum-Value-after-Insertion"><a href="#1881-Maximum-Value-after-Insertion" class="headerlink" title="1881. Maximum Value after Insertion"></a>1881. Maximum Value after Insertion</h2><p>贪心。正数时插入到第一个比x小的数，负数时插入到第一个比x大的数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxValue</span>(<span class="params">self, n: <span class="built_in">str</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        <span class="comment"># insert into the position where the first digit &lt; x</span></span><br><span class="line">        <span class="comment"># negative first &gt; x</span></span><br><span class="line">        <span class="keyword">if</span> n[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(n)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(n[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) &gt; x:</span><br><span class="line">                    <span class="keyword">return</span> n[:i] + <span class="built_in">str</span>(x) + n[i:]</span><br><span class="line">            <span class="keyword">return</span> n + <span class="built_in">str</span>(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(n)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">ord</span>(n[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) &lt; x:</span><br><span class="line">                    <span class="keyword">return</span> n[:i] + <span class="built_in">str</span>(x) + n[i:]</span><br><span class="line">            <span class="keyword">return</span> n + <span class="built_in">str</span>(x)</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="1882-Process-Tasks-Using-Servers"><a href="#1882-Process-Tasks-Using-Servers" class="headerlink" title="1882. Process Tasks Using Servers"></a>1882. Process Tasks Using Servers</h2><p>直接暴力模拟即可。使用优先队列维护空闲服务器，等待任务和释放时间。<br>模拟时需要注意时间不能1单位1单位地进行，而是只进行那些有事件发生的时刻。<br>即任务开始等待，服务器释放。<br>需要注意时间的大小可能会超过<code>int</code>, 用<code>long long</code>更保险些。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">assignTasks</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; servers, vector&lt;<span class="keyword">int</span>&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// brute-force: (m + n) * log n</span></span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; freeServers, releaseTime;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; servers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            freeServers.<span class="built_in">emplace</span>(servers[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;&gt;&gt; waitTasks;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = tasks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            waitTasks.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">while</span> (!releaseTime.<span class="built_in">empty</span>() &amp;&amp; releaseTime.<span class="built_in">top</span>().first &lt;= i) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> idx = releaseTime.<span class="built_in">top</span>().second;</span><br><span class="line">                freeServers.<span class="built_in">emplace</span>(servers[idx], idx);</span><br><span class="line">                releaseTime.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!freeServers.<span class="built_in">empty</span>() &amp;&amp; !waitTasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> idx = waitTasks.<span class="built_in">top</span>();</span><br><span class="line">                waitTasks.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">auto</span> [weight, serverIdx] = freeServers.<span class="built_in">top</span>();</span><br><span class="line">                freeServers.<span class="built_in">pop</span>();</span><br><span class="line">                ans[idx] = serverIdx;</span><br><span class="line">                releaseTime.<span class="built_in">emplace</span>(i + tasks[idx], serverIdx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll current = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!releaseTime.<span class="built_in">empty</span>() &amp;&amp; !waitTasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> idx = releaseTime.<span class="built_in">top</span>().second;</span><br><span class="line">            current = releaseTime.<span class="built_in">top</span>().first;</span><br><span class="line">            freeServers.<span class="built_in">emplace</span>(servers[idx], idx);</span><br><span class="line">            releaseTime.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span> (!releaseTime.<span class="built_in">empty</span>() &amp;&amp; releaseTime.<span class="built_in">top</span>().first &lt;= current) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> idx = releaseTime.<span class="built_in">top</span>().second;</span><br><span class="line">                current = releaseTime.<span class="built_in">top</span>().first;</span><br><span class="line">                freeServers.<span class="built_in">emplace</span>(servers[idx], idx);</span><br><span class="line">                releaseTime.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!freeServers.<span class="built_in">empty</span>() &amp;&amp; !waitTasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> idx = waitTasks.<span class="built_in">top</span>();</span><br><span class="line">                waitTasks.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">auto</span> [weight, serverIdx] = freeServers.<span class="built_in">top</span>();</span><br><span class="line">                freeServers.<span class="built_in">pop</span>();</span><br><span class="line">                ans[idx] = serverIdx;</span><br><span class="line">                releaseTime.<span class="built_in">emplace</span>(current + tasks[idx], serverIdx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O((m + n) * log n),<br>空间复杂度: O(m + n).</p>
<h2 id="1883-Minimum-Skips-to-Arrive-at-Meeting-On-Time"><a href="#1883-Minimum-Skips-to-Arrive-at-Meeting-On-Time" class="headerlink" title="1883. Minimum Skips to Arrive at Meeting On Time"></a>1883. Minimum Skips to Arrive at Meeting On Time</h2><p>动态规划。<br>dp(i, k)表示，从dist0到i（inclusive），k次休息，结束的最早时间。<br>状态转移方程为<br>dp(i, k) = min(<br>    dp(i-1, k) + .. 最后一站不休息<br>    dp(i-1, k-1) + .. 最后一站休息<br>)，<br>然后使用二分搜索找到最小的k使得 dp(n-1, k) &lt;= hoursBefore.<br>（其实不用二分也行，从小到大遍历寻找也行。因为时间复杂度瓶颈不在这里，而在计算dp那里）。</p>
<p>最近经常遇到动态规划的题目，之前在找状态转移方程时，时间复杂度总是超。试图利用枚举最后一个休息位置发生在何处。正确的做法应该是，只枚举最后一站是否休息。可以将时间复杂度降一个n.</p>
<p>本题有个坑是浮点数精度，我因此WA了2次。<br>解决方法有二:</p>
<ol>
<li>增加err, 我这里用了10^-9, 在大多数情况下都是够了。</li>
<li>转换成整型。可能需要用<code>long long</code>。在本题中就是把所有的 时间 * speed 用来表示距离，这种解决方案不存在精度丢失。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSkips</span>(<span class="params">self, dist: <span class="type">List</span>[<span class="built_in">int</span>], speed: <span class="built_in">int</span>, hoursBefore: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(dist)</span><br><span class="line">        err = <span class="number">10</span>**-<span class="number">9</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">i, k</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> dist[<span class="number">0</span>] / speed</span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># no relax</span></span><br><span class="line">                <span class="keyword">return</span> ceil(dp(i-<span class="number">1</span>, <span class="number">0</span>) - err) + dist[i] / speed</span><br><span class="line">            <span class="keyword">if</span> i == k:</span><br><span class="line">                <span class="comment"># relax all</span></span><br><span class="line">                <span class="keyword">return</span> dp(i-<span class="number">1</span>, k-<span class="number">1</span>) + dist[i] / speed</span><br><span class="line">            <span class="comment"># not relax + relax</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(ceil(dp(i-<span class="number">1</span>, k) - err) + dist[i] / speed, dp(i-<span class="number">1</span>, k-<span class="number">1</span>) + dist[i] / speed)</span><br><span class="line">                       </span><br><span class="line">        lo = <span class="number">0</span></span><br><span class="line">        hi = n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dp(n-<span class="number">1</span>, n-<span class="number">1</span>) &gt; hoursBefore + err: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> dp(n-<span class="number">1</span>, mid) &lt;= hoursBefore + err: <span class="comment"># -err?</span></span><br><span class="line">                hi = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> lo == n: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> lo</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n ^ 2),<br>空间复杂度: O(m ^ 2).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 244</title>
    <url>/2021/06/06/LeetCode-weekly-contest-244/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>142 / 14467</td>
<td>YoungForest</td>
<td>18</td>
<td>0:51:13</td>
<td>0:05:21</td>
<td>0:09:54</td>
<td>0:30:19</td>
<td>0:46:13 🐞1</td>
</tr>
</tbody></table>
<p>下午约了 <a href="http://leetcode.com/ddoudle">残酷东神</a> 吃饭，一个rating 2700+的大佬。他本科浙大，在加拿大读研。这个暑假来北京旷视实习。因此我们有机会线下面基。</p>
<span id="more"></span>

<h2 id="1886-Determine-Whether-Matrix-Can-Be-Obtained-By-Rotation"><a href="#1886-Determine-Whether-Matrix-Can-Be-Obtained-By-Rotation" class="headerlink" title="1886. Determine Whether Matrix Can Be Obtained By Rotation"></a>1886. Determine Whether Matrix Can Be Obtained By Rotation</h2><p>签到题。旋转3次 加上 原始 共4种状态，分别比较。旋转的话就是另外的一个LeetCode经典题目了，in-place还是实现起来比较复杂的。但因为n比较小，而且是签到题，我直接用了辅助数组。虽然时间复杂度上去了，但实现起来简单多了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; cp = mat;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                cp[j][n<span class="number">-1</span>-i] = mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mat = <span class="built_in">move</span>(cp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findRotation</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mat == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">rotate</span>(mat);</span><br><span class="line">            <span class="keyword">if</span> (mat == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(4 * n * n),<br>空间复杂度: O(n * n).</p>
<h2 id="1887-Reduction-Operations-to-Make-the-Array-Elements-Equal"><a href="#1887-Reduction-Operations-to-Make-the-Array-Elements-Equal" class="headerlink" title="1887. Reduction Operations to Make the Array Elements Equal"></a>1887. Reduction Operations to Make the Array Elements Equal</h2><p>理解整个减小的过程可以发现，每个数减到最小的操作数目其实等于小于他的元素（去除重复元素）的数目。<br>因此，先排序，再One pass 统计“小于他的元素”数目之和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reductionOperations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                ++add;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>
<h2 id="1888-Minimum-Number-of-Flips-to-Make-the-Binary-String-Alternating"><a href="#1888-Minimum-Number-of-Flips-to-Make-the-Binary-String-Alternating" class="headerlink" title="1888. Minimum Number of Flips to Make the Binary String Alternating"></a>1888. Minimum Number of Flips to Make the Binary String Alternating</h2><p>观察有：<br>操作1的数目不限。也就是说 我们可以遍历所有位置，假设它是开头，枚举开头分别是0/1的2种情况，然后统计之后和之前的不符合预期的数量。<br>统计“之前和之后不符合预期的数量” 这个操作可以通过维护之前/之后 奇偶位置 0/1 的数量 O(1)实现。</p>
<p>因为奇偶问题，“之前不符合预期的数量”需要分开讨论。<br>发现在偶数长度下，开头位置其实是无所谓的。这时可以进一步简化问题。<br>奇数长度下，还是需要枚举每个开头位置才行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                cnt[i % <span class="number">2</span>] += (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> half = n / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(half - cnt[<span class="number">0</span>] + cnt[<span class="number">1</span>], cnt[<span class="number">0</span>] + half - cnt[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">after</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                after[i % <span class="number">2</span>] += (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">before</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">int</span> ans = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> half = n / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> now = i % <span class="number">2</span>;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, half + <span class="number">1</span> - after[now] - before[<span class="number">1</span>-now] + after[<span class="number">1</span>-now] + before[now]); <span class="comment">// 1 begin</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans, after[now] + before[<span class="number">1</span>-now] + half - after[<span class="number">1</span>-now] - before[now]); <span class="comment">// 0 begin</span></span><br><span class="line">                after[i % <span class="number">2</span>] -= (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                before[i % <span class="number">2</span>] += (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>
<h2 id="1889-Minimum-Space-Wasted-From-Packaging"><a href="#1889-Minimum-Space-Wasted-From-Packaging" class="headerlink" title="1889. Minimum Space Wasted From Packaging"></a>1889. Minimum Space Wasted From Packaging</h2><p>本题的暴力解法很容易想：<br>遍历所有的<code>boxes</code>； 对于每一个供应商，再遍历所有的包裹；对于每一个包裹，找到仅大于它的盒子做包装。时间复杂度为：O(m * n * log m). 显然会TLE。</p>
<p>题目中给了数据范围，其中一个值得我们特别关注: <code>sum(boxes[j].length) &lt;= 10^5</code>。<br>也就是说，我们完全可以枚举每一个盒子，找到用它的包裹（可以通过二分搜索，找到它能装的最大包裹的位置。除了比它小的盒子装的，剩下就是它装的。）。然后通过前缀和快速计算空余空间。<br>时间复杂度为：`O(sum(boxes[j].length) * log n + n log n)，恰好符合要求。</p>
<p>因为最大空余空间是<code>max(boxes[i][j]) * packges.length = 10 ^ 10</code>, 因此<code>int</code>会溢出，需要使用<code>long long</code>.</p>
<p>最后，千万不要忘记MOD。我因此WA一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">    <span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minWastedSpace</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; packages, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; boxes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(packages.<span class="built_in">begin</span>(), packages.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = packages.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">presum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        presum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            presum[i+<span class="number">1</span>] = presum[i] + packages[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = numeric_limits&lt;ll&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = boxes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; b : boxes) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> lastIdx = <span class="number">0</span>;</span><br><span class="line">            ll current = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : b) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(packages.<span class="built_in">begin</span>(), packages.<span class="built_in">end</span>(), j);</span><br><span class="line">                <span class="keyword">const</span> ll d = <span class="built_in">distance</span>(packages.<span class="built_in">begin</span>(), it);</span><br><span class="line">                <span class="keyword">const</span> ll width = d - lastIdx;</span><br><span class="line">                current += width * j - (presum[d] - presum[lastIdx]);</span><br><span class="line">                lastIdx = d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.<span class="built_in">back</span>() &lt; packages.<span class="built_in">back</span>()) &#123; <span class="comment">// can not fit</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == numeric_limits&lt;ll&gt;::<span class="built_in">max</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(sum(boxes[j].length) * log n + n log n),<br>空间复杂度: O(n).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 245</title>
    <url>/2021/06/13/LeetCode-weekly-contest-245/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>1904 / 12724</td>
<td>YoungForest</td>
<td>12</td>
<td>1:39:20</td>
<td>0:02:52</td>
<td>1:24:20 🐞 3</td>
<td>0:21:30</td>
<td>null</td>
</tr>
</tbody></table>
<p>零神大数据：<br>1897,Redistribute Characters to Make All Strings Equal,redistribute-characters-to-make-all-strings-equal,1309.1422268153<br>1898,Maximum Number of Removable Characters,maximum-number-of-removable-characters,1912.8440554296<br>1899,Merge Triplets to Form Target Triplet,merge-triplets-to-form-target-triplet,1635.6879273926<br>1900,The Earliest and Latest Rounds Where Players Compete,the-earliest-and-latest-rounds-where-players-compete,2454.7653333657</p>
<p>今天的周赛翻车了。第二题一开始算错时间复杂度了，一直妄图找到更优算法。之后看到80人提交才重新审视二分暴力的时间复杂度，竟然是没问题的。实现过程中又遇到1次WA（判断子序列时，相等字符忘记更新<code>s</code>的下标了），2次TLE（标记remove下标不能用<code>unordered_set</code>, 而要用<code>vector</code>。算是被卡常数了)。这周又要残酷打卡了，幸运的是，因为前2周的成绩比较好，本周残酷榜更新后我的排名不降反升。</p>
<h2 id="1897-Redistribute-Characters-to-Make-All-Strings-Equal"><a href="#1897-Redistribute-Characters-to-Make-All-Strings-Equal" class="headerlink" title="1897. Redistribute Characters to Make All Strings Equal"></a>1897. Redistribute Characters to Make All Strings Equal</h2><p>签到题。本质是判断所有的字符是否可以平均分配到n个单词中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">makeEqual</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">                ++cnt[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % n != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(sum(words[i].length)),<br>空间复杂度: O(1).</p>
<h2 id="1898-Maximum-Number-of-Removable-Characters"><a href="#1898-Maximum-Number-of-Removable-Characters" class="headerlink" title="1898. Maximum Number of Removable Characters"></a>1898. Maximum Number of Removable Characters</h2><p>最优化问题转判定问题（双指针判断是否是子序列），二分搜索。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">int</span>;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; mark = vector&lt;<span class="keyword">bool</span>&gt;(<span class="number">1e5</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumRemovals</span><span class="params">(string s, string p, vector&lt;<span class="keyword">int</span>&gt;&amp; removable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = removable.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> binary = [&amp;](ll lo, ll hi, function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">const</span> ll)&gt; predicate) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                ll mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">predicate</span>(mid)) &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lo;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; s.size() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">binary</span>(<span class="number">0</span>, n + <span class="number">1</span>, [&amp;](<span class="keyword">const</span> ll x) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                mark[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; ++i) &#123;</span><br><span class="line">                mark[removable[i]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pi = <span class="number">0</span>, si = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (pi &lt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">while</span> (si &lt; s.<span class="built_in">size</span>() &amp;&amp; (mark[si] || s[si] != p[pi])) ++si;</span><br><span class="line">                <span class="keyword">if</span> (si == s.<span class="built_in">size</span>()) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot;:false&quot;  &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// if (s[si] != p[pi]) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span></span><br><span class="line">                ++si;</span><br><span class="line">                ++pi;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot;:true &quot;&lt;&lt; si   &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log removable.length * (s.length + p.length)),<br>空间复杂度: O(s.length).</p>
<p>本题有个坑是说，标记<code>s</code>中哪些位置被标记时，不能用<code>unordered_set</code>（即使加<code>reserve</code>)，会超时。可以用<code>vector&lt;bool&gt;</code>。算是被卡常数了。</p>
<h2 id="1899-Merge-Triplets-to-Form-Target-Triplet"><a href="#1899-Merge-Triplets-to-Form-Target-Triplet" class="headerlink" title="1899. Merge Triplets to Form Target Triplet"></a>1899. Merge Triplets to Form Target Triplet</h2><p>因为每次合并操作是去最大值，因此，只要有一个数大于<code>target</code>的<code>triplet</code>不能用。<br>所以把剩下可以用的都合并了，看能不能达到<code>target</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mergeTriplets</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; triplets, vector&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : triplets) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i] == target[i] &amp;&amp; v[(i + <span class="number">1</span>) % <span class="number">3</span>] &lt;= target[(i + <span class="number">1</span>) % <span class="number">3</span>] &amp;&amp; v[(i + <span class="number">2</span>) % <span class="number">3</span>] &lt;= target[(i + <span class="number">2</span>) % <span class="number">3</span>]) &#123;</span><br><span class="line">                    ++cnt[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(triplets.length),<br>空间复杂度: O(1).</p>
<h2 id="1900-The-Earliest-and-Latest-Rounds-Where-Players-Compete"><a href="#1900-The-Earliest-and-Latest-Rounds-Where-Players-Compete" class="headerlink" title="1900. The Earliest and Latest Rounds Where Players Compete"></a>1900. The Earliest and Latest Rounds Where Players Compete</h2><p>TNL~</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Lunch IPython from differnt conda env</title>
    <url>/2017/11/02/Lunch-IPython-from-differnt-conda-env/</url>
    <content><![CDATA[<p><a href="http://ipython.readthedocs.io/en/stable/install/kernel_install.html">reference</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># activate virtual python environment</span></span><br><span class="line">activate python27</span><br><span class="line"></span><br><span class="line"><span class="comment"># install package ipykernel in virtual environment</span></span><br><span class="line">pip install ipykernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># install ipython kernel for virtual environment</span></span><br><span class="line">python -m ipykernel install --user --name py27 --display-name <span class="string">&quot;Python (py27)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lunch jupyter QTConsole with specific kernel</span></span><br><span class="line">jupyter qtconsole --kernel=py27</span><br></pre></td></tr></table></figure>

<h2 id="using-mirror-instead-of-cross-GFW"><a href="#using-mirror-instead-of-cross-GFW" class="headerlink" title="using mirror instead of cross GFW"></a>using mirror instead of cross GFW</h2><p>You have 2 choices to make it work inside GFW.</p>
<ul>
<li>mirror(which I recommend for better speed)</li>
<li>VPN</li>
</ul>
<p><a href="http://mirrors.ustc.edu.cn/help/anaconda.html">mirror site</a></p>
<p><a href="https://mirrors.ustc.edu.cn/anaconda/archive/">Latest install package mirror site</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add package source mirror</span></span><br><span class="line">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>毕设大论文撰写问题汇总及解决</title>
    <url>/2021/05/06/Mendeley-GB-T-7714-2005/</url>
    <content><![CDATA[<h2 id="Mendeley-GB-T-7714-2005"><a href="#Mendeley-GB-T-7714-2005" class="headerlink" title="Mendeley GB/T 7714-2005"></a>Mendeley GB/T 7714-2005</h2><ul>
<li>针对英文文献中作者名字使用了全大写</li>
<li>针对英文文献中三个以上人名省略时使用了中文的“等”，而不是et al.</li>
</ul>
<p><a href="https://blog.csdn.net/yitian_z/article/details/104050142">Solution</a></p>
<p>我配置了自己的参考文献格式，在此分享给大家。特色有：</p>
<ul>
<li>删除参考文献中的 // 。特别是会议后面多出来的这个分隔符</li>
</ul>
<h2 id="引用知网参考文献"><a href="#引用知网参考文献" class="headerlink" title="引用知网参考文献"></a>引用知网参考文献</h2><p>知网上没有Mendeley支持的Bib参考文献格式，因此，我写了一个网站可以在线进行参考文献的转换: <a href="https://cnki2bib.youngforest.me/products">入口1</a> <a href="https://youngforest.me/products">入口2</a></p>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
  </entry>
  <entry>
    <title>米哈游 服务器开发 暑期实习</title>
    <url>/2020/03/20/Mihayo-backend-intern-interview/</url>
    <content><![CDATA[<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>time: 2020-03-20 16:29:48</p>
<p>上周五参加了在牛客网上的笔试。题目不难，分为计算机基础、算法 和 系统设计。<br>计算机基础靠着本科的认真学习，没啥问题。算法也属于LeetCode medium难度，很快AC了。<br>系统设计倒是难倒我了，并不擅长，也没有准备。需要设计一个 MOBA游戏的匹配机制，包括单人和组队。之前完全没想过，瞎写了一通。<br>昨天收到电话，说我通过了笔试，约了今天下午2:30的电话面试。</p>
<p>本科有个可爱的大佬舍友最后去米哈游了。我虽然对游戏不感冒，但本着多面试，多总结的态度，也报名了其春招内推。</p>
<p>面试预计30min, 实际40min。</p>
<p>自我介绍 + 项目经历 + 计算机基础。</p>
<p>计算机基础又分为：</p>
<ul>
<li>C++</li>
<li>操作系统</li>
<li>数据库</li>
<li>计算机网络</li>
<li>设计模式</li>
</ul>
<p>我不会的有：</p>
<ul>
<li>TCP 3次挥手，最后的time_wait的作用</li>
<li>C++ 父类析构函数为什么必需是虚函数</li>
<li>MySQL<ul>
<li>事务 及 ACID</li>
<li>Block 和 Tag 区别</li>
<li>BiLog是什么</li>
<li>timestamp, datetime的区别</li>
</ul>
</li>
<li>说出常用的设计模式，我讲了几个，但面试官好像并不满意</li>
</ul>
<p>没有手撕代码环节，稍微有些失落。</p>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>time: 2020-04-03 12:54:20</p>
<p>之前<a href="https://www.nowcoder.com/discuss/387235">一面的帖子</a>。</p>
<p>二面距离一面过去了整整2周。中间HR还打电话希望我能到上海onsite二面。我只好如实说 学校现在不允许跨省区流动。贵司心也是大。最后还是按计划视频面试。</p>
<p>整场面试持续50min。难度并不大，但由于是游戏公司，所以很多问题和项目是之前没有遇到或想过。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>合并2个有序链表。</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul>
<li>Linux下的项目。我告诉他我大多数全是Linux。</li>
<li>之前大四做的一个游戏（软件工程作业）<a href="https://github.com/xxr5566833/Game">github</a>。</li>
<li>内存泄漏诊断</li>
<li>protobuf</li>
</ul>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul>
<li>如何诊断网络问题？</li>
<li>一致性哈希，增桶、减桶。</li>
<li>单例模式，带模版的单例，多线程下的。这是共享屏幕在本地IDE实现的。</li>
</ul>
<h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1><p>time: 2020-04-08 12:58:36</p>
<p><a href="https://www.nowcoder.com/discuss/387235">一面</a><br><a href="https://www.nowcoder.com/discuss/399642">二面</a></p>
<h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><p>实现智能指针shared_ptr的构造、析构函数。<br>问：为什么count要用指针？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span>&lt;T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    T* data = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span>* count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="keyword">const</span> shared_ptr&amp; a) &#123;</span><br><span class="line">        data = a-&gt;data;</span><br><span class="line">        count = a-&gt;count;</span><br><span class="line">        ++(*count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* t) &#123;</span><br><span class="line">        data = t;</span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">            count = <span class="keyword">new</span> <span class="built_in">uint32_t</span>();</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shared_ptr <span class="keyword">operator</span> = (<span class="keyword">const</span> shared_ptr&amp; a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">this</span>) ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                --(*count);</span><br><span class="line">                <span class="keyword">if</span> (*count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">delete</span> data;</span><br><span class="line">                    <span class="keyword">delete</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            data = a-&gt;data;</span><br><span class="line">            count = a-&gt;count;</span><br><span class="line">            ++(*count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">shared_ptr</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                --(*count);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> data;</span><br><span class="line">                <span class="keyword">delete</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span>&lt;T&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ret</span>(<span class="keyword">new</span> <span class="built_in">T</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><blockquote>
<p>1，7，10 三种面值硬币。<br>给定一个n，最少硬币凑出这个值。</p>
</blockquote>
<p>我刚开始想要贪心，但面试官很快给出反例。</p>
<blockquote>
<p>15</p>
</blockquote>
<p>之后给出一个DP的O(N)的解法，面试官再提示N很大时，有何优化的思路。进而提出先mod最大公倍数，再对余数DP的O(1)解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dp</span>(n) = <span class="built_in">min</span>(</span><br><span class="line">    <span class="built_in">dp</span>(n - <span class="number">1</span>) + <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">dp</span>(n - <span class="number">7</span>) + <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">dp</span>(n - <span class="number">10</span>) + <span class="number">1</span>,</span><br><span class="line">); <span class="keyword">if</span> n &gt;= <span class="number">10</span>;</span><br><span class="line"><span class="number">1</span> * <span class="number">7</span> * <span class="number">10</span> = <span class="number">70</span></span><br><span class="line"><span class="built_in">O</span> (<span class="number">7</span> + <span class="number">1</span>) = <span class="built_in">O</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><p>设计一个百万量级排行榜 ，支持插入，按uid查找分数，按uid查找名次，按名次查找uid.<br>follow up: 分数相同时，按照上榜时间排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">order statisc tree</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(TreeNode* node)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set</span><br><span class="line">multiset</span><br><span class="line"></span><br><span class="line">order_statisc_tree&lt;pair&lt;分数, 时间&gt;，uid&gt;：按名次查uid log N</span><br><span class="line">hashmap&lt;uid, pair&lt;分数,时间&gt;&gt;: 按uid查分数 <span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line">按uid查排名 <span class="built_in">O</span>(log N)</span><br><span class="line">insert: <span class="built_in">O</span>(<span class="number">1</span> + log N)</span><br></pre></td></tr></table></figure>

<h2 id="计算机基础-1"><a href="#计算机基础-1" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>Linux熟不<br>排查线上某进程CPU为100%。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>游戏公司的特别之处。<br>玩过我们公司的游戏吗？（否）那平时玩什么游戏。</p>
<p>最后面试官问我能不能毕业前提前来实习。我说不能，没发去上海。</p>
<p>问题：贵司服务器开发内部分组情况。不同产品的后端共用情况。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>Mihayo</tag>
      </tags>
  </entry>
  <entry>
    <title>巴黎</title>
    <url>/2019/09/30/Paris/</url>
    <content><![CDATA[<p>上周五赶上了9月27日比利时的法语区节日，学校放假，连上周末，我们恰好有3天的假期。在上上周从阿姆斯特丹回来的火车上，我们就定下了本次的去巴黎之旅。本次旅行的成员有：我、zfn、lsd、wyd。</p>
<p>总的感受是：我太喜欢巴黎了，我爱巴黎.<br>在这里，我深刻地感受到法国的文化自信。</p>
<span id="more"></span>

<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>周五一大早，我们先乘火车到达Bruxell Nord站，转乘FlixBus直达巴黎。之所以坐大巴去，主要还是因为穷。最快的方式是 大力神火车，但需要99欧。大巴只需要15欧，缺点就是舒适性不足、速度慢。到达巴黎已经是下午1点半了。我们先买了巴黎公共交通的3天旅行通票，1-3Zone的。巴黎的行政区域划分为很多区，但交通系统分为5区，类似北京的二环、三环、四环、5环。买票可以选3区或5区。3区基本上可以满足大多数旅行需求，除了西北的莫奈花园和西南的凡尔赛宫。<br>我们没有选择直接去青旅放行李，而是一鼓作气开始了市区的旅行。依次参观了巴黎圣母院、先贤祠，晚上吃了正宗的法餐，放了行李后又游览了凯旋门和埃菲尔铁塔。</p>
<p>巴黎圣母院由于被烧毁还在修复，所以无法参观。我们仅在远处瞻仰了这座巴黎最有名的教堂。巴黎圣母院可以算是巴黎的地标，因为雨果的作品而名扬天下。即时被毁了，仍然是游客留念的必经之地。我们在被巴黎圣母院前合了影。从侧面可以看到正在修复的工程，之前从新闻上还不了解真正的损坏程度，近距离看的时候才发现，真的是毁了大半。修复工作需要持续数年，但愿之后我还有机会再次来到此地。</p>
<p><img src="/images/paris/church.jpg" alt="巴黎圣母院前的合影"></p>
<p>先贤祠是法兰西民族纪念民族伟人的地方。地宫中摆放着很多我们耳熟能详的人的遗体，如伏尔泰、卢梭、雨果、居里夫人、戴高乐（遗体没进来，但名字进来了）等。地位有点像我国的“八宝山”。<br>先贤祠位于一处高地，相比周围的建筑物可算宏伟。正门的门廊上刻着“伟人，祖国感谢你们”几个大字。在这里，我们也第一次感受到了巴黎的善意，我们凭借着比利时的D类签证，算是18～25岁的在欧洲居住的青年，国家维护的博物馆和景点全部免费。之后的凯旋门、卢浮宫、凡尔赛宫均免费。埃菲尔铁塔对所有12～24岁的Youth半价。<br>正殿里用壁画讲述了巴黎的主保圣人 圣女日南斐法 的事迹。同时还摆放着著名的“科博拜”，1851年科博用这个摆证明了地球的自转。以往只在教科书上看到的照片，如今却身临其境。这种感觉还是很奇妙的。</p>
<p><img src="/images/paris/pantheon.jpg" alt="伟人，祖国感谢你们"></p>
<p><img src="/images/paris/%E4%BC%8F%E5%B0%94%E6%B3%B0.jpg" alt="我和伏尔泰"></p>
<p>浏览完后，大家都已饥肠辘辘。所以我们去吃了法餐。<br>法餐算是欧洲餐饮的扛把子，高端的代名词，以往只有贵族才有时间和钱吃这些。共分为前菜、正餐、和 甜点，吃完差不多要一个小时。虽然量比较大，但时间长，也还是能吃完的。我们在巴黎共吃了3顿法餐，我也吃了3只鸭腿。</p>
<p><img src="/images/paris/first-duck.jpg" alt="第一顿法餐"></p>
<p>晚上我们参观了凯旋门和埃菲尔铁塔。</p>
<p>凯旋门是著名的爱国主义教育景点。让我们在凯旋门上祝祖国母亲70周年生日快乐。<br>看到凯旋门，我就想起阿汤哥在碟中谍6中骑着摩托环绕凯旋门的场景。可能是晚上来到这里，所以并没有想象中的宏伟和金碧辉煌。经过漫长的楼梯登顶后，可以看到以凯旋门为中心的巴黎夜景，整个街道以放射状铺开，远处的爱丽舍宫和埃菲尔铁塔清晰可见。</p>
<p><img src="/images/paris/kaixuanmen.jpg" alt="连灯都没有的凯旋门"></p>
<p>晚上的埃菲尔铁塔真的是太美了。真个塔身都被明亮的黄灯所笼罩，每到整点还会有不断闪亮的白灯出现。查过周五地铁凌晨2点45才关门后，我们放心大胆地继续玩了。埃菲尔铁塔也知道12点45关门。事实上，当我们回到旅店，已经是1点了。<br>虽然铁塔景区和战神广场参观免费，但登顶的电梯票必须买，好在我们还年轻，只需要12.7欧每人。<br>铁塔上的观光区共分为second floor和TOP，其中TOP是真正意义上的塔顶，而second floor是底座的顶端。在塔顶，我们可以眺望整个城市。巴黎夜景尽收眼底，我脑中的多巴胺也不断分泌。来此求婚、拍婚纱照、羞羞的人也络绎不绝，我们竟然都遇到了。唯一要注意的是，塔上风很大，晚上多穿点。我们已经被吹成傻x了。</p>
<p><img src="/images/paris/tieta.jpg" alt="我和铁塔"></p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>今天的日程以步行为主。<br>我们先后参观了卢浮宫、协和广场、香榭丽舍大街，并在塞纳河上做了游船。</p>
<p>卢浮宫 是世界三大博物馆之首，也是世界上每年参观人数最多的博物馆。其余2个分别是 纽约的大都会博物馆，伦敦的大英博物馆。都是殖民和掠夺世界的列强，在他们的博物馆内可以看到整个世界的珍宝，其中也不乏从中国抢的宝物。16年时有幸去过大英博物馆，算上卢浮宫，我也算是打卡2/3了。希望以后有机会去纽约玩。<br>卢浮宫宫内藏有“世界三宝”：蒙娜丽莎、断臂维纳斯、胜利女神。尤其是蒙娜丽莎，参观队列很长，每个人观看的时间也有所限定。整个博物馆很大，如果有时间的话，参观3天都是没问题的。由于我们本身只是游客，基本上也是走马观花，在重点藏品面前打个卡。在这里，你真的可以看到很多之前只能在教科书上看到的作品，如 历史课本中的 自由引导人民、拿破仑给皇后假加冕、蒙娜丽莎、断臂维纳斯，英语必修三的封面 贝聿铭金字塔。</p>
<p><img src="/images/paris/%E9%87%91%E5%AD%97%E5%A1%94.jpg" alt="金字塔"></p>
<p><img src="/images/paris/%E8%87%AA%E7%94%B1%E5%BC%95%E5%AF%BC%E4%BA%BA%E6%B0%91.jpg" alt="自由引导人民"></p>
<p><img src="/images/paris/%E6%96%AD%E8%87%82%E7%BB%B4%E7%BA%B3%E6%96%AF.jpg" alt="断臂维纳斯"></p>
<p>午饭照例吃了法餐，我继续吃了鸭子。</p>
<p><img src="/images/paris/second-duck.jpg" alt="第二顿法餐"></p>
<p>饭后我们前往了 协和广场 和 香榭丽舍大街 步行。协和广场并没有想象中的大，也只有一个“人民纪念碑”可供观看。香榭丽舍大街 与 香榭丽舍公园紧邻，也与爱丽舍宫相邻。这也是法国总统居住和办公的地方，所以戒备森严，公园也根本进不去，我们很失望。</p>
<p><img src="/images/paris/%E7%BA%AA%E5%BF%B5%E7%A2%91.jpg" alt="人民英雄纪念碑"></p>
<p>在大街上短暂休息后，我们步行前往塞纳河岸码头乘坐游船。<br>塞纳河因周杰伦的《告白气球》而名扬中华，我可以在塞纳河上乘坐游船，真是太棒了。巴黎城最早就是沿着塞纳河发展起来的，所以大多数历史古迹和地标建筑都位于河的两岸。由于太累了，我一上船就睡着了，直到快结束才醒来。14欧的船票大约睡了10欧的，也算是超值不菲的一觉。好在没有错过最后的埃菲尔铁塔，白天的埃菲尔铁塔有别样的壮美。完美体现了法国在第二次工业革命后的钢铁产能之大。在河中看岸边的铁塔，让我想起了红警中苏军磁化埃菲尔铁塔的任务。游戏设计者真是匠心独具，将这一著名铁塔和磁暴线圈结合起来。</p>
<p><img src="/images/paris/cibaoxianquan.jpg" alt="白天的铁塔"></p>
<h2 id="第三天-凡尔赛宫"><a href="#第三天-凡尔赛宫" class="headerlink" title="第三天 凡尔赛宫"></a>第三天 凡尔赛宫</h2><p>凡尔赛宫 是今天的绝对主题，也不辜负我们花一整天时间在它上面。由于之前的通票买的是3圈内的，无法去5圈的凡尔赛宫，我们早上又买了去凡尔赛宫的return tickets. 去凡尔赛的交通十分方便，地铁可以直达。事实上，步行从巴黎市中心来此也只需要4小时。法国大革命爆发时，正是来自巴黎的愤怒的市民将凡尔赛宫包围，将当时的国王路易十六挟持至巴黎，结束了凡尔赛宫作为王宫和王权象征的历史。我很喜欢的一首歌Viva La Vida即是以第一人称的口吻描述路易十六的遭遇。路易十六和玛丽皇后也因叛国罪被国民议会在断头台铡死。</p>
<p>来此之后发现参观人数众多，光在入口排队就排了一个多小时。不出所料，我们还是免费进。</p>
<p>著名的镜厅。历史书上的 德意志第一帝国成立，凡尔赛条约签订 均是在这里发生的。</p>
<p><img src="/images/paris/%E9%95%9C%E5%8E%85.jpg" alt="镜厅"></p>
<p>路易十四在位50余年，代表着王权的巅峰。凡尔赛宫也是在他任内完成，并成为国王的王宫和王权象征。宫内也随处可见他的画像和雕塑。历史上的他也是十分自恋的一个人，和乾隆爷有一拼。</p>
<p><img src="/images/paris/%E8%B7%AF%E6%98%93%E5%8D%81%E5%9B%9B.jpg" alt="我和路易十四"></p>
<p><img src="/images/paris/third-duck.jpg" alt="第三顿法餐"></p>
<h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>因为wyd同学下午有课，我们选择了周一上午返回列日。清晨从青旅check out，由于3天通票已经过期，我们买了单程的去FlixBus的Bercy station的票。之后乘坐Bus回到Bruxell，在Nord站内的KFC打发掉午餐，乘IC火车回到列日。</p>
<p>从Bercy站出发的时候遇到一个小插曲：一名男子试图用身体阻止我们的车出站，好像是有什么诉求，咱也不敢问。车站的保安试图说服和驱逐他，双方用身体反复对抗。经历一些周折，我们才得以出站。<br>这里还是有很多不讲理的暴民在。我们要注意自己的安全，不要与之接触，必要的时候要寻求警方的帮助。如果是自己开车的话，千万不要开车门和窗户，把车门锁好，等待救援。</p>
<p>我在KFC点了6只鸡翅的套餐，因为比较饥饿，感觉还蛮好吃的。不过后来越吃越想念国内的辣翅。这里的炸鸡翅和辣翅有些像，但味道差些。</p>
<p>比利时有方便学生乘坐火车的GO PASS票，53欧可以乘坐10次，但仅限国内交通，也就是IC车。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title>Queue and Stack</title>
    <url>/2019/02/17/Queue-and-Stack/</url>
    <content><![CDATA[<p>今天我们一起学习2种重要的数据结构：队列 和 栈。<br>本文根据LeetCode上的Explore教程 <a href="https://leetcode.com/explore/featured/card/queue-stack/">Introduction to Data Structure - Queue &amp; Stack</a> 整理而成。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>最常用的Collection是数组(Array)，其最常使用的获取数据的操作是随机获取(Random access), 在C++中一般称作 subscribe。<br>但是有时，我们想要限制处理数据的顺序。最常见的限制是：先进先出(First in first out), 后进先出(Last in first out)。分别对应2种数据结构 队列(Queue) 和 栈(Stack)。</p>
<p>我们从 定义、实现 和 每种数据结构的内置操作 分别学习 队列 和 栈。<br>学习目标：</p>
<ol>
<li>理解数据处理顺序FIFO和LIFO的原则；</li>
<li>手动实现数据结构；</li>
<li>熟悉语言内置的Queue和Stack；</li>
<li>解决基础的Queue-related问题，尤其是BFS；</li>
<li>解决基础的Stack-related问题；</li>
<li>理解系统的栈如何帮助你，在解决dfs和其他递归问题的时候。</li>
</ol>
<h2 id="Queue-First-in-first-out-Data-Structure"><a href="#Queue-First-in-first-out-Data-Structure" class="headerlink" title="Queue: First-in-first-out Data Structure"></a>Queue: First-in-first-out Data Structure</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先进先出 最普遍的比喻是排队(也就是队列), 最早进入队列的人最早被服务到。<br>所以队列总共只有2个modify 方法：</p>
<ul>
<li>enqueue</li>
<li>dequeue</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Queue并不是基础的数据结构，我们可以用内置的数组来实现它。在C++中，Queue是container adapter, 并不是真正的container，其内部其实是deque。</p>
<p>实现实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// store elements</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; data;       </span><br><span class="line">        <span class="comment">// a pointer to indicate the start position</span></span><br><span class="line">        <span class="keyword">int</span> p_start;            </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">MyQueue</span>() &#123;p_start = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="comment">/** Insert an element into the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p_start++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[p_start];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** Checks whether the queue is empty or not. */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p_start &gt;= data.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyQueue q;</span><br><span class="line">    q.<span class="built_in">enQueue</span>(<span class="number">5</span>);</span><br><span class="line">    q.<span class="built_in">enQueue</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">deQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">deQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">Front</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环队列-Circular-Queue"><a href="#循环队列-Circular-Queue" class="headerlink" title="循环队列 Circular Queue"></a>循环队列 Circular Queue</h3><p>在之前的实现中，p_start之前的内存空间是被浪费掉的。为了充分利用，我们可以在内部使用循环利用array。</p>
<p>Circular Queue也叫做”Ring Buffer”。</p>
<p>Ring Buffer的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> &#123;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">    <span class="built_in">MyCircularQueue</span>(<span class="keyword">int</span> k) &#123;</span><br><span class="line">        data.<span class="built_in">insert</span>(data.<span class="built_in">begin</span>(), k, <span class="number">0</span>);</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isFull</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        data[(head + size) % data.<span class="built_in">size</span>()] = value;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        head = (head + <span class="number">1</span>) % data.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[head];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[(head + size - <span class="number">1</span>) % data.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == data.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularQueue* obj = new MyCircularQueue(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;enQueue(value);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;deQueue();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;Front();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;Rear();</span></span><br><span class="line"><span class="comment"> * bool param_5 = obj-&gt;isEmpty();</span></span><br><span class="line"><span class="comment"> * bool param_6 = obj-&gt;isFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Queue的应用"><a href="#Queue的应用" class="headerlink" title="Queue的应用"></a>Queue的应用</h3><p>最典型的应用，BFS。<br>BFS(Breadth-first Search)一般用来发现从根节点到目标节点的最短距离。</p>
<p>应用BFS的场景：</p>
<ul>
<li>do traversal</li>
<li>find the shortest path</li>
</ul>
<p>场景中常使用的数据结构：</p>
<ul>
<li>图</li>
<li>树</li>
</ul>
<p>在具体应用中，BFS里的节点可能是<strong>真正的节点</strong>或<strong>状态</strong>，边可能是<strong>真正的边</strong>或<strong>状态间的转移</strong>。</p>
<p>BFS的模版，一定要背下来，以后面试或做题提高速度和bug-free的可能。</p>
<h4 id="template-1"><a href="#template-1" class="headerlink" title="template 1"></a>template 1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                add next to queue;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="template-2"><a href="#template-2" class="headerlink" title="template 2"></a>template 2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; visited;  <span class="comment">// store all the nodes that we&#x27;ve visited</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to visited;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to visited;</span><br><span class="line">                &#125;</span><br><span class="line">                remove the first node from queue;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在每一轮中，队列中的节点都是等待被处理的。</li>
<li>没经历一次外层的while循环，都离root更远一步， step++。</li>
</ol>
<h4 id="template-2-1"><a href="#template-2-1" class="headerlink" title="template 2"></a>template 2</h4><p>在图中，确保每个节点不被多次访问很重要。否则BFS会陷入无限循环。此时，我们增加一个<code>hashset</code>用来标注是否节点已经被访问到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the length of the shortest path between root and target node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node root, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; queue;  <span class="comment">// store all nodes which are waiting to be processed</span></span><br><span class="line">    Set&lt;Node&gt; visited;  <span class="comment">// store all the nodes that we&#x27;ve visited</span></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;       <span class="comment">// number of steps neeeded from root to current node</span></span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    add root to queue;</span><br><span class="line">    add root to visited;</span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">while</span> (queue is not empty) &#123;</span><br><span class="line">        step = step + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// iterate the nodes which are already in the queue</span></span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            Node cur = the first node in queue;</span><br><span class="line">            <span class="keyword">return</span> step <span class="keyword">if</span> cur is target;</span><br><span class="line">            <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next is not in used) &#123;</span><br><span class="line">                    add next to queue;</span><br><span class="line">                    add next to visited;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            remove the first node from queue;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;          <span class="comment">// there is no path from root to target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么情况下可以不使用visited呢？</p>
<ol>
<li>你确定不会出现重复访问的情况。比如，遍历树的时候。</li>
<li>你确实想要把一个节点加入队列多次。</li>
</ol>
<h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>提到栈，我就想起周杰伦的《七里香》。歌中唱到，</p>
<blockquote>
<p>雨下整夜，我的栈溢出就像雨水。</p>
</blockquote>
<p>在LIFO数据结构中，最新被添加的元素最早被处理。在栈中，添加元素的操作叫做push(压栈)，移除元素的操作叫做pop（弹出）。虽然在C++中，queue的操作也是同样的名字，但在大多数语言中，push 和 pop是stack专有的。</p>
<p>像队列一样，绝大多数语言提供了built-in的stack库，你不需要重复造轮子，只需要熟悉stack的常用操作，包括 push, pop, top（获取栈顶元素）。</p>
<h3 id="单调栈的应用"><a href="#单调栈的应用" class="headerlink" title="单调栈的应用"></a>单调栈的应用</h3><p><a href="https://leetcode.com/explore/featured/card/queue-stack/230/usage-stack/1363/">https://leetcode.com/explore/featured/card/queue-stack/230/usage-stack/1363/</a></p>
<p>Intution: 维护一个单调递减的栈，遍历一遍数组T，如果将其放入栈中，把栈中比它小的元素都pop出来，并计算出相应的间隔。</p>
<p>时间复杂度：O(n),<br>空间复杂度: O(n).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(T.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s; <span class="comment">// temperature, day</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>().first &lt; T[i]) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; current = s.<span class="built_in">top</span>();</span><br><span class="line">                result[current.second] = i - current.second;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(&#123;T[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="stack-和-DFS"><a href="#stack-和-DFS" class="headerlink" title="stack 和 DFS"></a>stack 和 DFS</h3><p>DFS是stack的重要应用之一，可以用来寻找从根节点到目标节点的路径(注意不一定是最短)。DFS是回溯的一种算法，只有到达最深的节点才进行回溯，尝试其他路径。</p>
<h4 id="DFS-模版-1，递归版本"><a href="#DFS-模版-1，递归版本" class="headerlink" title="DFS 模版 1，递归版本"></a>DFS 模版 1，递归版本</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">    <span class="keyword">for</span> (next : each neighbor of cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">            add next to visted;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">true</span> <span class="keyword">if</span> <span class="title">DFS</span><span class="params">(next, target, visited)</span> </span>== <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DFS-模版-2，迭代版本"><a href="#DFS-模版-2，迭代版本" class="headerlink" title="DFS 模版 2，迭代版本"></a>DFS 模版 2，迭代版本</h4><p>递归版本的优点是实现起来更加简单。缺点是，如果递归深度太深，会stack overflow。<br>这时，你可能会想要用 BFS 或者 用显式的栈实现DFS。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return true if there is a path from cur to target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; visited;</span><br><span class="line">    Stack&lt;Node&gt; stack;</span><br><span class="line">    add root to stack;</span><br><span class="line">    <span class="keyword">while</span> (s is not empty) &#123;</span><br><span class="line">        Node cur = the top element in stack;</span><br><span class="line">        remove the cur from the stack;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> cur is target;</span><br><span class="line">        <span class="keyword">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next is not in visited) &#123;</span><br><span class="line">                add next to visited;</span><br><span class="line">                add next to stack;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的逻辑和递归解法相同。只不过我们使用<code>while</code>循环和显式的<code>stack</code>来模仿系统栈。</p>
<h3 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a><a href="https://leetcode.com/explore/featured/card/queue-stack/239/conclusion/1386/">Implement Queue using Stacks</a></h3><p>用栈来实现队列。<br>我记得在程序员面试金典上遇到过一样的题目，感觉是一道很经典的题目。需要面试者对队列和栈都非常熟悉才行。</p>
<p>Intuition: 队列是FIFO，栈是LIFO，所以我们可以用2个栈来实现一个队列。定义将一个栈装入另一个栈的操作为<strong>颠倒</strong>。我们可以通过<strong>颠倒</strong>, 将LIFO变为FIFO，而且只有在需要dequeue的时候，才需要做颠倒的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                b.<span class="built_in">push</span>(a.<span class="built_in">top</span>());</span><br><span class="line">                a.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = b.<span class="built_in">top</span>();</span><br><span class="line">        b.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                b.<span class="built_in">push</span>(a.<span class="built_in">top</span>());</span><br><span class="line">                a.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">empty</span>() &amp;&amp; b.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Implement-Stack-using-Queues"><a href="#Implement-Stack-using-Queues" class="headerlink" title="Implement Stack using Queues"></a><a href="https://leetcode.com/explore/featured/card/queue-stack/239/conclusion/1387/">Implement Stack using Queues</a></h3><p>那么如何用FIFO实现LIFO呢？解法可能不是那么明显，但却十分简单。每次push时，都把队列里的元素重新入对一遍，就把最后入对的放到第一个位置了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>dfs 和 bfs 属于想法简单，但实现起来不容易，尤其是bug-free并且快速地实现更属不易。<br>由于考察的编程基础涉及广泛，面试官也特别喜欢考类似的题目。几个模版必须熟练背会才行。</p>
<p>队 和 栈 更是基础的数据结构。在计算机科学中随处可见，虽然很多时候不会直接考察，但很多算法都要用到。熟练手写stack 和 queue 和使用built-in的stack 和 queue是每个合格程序员的基础。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>SSD: Single Shot MultiBox Detector 配置使用总结</title>
    <url>/2017/01/12/SSD-Single-Shot-MultiBox-Detector-configuration/</url>
    <content><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>Ubuntu 16.04</li>
<li>CPU only (自己的机器上没有NVIDIA的卡, AMD说起来都是泪.)</li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>基本上是按照<a href="https://github.com/weiliu89/caffe/tree/ssd">官方文档</a>. 这里只展示与文档中不同的部分.</p>
<span id="more"></span>
<h3 id="Makefile-confile"><a href="#Makefile-confile" class="headerlink" title="Makefile.confile"></a>Makefile.confile</h3><ul>
<li>line 8: CPU only</li>
<li>line 79, 80: support for python3</li>
<li>line 81: /usr/lib/python3.5/dist-packages/numpy/core/include -&gt; /usr/local/lib/python3.5/dist-packages/numpy/core/include</li>
<li>line 95: fix fatal of <code>hdf5</code></li>
</ul>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><blockquote>
<p>./include/caffe/util/hdf5.hpp:6:18: fatal error: hdf5.h: No such file or directory</p>
</blockquote>
<p>应该只有Ubuntu15.10+的版本才会遇到这样的问题, 原因是hdf5的头文件和库的路径在新版本中发生了改变.<br><a href="https://gist.github.com/wangruohui/679b05fcd1466bb0937f#">解决方法</a></p>
<blockquote>
<p>/usr/bin/ld: cannot find -lopenblas</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ locate libopenblas.so</span><br><span class="line">/usr/lib/libopenblas.so.0</span><br><span class="line"></span><br><span class="line">$ sudo ln -s libopenblas.so.0 libopenblas.so</span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/335928/ld-cannot-find-an-existing-library">参考</a></p>
<blockquote>
<p>/usr/bin/ld: cannot find -lboost_python3</p>
</blockquote>
<p><a href="https://github.com/BVLC/caffe/issues/4843">解决方法</a></p>
]]></content>
  </entry>
  <entry>
    <title>SSH 通过跳板机登陆服务器</title>
    <url>/2021/03/26/SSH-proxy-by-jump-server/</url>
    <content><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>接上篇<a href="https://youngforest.github.io/2021/03/18/Ubuntu-vpn-cannot-access-public-resource/">解决台式机Ubuntu VPN访问公网资源</a>的问题后，我尝试了配置跳板机访问杭研院机器。</p>
<p>在科研工作中，MAC笔记本无法连接OpenVPN，从而访问杭研院机器。我的台式机Ubuntu已经配置好了VPN，可以访问服务器。我现在想通过台式机Ubuntu中转，从而实现MAC“直接”访问杭研院。抽象一下问题为：</p>
<ul>
<li>A可以访问B</li>
<li>A不可以访问C</li>
<li>B可以访问C</li>
<li>我现在想A访问C</li>
</ul>
<p>由于工作中主要使用SSH，因此，问题简化成A通过SSH直接登陆C。<br>我经过不屑的网上搜索和尝试，总结了2中技术和方法实现我的目的。</p>
<ul>
<li>SSH 代理</li>
<li>SSH 隧道</li>
</ul>
<span id="more"></span>


<h2 id="SSH-代理"><a href="#SSH-代理" class="headerlink" title="SSH 代理"></a>SSH 代理</h2><p>这种方法最简单，不需要在B上进行任何操作，无缝连接C。</p>
<p>A上执行，其中<code>rentao@10.134.150.154</code>是B，<code>ldmc@192.168.131.181</code>是C。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -o <span class="string">&quot;ProxyJump rentao@10.134.150.154&quot;</span> ldmc@192.168.131.181</span><br></pre></td></tr></table></figure>

<p>Reference: <a href="https://www.xiebruce.top/650.html">穿越跳板机</a></p>
<h2 id="SSH-隧道"><a href="#SSH-隧道" class="headerlink" title="SSH 隧道"></a>SSH 隧道</h2><p>B上执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -f -N -L 0.0.0.0:9906:192.168.131.181:22 ldmc@192.168.131.181</span><br></pre></td></tr></table></figure>

<p>A上执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 9906 ldmc@10.134.150.154</span><br></pre></td></tr></table></figure>

<p>虽然这种方法看起来更麻烦些，需要A B协作。但是相比第一种方法，其实更加灵活。可以通过SSH 隧道的方式通过B中转暴露更多C的服务（如观察训练数据的tensorboard HTTP服务也是我常需要暴露的），并不一定是SSH登陆。</p>
<p>Reference: <a href="https://www.zsythink.net/archives/2450">SSH 端口转发：SSH 隧道</a></p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu OpenVPN 无法获取公网资源</title>
    <url>/2021/03/18/Ubuntu-vpn-cannot-access-public-resource/</url>
    <content><![CDATA[<p>由于科研需求，我需要连接杭州研究院的VPN，才能使用显卡做神经网络的训练任务。<br>然而在Ubunut 18.04配置好OpenVPN后，发现一个难题：连上VPN后无法上外网（百度等网站，不是墙外的网站，而是相对局域网内网的“外网”），断开VPN后可以连外网，但无法连接杭研院的资源。鉴于工作中，外网和杭研院内网基本缺一不可，我花了2天时间调研和修复改问题。而且其他同学使用VPN并没有类似问题，所以我认为是<code>Ubuntu</code>独特的问题。修复的操作很简单，但定位到问题的过程十分坎坷。</p>
<h2 id="现象整理"><a href="#现象整理" class="headerlink" title="现象整理"></a>现象整理</h2><p>连接VPN后，可以ping通baidu的IP，但浏览器无法连接baidu，也无法直接ping通baidu.com。浏览器只能打开杭研院和北航内部的网站。<br>初步判断是网络上DNS服务器的问题，但调研之后发现DNS的配置并无问题。<br>猜测是访问外部资源时，理应的DNS解析并没有办法完成。</p>
<p>最后在网上查了半天，才发现真正的问题（VPN本地配置问题）和解决方案。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="https://askubuntu.com/a/713066/558370">网上最类似的一个问题和解决方案</a></p>
<p>由于我是Ubuntu 18.04, 并不大一样。<br>在我这里给出我的完整解决方案，以供大家参考。</p>
<p>打开VPN的配置。</p>
<p><img src="/images/vpn1.png" alt="Step 1"></p>
<p><img src="/images/vpn2.png" alt="Step 2"></p>
<p>勾选“Use this connection only for resources on its network”</p>
<p><img src="/images/vpn2.png" alt="Step 2"></p>
<p>Apply后，重新连接VPN即可解决问题。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>下一步，我还会试着在Ubuntu上装个跳板机。这样我的Mac或许可以通过该跳板机连入杭研院的机器。 (已经成功啦，下篇更新在<a href="https://youngforest.github.io/2021/03/26/SSH-proxy-by-jump-server/">这里</a>)。</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>atom 浅尝辄止</title>
    <url>/2017/04/08/atom-explore/</url>
    <content><![CDATA[<h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>笔者的需求是在markdown文档中插入LaTeX公式, atom默认的<code>markdown-preview</code>包无法满足要求. 经过搜索, 社区包<code>markdown-preview-plus</code>可是满足该需求.</p>
<h3 id="atom包管理"><a href="#atom包管理" class="headerlink" title="atom包管理"></a><a href="http://flight-manual.atom.io/using-atom/sections/atom-packages/#atom-packages">atom包管理</a></h3><p>按照官方教程, 安装失败</p>
<blockquote>
<p>Installing “<a href="mailto:&#x6d;&#x61;&#114;&#107;&#100;&#x6f;&#x77;&#110;&#x2d;&#x70;&#114;&#101;&#x76;&#105;&#101;&#x77;&#45;&#x70;&#x6c;&#117;&#x73;&#64;&#x32;&#46;&#52;&#x2e;&#57;">&#x6d;&#x61;&#114;&#107;&#100;&#x6f;&#x77;&#110;&#x2d;&#x70;&#114;&#101;&#x76;&#105;&#101;&#x77;&#45;&#x70;&#x6c;&#117;&#x73;&#64;&#x32;&#46;&#52;&#x2e;&#57;</a>” failed.</p>
</blockquote>
<p>在log中, 笔者发现了这样的请求</p>
<blockquote>
<p>GET <a href="https://atom.io/download/electron/v1.3.13/iojs-v1.3.13.tar.gz">https://atom.io/download/electron/v1.3.13/iojs-v1.3.13.tar.gz</a></p>
</blockquote>
<p>笔者接着使用浏览器测试该网址, 无法相应, 猜测是被q了. 幸运的是, atom文档中考虑到使用代理的需要, 并给出了guide.</p>
<p> <a href="http://flight-manual.atom.io/getting-started/sections/installing-atom/#using-a-proxy">配置apm的代理</a></p>
<p>最后, <a href="http://blog.youngforest.me/2016/11/02/%E5%AE%9E%E7%8E%B0terminal%E4%BB%A3%E7%90%86/">fq基本功</a>. 不解释.</p>
<h3 id="具体命令"><a href="#具体命令" class="headerlink" title="具体命令"></a>具体命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sean@sean-OptiPlex-790:~$ apm config <span class="built_in">set</span> https-proxy http://localhost:8123</span><br><span class="line">sean@sean-OptiPlex-790:~$ apm config get https-proxy</span><br><span class="line">http://localhost:8123/</span><br><span class="line">sean@sean-OptiPlex-790:~$ apm install markdown-preview-plus</span><br><span class="line">Installing markdown-preview-plus to /home/sean/.atom/packages ✓</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>atom</tag>
      </tags>
  </entry>
  <entry>
    <title>突破百度云限速</title>
    <url>/2018/11/05/baidu-cloud-download-speed-hack/</url>
    <content><![CDATA[<p>最近因为英语学习的需要，经常到百度云上下载一些大文件。众所周知，百度云对下载进行了限速，不开他家的会员的话，下载速度只有几十k/s。实在不能忍，遂搜索了限速破解工具，下载速度达到了15M/s，哈哈。在此分享给大家。<br>不过需要注意的是，由于百度云也会更新限速机制，防止大家滥用。所以如果本文的方法失效的话，也不足为奇，还可以在网上寻找其他更新的方法。要相信广大程序员的力量。<br>截止至2018年11月5日，此方法是可行的。</p>
<span id="more"></span>

<p><a href="https://github.com/gxvv/ex-baiduyunpan">获取百度云 原始连接</a></p>
<p>运行脚本后，百度云的下载界面会变成这个样子。</p>
<p><img src="/images/ex-baiduyun.jpg" alt="Ex-百度云脚本结果"></p>
<p>至于为什么点压缩连接呢？因为我发现用”复制链接“并不能获取文件本身的下载地址；而且下载压缩包也更快。</p>
<p><a href="https://github.com/proxyee-down-org/proxyee-down">http 多线程下载工具</a></p>
<p><img src="/images/proxyee-down.png" alt="下载工具效果"></p>
]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>丰宁坝上草原2日游</title>
    <url>/2018/10/07/bashang-grassland/</url>
    <content><![CDATA[<p>如何欢度2018年最后一个假期–国庆节呢？我选择了跟团(北京初心户外)去河北丰宁的坝上草原骑马。9月30号晚19点半在惠通西街南口集合上大巴。一路向北，9点半到达一个北京最北的服务站时，已经感觉很冷了。晚上近12点到达丰宁县的一个农家乐住宿时，天气已经非常冷了。据房东说，前一天刚刚下过雪，所以这两天非常冷。后来国庆节后刷朋友圈时，看到去什么沙漠、戈壁、火山的，无一例外都是很冷。所以，秋天去这些地方，还是要三思而后行的，做足充分准备的。出发前，领队反复强调需要带厚衣服，最好是羽绒服。我从小怕冷，直接带了最厚的羽绒服–500g 绒的加拿大鹅。据说这衣服去南极都没问题，我没去过南极，不知真假。但这件衣服抵抗秋天的草原夜晚的温度，还是一点问题也没有的。</p>
<span id="more"></span>

<p>第一天上午，到村庄附近骑马，80元/小时。这个旅行团来骑马的有40余人，上马的时候很混乱。我稀里糊涂就跟着一批人走了。这批人由大约20名游客，3个马夫组成。通过后来的交流，我才知道，自己上了一条“贼船”。怎么个贼法呢？首先，我们绕了一大圈，走了最远的路线。这意味着，最长的时间(4小时)，最高的花费。过长的骑马对于第一次上马的我来说，度过了最初的激动和策马奔腾后，到最后回程的时候简直是一种折磨。马归心似箭，总想快跑，而我已经内脏都要被颠碎了。回来之后，腰背疼了4天，尾椎骨也破了，小腿的胫骨中部被马镫磨烂了，过了一周才慢慢痊愈。当然绕远也有好处。我们经过了附近风景最美的“情人谷”。山丘、草原、蓝天、白云相映生辉，组成一幅幅屏保级的图案。在马上随手一拍就是美景。尤其是还能看到成片的白桦林，远近不一的成群的风力发电机和覆盖着白雪的山顶。其次，我们中间休息了3次。每次休息都在简陋的茶房，加起来休息时间竟达到了1个小时。然而这些都是仍然算是收费的。你可以认为这些马和马夫在带薪休假。最后，回到农家乐已经下午一点了。12点开饭，回的早的人有大鱼大肉，回的晚的人只剩残羹冷炙了。</p>
<p>下午，乘车参观了 大汗行宫 外围 和 闪电湖。</p>
<p>晚上，品尝了烤全羊，和众人一起点篝火、放烟花。</p>
<p>第二天上午，去 草原游乐场 玩耍。</p>
<p>最后放一张骑马的照片，同行的人，由于我人高，所以分配到的马也大。<br><img src="/images/riding.jpg" alt="草原骑马"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本次旅行的所有花费：</p>
<ul>
<li>报名费 350</li>
<li>骑马 350</li>
<li>闪电湖 20</li>
<li>游乐场 40</li>
<li>路上零食 10</li>
<li>总计 770</li>
</ul>
]]></content>
      <tags>
        <tag>trvalling</tag>
      </tags>
  </entry>
  <entry>
    <title>Best implement to use pair as key to std::unordered_map in C++</title>
    <url>/2020/05/27/best-implement-to-use-pair-as-key-to-std-unordered-map-in-C/</url>
    <content><![CDATA[<p>Reference: <a href="https://www.mica.edu.vn/perso/Vu-Hai/EE3490/Ref/The%20C++Standard%20Library%20-%202nd%20Edition.pdf">C++ Standard Library: A tutorial and reference, Second version</a> Chapter 7.9.2: Creating and Controlling unordered Container</p>
<p>All solutions I found in Google use <code>XOR</code> to generate hashcode of <code>pair</code>, which is totally bad. see <a href="https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes">why-is-xor-the-default-way-to-combine-hashes</a>. However, the book has given us the best solution, using <code>hash_combine</code>, which is taken from <code>Boost</code>. The solution is much better than XOR when I tested it in Online Judge(<a href="https://atcoder.jp/contests/abc168/tasks/abc168_e">Atcoder</a>). I organized the code as a template as follow. You can copy and paste it as much as you can. And it is convenient to change it to fit any custom struct/class.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">// from boost (functional/hash):</span></span><br><span class="line"><span class="comment">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash_combine</span><span class="params">(std::<span class="keyword">size_t</span> &amp;seed, <span class="keyword">const</span> T &amp;val)</span> </span>&#123;</span><br><span class="line">    seed ^= std::hash&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed &lt;&lt; <span class="number">6</span>) + (seed &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// auxiliary generic functions to create a hash value using a seed</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span> &amp;seed, <span class="keyword">const</span> T &amp;val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span> &amp;seed, <span class="keyword">const</span> T &amp;val, <span class="keyword">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">    <span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::<span class="keyword">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="keyword">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class="line">    std::<span class="keyword">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair_hash</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash_val</span>(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;</span><br><span class="line">    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There is a hash implementation for <code>Tuple</code>. I updated the answer in<a href="https://stackoverflow.com/a/62035742/6393787">StackOverflow</a>。Please go there if you need hash tuple.</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>hash</tag>
        <tag>unordered_map</tag>
      </tags>
  </entry>
  <entry>
    <title>MAC 手动编译 build qBittorrent</title>
    <url>/2021/02/27/build-qBittorrent/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近毕业压力比较大，想在北邮人上下载个电影看看，放松下。却发现一直使用的做种下载工具qBittorrent无法打开了。在网上寻找了半天原因和解决方案。</p>
<p>最终确认是MAC更新的锅，qBittorrent 属于认证不完整的应用：<a href="https://github.com/qbittorrent/qBittorrent/issues/11570">Issue 11570</a>。<br>解决方案有二：</p>
<ul>
<li>禁掉APPLE的安全检查</li>
<li>自己手动编译一遍应用</li>
</ul>
<p>由于某些原因，我无法对MAC做过多的系统更改。只好尝试第二个解决方案。事实证明，手动编译qBittorrent并不简单，一下午就此度过，电影也不用看了。为方便有相同问题的同学参考，我记录我的解决方案于此。因为在我编译构建过程中，网上并没有类似的教程或是参考，而且确实有不少坑。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>如果之前没有QT环境，<code>./configure</code>会报找不到<code>qmake</code>的错误。需要配置相应的环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install qt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;/usr/local/opt/qt/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/usr/local/opt/qt/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">&quot;-L/usr/local/opt/qt/lib&quot;</span></span><br><span class="line"><span class="built_in">export</span> CPPFLAGS=<span class="string">&quot;-I/usr/local/opt/qt/include&quot;</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=<span class="string">&quot;/usr/local/opt/qt/lib/pkgconfig</span></span><br></pre></td></tr></table></figure>

<p>如果之前没有<code>boost</code>环境，会报找不到<code>boostlib</code>的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">checking <span class="keyword">for</span> boostlib &gt;= 1.65 (106500)... configure: We could not detect the boost libraries (version 1.65 or higher). If you have a staged boost library (still not installed) please specify <span class="variable">$BOOST_ROOT</span> <span class="keyword">in</span> your environment and <span class="keyword">do</span> not give a PATH to --with-boost option.  If you are sure you have boost installed, <span class="keyword">then</span> check your version number looking <span class="keyword">in</span> &lt;boost/version.hpp&gt;. See http://randspringer.de/boost <span class="keyword">for</span> more documentation.</span><br><span class="line">configure: error: Could not find Boost</span><br></pre></td></tr></table></figure>

<p>需要安装<code>boost</code>环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install boost</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install libtorrent-rasterbar</span><br></pre></td></tr></table></figure>

<p>如果遇到报错，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: Directory not empty @ dir_s_rmdir - /usr/<span class="built_in">local</span>/opt/openssl</span><br></pre></td></tr></table></figure>

<p>可以删掉对应文件夹或是更改其所有人<code>chown</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew cleanup</span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/Cellar/openssl/1.0.2q</span><br></pre></td></tr></table></figure>

<p>在我<code>brew install libtorrent-rasterbar</code>后再<code>./configure</code>时，仍然会发生该库版本不对的问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Requested <span class="string">&#x27;libtorrent-rasterbar &gt;= 1.2.11&#x27;</span> but version of libtorrent-rasterbar is 1.2.10</span><br></pre></td></tr></table></figure>

<p>因为<code>brew</code>的formula中只有1.2.10，我们只好手动编译一个新版了。</p>
<p>去github找到libtorrent-rasterbar对应版本的源码：<a href="https://github.com/arvidn/libtorrent/releases/tag/v1.2.11">download</a>。按照文档中的构建说明编译安装即可。</p>
<p>对于MAC来说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install boost-build boost openssl@1.1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;using darwin ;&quot;</span> &gt;&gt;~/user-config.jam</span><br><span class="line">b2 crypto=openssl cxxstd=17 openssl-lib=/usr/<span class="built_in">local</span>/Cellar/openssl@1.1/1.1.1j/lib openssl-include=/usr/<span class="built_in">local</span>/Cellar/openssl@1.1/1.1.1j/include release</span><br><span class="line">b2 crypto=openssl cxxstd=17 openssl-lib=/usr/<span class="built_in">local</span>/Cellar/openssl@1.1/1.1.1j/lib openssl-include=/usr/<span class="built_in">local</span>/Cellar/openssl@1.1/1.1.1j/include install --prefix=/usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> libtorrent_LIBS=<span class="string">&quot;-L/usr/local/lib&quot;</span></span><br><span class="line"><span class="built_in">export</span> libtorrent_CFLAGS=<span class="string">&quot;-I/usr/local/include&quot;</span></span><br><span class="line"><span class="built_in">export</span> openssl_CFLAGS=<span class="string">&quot;-I/usr/local/Cellar/openssl@1.1/1.1.1j/include&quot;</span></span><br><span class="line"><span class="built_in">export</span> openssl_LIBS=<span class="string">&quot;-L/usr/local/Cellar/openssl@1.1/1.1.1j/lib&quot;</span></span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">qbittorrent</span><br></pre></td></tr></table></figure>

<!-- ```bash
Undefined symbols for architecture x86_64:
  "_EVP_sha512"
``` -->

<p>除此之外，你还可以参考<a href="https://github.com/qbittorrent/qBittorrent/wiki#compilation">官网的另外一些编译构建文档</a>. 这里提供了使用CMake或QT Creator的编译方案。</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>codeforces round 633 Div2</title>
    <url>/2020/04/12/codeforces-round-633-Div2/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/blog/entry/75913">官方题解</a></p>
<p>codeforces上题目一般高于平时的面试题。如果是为了面试的话，只刷LeetCode就可以了。不过如果是对算法和竞赛感兴趣，强烈鼓励试一试。题目的数量和质量都远超LeetCode。而且为不同水平的同学有不同的赛道，题目难度也不同。对于高水平玩家来说，竞赛体验会好的多。</p>
<p>我目前共参加过2场Div.2，rating 1480。没错，初始值是1500，我反而掉下来了。</p>
<h2 id="A-Filling-Diamonds"><a href="#A-Filling-Diamonds" class="headerlink" title="A. Filling Diamonds"></a>A. Filling Diamonds</h2><p>可以用动态规划的方式思考这个问题。对于长度为n的belt来说，共有2种状态：</p>
<p>0.<br><br>/</p>
<p>和<br>1.<br>/<br>\</p>
<p>状态转移方程有:<br>dp[n][0] = dp[n-1][1] + dp[n-1][0],<br>dp[n][1] = dp[n-1][1].</p>
<p>对于初始值有:<br>dp[0][1] = 1,<br>dp[0][0] = 0.</p>
<p>答案为: dp[n][0].</p>
<p>通过该方程可以很快地得出<code>dp[n][0] = n</code>。</p>
<p>时间复杂度: O(1),<br>空间复杂度: O(1).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出题人也很骄傲地说，这是目前最简单的Div.2 A了。代码很简单，但是思路还挺巧妙。</p>
<h2 id="B-Sorted-Adjacent-Differences"><a href="#B-Sorted-Adjacent-Differences" class="headerlink" title="B. Sorted Adjacent Differences"></a>B. Sorted Adjacent Differences</h2><p>贪心。先排序，从中间开始选，向右跳一下，向左跳一下。</p>
<p>时间复杂度: O(n log n),<br>空间复杂度: O(n).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(SIZE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="keyword">int</span> current = (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left = current, right = current;</span><br><span class="line">        <span class="keyword">bool</span> direction = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (current &gt;= <span class="number">0</span> &amp;&amp; current &lt; n) &#123;</span><br><span class="line">            cout &lt;&lt; a[current] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (direction) &#123;</span><br><span class="line">                ++right;</span><br><span class="line">                current = right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --left;</span><br><span class="line">                current = left;</span><br><span class="line">            &#125;</span><br><span class="line">            direction = !direction;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Powered-Addition"><a href="#C-Powered-Addition" class="headerlink" title="C. Powered Addition"></a>C. Powered Addition</h2><p>问题可以转化为: 可以给数组中的任何数 加 最多 2^k - 1. 使得整个数组非递减。求最小的k.</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ll max_value_in_array = numeric_limits&lt;ll&gt;::<span class="built_in">min</span>();</span><br><span class="line">        ll max_demand = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ll current;</span><br><span class="line">            cin &gt;&gt; current;</span><br><span class="line">            <span class="keyword">if</span> (current &gt; max_value_in_array) &#123;</span><br><span class="line">                max_value_in_array = current;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max_demand = <span class="built_in">max</span>(max_demand, max_value_in_array - current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        ll could_present = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (could_present &lt;= max_demand) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            could_present *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>contest</tag>
      </tags>
  </entry>
  <entry>
    <title>face++ 面试</title>
    <url>/2018/08/14/face-interview/</url>
    <content><![CDATA[<p>一个清华的毕业生做为面试官，一开始问了我之后的工作意向。我回答说是“算法工程师”，其实我这次面的是开发岗，就被大佬教育了一顿。说你是不是投错组了，还没找到自己感兴趣的方向嘛。之后问我，现在在快手的实习是做什么的？我讲了一些。然后又被diss了。说这些特征工程之后都会被深度学习所取代的。</p>
<p>正式进入面试只问了2个问题：维护最小值的队实现，和 维护最小指的栈实现。</p>
<p>之后本来有二面的，后来没找到面试官就不了了之了。</p>
<p>我是对这次面试结果不抱太大期望的，毕竟过程比较水，也不是很愉快。果然之后face++那边一直都没有消息。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>旷视</tag>
      </tags>
  </entry>
  <entry>
    <title>Find all unique pairs of maximum and second maximum elements 子数组的最大值和次大值对</title>
    <url>/2019/12/14/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/</url>
    <content><![CDATA[<p>问题的根源是有个同学问了个lucky number的问题<a href="https://codeforces.com/problemset/problem/280/B">Codeforces 280B</a>, <a href="https://codeforces.com/problemset/problem/281/D">Codeforces 281D</a>也是同样的问题。</p>
<p><a href="https://www.geeksforgeeks.org/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/">Find all unique pairs of maximum and second maximum elements over all sub-arrays in O(NlogN)</a></p>
<p>幸运数的定义为：数组中子数组的最大值和次大值的XOR值。寻找所有幸运数中的最大的。</p>
<p>Brute force 的解法是枚举所有的子数组，时间复杂度为O(N ^ 2).<br>有没有更优的方法呢？<br>今天要讨论的就是这个问题。</p>
<h2 id="通用的解法，快速寻找-最大次大值对-算法"><a href="#通用的解法，快速寻找-最大次大值对-算法" class="headerlink" title="通用的解法，快速寻找 最大次大值对 算法"></a>通用的解法，快速寻找 最大次大值对 算法</h2><p>寻找子数组中最大值和次大值其实是有快速算法的:<br><a href="https://www.geeksforgeeks.org/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/">Find all unique pairs of maximum and second maximum elements over all sub-arrays in O(NlogN)</a></p>
<p>基于这个的观察：数组中的每个数，如果想要成为次大值，就只能和向前的第一个比他大的数 或 向后的第一个比他大的数组成。<br>我们可以维护一个 单调递减栈，加入新数时，维持单调递增需要弹出所有小于它的数，这时新数就是被弹出来的数后面的第一个比他大的数；栈顶中最大的数 就是 新数 向前的第一个比他大的数。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">nums</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;ll&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, nums[i] ^ st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, nums[i] ^ st.<span class="built_in">top</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="built_in">solve</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="我独立思考出的解法"><a href="#我独立思考出的解法" class="headerlink" title="我独立思考出的解法"></a>我独立思考出的解法</h2><p>我的解法利用了XOR的性质，如果换成别的运算就不通用了。</p>
<p>首先遍历一遍找到最高的位数。<br>再遍历一遍找到最高的位数为1的那些数，我们先称其为 最高数。<br>从这些最高数出发，往两边扩充，直到遇到另一个最高数，在这个过程中寻找次大数并更新幸运数的最大值。可以证明，每个数最多被找2次。<br>所以，总的时间复杂度是 O(N), 空间复杂度 O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">nums</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_BIT_BEGIN = <span class="number">40</span>;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">flag</span>(MAX_BIT_BEGIN + <span class="number">1</span>, vector&lt;ll&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (ll i : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt;= MAX_BIT_BEGIN; ++j) &#123;</span><br><span class="line">            ++flag[j][((i &gt;&gt; j) &amp; <span class="number">1</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll max_bit = MAX_BIT_BEGIN;</span><br><span class="line">    <span class="keyword">for</span> (; max_bit &gt;= <span class="number">0</span>; --max_bit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[max_bit][<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; flag[max_bit][<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max_bit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (max_bit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vector&lt;ll&gt; max_bit_is_1_indexs;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((nums[i] &gt;&gt; max_bit) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                max_bit_is_1_indexs.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll index : max_bit_is_1_indexs) &#123;</span><br><span class="line">            ll second_max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ll i = index - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; ((nums[i] &gt;&gt; max_bit) &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">                 --i) &#123;</span><br><span class="line">                second_max = <span class="built_in">max</span>(second_max, nums[i]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, nums[index] ^ second_max);</span><br><span class="line">            &#125;</span><br><span class="line">            second_max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ll i = index + <span class="number">1</span>; i &lt; N &amp;&amp; ((nums[i] &gt;&gt; max_bit) &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">                 ++i) &#123;</span><br><span class="line">                second_max = <span class="built_in">max</span>(second_max, nums[i]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, nums[index] ^ second_max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="built_in">solve</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>用gitbook写一本书</title>
    <url>/2019/07/16/gitbook/</url>
    <content><![CDATA[<p>与博客不同，一本书相对内容更为完成，更为体系。博客相比之下就零散的多。不过优秀的系列博客也常常被改编成书。<br>如果你想分享规模更大，成体系的知识的话，写本小书是个很好的选择。<br>本文介绍一个工具<code>GitBook</code>，可以用Markdown写书，放在GitHub上，生成网页版和PDF版本的书籍。相较传统的Latex，更简单方便。适合当代程序员。</p>
<p>本文参考的资料主要来源于<a href="https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md">官网</a>，相较之下，重点更突出，可以快速地 初始化、撰写、发布 一本书。</p>
<p>Install gitbook command line tool:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install gitbook-cli -g</span><br></pre></td></tr></table></figure>

<p>Create a book:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitbook init ./directory</span><br></pre></td></tr></table></figure>

<p>Preview and serve your book:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitbook serve</span><br></pre></td></tr></table></figure>

<p>Or build the static website:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitbook build</span><br></pre></td></tr></table></figure>

<p>Debug for better error message with stack trace:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gitbook build ./ --log=debug --debug</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
  </entry>
  <entry>
    <title>为GitHub Page绑定自己的域名</title>
    <url>/2018/05/07/github-page-binding-domain/</url>
    <content><![CDATA[<p>我使用的是腾讯云的免费域名.</p>
<p>除此之外, github上也需要进行一定的设置, 可以参考<a href="https://help.github.com/articles/about-supported-custom-domains/">官方帮助文件</a>.</p>
]]></content>
  </entry>
  <entry>
    <title>gogogo</title>
    <url>/2016/11/09/gogogo/</url>
    <content><![CDATA[<p>最近经历了两件事情, 使得我感觉需要反思一下近几年的自己.</p>
<p>第一件事是, 昨晚的编译测试一没过, 具体地说是正确的程序没有跑出正确的结果. 编译测试让我想起两年前的计组测试, 进而想了很多.</p>
<p>第二件事是, 今天早上的编译课上的小测, 第二道题完全不会, 想要抄别人的也没有的抄, 周围人没有靠谱的, 靠谱的不在周围. 这让我再次认识到, 只有自己才是最靠得住的, 如果自己都靠不住, 那就没人可以真正依靠了.</p>
<h2 id="往者"><a href="#往者" class="headerlink" title="往者"></a>往者</h2><p>大一时抱怨数学课太多, 大家纷纷在说说上晒课表, 说”我上的是计算机系, 不是数学系”之类的. 现在看来, 当时真是太naive, 事实上, 现在的我最喜欢数学课了, 而不是计算机课. 究其原因, 当时的专业课只有C语言, 当时的大计基python也确实对计算机学习很重要, 但这些比起现在的专业课真是太简单了. 对于可怜的GPA来说, 大一是最重要的, 因为那些我们不喜欢的数学课, 英语课占的学分很多. 一个学长告诉我说, 你的成绩基本上大一就已经定了. 现在看来, 确实是这样, 只有对自己的无能更加愤怒.</p>
<p>大二上抱怨计组太难, 6系不是人呆的地方. 熬夜成了家庭便饭, 考期甚至有两门课需要刷夜, 经历了胸闷心痛的感觉. 大二下抱怨OO制度没人性, OS实验懒惰没有申优.</p>
<p>大三到了该考虑出路的时候, 才发现别人是从一上大学就有了目标并为之奋斗四年, 现在到了即将收获果实的季节; 而自己却发现很多事情都已经为时甚完了; 要GPA, 有前两年的基础, 现在已经很难获得提高了; 要语言考试的成绩, 自己六级飘过的水平, 加上懒惰的习惯, 很难将命运全然托付之; 要找工作, 进顶尖公司, 赚大钱, 自己没有竞赛经验, 算法渣的一比, 自己都羞愧的向优秀的学长道歉. 感觉自己难道真的成了扶不起的阿斗了?</p>
<h2 id="出路"><a href="#出路" class="headerlink" title="出路"></a>出路</h2><h4 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h4><p>这条路是最有可能也是现在面临的最轻松的一条路了, 但看着自己可怜的GPA, 现在已无力力挽狂澜, 只能任人宰割. 外推是绝无可能了, 甚至保本校我都不敢打包票, 毕竟后面还有一大堆加分的.</p>
<h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><p>就像舍友zjy说的, 自己什么都不会, 哪里有公司会要呐. 我和他的处境类似, 虽说2年半来认真学习专业知识, 但无论是深度还是适合度, 都与市场上的需求相差甚远. tls自然不同担心, 有ACM的丰富经验再此, 无论是出国留学还是进入国际顶尖公司, 固然是走上人生巅峰了.</p>
<h4 id="留学"><a href="#留学" class="headerlink" title="留学"></a>留学</h4><p>说起来, 自从2016年暑假去英国呆了两周, 竟然有了出国深造的想法和勇气. 没想到已半年过去, 锐气已然消失, 但信念仍存. 虽无背水一战的勇气, 但也有不屈服命运的倔强.</p>
<h4 id="创业"><a href="#创业" class="headerlink" title="创业"></a>创业</h4><p>这个选项是留给别人的, 我从来都是想也不敢想. 没有资金, 没有人脉, 没有强爹, 没有素质, 也没有勇气.</p>
<h2 id="来者"><a href="#来者" class="headerlink" title="来者"></a>来者</h2><p>新的一年, 新的学期. 这一年, 至少将决定接下来2年的发展, 甚至会决定一生的命运.</p>
<p>加油!</p>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>游记 | 穗港澳</title>
    <url>/2018/10/09/guangzhou-tour/</url>
    <content><![CDATA[<p>国庆节后，我和二师兄有机会前往广东，依次游览了广州、澳门 和 香港。10月6号从北京出发，坐10个小时高铁，来到广州南站，之后落塌广东大厦。</p>
<h2 id="广州"><a href="#广州" class="headerlink" title="广州"></a>广州</h2><p>第一天先歇一天，在广州玩。早起去爬越秀公园。由于是长假的最后一天，年轻人都玩累了躺在家里休息，大街上和公园里只能看到大量的中老年人在锻炼身体。在公园里，我终于亲眼看到了生长在南方的“木棉”。想起《致橡树》中的诗句，“我愿做你身旁的一株木棉…“；和 《致橡树》电视剧中的情节。橡树 和 木棉 分别生长在北方和南方，注定不能生长在一起。知道这一点的话，才能体会到《致橡树》中传达的悲伤的情感。</p>
<p>之后到了9点，吃早茶的时间。我们来到“陶陶居”–广州很有名的早茶连锁店，一起吃早茶。早茶是广东的特色。算是早餐，但是可以吃一上午。很多本地人会每天吃早茶，在那里喝一上午的茶，聊一上午的天。很佩服那些吃早茶可以吃一上午的人，羡慕他们的悠闲自在。我是绝对坐不住的，也坐不起。每天早上不学习工作的话，我估计很快就会被淘汰、饿死。早茶 主要包含茶和茶点。一上来会给你一个小盆，后来我才知道是用来涮餐具的。用滚烫的茶水清洗盘子和碗筷，既消了毒，又给餐具带来了茶的清香。茶可以无限续杯，否则怎么坐一上午呢。茶点真是好吃极了，此行不虚。</p>
<p>吃完早茶后，时间还早，我们就去了城南的沙面公园玩。这里有大量租借时期的建筑和遗留。我很喜欢这里。有很多家长带着来自在公园嬉戏，西式建筑也很符合我的口味，每栋都有自己的特色，因为是不同国家修的。让我想起天津的租界和老房子。在这里，我们还误打误撞进了一家豪华的酒店–白天鹅。二楼的自助餐给我留下了深刻印象。385一位，但由于当天还是国庆假期，425一位。我们进去看了看就出来了，还是等以后有钱了再光临这里吧。我对这里的深刻印象不是因为这里的自助餐有多豪华、多可口，而是这里的位置。落地窗外就是珠江，给人一种整座酒店浮在珠江上一样。满足了我对有钱人奢华生活的想象。这样贵的酒店，生意竟然特别好。更是有人包下整个餐厅举办婚礼。中国有钱人真多，贫穷限制了我的想象。我等屁民，还是紧衣缩食，看看就好了。</p>
<p>中午吃饭的时候去了一家网红店–吴财记云吞面。位置极其偏僻，人还居多，几乎座无虚席，等的时间还很长。好在味道还可以。我点的炸云吞，不过二师兄点的云吞面味道就一般了。城南是老城区，怎一个破字了得，一点也没有一线城市的氛围。不过晚上到天河区后，就知道，广州当得起一线的地位。</p>
<p>吃完饭后坐地铁回酒店休息。4点时出发去 中山大学（也叫 双鸭山大学）参观。中山大学的校园很漂亮，妹子也特别多，有个门直接面向珠江，顺江而上就是广州塔。我们骑单车沿着江、跨过桥，总算来到最繁华的天河区了。在这里我们体验了资本主义的奢华和腐败，从此励志好好学习，做共产主义的接班人。我们晚上在地下商场的网红店吃了 鸡煲。打算找个超市买点水果和早餐就回酒店。跟着导航到了一家附近看起来不错的超市，进去后，才一脸蒙蔽，太贵了，消费不起。在二师兄的怂恿下，我破费了一码，买了价值50元的一小盒指头大小的西瓜。最后证明，小西瓜巨难吃，全都浪费了。二师兄这次旅程中都是，聊什么吃的都吹牛说巨好吃。除此之外，没有其他形容词了。等我真正吃到是，发现大多数都一般般，少数食物倒是挺好吃的。我不是个吃货，对这些也没有研究和感受。吃了更多的也是浪费。</p>
<p><img src="/images/zaocha.jpg" alt="巨好吃的早茶"></p>
<h2 id="澳门"><a href="#澳门" class="headerlink" title="澳门"></a>澳门</h2><p>去港澳的行程是早就规划好的，也正是这两个特别行政区吸引了二师兄，否则，单单一个广州他是不会和我来的。我提前一个月办好了港澳通行证，当时还经历了一些小波折。出入境管理中心的网站今年更新了，但最近新系统一直处于宕机状态。不知道是有意还是无意，但这无疑很大地提高了公民出境的难度。我等不到系统修复了，只好去不需要预约的海淀出入境大厅办理了港澳通行证。从办理到收到，算上休息日一共14天，效率还可以。二师兄是在我之后办的。他的做法是不停地刷新预约系统，偶尔就可以进去，完成了预约，在花园路派出所就直接办了，而且还办了二次往返的签注。我只有一次出入境的签注，但已经足够了。</p>
<p>去澳门的路线是乘坐广州-珠海的城际高铁，10分钟一趟公交化运行及其方便。从珠海站下来就是拱北口岸，步行可过关。来到澳门一侧后，就是停车场，有各大赌场的免费接送班车，可以方便的前往凼仔和澳门半岛。我们随便找了一家大巴就走了，最后来到了威尼斯人。</p>
<p>澳门以赌场闻名。如果说，香港金融中心的地位在大陆有近有广州、远有上海的竞争；澳门的优势可是独一无二的。此次去澳门，真的是长见识了。<br>我们先后去了2家赌场，威尼斯人 和 银河。上午在威尼斯人，我们赢了130港币，中午去官也街吃喝，很快就把赢了的钱挥霍完了。下午赌意未尽，又去了另一家大赌场–银河。此次输了100港币，悻悻而退。小赌怡情，大赌伤身。当我拿着ticket去兑换400港币(取了500，输了100）时，前面2个其貌不扬的大叔，兑换的是筹码，兑换的结果有大概10cm厚的几沓1000港币的现金，看上去有几十万。真是不能以貌取人。赌场还是有钱人玩的地方。我们花了100块体验一下就好。与银河的缘分在于，晚上我们打算回拱北口岸时，坐公交方向坐反了，最后又从澳门半岛回到了凼仔的银河赌场。之后干脆在银河吃了晚饭(KFC，这些天二师兄吃快餐都要吃吐了)，坐赌场的大巴回拱北口岸了。</p>
<p>下午我们还去了澳门半岛，参观了著名的 大三巴牌坊，逛了附近的街市。<br>这里也有很多赌场，包括 新旧葡京。我们最后克制住了赌意，一是没钱，二是已经玩的很累了，就像找个地方休息。黄赌毒不能碰，真的是太有道理了。根本克制不住自己的，干脆就不要沾染的好。<br>大三巴牌坊其实是一个古老教堂的前墙，后来教堂由于大火毁坏，只留下了这面墙。后来成为历史课本上象征澳门的标志。</p>
<p><img src="/images/dasanba.jpg" alt="大三巴牌坊"></p>
<h2 id="香港"><a href="#香港" class="headerlink" title="香港"></a>香港</h2><p>香港比澳门大的多，我们把最后2天的时间都留在香港了。今年，广州和香港的城际高铁已经开通，每半个小时一趟。乘客只需在香港西九龙站一地两检，十分方便。随着10月份珠港澳大桥的正式开通，珠三角的城际交通会更加方便。我们于10号晚乘坐高铁到达西九龙，出站后就可以换乘地铁。吐槽一下香港的地铁设计。香港地铁不像国内的地铁，换乘站地铁站不只是一个地铁站，还是一个商场。线路换乘就更复杂了，你要在商场中穿梭，甚至有时需要先出站后进站，十分不方便。换乘的线路标示还算清晰，但有个问题是，你跟着指示来到了正确的位置，没有标示告诉你到了。另一方面，地铁报站每站途中只报一次，到站了也不报；不像国内地铁，不停地报站，到站了使劲地告诉你到达哪站了，生怕你坐过站。我们刚去的时候一脸捉瞎，不过很快就适应这些问题了。但用户体验还是极差的。</p>
<p>图便宜，我们订了一家每晚近600RMB的酒店（皇悦酒店）。果然便宜没好货。香港的酒店外观、走廊、服务人员都不错，只是房间极其狭窄局促，被褥也很潮湿。住2天我们就受不了了，再住下去就要疯了。早就听说香港“居大不易”，现在可算有了切身体会。香港繁华是繁华，居家过日还是不适合的。<br>前台的糖巨还难吃，就不能像内地一样放些好吃的薄荷糖嘛，毕竟客户都是内地的呀！</p>
<p>第一天，以游玩迪士尼乐园为主，晚上去吃了网红的牛腩面。迪士尼乐园可能比不上很多游乐场(包括 大家一直推荐的海洋公园)，年代久远，世界上最小的迪士尼乐园，但这一天我们玩的还是非常开心的。因为在这个地方，我不需要考虑生活的琐碎，人生的规划，只需要像一个孩子一样玩耍就好了。这种感觉很久违了。由于是工作日，乐园的游客比较少，大多数项目都不需要排队。工作日出来玩的，除了我们这样的傻逼，可能就只有富二代们带着孩子出来玩了。很多年轻夫妇看上去确实不像穷人，穷人现在肯定都在哼哧哼哧地工作或者学习呐！</p>
<p>第二天，我们以太平山观光和购物为主。一大早，坐有名的“叮叮车”来到太平山底。<br>买了缆车上行和摩天阁的套票，之所以没买往返的缆车，是因为攻略上建议下山的时候可以乘坐巴士，体验不同的交通工具。“缆车”名为“缆车”，其实和我们在其他山上做的缆车完全不同，更像是有轨电车。不过这个有轨电车是登山用的，上山期间基本上坡度特别陡，有时能达到45度。是次不错的体验。<br>到达太平山顶的摩天阁，就可以俯瞰整个香港了。当天的天气特别好，蓝天白云。香港岛和新街尽收眼底。ifc、维港、和其他所有的地标建筑，都可以看到。大有一种指点江山、激扬文字的快感。不过在上面看个一个小时大概也就够了，都是那些建筑和景色，除非换个时间段，否则全无新意。我们在港呆的时间有限，否则傍晚过来，或者晚上过来看维港的灯火，都是很不错的选择。<br>太平山也是我到过的最靠南的地方了。<br>我们按照攻略上的指示，乘坐了小巴士。司机带着我们在蜿蜒的山路上疾驰，时不时有做过山车的感觉。说实话，香港的司机开车真是快，就是不知道有没有香港的记者快。乘坐巴士的好处是可以一路做到维港边的ifc楼下，而我们下一站的目的地就在于此，ifc的apple store。来香港购置电子产品尤其是苹果家的手机电脑应当是不错的选择，汇率加上税收优惠可以省上不少钱。所以此次我们二人揣了2部iPhone xs，一台Macbook Pro就出境了。<br>下午从ifc坐船渡过海峡，来到尖沙咀的海港城购物，二师兄主要想去那里买些衣服和化妆品。由于玩了一天都没有休息，到了诺大的商场二人都很疲惫了。而且海港城店铺的设置和大陆的有很大区别，我们找店找餐厅就废了很大劲。外加上衣服并没有很实惠，想帮大师兄代购的索尼耳机竟然还没大陆便宜。基本上空手而归，人逛的也很疲惫。到了最后我基本到了一家店就找地方坐着或躺着，等二师兄逛完就走。<br>海港城离西九龙高铁站已经很近了，所以我们边走边逛，来到高铁站。然后坐上高铁回广州了。<br>回到广州，躺在上广东大厦的大床上，觉得还是广州的酒店好。起码床铺是干燥的，房间空间也大的多。</p>
<p><img src="/images/%E5%A4%AA%E5%B9%B3%E5%B1%B1%E9%A1%B6.jpg" alt="太平山顶"></p>
<h2 id="北京"><a href="#北京" class="headerlink" title="北京"></a>北京</h2><p>10月13号，我们坐上高铁，沿着京广线一路向北，回到帝都。下午6点一回到北京，甚至还在地铁上，就觉得整个人感觉都不一样了。没有在外的很皮、很想玩的心情了，整个身心都收回来了。满脑子想的都是这一周挤压的工作和荒废的学业，想想也是，从中秋节开始放飞自我，有半个月没有好好学习了。二师兄也很佩服我，在外很浪，但一回到北京很快就可以重新进入状态。<br>我从来不是一个能玩会玩的人。这次出门可多地方承蒙二师兄的照顾，很多事情的是他在操心，偶尔我试着操心带带路还带错了。我生来就是不会操心的人，在学习生活中因为这样还经常把事情办砸。当然这样的性格也有很多好处。比如，我可以轻松地专心做一件事情；想的少，相应的烦恼也少。凡事都是双刃剑。我接受这样的自己，但也尝试寻找一个平衡，虽然不会操心，但往往该操的时候还是要操的。</p>
<p>虽然已经在帝都呆了4年了，但最近的我一直有种强烈的感觉：自己以后不会定居在这里。一来，北京居大不易，户口卡的很死；二来，外面的世界诱惑太大，机会也很多。将来会漂泊在何方呢？无论最后的答案是什么，我都希望是自己的选择，在任何地方都要活得精彩。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>travel</tag>
      </tags>
  </entry>
  <entry>
    <title>gvim configuration for windows</title>
    <url>/2017/03/26/gvim-configuration-for-windows/</url>
    <content><![CDATA[<p>最近由于准备GRE, 整天背单词, 练听力和写作, 很是心烦, 很久没折腾了, 所以抽出时间, 给自己的笔记本下载并配置gvim, 也算是休憩.</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a><a href="http://www.vim.org/download.php#pc">下载</a></h1><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>与Linux不同, Windows中gvim的配置文件为<code>$HOME/_vimrc</code>(个人配置文件), <code>$VIMROOT/_vimrc</code>(系统配置文件), 默认情况下为<code>C:\Program Files (x86)\Vim</code>. 除此之外, 还可以有<code>_gvimrc</code>文件, 只有在gui情况下打开才会读取, 在terminal下不会. 这对于两者应用不同的配置很有帮助, 尤其是使用不同的主题, 同一主题下, 两者的效果很不同. 这样就避免了使用<code>if(has&#39;gui_running&#39;)</code>这样复杂的配置内容.</p>
<h1 id="vimrc配置"><a href="#vimrc配置" class="headerlink" title=".vimrc配置"></a>.vimrc配置</h1><h2 id="打开配置文件"><a href="#打开配置文件" class="headerlink" title="打开配置文件"></a>打开配置文件</h2><ul>
<li><code>:e $MYVIMRC</code>: 打开用户配置文件, 如果没有的话可以参考<code>help vimrc</code></li>
<li><code>:e $MYGVIMRC</code>: 打开GUI用户配置<br><code>help vimrc</code>中推荐的配置文件位置是<code>$HOME/vimfiles/vimrc</code>(Windows)或<code>~/.vim/vimrc(Windows)</code>, 这样比起<code>$HOME/_vimrc</code>和<code>~/.vim</code>更portable.</li>
</ul>
<h2 id="个性化内容"><a href="#个性化内容" class="headerlink" title="个性化内容"></a>个性化内容</h2><p>$MYGVIMRC</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> clipboard=unnamed   <span class="comment">&quot; 与Windows公用clipboard, 默认情况下, y, p只使用vim的clipboard, 不是很方便</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">colorscheme</span> monokai <span class="comment">&quot; 一个我比较喜欢的主题, 不过在terminal下很难看, 所以放在gvimrc中</span></span><br><span class="line"><span class="keyword">set</span> guifont=Consola<span class="variable">s:h18</span>:cANSI:qDRAFT   <span class="comment">&quot;换个字体, 默认字体忍不了</span></span><br></pre></td></tr></table></figure>

<p>$MYVIMRC</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="keyword">set</span> nobackup    <span class="comment">&quot;不产生~文件</span></span><br><span class="line"><span class="keyword">set</span> noswapfile  <span class="comment">&quot;不产生.swp文件</span></span><br><span class="line"><span class="keyword">set</span> noundofile  <span class="comment">&quot;不产生.un文件</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span>  <span class="comment">&quot;默认为cp936, 改为与系统兼容的utf-8</span></span><br><span class="line"><span class="keyword">set</span> fileformat=dos  <span class="comment">&quot;换行符以\r\n为准</span></span><br><span class="line"><span class="keyword">set</span> fileencoding=utf-<span class="number">8</span>  <span class="comment">&quot;与系统兼容</span></span><br><span class="line"><span class="keyword">syntax</span> enable</span><br></pre></td></tr></table></figure>
<h2 id="markdown支持"><a href="#markdown支持" class="headerlink" title="markdown支持"></a>markdown支持</h2><p>vim的插件可以说可以满足你的任何需求, 然而在这里我不是用vim插件, 而是使用chrome extension满足自己的需求. 理由是配置更简单, 未来其他编辑器也可以利用.</p>
<p><a href="https://github.com/volca/markdown-preview">插件安装和使用说明</a></p>
<p><strong>绑定快捷键.</strong> 在vimrc中加入:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; Open markdown files with Chrome.</span></span><br><span class="line"><span class="keyword">autocmd</span> BufEnter *.md <span class="keyword">exe</span> <span class="string">&#x27;noremap &lt;F5&gt; :!start C:\Program Files (x86)\Google\Chrome\Application\chrome.exe %:p&lt;CR&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用时按<code>F5</code>就可以了.</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇post就是用<code>gvim for MS-WINDOWS</code>完成的.</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>我的投资故事（持续更新）</title>
    <url>/2021/03/22/investment/</url>
    <content><![CDATA[<p>分享我的投资故事。<br>首发于 <a href="https://youngforest.github.io/2021/03/22/investment/">Forest的博客</a>.</p>
<h2 id="初出茅庐"><a href="#初出茅庐" class="headerlink" title="初出茅庐"></a>初出茅庐</h2><p>小时候，没啥理财习惯和资本。一是没零花钱，二是压岁钱基本需要上交。有一年，大概是为了培养我的理财意识，爸爸带我去建设银行开了户，几百块钱的压岁钱给我补齐到一千，存进了存折。定期一年，自动复利。</p>
<p>本身是很好的开端。大概是我家对钱的追求不那么在意，这笔钱竟然忘记了。我之前设置的密码也说是不对。后来长大了竟然取不出来了。<br>而且一开始是通过户口本办的。当年小孩子都没身份证，不像现在。<br>后来去建设银行说了这个事情后，工作人员说必须开户整周年的当天才能取出来。也是醉了。<br>后来我过上了北漂生活，半年才能回一次家。赶不上时间，也怕麻烦，这笔钱竟然就一直在那里。</p>
<p>这次理财经历算是一次失败的教训，毕竟本金都取不出来了。</p>
<h2 id="再试牛刀"><a href="#再试牛刀" class="headerlink" title="再试牛刀"></a>再试牛刀</h2><p>上大学后，终于有独立花钱和管钱的权限了。一开始，只是父亲给的生活费和学费；再到后来有了不菲的奖学金和助教工作收入，基本实现了经济独立。因为花费和收入都较少，也没有专门打理；学成一定之后，有了实习工作，开始每天三百，之后每天四百，竟然有了几万的积蓄。这时候，我看到自己挣得钱，第一反应是存起来，就有了理财的再试牛刀。</p>
<p>当时余额宝和朝朝盈的收益还不错，绝大多数钱都放在里面，也不用操心。后来了解到基金这么个玩意儿。虽然之前父亲买过基金，还赔了钱。不过好在他一直没取出来，之后也一直没看，也不能叫赔。现在说不定还赚了不少也是有可能的。我想当然认为自己也可以。而且当时已经到了2018年，在支付宝上买卖基金十分方便。我梭哈了支付宝给我推荐的一只鸡：嘉实环保低碳股票。支付宝说该基金过往收益多牛，我也觉得环保是未来的方向，就买了6千块钱的。</p>
<p>先说结论，又一次失败的理财投资。也是第一次当韭菜，感觉到资本市场的寒冷。最后清仓时赔了1600元，持有时间半年。<br>总结几点教训：</p>
<ul>
<li>相信支付宝的推荐，没有自己的思考。要知道，APP或其他经理推荐给你的不一定是能让你挣钱的，但一定是可以让它们挣钱的。所以不要听信其一面之词，而是要有自己的思考和理解。大多数时候，APP的推荐都是不靠谱的。</li>
<li>持有时间过短。当是持有了半年，割肉离场，后来2年多时间没大规模碰基金。我以为已经是坚持挺长时间的了。后来发现基金持有基本上是要以年为单位的。基金持有大于3年也绝不是空穴来风。后来发现该基金确实后来有涨了上去，而且涨的不少。不过这些都是在我清仓后面几年的事情了。</li>
<li>一开始就碰股票基金，而且是比较激进的行业型基金。涨的快回撤也大，一般人确实遭不住。环保确实是未来的方向，但这个未来可能以年甚至十年来计，绝不是我能hold住的。新手一开始应该购买货币基金（也就是余额宝之类的），然后是债卷基金，最后是股票型的指数基金。行业基金能不碰就不碰，如果碰了，你一定要对该行业有独特的信仰，支撑你坚持下去。</li>
</ul>
<p>本次被割之后，我之后就很少碰基金了。只有一次小额投资。<br>读研之后，有一次上党课。有个讲国际关系的老师说石油要涨，推荐大家买石油。我买了500块钱的QDII的石油基金，后来持有半年收益10%，然后清仓了。这也是我第一次从基金上挣钱。总结经验是党课还是挺有用的，研究国际关系的老师还是牛逼的。追随他们确实顺从国际大势，从中获利。</p>
<h2 id="韭菜归来"><a href="#韭菜归来" class="headerlink" title="韭菜归来"></a>韭菜归来</h2><p>疫情过后，由于全球各国放水印钱，各国故事都开始疯涨。基金和股票也重新回归大众的目光。<br>我也再次没有忍受住诱惑，加入到“韭零”后买基大军。<br>大概是20年4月份，我陆续买了1500块基金，集中于地产和银行。大多数持有半年，2只基持有一年。<br>总的还说是收支平衡（靠2只银行基金，最后小盈利几十块）的一次失败投资。教训主要是：</p>
<ul>
<li>追涨杀跌。把跌的卖了，此时亏了60块，继续持有涨的2只基。虽然这2只基不负众望，1年涨了10%，弥补了一些损失，但相比同期沪深300啥的也是比不过的。</li>
<li>在基金最热的时候入场，买在了高点。正所谓巴菲特说的“别人贪婪我恐惧，别人恐惧我贪婪”。我在大家贪婪时入场，果然买在高点。即使是后来盈利的2只基也是买到了高点，只涨了10%。如果在高点前或跌了后买会更划算。</li>
<li>again，持有时间不够长。从心理上没有做好长期持有的打算，也没有忍受回撤的能力。</li>
</ul>
<p>转眼来到21年，此时全球疫情继续，股市继续火热，我作为韭菜又入场了。这次是火热的白酒。我本次投资主要买了白酒/消费和沪深300指数基金。买前包括买后还补习了不少基金知识，稳定自己的信心。<br>然而又是高点（事实上是高点前一点）。目前已经亏了13%，大概300块了。最多时候亏17%，400块。<br>不过本次我做好了长期持有（3年），装死卧倒不动的打算（其实也算是被套牢了）。而且仍然继续加仓，以实现传说中的右侧交易。只要我不割肉卖出，就不算亏。而且基金便宜了，更要买入了。相信随着疫情的过去，全球经济会缓慢恢复的。<br>另外一个经验是，沪深300确实比大多数基金经理更牛逼。涨的时候可能比不上行业基金，但市场波动，抱团股下跌的背景下，谁优孰劣就知道了。</p>
<p>未来我会继续关注和学习投资和基金，是不是韭菜，只能10年以后再见分晓。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>money</tag>
      </tags>
  </entry>
  <entry>
    <title>景弛（文远之行）面试</title>
    <url>/2018/09/28/jingchi-interview/</url>
    <content><![CDATA[<p>昨天参与了景驰科技的实习生面试。此次实习生面试是实验室统一安排的，并不是我自己找的。<br>形式为在线面试。总共2轮，预计每轮1小时，实际上第二轮只问了半个小时。第一轮用的Skype，通话质量比较差，视频输出也没有。第二轮，用的微信语音 + <a href="http://collabedit.com/">collabedit</a>。效果好了很多。</p>
<p>技术面都很简单。因为是招数据标注平台的码农实习生嘛，自然要求超级低。感觉自己要被廉价卖掉了。</p>
<span id="more"></span>

<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>一面问了项目和一道<a href="https://leetcode.com/problems/valid-parentheses/description/">括号匹配</a>的问题。</p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>二面问了项目和一道<a href="https://leetcode.com/problems/3sum/description/">三数之和</a>的问题。过程中，因为我在简历里写的项目是 大三时在act云计算和系统安全组实习做的一系列项目 和 大四做的毕设。尤其是大三的项目，都是琐碎的小项目，而且年代过于久远，很多细节我都记不清了。所以，我干脆提到了我大四做的2次实习。当听到我曾经在快手实习过3个月后，Eric(二面的面试官)很感兴趣。和我聊了一会儿实习的经历，就开始聊景驰的一些技术细节和在景驰科技实习的要求。</p>
<h2 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h2><p>下午回到宿舍后，HR小姐姐又给我打了20min电话，也就是聊了一些实习和公司的问题。通过这次交谈，我也对景驰科技有了进一步的了解。<br>景驰总共只有150人，总部在广州。在北京和硅谷有研发中心。其中北京这边刚刚建立，只有七八个人。硅谷那边有60+人。主要人员都集中在广州。<br>我还问了她transfer到硅谷的问题。她说，硅谷那边大多数在那边直接招的人，当然优秀的员工想要过去也是可以的(估计只是想吸引我)，甚至还有员工领着硅谷的薪水在中国工作。那岂不是年薪巨高（相对中国这边）。</p>
<p>从Eric和HR的谈话中，我感觉景驰真的很缺人。估计我们都会被招，毕竟便宜嘛。</p>
<p>我的计划是先实习3个月，认识一些人，学习一些技能。之后想办法再跳出来。继续实习下去，边际收益比较低。</p>
<p>总之，我现在时间已经不多了。做什么事情都要 不忘初心…</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>WeRide</tag>
      </tags>
  </entry>
  <entry>
    <title>kaggle入门之-titanic</title>
    <url>/2018/08/14/kaggle-titanic-tutorial/</url>
    <content><![CDATA[<p>为了更快地锻炼自己数据挖掘的能力，我计划最近一个月花一定的时间在kaggle比赛上。目前的计划是把<a href="https://www.kaggle.com/tags/tutorial">Tutorial</a>上的比赛、Datasets和牛人们的notebook跟完作为入门。之后再选择一个简单的常规比赛参加。<br>至于最后是否像欢哥一样走上数据挖掘竞赛之路，看入门之后的感受。自己是否愿意继续花大量的精力在上面。</p>
<p>数据挖掘的能力主要分为2部分：</p>
<ul>
<li>机器学习</li>
<li>特征工程</li>
</ul>
<p>之前在快手推荐组实习的时候，工作也涉及这些。推荐系统也算是数据挖掘的一个分支，从结果上看，是预测某个item是否会被用户点击。</p>
<p><a href="https://www.kaggle.com/c/titanic">Titanic: Machine Learning from Disaster</a>作为大多数人入门kaggle的第一步，确实是对数据挖掘技巧的集中体现。相反，最近在kaggle上比较火的比赛，都是和CV或NLP相关的。领域知识的要求更高，淡化了通用的数据挖掘技能。<br>在kaggle上还有许多<a href="https://www.kaggle.com/tags/tutorial">其他的教程</a>可供用户学习，我今后会选择其中的一些进行重点学习，争取在开学前入门kaggle。</p>
<span id="more"></span>
<p>Titanic训练的技能为：</p>
<ul>
<li>二分类(活/死)</li>
<li>Python/R 基础</li>
</ul>
<p><a href="https://www.kaggle.com/helgejo/an-interactive-data-science-tutorial/notebook">notebook link</a>这是我本次跟的notebook。<br>我把所有的代码都手敲了一遍，拒绝复制粘贴；该完成的Exercises也全部完成；对比赛的一般流程有了初步了解：</p>
<ul>
<li>题目理解</li>
<li>数据理解</li>
<li>数据预处理</li>
<li>机器学习建模</li>
<li>模型评估</li>
<li>提交结果</li>
</ul>
<h2 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h2><p>在问题描述中，一般会给出数据集的背景、每个challenge的目标、还有所需的技能。<br>还可以判断出需要哪些领域知识。比如在Titanic中，20世纪初 西方人的姓名、贵族爵位、船的相关知识都是极其有帮助的。</p>
<p>看完问题描述后，可以有自己基本的猜测：什么因素对是否存活影响最大？<br>我会想到 年龄和性别。媒体不是一直宣传沉船的时候，会让妇女儿童先走？<br>之后，我们会用数据分析的方式验证猜测是否合理。</p>
<h2 id="数据理解"><a href="#数据理解" class="headerlink" title="数据理解"></a>数据理解</h2><p>通过一些Python及其可视化的工具，我们可以快速对数据有初步的了解。</p>
<p>比如：<code>titanic</code>是存储所有原始数据的<code>pd.DataFrame</code>，<code>titanic.head()</code>可以显示最开始的5行，<code>titanic.describe()</code>显示所有特征的统计结果，包括最大值、最小值、缺失数量、均值方差等。<br>对所有原始特征有直观的了解后，可以知道，哪些特征是离散值，哪些是连续值，哪些需要预处理。</p>
<p>利用热力图，可以直观地看到不同特征之间的相关性。<br>对连续值，画出其分布图(<code>plot_distribution()</code>)；对离散值，画出箱形图(<code>plot_categories</code>).</p>
<p>通过这些技能，可以对<strong>选择哪些特征进行建模</strong>、<strong>如何进行数据预处理</strong> 心中有数。</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>对于离散值(Categorical variables)，需要将其转化为数值类型才能进行下一步的建模。<br>二类离散值可以简单地映射为(0, 1)，<br>多类离散值需要利用<code>pd.get_dummies()</code>进行one hot编码。</p>
<p><strong>对缺失值进行填充</strong>。由于真实数据采集过程中的不确定性，有些行的某些列是缺失的，这时有2种选择：丢弃整个行，用有意义的值填充缺失值。<br>在数据比较宝贵的情况(数据量小 或 缺失值过多）下，一般采取填充的方式。对于离散值，可以填充“Unknown”；对于连续值，一般填充其均值。</p>
<p><strong>特征工程</strong>。这是拉开不同选手之间水平的一项技能，需要一定的领域知识和对数据足够的敏感性。不过今年由于深度学习的原因，特征工程有被放弃的趋势。选手之前的差别主要靠调参。在Titanic中，如果你对20世纪初的西方足够了解的话，一些特征工程才能做。如，从姓名中提取出“Title”，是贵族、平民、还是职员。对船足够熟悉的话，可以从舱室提取出是几等舱，票号中提取出几等票。</p>
<p><strong>组装最后的数据集</strong>。数据集经过我们的预处理后，需要进行特征选择，并组装成可以进行建模的形式。一般是一个<code>pd.DataFrame</code>，还需要切分成 训练集(Train)、验证集(Valid) 和 测试集(Test)。</p>
<h2 id="建模-和-模型评估"><a href="#建模-和-模型评估" class="headerlink" title="建模 和 模型评估"></a>建模 和 模型评估</h2><p>这里也是大量工作所在。常用的机器学习模型要一个一个试，每个的参数也要进行调整后再试，然后用验证集评估，选出最好的。<br>很多时候，还需要回到数据预处理的部分，选择不同的特征，进行不同的特征工程，再回来进行建模和评估。</p>
<p>这部分属于枯燥的实验部分，因为需要大量的尝试和选择。当然，可以写自动化的脚本加速这些工作。</p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>提交比较简单。主要是需要注意提交的方法和格式。一般比赛都会给一个提交的模板，帮助参赛者理解所要求的格式。</p>
<p>我第一次提交因为预测值没有从浮点数转化为整数，分数只有0。之后解决这个问题后，获得了0.77033这样的分数，排名6242/9939。<br>这次提交算是对整个流程的一次体验。<br>我之后会继续特征工程和调参，以获得更高的分数。<br>牛逼的是有很多人满分，之前听说会有泄露预测信息到特征中的bug，不知道是不是这个原因。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>据今年找工作的师兄们和网络上的消息，今年算法工程师的岗位竞争十分激烈。很大程度是因为算法岗的高薪资，和去年毕业生尝到的甜头。大家纷纷从开发岗转去算法岗。众多数据挖掘的比赛也因此十分火爆，kaggle就是其中最火的一个比赛平台。我也打算花1个月时间蹭蹭热度，看看自己有没有做算法的天赋和能力。</p>
<p>在kaggle上，我首先关注了欢哥(mgchbot)，和大师兄(sparkingarthur)。看了他们的Profile，真是很厉害的人呐。尤其是欢哥，不愧是KDD的双料冠军。大师兄也不赖，平时在我面前特别谦虚（也可能是欢哥这样的人一直在身边吧）。他们的kaggle排名分别是100，和1000（现在共有超过8w人）。由于我还没有任何比赛结束，所以排名为Unranked。向优秀的人学习，因为有40w+户口的诱惑。</p>
]]></content>
      <categories>
        <category>kaggle</category>
      </categories>
  </entry>
  <entry>
    <title>Kick start 2019 round A</title>
    <url>/2019/03/24/kick-start-2019-round-A/</url>
    <content><![CDATA[<p>[题目链接]</p>
<p>这是我首次参加Kick start比赛。之前本科的时候，和舍友tls 参加过它的前身Code Jam。今年才正式准备Kick start的一系列比赛。原因是这是Google选拔软件工程师的途径，而Google是我的Dream Company。<br>我于5月22日在清华参加了Google的校园宣讲会。在宣讲会上，前辈们也分外强调准备和参加Kick start的重要性。GG作为一家很左的公司，分外强调公平。而Kick start就是实现招聘公平的一个工具。毕竟相比其他公司的过分注重内推，Kick start给了弱势学校的学生一个机会。</p>
<p>由于平台故障，最后25min无法提交。虽然我提前一个小时放弃比赛了，但是晚上收到邮件告知这个bug。如果没有这个Bug的话，我的排名可能还要后退。<br>最后的排名是 600/3305.<br>得分分别为<br>| | Training  | Parcels | Contention | Total |<br>|–|–|–|–|–|<br>| 我的 | 20 | 15 | 0 | 35 |<br>| 总分 | 20 | 35 | 45 | 100 |</p>
<p>也就是说，我过了签到题和第二题的small case。<br>题目的难度总体比LeetCode要难的多，最后只有2个人拿到了满分。</p>
<h2 id="1-Training"><a href="#1-Training" class="headerlink" title="1. Training"></a>1. Training</h2><p>从一个N人的队伍中，挑出P人。要求这P个人的训练时长最小，训练时长为 技能点最大的人的技能点 - 每个人的技能点 之和。<br>Intuition：<br>先排序。然后用一个长度为P的窗口，不断滑动，求的最小值。</p>
<p>时间复杂度：O(N log N), 因为排序。<br>空间复杂度：O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;skills, <span class="keyword">int</span> N, <span class="keyword">int</span> P)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(skills.<span class="built_in">begin</span>(), skills.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> need_hour = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        need_hour += skills[P - <span class="number">1</span>] - skills[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = need_hour;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = P - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; N) &#123;</span><br><span class="line">        right++;</span><br><span class="line">        need_hour += (P - <span class="number">1</span>) * (skills[right] - skills[right - <span class="number">1</span>]);</span><br><span class="line">        need_hour -= skills[right - <span class="number">1</span>] - skills[left];</span><br><span class="line">        left++;</span><br><span class="line">        ret = <span class="built_in">min</span>(ret, need_hour);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, P;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; P;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; skills;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> s;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            skills.<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">solution</span>(skills, N, P) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Parcels"><a href="#2-Parcels" class="headerlink" title="2. Parcels"></a>2. Parcels</h2><p>给定一个R * C的网格。网格中分布着一些邮局，你只能新建造一个邮局。使得所有格子到达最近邮局的最大距离（定义为曼哈顿距离）最短。</p>
<p>Intuition：<br>我只想到了一种暴力的解法，过了small case。<br>从邮局出发，更新所有格子的距离。<br>新加邮局时，枚举所有可能的位置。<br>时间复杂度: O((R * C)^2)<br>空间复杂度: O(R * C).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里函数名其实应该是 dfs</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; distance, <span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">	distance[i][j] = depth;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; di = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; dj = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">		<span class="keyword">int</span> ni = i + di[k];</span><br><span class="line">		<span class="keyword">int</span> nj = j + dj[k];</span><br><span class="line">		<span class="keyword">if</span> (ni &lt; R &amp;&amp; nj &lt; C &amp;&amp; ni &gt;= <span class="number">0</span> &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; distance[ni][nj] &gt; depth + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">bfs</span>(distance, R, C, ni, nj, depth + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;string&gt; &amp;grids, <span class="keyword">int</span> R, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">distance</span>(R, vector&lt;<span class="keyword">int</span>&gt;(C, numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>()));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (grids[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">				<span class="built_in">bfs</span>(distance, R, C, i, j, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (grids[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">auto</span> distance_copy = distance;</span><br><span class="line">				<span class="built_in">bfs</span>(distance_copy, R, C, i, j, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">int</span> max_distance = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; R; k++) &#123;</span><br><span class="line">					max_distance = <span class="built_in">max</span>(max_distance, *<span class="built_in">max_element</span>(distance_copy[k].<span class="built_in">begin</span>(), distance_copy[k].<span class="built_in">end</span>()));</span><br><span class="line">				&#125;</span><br><span class="line">				ret = <span class="built_in">min</span>(ret, max_distance);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (ret == numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>()) ? <span class="number">0</span> : ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> R, C;</span><br><span class="line">		cin &gt;&gt; R &gt;&gt; C;</span><br><span class="line">		<span class="function">vector&lt;string&gt; <span class="title">grids</span><span class="params">(R)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">			cin &gt;&gt; grids[j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">solution</span>(grids, R, C) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>赛后学习官方的ANALYSIS，正确的解法是：</p>
<p>首先考虑如下的子问题：给定一个最大距离K，我们是否可以通过增加一个邮局，使得最大距离小于等于K？<br>这是一个判定问题。<br>可以利用我的解法，但是只需要关心那些最大距离大于K的格子。利用这点不同，最后算法的效率会大幅提高。<br>有了判定问题的解法，我们可以二分搜索出最优解。这也是一种讲 最优化问题 转化为 判定问题的方法。</p>
<p>总的做法如下：</p>
<ol>
<li>首先求的所有格子到最近邮局的距离。可以通过BFS，从所有邮局开始搜索。因为每个格子访问一次，所以时间复杂度为<code>O(R * C)</code>.</li>
<li>对于所有到邮局距离超过K的格子，我们需要找到是否存在一个格子到这些格子的距离小于等于K。为了有效的实现这个步骤，注意到曼哈顿距离计算的等价公式为：<code>dist((x1, y1), (x2, y2)) = max(abs(x1 + y1 - (x2 + y2)), abs(x1 - y1 - (x2 - y2)))</code>. 固定点<code>(x2, y2)</code>, 最大的曼哈顿距离在 <code>x1 + y1</code> 或 <code>x1 - y1</code> 最大或最小时达到。对于所有最大到邮局距离超过K的格子，我们都计算<code>x1 + y1</code> 或 <code>x1 - y1</code> 最大 和 最小值，得到4个值。然后，再尝试所有可以放邮局的格子。每个格子我们都可以在常数时间内判定。所以此步骤的时间复杂度为<code>RC + RC = O(RC)</code>。</li>
<li>二分搜索。总的时间复杂度为<code>O(RC log(R+C))</code>.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  vector&lt;set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; manhatten; <span class="comment">// [i] 表示距离为i的点的集合</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; max_x_sub_y;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; min_x_sub_y;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; max_x_add_y;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; min_x_add_y;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;string&gt; &amp;grids, <span class="keyword">int</span> R, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(R, vector&lt;<span class="keyword">bool</span>&gt;(C, <span class="literal">false</span>));</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grids[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">          visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> current = q.<span class="built_in">front</span>();</span><br><span class="line">        manhatten[level].<span class="built_in">insert</span>(current);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; di = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dj = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">          <span class="keyword">int</span> ni = current.first + di[k];</span><br><span class="line">          <span class="keyword">int</span> nj = current.second + dj[k];</span><br><span class="line">          <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; R &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; C &amp;&amp;</span><br><span class="line">              visited[ni][nj] == <span class="literal">false</span>) &#123;</span><br><span class="line">            visited[ni][nj] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;ni, nj&#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++level;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">possible</span><span class="params">(vector&lt;string&gt; &amp;grids, <span class="keyword">int</span> K, <span class="keyword">int</span> R, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> grids_count_larger_than_K =</span><br><span class="line">        <span class="built_in">accumulate</span>(manhatten.<span class="built_in">cbegin</span>() + K + <span class="number">1</span>, manhatten.<span class="built_in">cend</span>(), <span class="number">0</span>,</span><br><span class="line">                   [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;lhs, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;rhs) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">                     <span class="keyword">return</span> lhs + rhs.<span class="built_in">size</span>();</span><br><span class="line">                   &#125;);</span><br><span class="line">    <span class="keyword">if</span> (grids_count_larger_than_K == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> max_x_sub_y_K =</span><br><span class="line">        *<span class="built_in">max_element</span>(max_x_sub_y.<span class="built_in">cbegin</span>() + K + <span class="number">1</span>, max_x_sub_y.<span class="built_in">cend</span>());</span><br><span class="line">    <span class="keyword">int</span> min_x_sub_y_K =</span><br><span class="line">        *<span class="built_in">min_element</span>(min_x_sub_y.<span class="built_in">cbegin</span>() + K + <span class="number">1</span>, min_x_sub_y.<span class="built_in">cend</span>());</span><br><span class="line">    <span class="keyword">int</span> max_x_add_y_K =</span><br><span class="line">        *<span class="built_in">max_element</span>(max_x_add_y.<span class="built_in">cbegin</span>() + K + <span class="number">1</span>, max_x_add_y.<span class="built_in">cend</span>());</span><br><span class="line">    <span class="keyword">int</span> min_x_add_y_K =</span><br><span class="line">        *<span class="built_in">min_element</span>(min_x_add_y.<span class="built_in">cbegin</span>() + K + <span class="number">1</span>, min_x_add_y.<span class="built_in">cend</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grids[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> distance = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">          distance = <span class="built_in">max</span>(distance, <span class="built_in">abs</span>(i - j - max_x_sub_y_K));</span><br><span class="line">          distance = <span class="built_in">max</span>(distance, <span class="built_in">abs</span>(i - j - min_x_sub_y_K));</span><br><span class="line">          distance = <span class="built_in">max</span>(distance, <span class="built_in">abs</span>(i + j - max_x_add_y_K));</span><br><span class="line">          distance = <span class="built_in">max</span>(distance, <span class="built_in">abs</span>(i + j - min_x_add_y_K));</span><br><span class="line">          <span class="keyword">if</span> (distance &lt;= K)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(vector&lt;string&gt; &amp;grids, <span class="keyword">int</span> R, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    manhatten.<span class="built_in">resize</span>(R + C);</span><br><span class="line">    <span class="built_in">bfs</span>(grids, R, C);</span><br><span class="line">    max_x_sub_y.<span class="built_in">resize</span>(R + C);</span><br><span class="line">    min_x_sub_y.<span class="built_in">resize</span>(R + C);</span><br><span class="line">    max_x_add_y.<span class="built_in">resize</span>(R + C);</span><br><span class="line">    min_x_add_y.<span class="built_in">resize</span>(R + C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; manhatten.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      max_x_sub_y[i] = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">      min_x_sub_y[i] = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">      max_x_add_y[i] = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">      min_x_add_y[i] = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;point : manhatten[i]) &#123;</span><br><span class="line">        max_x_sub_y[i] = <span class="built_in">max</span>(max_x_sub_y[i], point.first - point.second);</span><br><span class="line">        min_x_sub_y[i] = <span class="built_in">min</span>(min_x_sub_y[i], point.first - point.second);</span><br><span class="line">        max_x_add_y[i] = <span class="built_in">max</span>(max_x_add_y[i], point.first + point.second);</span><br><span class="line">        min_x_add_y[i] = <span class="built_in">min</span>(min_x_add_y[i], point.first + point.second);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = R + C;</span><br><span class="line">    <span class="keyword">auto</span> binary = [&amp;grids, R, C, <span class="keyword">this</span>](<span class="keyword">int</span> K) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">possible</span>(grids, K, R, C);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// [lo, hi)</span></span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">binary</span>(mid)) &#123;</span><br><span class="line">        lo = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hi = mid;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    cin &gt;&gt; R &gt;&gt; C;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">grids</span><span class="params">(R)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; R; j++) &#123;</span><br><span class="line">      cin &gt;&gt; grids[j];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">Solution</span>().<span class="built_in">solution</span>(grids, R, C)</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- 
进一步优化到O(RC)。在第2步中，我们可以计算得到所有格子的最大最小值。然后，遍历所有可能的格子，得到最大邮局的位置和距离。 -->

<h2 id="3-Contention"><a href="#3-Contention" class="headerlink" title="3. Contention"></a>3. Contention</h2><p>题意：<br>给定Q个Bookings，N个seats, 每个booking用L和R表示，意思是索取从L到R的座位，包括L和R。<br>后面的booking，如果前面的座位被占用的话，就只占用可以占用的那些座位。<br>求一个最大的K，使得存在一个Bookings的序列。每个Booking都被满足最少K个座位。</p>
<p>数据范围: Q 30000, N 10^6</p>
<p>官方分析：</p>
<p>观测有：给定一个booking序列，最后一个booking可以获得的seats数不依赖于前面的booking的顺序。<br>所以，我们可以每次确定最后一个booking，然后不断向前挪。答案是Q步中，最小的座位预定数。</p>
<p>另一个观察：每次向前挪的时候，我们可以从剩余的booking中贪心地选择最后一个请求：选择那个我们可以获得最多seats的请求。贪心的直觉证明是：最后的答案在向前挪的时候是非递增的。</p>
<p>该题难度还是很大的，赛中只有2人做出来。我花了半天也还是无法很好地理解。所以题解暂时搁置了。</p>
]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2019 round B</title>
    <url>/2019/07/24/kick-start-2019-round-B/</url>
    <content><![CDATA[<p>赛后补的题解。<br><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050eda">题目链接</a></p>
<h2 id="Building-Palindromes"><a href="#Building-Palindromes" class="headerlink" title="Building Palindromes"></a>Building Palindromes</h2><p>给定长度为N的一个字符串，和Q个Query。每个query是一个range，可以得到字串。判断子串重新排列后是否回文。因为可以任意重排，所以子串中字符的顺序不重要，重要的是每个字符出现的频数。频数为奇数的字符数目为0或1，即可重排为回文串。<br>因为N和Q的规模较大，<code>10^5</code>。平方算法会超时。这里借用前缀和的思路，快速计算子串字符频数。<br>时间复杂度为线性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, Q;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">prefix</span>(N+<span class="number">1</span>);</span><br><span class="line">        prefix[<span class="number">0</span>] = vector&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            prefix[j] = prefix[j<span class="number">-1</span>];</span><br><span class="line">            ++prefix[j][s[j<span class="number">-1</span>] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Q; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> L, R;</span><br><span class="line">            cin &gt;&gt; L &gt;&gt; R;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; l = prefix[L<span class="number">-1</span>], r = prefix[R];</span><br><span class="line">            <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((r[k] - l[k]) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    ++odd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (odd &lt;= <span class="number">1</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Energy-Stones"><a href="#Energy-Stones" class="headerlink" title="Energy Stones"></a>Energy Stones</h2><p>本题的思想是 贪心 + 动态规划 (一种<a href="https://en.wikipedia.org/wiki/Knapsack_problem">0-1背包</a>)。更多背包问题，可以参考<a href="https://comzyh.com/upload/PDF/Pack-PDF-Comzyh.pdf">背包九讲</a>。<br>难点在于，背包遍历的顺序需要用贪心的思路去排序的。</p>
<p>对于S相同的小的测试集而言，L大的先去遍历。可以是的损失的能量最少。<br>对于S不同的大的测试集而言，2个石头<code>i</code>, <code>j</code>的顺序由<code>S_i * L_j</code>决定，如果<code>S_i * L_j &lt; S_j * L_i</code>，则先去<code>i</code>损失的能量更少。</p>
<p>贪心的正确性也很容易去证明。如果我们有一个吃石头的序列，则 必然是按照能量损失较小的顺序去吃的。否则交换一下顺序，可以获得更大的能量。</p>
<p>时间复杂度: O(N * N * S_i).<br>空间复杂度: O(N * N * S_i), 可以进一步优化到O(N * S_i)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stone</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> s, e, l;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stone &amp;p) <span class="keyword">const</span> &#123; <span class="keyword">return</span> s * p.l &lt; l * p.s; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;Stone&gt; <span class="title">data</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> S_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; data[i].s &gt;&gt; data[i].e &gt;&gt; data[i].l;</span><br><span class="line">      S_sum += data[i].s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(data.<span class="built_in">begin</span>() + <span class="number">1</span>, data.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(S_sum + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">0</span>; time &lt;= S_sum; ++time) &#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; data[i].s) &#123;</span><br><span class="line">          dp[i][time] = dp[i - <span class="number">1</span>][time];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][time] =</span><br><span class="line">              <span class="built_in">max</span>(dp[i - <span class="number">1</span>][time],</span><br><span class="line">                  dp[i - <span class="number">1</span>][time - data[i].s] +</span><br><span class="line">                      <span class="built_in">max</span>(<span class="number">0</span>, data[i].e - data[i].l * (time - data[i].s)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">0</span>; time &lt;= S_sum; ++time) &#123;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, dp[N][time]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Diverse-Subarray"><a href="#Diverse-Subarray" class="headerlink" title="Diverse Subarray"></a>Diverse Subarray</h2><p>本题和第一题一样，都需要用到前缀和，但这一转换其实并不是很明显。<br>需要先把 types序列 转换成 增减事件序列，此时可以看出，增减事件的前缀和即是最后的我们需要优化的礼物数。<br>然后，为了快速获取最大前缀和，可以使用 [线段树](// <a href="https://www.geeksforgeeks.org/maximum-prefix-sum-given-range/">https://www.geeksforgeeks.org/maximum-prefix-sum-given-range/</a>) 这一工具。实现<code>O(log N)</code>效率的查询一个Range中最大的前缀和，和<code>O(log N)</code>更新线段树。</p>
<p>总的时间复杂度: O(N log N)</p>
<ul>
<li>初始化线段树 O(N log N)</li>
<li>对于N个起点，更新、查询 线段树 O(log N)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="keyword">int</span> prefix = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sum != numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>() &amp;&amp;</span><br><span class="line">             prefix != numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Node &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Node &amp;rhs) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;sum = rhs.sum;</span><br><span class="line">      <span class="keyword">this</span>-&gt;prefix = rhs.prefix;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">1</span> &lt;&lt; <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储线段树的全局数组</span></span><br><span class="line">  vector&lt;Node&gt; dat;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="built_in">SegmentTree</span>(<span class="keyword">int</span> n_, <span class="keyword">int</span> a[]) &#123;</span><br><span class="line">    <span class="comment">// 为简单起见，把元素个数扩大到2的幂</span></span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; n_)</span><br><span class="line">      n *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把所有的值都设为INT_MAX</span></span><br><span class="line">    dat.<span class="built_in">resize</span>(<span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; ++i) &#123;</span><br><span class="line">      <span class="built_in">update</span>(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;d : dat) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span> &lt;&lt; d.sum &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.prefix &lt;&lt; <span class="string">&quot;&#125;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把第k个值(0-indexed)更新为a</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 叶子节点</span></span><br><span class="line">    k += n - <span class="number">1</span>;</span><br><span class="line">    dat[k].sum = a;</span><br><span class="line">    dat[k].prefix = a;</span><br><span class="line">    <span class="comment">// 向上更新</span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      k = (k - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (!dat[<span class="number">2</span> * k + <span class="number">2</span>].<span class="built_in">isValid</span>())</span><br><span class="line">        dat[k] = dat[<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        dat[k].sum = dat[<span class="number">2</span> * k + <span class="number">1</span>].sum + dat[<span class="number">2</span> * k + <span class="number">2</span>].sum;</span><br><span class="line">        dat[k].prefix = <span class="built_in">max</span>(dat[<span class="number">2</span> * k + <span class="number">1</span>].prefix,</span><br><span class="line">                            dat[<span class="number">2</span> * k + <span class="number">1</span>].sum + dat[<span class="number">2</span> * k + <span class="number">2</span>].prefix);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求[beg, end)的最小值</span></span><br><span class="line">  <span class="comment">// 后面的参数是为了计算起来方便而转入的。</span></span><br><span class="line">  <span class="comment">// k 是节点的编号, l, r表示这个节点对应的是[l, r)区间。</span></span><br><span class="line">  <span class="comment">// 在外部调用时，用query(index, beg, end, 0, n)</span></span><br><span class="line">  <span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">const</span> <span class="keyword">int</span> beg, <span class="keyword">const</span> <span class="keyword">int</span> end, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;(&quot; &lt;&lt; index &lt;&lt; &quot;, &quot; &lt;&lt; l &lt;&lt; &quot;, &quot; &lt;&lt; r &lt;&lt; &quot;);&quot; &lt;&lt; endl;</span></span><br><span class="line">    Node ret;</span><br><span class="line">    <span class="comment">// 如果[beg, end) 和 [l, r)不相交，则返回INT_MAX</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt;= beg || end &lt;= l)</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// 如果[beg, end)完全包含[l, r), 则返回当前节点的值</span></span><br><span class="line">    <span class="keyword">if</span> (beg &lt;= l &amp;&amp; r &lt;= end)</span><br><span class="line">      <span class="keyword">return</span> dat[index];</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> vl = <span class="built_in">query</span>(index * <span class="number">2</span> + <span class="number">1</span>, beg, end, l, mid);</span><br><span class="line">    <span class="keyword">auto</span> vr = <span class="built_in">query</span>(index * <span class="number">2</span> + <span class="number">2</span>, beg, end, mid, r);</span><br><span class="line">    <span class="keyword">if</span> (!vr.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">      ret = vl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vl.<span class="built_in">isValid</span>()) &#123;</span><br><span class="line">      ret = vr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret.sum = vl.sum + vr.sum;</span><br><span class="line">      ret.prefix = <span class="built_in">max</span>(vl.prefix, vl.sum + vr.prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Node <span class="title">queryMin</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">0</span>, a, b, <span class="number">0</span>, n); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://www.geeksforgeeks.org/maximum-prefix-sum-given-range/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">    <span class="keyword">int</span> N, S;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; S;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span>, <span class="title">events</span><span class="params">(N)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; types; <span class="comment">// type, &lt;index&gt;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; A[i];</span><br><span class="line">      types[A[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (types[A[i]].<span class="built_in">size</span>() &lt;= S) &#123;</span><br><span class="line">        events[i] = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types[A[i]].<span class="built_in">size</span>() == S + <span class="number">1</span>) &#123;</span><br><span class="line">        events[i] = -S;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        events[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">SegmentTree <span class="title">st</span><span class="params">(N, events.data())</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ans = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">      <span class="keyword">auto</span> r = st.<span class="built_in">queryMin</span>(i, N);</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, r.prefix);</span><br><span class="line">      <span class="keyword">auto</span> &amp;v = types[A[i]];</span><br><span class="line">      <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), i);</span><br><span class="line">      <span class="keyword">if</span> (it + S &lt; v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        st.<span class="built_in">update</span>(*(it + S), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (it + S + <span class="number">1</span> &lt; v.<span class="built_in">end</span>())</span><br><span class="line">          st.<span class="built_in">update</span>(*(it + S + <span class="number">1</span>), -S);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>练习了2场Kick Start，并实际参与1场。我发现自己的水平里Google的要求还差的远呢。Google的对算法的要求直逼ACM，竞赛选手会有很大优势的。我虽然水平有限，但还有时间可以进步。<br>过去有6年的比赛题，每年8轮。足够练习2个月时间了。</p>
<p>周末一场2019 Round D，我会参加练手。争取拿到第1题的全部分数 和 后2题的小 case的分数。<br>加油，Forest！</p>
]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2019 round C</title>
    <url>/2019/07/25/kick-start-2019-round-C/</url>
    <content><![CDATA[<p>赛后补的题解。<br><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050ff2">题目链接</a></p>
<p>主要参考的是 旷神 直播的解法，和官方 Analysis的解法。</p>
<h2 id="Wiggle-Walk"><a href="#Wiggle-Walk" class="headerlink" title="Wiggle Walk"></a>Wiggle Walk</h2><p>比较容易想到的是暴力解法。模拟整个命令执行过程，标记每个格子是否之前走过。<br>时间复杂度: O(N ^ 2).</p>
<p>虽然实际上凑巧可以AC，但比较冒险。理论上会在大的测试集上TLE。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="keyword">const</span> string&amp; instructions, <span class="keyword">const</span> <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span> C, <span class="keyword">const</span> <span class="keyword">int</span> Sr, <span class="keyword">const</span> <span class="keyword">int</span> Sc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current_x = Sr, current_y = Sc;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(R + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt; (C + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">    visited[current_x][current_y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : instructions) &#123;</span><br><span class="line">        <span class="keyword">int</span> dx, dy;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">            dx = <span class="number">-1</span>;</span><br><span class="line">            dy = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            dx = <span class="number">0</span>;</span><br><span class="line">            dy = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">            dx = <span class="number">0</span>;</span><br><span class="line">            dy = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">            dx = <span class="number">1</span>;</span><br><span class="line">            dy = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Bad instruction: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current_x += dx;</span><br><span class="line">            current_y += dy;</span><br><span class="line">        &#125; <span class="keyword">while</span> (visited[current_x][current_y] == <span class="literal">true</span>);</span><br><span class="line">        visited[current_x][current_y] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;current_x, current_y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, R, C, Sr, Sc;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; R &gt;&gt; C &gt;&gt; Sr &gt;&gt; Sc;</span><br><span class="line">        string instructions;</span><br><span class="line">        cin &gt;&gt; instructions;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">solve</span>(instructions, R, C, Sr, Sc);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要找到快速跳过已经走过格子的方法。一种是题解里给的，记录interval的方式。时间复杂度: O(N log N). 每次查询interval需要O(log N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;visited, <span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = visited.<span class="built_in">lower_bound</span>(&#123;x + <span class="number">1</span>, x + <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="built_in">assert</span>(it != visited.<span class="built_in">begin</span>());</span><br><span class="line">  --it;</span><br><span class="line">  <span class="keyword">if</span> (direction &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> it-&gt;first - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitRow</span><span class="params">(set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;row, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = row.<span class="built_in">lower_bound</span>(&#123;y + <span class="number">1</span>, y + <span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">if</span> (it == row.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">    it = row.<span class="built_in">insert</span>(&#123;y, y + <span class="number">1</span>&#125;).first;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    --it;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;first &lt;= y &amp;&amp; it-&gt;second &gt; y) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second == y) &#123;</span><br><span class="line">      <span class="keyword">auto</span> old = it;</span><br><span class="line">      it = row.<span class="built_in">insert</span>(it, &#123;it-&gt;first, it-&gt;second + <span class="number">1</span>&#125;);</span><br><span class="line">      it = row.<span class="built_in">erase</span>(old);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      it = row.<span class="built_in">insert</span>(&#123;y, y + <span class="number">1</span>&#125;).first;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// merge interval</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">next</span>(it) != row.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">next</span>(it)-&gt;first == it-&gt;second) &#123;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="built_in">next</span>(it)-&gt;second;</span><br><span class="line">    <span class="keyword">int</span> begin = it-&gt;first;</span><br><span class="line">    row.<span class="built_in">erase</span>(<span class="built_in">next</span>(it));</span><br><span class="line">    row.<span class="built_in">erase</span>(it);</span><br><span class="line">    row.<span class="built_in">insert</span>(&#123;begin, end&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(vector&lt;set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; &amp;visitedR,</span></span></span><br><span class="line"><span class="params"><span class="function">           vector&lt;set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; &amp;visitedC, <span class="keyword">const</span> <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;row = visitedR[x];</span><br><span class="line">  <span class="built_in">visitRow</span>(row, y);</span><br><span class="line">  <span class="keyword">auto</span> &amp;column = visitedC[y];</span><br><span class="line">  <span class="built_in">visitRow</span>(column, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="keyword">const</span> string &amp;instructions, <span class="keyword">const</span> <span class="keyword">int</span> R, <span class="keyword">const</span> <span class="keyword">int</span> C,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">const</span> <span class="keyword">int</span> Sr, <span class="keyword">const</span> <span class="keyword">int</span> Sc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> current_x = Sr, current_y = Sc;</span><br><span class="line">  vector&lt;set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">visitedR</span>(R + <span class="number">1</span>);</span><br><span class="line">  vector&lt;set&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">visitedC</span>(C + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">visit</span>(visitedR, visitedC, current_x, current_y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> c : instructions) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">      current_x = <span class="built_in">getNext</span>(visitedC[current_y], current_x, <span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">      current_y = <span class="built_in">getNext</span>(visitedR[current_x], current_y, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">      current_y = <span class="built_in">getNext</span>(visitedR[current_x], current_y, <span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">      current_x = <span class="built_in">getNext</span>(visitedC[current_y], current_x, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      cerr &lt;&lt; <span class="string">&quot;Bad instruction: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">visit</span>(visitedR, visitedC, current_x, current_y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;current_x, current_y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> N, R, C, Sr, Sc;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; R &gt;&gt; C &gt;&gt; Sr &gt;&gt; Sc;</span><br><span class="line">    string instructions;</span><br><span class="line">    cin &gt;&gt; instructions;</span><br><span class="line">    <span class="keyword">auto</span> ans = <span class="built_in">solve</span>(instructions, R, C, Sr, Sc);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans.second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种是 邝神 直播中的方法。用并查集，需要注意的是union时，方向是重要的。时间复杂度为 O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> F[<span class="number">200010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (F[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> F[x] = <span class="built_in">find</span>(F[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(F));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> t2 = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">            F[t2] = t1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UF N, E, W, S;</span><br><span class="line"></span><br><span class="line">map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; p2Id;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line">map&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; id2P;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N.<span class="built_in">init</span>();</span><br><span class="line">    E.<span class="built_in">init</span>();</span><br><span class="line">    W.<span class="built_in">init</span>();</span><br><span class="line">    S.<span class="built_in">init</span>();</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    p2Id.<span class="built_in">clear</span>();</span><br><span class="line">    id2P.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p = <span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    <span class="keyword">if</span> (!p2Id.<span class="built_in">count</span>(p)) &#123;</span><br><span class="line">        p2Id[p] = tot;</span><br><span class="line">        id2P[tot] = p;</span><br><span class="line">        tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2Id[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gao</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="built_in">getId</span>(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> w = <span class="built_in">getId</span>(x, y<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> e = <span class="built_in">getId</span>(x, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">getId</span>(x<span class="number">-1</span>, y);</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">getId</span>(x+<span class="number">1</span>, y);</span><br><span class="line">    W.<span class="built_in">join</span>(w, now);</span><br><span class="line">    E.<span class="built_in">join</span>(e, now);</span><br><span class="line">    N.<span class="built_in">join</span>(n, now);</span><br><span class="line">    S.<span class="built_in">join</span>(s, now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="built_in">getId</span>(x, y);</span><br><span class="line">    <span class="keyword">int</span> nextId;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line">        nextId = N.<span class="built_in">find</span>(now);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        nextId = E.<span class="built_in">find</span>(now);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">        nextId = W.<span class="built_in">find</span>(now);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">        nextId = S.<span class="built_in">find</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id2P[nextId];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">50010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> iCase = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        iCase++;</span><br><span class="line">        <span class="keyword">int</span> N, R, C, sx, sy;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;N, &amp;R, &amp;C, &amp;sx, &amp;sy);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">gao</span>(sx, sy);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now = <span class="built_in">make_pair</span>(sx, sy);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            now = <span class="built_in">getNext</span>(now.first, now.second, str[i]);</span><br><span class="line">            <span class="built_in">gao</span>(now.first, now.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d %d\n&quot;</span>, iCase, now.first, now.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Circuit-Board"><a href="#Circuit-Board" class="headerlink" title="Circuit Board"></a>Circuit Board</h2><p>旷神用了比较暴力的解法。O(R * C^2).<br>记录每个格子之前相差K的格子数。<br>然后，枚举每列和K，扫描行，更新最大面积。</p>
<p>观察数据规模，和实际测试，都是能过的。Kick start的时间复杂度基本上也是<code>10^6</code>这个量级。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="keyword">int</span> diff[<span class="number">310</span>][<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  <span class="keyword">int</span> iCase = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">    iCase++;</span><br><span class="line">    <span class="keyword">int</span> R, C, K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;R, &amp;C, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> Min = a[i][j];</span><br><span class="line">        <span class="keyword">int</span> Max = a[i][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; C; ++k) &#123;</span><br><span class="line">          Min = <span class="built_in">min</span>(a[i][k], Min);</span><br><span class="line">          Max = <span class="built_in">max</span>(a[i][k], Max);</span><br><span class="line">          diff[i][j][k] = Max - Min;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; C; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff[i][j][k] &lt;= K) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, (k - j + <span class="number">1</span>) * (i - now + <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    now = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, iCase, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方的解法是<code>O(N log N)</code>的。<br>借助线段树快速查询最大最小值，二分确定满足K的右边界，largest-rectangle-under-histogram 获取最大矩形面积。<br>十分考验就高级数据结构和算法的熟悉程度和快速实现能力。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// https://www.geeksforgeeks.org/min-max-range-queries-array/</span></span><br><span class="line"><span class="comment">// https://www.geeksforgeeks.org/largest-rectangle-under-histogram/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a) &#123;</span><br><span class="line">        n = a.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">ceil</span>(<span class="built_in">log2</span>(n));</span><br><span class="line">        <span class="keyword">int</span> max_size = std::<span class="built_in">pow</span>(<span class="number">2</span>, x + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        st.<span class="built_in">resize</span>(max_size);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">constructSTUtil</span>(a, <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A recursive function that constructs Segment Tree for array[ss..se].</span></span><br><span class="line">    <span class="comment">// si is index of current node in segment tree st</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">constructSTUtil</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> si)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If there is one element in array, store it in current node of segment tree and return</span></span><br><span class="line">        <span class="keyword">if</span> (ss == se) &#123;</span><br><span class="line">            st[si].first = arr[ss];</span><br><span class="line">            st[si].second = arr[ss];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If there are more than one elements, then recurse for left and right</span></span><br><span class="line">        <span class="comment">// subtrees and store the minimum and maximum of two values in this nodee</span></span><br><span class="line">        <span class="keyword">int</span> mid = ss + (se - ss) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">constructSTUtil</span>(arr, ss, mid, si*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">constructSTUtil</span>(arr, mid+<span class="number">1</span>, se, si*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">        st[si].first = <span class="built_in">min</span>(st[si*<span class="number">2</span>+<span class="number">1</span>].first, st[si*<span class="number">2</span>+<span class="number">2</span>].first);</span><br><span class="line">        st[si].second = <span class="built_in">max</span>(st[si*<span class="number">2</span>+<span class="number">1</span>].second, st[si*<span class="number">2</span>+<span class="number">2</span>].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A recursive function to get the minimun and maximum value in a</span></span><br><span class="line"><span class="comment">     * given range of array indexes. The following are parameters for thie function.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * st --&gt; segment tree vector</span></span><br><span class="line"><span class="comment">     * index --&gt; index of current node in the segment tree. Initially 0 is passed as root is always at index 0</span></span><br><span class="line"><span class="comment">     * ss &amp;&amp; se --&gt; Starting and ending indexes of the segment represented by current node, i.e. st[index]</span></span><br><span class="line"><span class="comment">     * qs &amp;&amp; qe --&gt; Starting and ending indexes of query range</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">maxMinUtil</span><span class="params">(<span class="keyword">int</span> ss, <span class="keyword">int</span> se, <span class="keyword">int</span> qs, <span class="keyword">int</span> qe, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if segment of this node is a part of given range,</span></span><br><span class="line">        <span class="comment">// then return the minimum and maximum node of the segment</span></span><br><span class="line">        <span class="keyword">if</span> (ss &gt;= qs &amp;&amp; se &lt;= qe) &#123;</span><br><span class="line">            <span class="keyword">return</span> st[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If segment of this node is outside the given range</span></span><br><span class="line">        <span class="keyword">if</span> (se &lt; qs || ss &gt; qe) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>(), numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If a part of this segment overlaps with the given range</span></span><br><span class="line">        <span class="keyword">int</span> mid = ss + (se - ss) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">maxMinUtil</span>(ss, mid, qs, qe, index*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">maxMinUtil</span>(mid+<span class="number">1</span>, se, qs, qe, index*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">min</span>(left.first, right.first), <span class="built_in">max</span>(left.second, right.second)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">maxMin</span><span class="params">(<span class="keyword">int</span> qs, <span class="keyword">int</span> qe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qs &lt; <span class="number">0</span> || qe &gt; n - <span class="number">1</span> || qs &gt; qe) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Invalid Input&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> &#123;numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>(), numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">min</span>()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxMinUtil</span>(<span class="number">0</span>, n<span class="number">-1</span>, qs, qe, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">queryDiff</span><span class="params">(<span class="keyword">int</span> qs, <span class="keyword">int</span> qe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">maxMin</span>(qs, qe);</span><br><span class="line">        <span class="keyword">return</span> ans.second - ans.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; board, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> C = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">heigth</span>(R, vector&lt;<span class="keyword">int</span>&gt;(C));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> maxMin = <span class="built_in">SegmentTree</span>(board[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++ j) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = j, hi = C;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (maxMin.<span class="built_in">queryDiff</span>(j, mid) &lt;= K) &#123;</span><br><span class="line">                    lo = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hi = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            heigth[i][j] = lo - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; R) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || heigth[s.<span class="built_in">top</span>()][j] &lt;= heigth[i][j]) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(i);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tp = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, heigth[tp][j] * (s.<span class="built_in">empty</span>() ? i : i - s.<span class="built_in">top</span>() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> tp = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, heigth[tp][j] * (s.<span class="built_in">empty</span>() ? i : i - s.<span class="built_in">top</span>() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T;</span><br><span class="line">  cin &gt;&gt; T;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> R, C, K;</span><br><span class="line">      cin &gt;&gt; R &gt;&gt; C &gt;&gt; K;</span><br><span class="line">      vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">board</span>(R, vector&lt;<span class="keyword">int</span>&gt;(C));</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; R; ++j) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; C; ++k) &#123;</span><br><span class="line">              cin &gt;&gt; board[j][k];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> ans = <span class="built_in">solve</span>(board, K);</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Catch-Some"><a href="#Catch-Some" class="headerlink" title="Catch Some"></a>Catch Some</h2><p>经典的DP问题。<br>每种颜色的衬衫肯定只穿一次。因为2次所走的路肯定大于一次，而且观察到的狗的数量是一样的。<br>每种颜色有2个最小花费，一种是需要返回到原点的，另一种是不需要。<br>dp[i][j][0/1]表示使用了 (第i种颜色，观察了j个狗，不返回/返回到原点) 所需的最小花费。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P[<span class="number">1010</span>], A[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">int</span> iCase = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        iCase++;</span><br><span class="line">        <span class="keyword">int</span> n, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;P[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            vec[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            vec[A[i]].<span class="built_in">push_back</span>(P[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(vec[i].<span class="built_in">begin</span>(), vec[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = dp[i][j][<span class="number">1</span>] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j][<span class="number">0</span>] == INF &amp;&amp; dp[i][j][<span class="number">1</span>] == INF) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> sz = vec[i+<span class="number">1</span>].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= sz; ++x) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = x == <span class="number">0</span> ? <span class="number">0</span> : vec[i+<span class="number">1</span>][x<span class="number">-1</span>];</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+x][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j+x][<span class="number">0</span>], dp[i][j][<span class="number">0</span>] + <span class="number">2</span> * tmp);</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+x][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j+x][<span class="number">1</span>], dp[i][j][<span class="number">0</span>] + tmp);</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+x][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j+x][<span class="number">1</span>], dp[i][j][<span class="number">1</span>] + <span class="number">2</span> * tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, iCase, dp[<span class="number">1000</span>][k][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总结一下kick start的常考考点：</p>
<ul>
<li>DP/背包</li>
<li>二分</li>
<li>线段树</li>
</ul>
]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2019 round D</title>
    <url>/2019/07/28/kick-start-2019-round-D/</url>
    <content><![CDATA[<p>排名: 765 / 1866.</p>
<h2 id="X-or-What"><a href="#X-or-What" class="headerlink" title="X or What"></a>X or What</h2><p>本题是找规律的题目，考察最xor的熟悉程度。事实上，我曾经很接近于正确解法了。但一头心思钻到 interval 题目用线段树求解的经验上，试图寻找节点记录什么信息。结果越走越偏。</p>
<p>总结起来规律是这样的:<br>题目中给了xor-even的定义。<br>我们根据xor的性质有：</p>
<ul>
<li>odd xor odd -&gt; even</li>
<li>odd xor even -&gt; odd</li>
<li>even xor even -&gt; even</li>
</ul>
<p>想要最后xor-even，interval中的odd必须是偶数个。一个非常直接的思路就出来了。统计odd的数量，如果是偶数，那么最长的interval就是整个数组的长度。如果是奇数，则去掉头或尾，找最长的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> a[N], v[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">even</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    count += i % <span class="number">2</span>;</span><br><span class="line">    i /= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    a[i] = <span class="built_in">even</span>(x) &amp; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, p+i, &amp;x);</span><br><span class="line">    v[i] = <span class="built_in">even</span>(x) &amp; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; idx[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    idx[a[i]].<span class="built_in">insert</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[p[i]] != v[i]) &#123;</span><br><span class="line">      idx[a[p[i]]].<span class="built_in">erase</span>(p[i]);</span><br><span class="line">      a[p[i]] = v[i];</span><br><span class="line">      idx[a[p[i]]].<span class="built_in">insert</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (idx[<span class="number">1</span>].<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> ans = <span class="built_in">max</span>(*idx[<span class="number">1</span>].<span class="built_in">rbegin</span>(), n-*idx[<span class="number">1</span>].<span class="built_in">begin</span>()<span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  <span class="keyword">time_t</span> starttime = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> tt;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;tt);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> tc = <span class="number">1</span>; tc &lt;= tt; tc++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, tc);</span><br><span class="line">    <span class="built_in">read_input</span>();</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;~ TC#&quot;</span> &lt;&lt; tc &lt;&lt; <span class="string">&quot; done! execution time: &quot;</span> &lt;&lt;</span><br><span class="line">      (<span class="keyword">double</span>)(<span class="built_in">clock</span>()-starttime) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; s&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2019 round E</title>
    <url>/2019/08/29/kick-start-2019-round-E/</url>
    <content><![CDATA[<h2 id="Cherries-Mesh"><a href="#Cherries-Mesh" class="headerlink" title="Cherries Mesh"></a>Cherries Mesh</h2><p>Minimum spanning tree.<br>尤其要注意Union-find的实现中，find要采用path compression的方法才能实现O(1).<br>否则会超时。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UF</span> &#123;</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; parents;</span><br><span class="line">	<span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">		parents.<span class="built_in">resize</span>(n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			parents[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> parents[x] == x ? x : (parents[x] = <span class="built_in">find</span>(parents[x]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> px = <span class="built_in">find</span>(x);</span><br><span class="line">		<span class="keyword">int</span> py = <span class="built_in">find</span>(y);</span><br><span class="line">		parents[px] = py;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> N, M;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">		<span class="function">UF <span class="title">uf</span><span class="params">(N)</span></span>;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">			<span class="keyword">int</span> l, r;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			--l;</span><br><span class="line">			--r;</span><br><span class="line">			<span class="keyword">if</span> (uf.<span class="built_in">find</span>(l) == uf.<span class="built_in">find</span>(r)) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			uf.<span class="built_in">unio</span>(l, r);</span><br><span class="line">			ans += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += (N - <span class="number">1</span> - ans) * <span class="number">2</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Code-Eat-Switcher"><a href="#Code-Eat-Switcher" class="headerlink" title="Code-Eat Switcher"></a>Code-Eat Switcher</h2><h3 id="Test-set-1"><a href="#Test-set-1" class="headerlink" title="Test set 1:"></a>Test set 1:</h3><p>S = 1 或 2。列不等式就可以求解。<br>当S = 2时，有2个变量，不等式求解过程类似线性规划。</p>
<p>比赛的时候思路是对的，但是因为S = 1时，返回值写错了，一直没有AC。当时一直在调S = 2时的逻辑，完全没有想到S = 1时会出错。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; energy, <span class="keyword">const</span> <span class="keyword">int</span> S, <span class="keyword">double</span> code, <span class="keyword">double</span> eat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> Ci = energy[<span class="number">0</span>].first;</span><br><span class="line">        <span class="keyword">double</span> Ei = energy[<span class="number">0</span>].second;</span><br><span class="line">        <span class="keyword">return</span> code / Ci + eat / Ei &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> C1 = energy[<span class="number">0</span>].first, C2 = energy[<span class="number">1</span>].first;</span><br><span class="line">        <span class="keyword">double</span> E1 = energy[<span class="number">0</span>].second, E2 = energy[<span class="number">1</span>].second;</span><br><span class="line">        <span class="keyword">if</span> (C1 / C2 == E1 / E2) &#123;</span><br><span class="line">            vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; tmp = &#123;<span class="built_in">make_pair</span>(energy[<span class="number">0</span>].first + energy[<span class="number">1</span>].first, energy[<span class="number">0</span>].second + energy[<span class="number">1</span>].second)&#125;;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">solve</span>(tmp, <span class="number">1</span>, code, eat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> C = code, E = eat;</span><br><span class="line">        <span class="keyword">double</span> x = (C / C2 - <span class="number">1</span> + E / E2 - E1 / E2) / (C1 / C2 - E1 / E2);</span><br><span class="line">        <span class="keyword">double</span> y = C / C2 - x * C1 / C2;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;result: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;|&quot; &lt;&lt; x * C1 + y * C2 &lt;&lt; &quot;, &quot; &lt;&lt; (1 - x) * E1 + (1 - y) * E2 &lt;&lt; &quot; | &quot; &lt;&lt; </span></span><br><span class="line">        <span class="comment">// 1 - E / E2 + E1 / E2 - x * E1 / E2</span></span><br><span class="line">        <span class="comment">// &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - E / E2 + E1 / E2 - <span class="number">1</span> * E1 / E2 &gt;= C / C2 - <span class="number">1</span> * C1 / C2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> - E / E2 + E1 / E2 - <span class="number">1</span>) * (E2 / E1) &gt;= (C / C2 - <span class="number">1</span>) * (C2 / C1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> - E / E2 + E1 / E2 &gt;= C / C2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> - E / E2 + E1 / E2) * (E2 / E1) &gt;= (C / C2) * (C2 / C1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt;= 1 &amp;&amp; y &lt;= 1;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> D, S;</span><br><span class="line">        cin &gt;&gt; D &gt;&gt; S;</span><br><span class="line">        string ans;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">energy</span>(S);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; energy[i].first &gt;&gt; energy[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> A, B;</span><br><span class="line">            cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">            <span class="keyword">bool</span> yes = <span class="built_in">solve</span>(energy, S, A, B);</span><br><span class="line">            <span class="keyword">if</span> (yes) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&#x27;N&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Test-Set-2"><a href="#Test-Set-2" class="headerlink" title="Test Set 2"></a>Test Set 2</h3><p>观察有，对于每个slot，每获得1份eating能量，就会少收获$C_i / E_i$份coding能量。所以如果$C_i / E_i &lt; C_j / E_j$的话，更好的选择永远时i。<br>根据这个观察，我们把slot根据$C_i / E_i$排序，计算E的前缀和和C的后缀和。每天使用二分查找找到满足eating的分界点，再判断是否满足coding。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;energy, <span class="keyword">const</span> <span class="keyword">int</span> S,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;prefix, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;suffix, <span class="keyword">int</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> eat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(prefix.<span class="built_in">begin</span>(), prefix.<span class="built_in">end</span>(), eat);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">distance</span>(prefix.<span class="built_in">begin</span>(), it);</span><br><span class="line">    <span class="keyword">if</span> (index == S) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> need;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        need = eat;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        need = eat - prefix[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> f = need / energy[index].second;</span><br><span class="line">    <span class="keyword">double</span> code_have;</span><br><span class="line">    <span class="keyword">if</span> (index == S - <span class="number">1</span>) &#123;</span><br><span class="line">        code_have = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        code_have = suffix[index + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> code_need = code - code_have;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - f) * energy[index].first &gt;= code_need;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> D, S;</span><br><span class="line">        cin &gt;&gt; D &gt;&gt; S;</span><br><span class="line">        string ans;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">energy</span>(S);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; energy[i].first &gt;&gt; energy[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(energy.<span class="built_in">begin</span>(), energy.<span class="built_in">end</span>(),</span><br><span class="line">             [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;lhs, <span class="keyword">const</span> <span class="keyword">auto</span> &amp;rhs) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> lhs.first / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(lhs.second) &lt;</span><br><span class="line">                        rhs.first / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(rhs.second);</span><br><span class="line">             &#125;);</span><br><span class="line">        <span class="comment">// build prefix cumulative for eating</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">prefix</span><span class="params">(S)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; ++i) &#123;</span><br><span class="line">            current += energy[i].second;</span><br><span class="line">            prefix[i] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// build suffix cumulative for coding</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">suffix</span><span class="params">(S)</span></span>;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            current += energy[i].first;</span><br><span class="line">            suffix[i] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// binary search for each day</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> A, B;</span><br><span class="line">            cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">            <span class="keyword">bool</span> yes = <span class="built_in">solve</span>(energy, S, prefix, suffix, A, B);</span><br><span class="line">            <span class="keyword">if</span> (yes) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="string">&#x27;N&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Street-Checkers"><a href="#Street-Checkers" class="headerlink" title="Street Checkers"></a>Street Checkers</h2><p>一个数X是否是interesting的，可以转化为 |(# of odd divisors) - (# of even divisors)| &lt;= 2.<br>对于R &lt; 10^6的数据集，我们可以把所有小于10^6的数，进行预处理获得其约束的个数，时间复杂度为O(sqrt(X))，然后建立[1, X]中interesting数目的prefix sum。对于query [L, R]，我们就可以O(1)获得答案了。总的时间复杂度为$O(R_{max} \sqrt{R_{max}} + T)$, 预处理 + T个测试用例.</p>
<p>对于大的数据集，我们还需要继续观察。<br>任何奇数的约数仍然是奇数。每个整数X都能写成$X = A \times 2 ^ p$, 其中 A是一个奇数，X是非负整数。<br>因此，我们可以把X的所有约数分为组, 其中$d_1$,$d_2$,…,$d_k$是A的约数。</p>
<p>${d_1, d_1 * 2, d_1 * 2^2, \dots, d_1 * 2^p}$<br>${d_2, d_2 * 2, d_2 * 2^2, \dots, d_2 * 2^p}$<br>$\dots$<br>${d_k, d_k * 2, d_k * 2^2, \dots, d_k * 2^p}$</p>
<p>可以发现，奇约数的个数为k, (k &gt;= 1, 至少有个奇约数为1)。<br>偶约数为k * X.<br>奇偶之差为 $|k(X-1)| \le 2$.<br>解为：</p>
<ul>
<li><p>Case 1: X = 0, k = 1 or 2</p>
</li>
<li><p>Case 2: X = 1, k can be any value</p>
</li>
<li><p>Case 3: X = 2, k = 1 or 2</p>
</li>
<li><p>Case 4: X = 3, k = 1</p>
</li>
<li><p>Case 1 表示 1 或 一个奇质数。</p>
</li>
<li><p>Case 2 表示，A可以为任意奇数，则原数的形式为 $ 2*(2n + 1) = 4 * n + 2$, 可以通过O(1)算出。</p>
</li>
<li><p>Case 3 表示, A 为 1 或 任意奇质数。也就是[L / 4, R / 4]中的奇质数个数。</p>
</li>
<li><p>Case 4 只表示一个数 8.<br>求质数的个数可以使用<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>.</p>
</li>
</ul>
<p>时间复杂度: $O(T * (R - L + 1) * log(\sqrt{R}))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2019 round G</title>
    <url>/2019/10/20/kick-start-2019-round-G/</url>
    <content><![CDATA[<p>本轮是今年的倒数第二轮，也是相对比较简单的一个轮次。<br>我做出了第3题和1 2题的小数据集。第二题我本身的算法是对的，但是没有正确的评估最大的k的位数，并防止溢出操作，所以字大数据集上WA。第一题其实本身不难，只是我对约数不很敏感，导致错失没有想出更好的解法。总的来说，本轮是我最接近AC的轮次，运气相对不错，也提前1个小时完成了比赛。因为后来实在想不出解法 和 要注意的点了，就放弃了。</p>
<h2 id="Book-Reading"><a href="#Book-Reading" class="headerlink" title="Book Reading"></a>Book Reading</h2><p>暴力法加memo可以直接过。可以我的记忆化写错了，忘记记忆了。导致TLE，损失了不少分数，太可惜 了。<br>另外，能用<code>long long</code>就不要用<code>int</code>。否则最后的<code>ans</code>会溢出。</p>
<p>时间复杂度: O(N log (N)).</p>
<p>因为记忆化 的存在，计算的页数最多是<code>1 + 1 / 2 + 1 / 3 + ... + 1 / N = log N</code>, 即调和级数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (ll iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll N, M, Q;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">pages</span><span class="params">(N + <span class="number">1</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">        pages[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">            ll P;</span><br><span class="line">            cin &gt;&gt; P;</span><br><span class="line">            pages[P] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;ll, ll&gt; memo;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; Q; ++i) &#123;</span><br><span class="line">            ll R;</span><br><span class="line">            cin &gt;&gt; R;</span><br><span class="line">            ll count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (memo.<span class="built_in">find</span>(R) != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                count = memo[R];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (ll j = <span class="number">1</span>; j * R &lt;= N; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pages[j * R]) &#123;</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                memo[R] = count;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += count;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="The-Equation"><a href="#The-Equation" class="headerlink" title="The Equation"></a>The Equation</h2><p>本题要注意的点相对比较多，本身算法并不难。</p>
<ol>
<li>long long  常数是<code>1L</code>。否则<code>1</code>默认 是<code>int</code>，会有溢出风险。</li>
<li>我们不能从A中的最高位开始找，因为可能k会是更大的数。而应该从 M的角度考虑k的最大值，这里M是15位的，对应二进制50位。然而，我们同样不能从太高的位开始找，否则 <code>N*( 1&lt;&lt;i )</code>会溢出64位。鉴于N最大是1000，二进制10位。我们可以从50~53位开始找。</li>
</ol>
<p>因为要最大化k，所以我们可以使用贪心的思路，从高位向低位数，尽量放置1，否则放置0，超过要求回溯。</p>
<p>因为有大量的回溯剪枝的存在，时间复杂度不是很好分析。但可以过大的数据集。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">backtracking</span><span class="params">(<span class="keyword">const</span> vector&lt;ll&gt; &amp;bits, <span class="keyword">const</span> ll N, <span class="keyword">const</span> ll M, ll position,</span></span></span><br><span class="line"><span class="params"><span class="function">                ll accu, ll k)</span> </span>&#123;</span><br><span class="line">    ll one = bits[position];</span><br><span class="line">    ll zero = N - one;</span><br><span class="line">    <span class="comment">// k always wants to be 1 in position i</span></span><br><span class="line">    ll i = position;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (accu + zero * (<span class="number">1L</span> &lt;&lt; i) &lt;= M) &#123; <span class="comment">// if one</span></span><br><span class="line">        ret = <span class="built_in">backtracking</span>(bits, N, M, position - <span class="number">1</span>,</span><br><span class="line">                           accu + zero * (<span class="number">1L</span> &lt;&lt; i),</span><br><span class="line">                           k + (<span class="number">1L</span> &lt;&lt; i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123; <span class="comment">// zero</span></span><br><span class="line">        <span class="keyword">if</span> (accu + one * (<span class="number">1L</span> &lt;&lt; i) &lt;= M) &#123;</span><br><span class="line">            ret = <span class="built_in">backtracking</span>(bits, N, M, position - <span class="number">1</span>,</span><br><span class="line">                               accu + one * (<span class="number">1L</span> &lt;&lt; i), k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (ll iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        ll N, M;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">bits</span><span class="params">(<span class="number">64</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        ll max_position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            ll A;</span><br><span class="line">            cin &gt;&gt; A;</span><br><span class="line">            ll position = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (A &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ll last_bit = A % <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (last_bit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++bits[position];</span><br><span class="line">                    max_position = <span class="built_in">max</span>(max_position, position);</span><br><span class="line">                &#125;</span><br><span class="line">                A = A / <span class="number">2</span>;</span><br><span class="line">                ++position;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">backtracking</span>(bits, N, M, <span class="number">53</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Shifts"><a href="#Shifts" class="headerlink" title="Shifts"></a>Shifts</h2><p>同第二题，我采用了回溯法加大量剪枝和记忆化，以枚举所有的组合。没想到竟然过了。</p>
<p>题解给出的方法是采用 分治法，分别枚举2个小的集合的组合。然后再遍历所有组合，寻找合并后符合要求的组合数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">backtracking</span><span class="params">(<span class="keyword">const</span> vector&lt;ll&gt; &amp;A, <span class="keyword">const</span> vector&lt;ll&gt; &amp;B,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">const</span> vector&lt;ll&gt; &amp;suffixA, <span class="keyword">const</span> vector&lt;ll&gt; &amp;suffixB, ll needA,</span></span></span><br><span class="line"><span class="params"><span class="function">                ll needB, ll position, map&lt;tuple&lt;ll, ll, ll&gt;, ll&gt; &amp;memo,</span></span></span><br><span class="line"><span class="params"><span class="function">                map&lt;tuple&lt;ll, ll&gt;, ll&gt; &amp;memoA, map&lt;tuple&lt;ll, ll&gt;, ll&gt; &amp;memoB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ll n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= n) &#123;</span><br><span class="line">        <span class="keyword">return</span> needA &lt;= <span class="number">0</span> &amp;&amp; needB &lt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = memo.<span class="built_in">find</span>(&#123;needA, needB, position&#125;);</span><br><span class="line">    <span class="keyword">if</span> (it != memo.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needA &lt;= <span class="number">0</span> &amp;&amp; needB &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[&#123;needA, needB, position&#125;] = <span class="built_in">pow</span>(<span class="number">3</span>, n - position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needA &gt; suffixA[position] || needB &gt; suffixB[position]) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[&#123;needA, needB, position&#125;] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needA &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = memoA.<span class="built_in">find</span>(&#123;needB, position&#125;);</span><br><span class="line">        <span class="keyword">if</span> (it != memoA.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needA &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = memoA.<span class="built_in">find</span>(&#123;needB, position&#125;);</span><br><span class="line">        <span class="keyword">if</span> (it != memoA.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needB &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = memoB.<span class="built_in">find</span>(&#123;needA, position&#125;);</span><br><span class="line">        <span class="keyword">if</span> (it != memoB.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    ret += <span class="built_in">backtracking</span>(A, B, suffixA, suffixB, needA - A[position],</span><br><span class="line">                        needB - B[position], position + <span class="number">1</span>, memo, memoA, memoB);</span><br><span class="line">    ret += <span class="built_in">backtracking</span>(A, B, suffixA, suffixB, needA, needB - B[position],</span><br><span class="line">                        position + <span class="number">1</span>, memo, memoA, memoB);</span><br><span class="line">    ret += <span class="built_in">backtracking</span>(A, B, suffixA, suffixB, needA - A[position], needB,</span><br><span class="line">                        position + <span class="number">1</span>, memo, memoA, memoB);</span><br><span class="line">    <span class="keyword">if</span> (needA &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        memoA[&#123;needB, position&#125;] = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needB &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        memoB[&#123;needA, position&#125;] = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[&#123;needA, needB, position&#125;] = ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (ll iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        ll N, H;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; H;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">A</span><span class="params">(N)</span>, <span class="title">B</span><span class="params">(N)</span>, <span class="title">suffixA</span><span class="params">(N)</span>, <span class="title">suffixB</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            suffixA[N - <span class="number">1</span>] = A[N - <span class="number">1</span>];</span><br><span class="line">            suffixB[N - <span class="number">1</span>] = B[N - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            suffixA[i] = A[i] + suffixA[i + <span class="number">1</span>];</span><br><span class="line">            suffixB[i] = B[i] + suffixB[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;tuple&lt;ll, ll, ll&gt;, ll&gt; memo;</span><br><span class="line">        map&lt;tuple&lt;ll, ll&gt;, ll&gt; memoA;</span><br><span class="line">        map&lt;tuple&lt;ll, ll&gt;, ll&gt; memoB;</span><br><span class="line">        <span class="keyword">auto</span> ans =</span><br><span class="line">            <span class="built_in">backtracking</span>(A, B, suffixA, suffixB, H, H, <span class="number">0</span>, memo, memoA, memoB);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2019 round H</title>
    <url>/2019/11/25/kick-start-2019-round-H/</url>
    <content><![CDATA[<p>由于欧洲这边夏令时的原因，处于UTC +1.00，所以本次比赛我是特意早上6点起来打的。打完后休息了一个小时，又和小伙伴去根特玩了一天。晚上回来的时候，才想起来Machine Learning的assignment 2当天截止，又疯狂地赶起了Deadline。事实证明，没有认真学习还是搞不定作业的。马马虎虎交上去了，总比不交好些。空白的题目，大方地告诉助教我就是不会。</p>
<p>本次比赛是Kick start 2019的最后一个轮次，我还是很想参加的。今年我共参加了6轮kick start。虽然A轮就拿到了面试的邀请，但仍然不可马虎。各次的排名如下所示:</p>
<table>
<thead>
<tr>
<th>轮次</th>
<th>A</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
<th>H</th>
</tr>
</thead>
<tbody><tr>
<td>Rank</td>
<td>600</td>
<td>765</td>
<td>1566</td>
<td>1341</td>
<td>462</td>
<td>330</td>
</tr>
<tr>
<td>Score</td>
<td>35</td>
<td>27</td>
<td>22</td>
<td>11</td>
<td>42</td>
<td>41</td>
</tr>
</tbody></table>
<p>除了F轮，我当时在巴黎玩，趁晚上在青旅的功夫瞎做的外。其他轮次还是可以说是全力以赴的。<br>总的名次是先下降后上升，并不能体现实力的变化，更多的是心态的改变。因为D轮次比较重要，当时也有同学一起竞争，不忍心与他比赛时交流。E轮次时，当时是在字节跳动的夏令营，和一个妹子一起做的。本身还是很想打好的，但由于并查集没有实现find的折叠，导致 超时。这也是之前没有注意到的盲点。其他3次结果相对好的轮次反而是没有包袱，更放松的时候。</p>
<p>最近还意外地收获了Google北京 A day with Google的邀请。无奈我不再北京，只能拒绝了。另外，我还通过邮件向Google反映了Google所有招聘相关的Form中My University中都没有 Beihang University的选项（我猜测这可能是因为北航在美国商务部的黑名单上的原因）。Google很快解决了，我航以后再也不是野鸡大学了。</p>
<p>本次做出签到题和第3题的小测试集1，算是正常发挥吧。</p>
<h2 id="A-H-index"><a href="#A-H-index" class="headerlink" title="A. H-index"></a>A. H-index</h2><p>第一次做误解了题意，以为是求最后的H-index就可以了。简单地写了个二分查找用判定问题求最大值的解法。<br>后来才发现是需要求每次论文的结果，之后又因编写了几个bug的问题影响了耗时。</p>
<p>Intuition：<br>随着论文的发表，H-index是单调递增的。利用这一特性，每次发表论文后，尝试去增加H-index.<br>这里我利用里C++ STL set中有序的特点和基于节点的container再插入新节点后iterator的不变性，高效地实现了尝试增加H-index的操作。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MAX_N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>, std::greater&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> come = A[i];</span><br><span class="line">        <span class="keyword">if</span> (come &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(come);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">                it = s.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">if</span> (come &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    ans = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (come &gt; *it) &#123;</span><br><span class="line">                --it;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; &quot; --it &quot; &lt;&lt; *it &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                <span class="comment">// if (next(it) != s.end()) &#123;</span></span><br><span class="line">                <span class="comment">//     cout &lt;&lt; &quot; next(it): &quot; &lt;&lt; *(next(it)) &lt;&lt; &quot; &quot;;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it != s.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">next</span>(it) != s.<span class="built_in">end</span>() &amp;&amp; *<span class="built_in">next</span>(it) &gt;= ans + <span class="number">1</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                ++it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(MAX_N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">0</span>; iCase &lt; T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">solve</span>(A, N);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Diagonal-Puzzle"><a href="#B-Diagonal-Puzzle" class="headerlink" title="B. Diagonal Puzzle"></a>B. Diagonal Puzzle</h2><p>比赛时试图通过回溯枚举所有的翻转找到最小解，时间复杂度O(2 ^ (4 * N))。没想到连最小的数据集都超时了。所以，题解都是通过赛后从官方的Analysis中看来得。</p>
<h3 id="小测试集"><a href="#小测试集" class="headerlink" title="小测试集"></a>小测试集</h3><p>没必要枚举所有的翻转。我们可以只枚举同一个方向的翻转，然后检查是否另一个方向每条线上都同色。<br>与主对角线平行的翻转有<code>2 * N - 1</code>个，与主对角线垂直的也有<code>2 * N - 1</code>个。<br>检查同色的复杂度为<code>O(N ^ 2)</code>.<br>所以总的时间复杂度为<code>O(2 ^ (2 * N - 1) * N ^ 2)</code>.</p>
<h3 id="大测试集"><a href="#大测试集" class="headerlink" title="大测试集"></a>大测试集</h3><p>本解法基于一个有趣的观察，如果我们确定主对角线和反主对角线的翻转，为了确定最后全为白色，其余翻转可以因此确定。当N为奇数时，是主对角线和次反主对角线。<code>N == 6， 7</code>时的情况如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\..../ \......</span><br><span class="line">.\../. .\..../</span><br><span class="line">..\/.. ..\../.</span><br><span class="line">../\.. ...\/..</span><br><span class="line">./..\. .../\..</span><br><span class="line">/....\ ../..\.</span><br><span class="line">       ./....\</span><br></pre></td></tr></table></figure>

<p>所以，我们可以枚举主对角线的翻转 情况 ，共4种，然后根据对角线上 的 其他元素的颜色，确定其他翻转 。最后检查是否符合全是白的要求。<br>时间复杂度: <code>O(4 * N ^ 2)</code>.</p>
<p>此解法其实和我之前经常做的翻灯的题目很像，翻转一个灯，同时会翻转其周围的4个灯。最后求全部灭掉灯的步数。<br>只需要枚举第一行的翻转，为了改变当前行的灯的状态，我们只能翻转下一行的灯，其余行会因此确定。<br>题目在LeetCode上可以找到：<a href="https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/description/">LeetCode 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</a>.<br>我的解法是从<a href="https://www.acwing.com/problem/content/97/">acwing</a>获得的，还可以 看大雪菜的视频学习。</p>
<h4 id="另一种解法"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法</h4><p>将此问题转换成<a href="https://en.wikipedia.org/wiki/Graph_coloring#Vertex_coloring">2-coloring</a>的一种变形。每个格子都由2条线共享。如果格子是白的，2条线之一需要被翻转。如果格子是黑的，不需要翻转，或 都翻转。<br>我们考虑每条对角线是图中的节点，格子是边。<br>如果格子是黑的，对应的边连接的2个节点必须是相同颜色的。反之，必须是不同颜色的。<br>可以通过DFS解决2-coloring的图问题。<br>枚举root的颜色，DFS确定邻居的颜色，如果邻居的颜色已确定，则检查即可。更少的颜色就代表着翻的个数。</p>
<p>边数 为 <code>O(N^2)</code>, DFS的解法复杂度为<code>O(|Edges|)</code>。<br>总的时间复杂度为<code>O(N ^ 2)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    ll difference;</span><br><span class="line">    <span class="keyword">bool</span> positive;</span><br><span class="line">    vector&lt;weak_ptr&lt;Line&gt;&gt; same_color_neighbors, different_color_neighbors;</span><br><span class="line">    <span class="built_in">Line</span>(ll d, <span class="keyword">bool</span> p) : <span class="built_in">difference</span>(d), <span class="built_in">positive</span>(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(shared_ptr&lt;Line&gt; root, set&lt;shared_ptr&lt;Line&gt;&gt; &amp;white,</span></span></span><br><span class="line"><span class="params"><span class="function">         set&lt;shared_ptr&lt;Line&gt;&gt; &amp;black)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">bool</span> w = white.<span class="built_in">find</span>(root) != white.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> node : root-&gt;different_color_neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> node_shared_ptr = node.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (white.<span class="built_in">find</span>(node_shared_ptr) == white.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">                black.<span class="built_in">find</span>(node_shared_ptr) == black.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;color = w ? black : white;</span><br><span class="line">                color.<span class="built_in">insert</span>(node_shared_ptr);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">dfs</span>(node_shared_ptr, white, black))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (white.<span class="built_in">find</span>(node_shared_ptr) != white.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!w) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> node : root-&gt;same_color_neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> node_shared_ptr = node.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (white.<span class="built_in">find</span>(node_shared_ptr) == white.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">                black.<span class="built_in">find</span>(node_shared_ptr) == black.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;color = w ? white : black;</span><br><span class="line">                color.<span class="built_in">insert</span>(node_shared_ptr);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">dfs</span>(node_shared_ptr, white, black))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (white.<span class="built_in">find</span>(node_shared_ptr) != white.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!w)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (w)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;puzzle)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, shared_ptr&lt;Line&gt;&gt; positive, negative;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = puzzle.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> j_sub_i = j - i;</span><br><span class="line">            <span class="keyword">int</span> j_add_i = j + i;</span><br><span class="line">            <span class="keyword">if</span> (positive[j_sub_i] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                positive[j_sub_i] = make_shared&lt;Line&gt;(j_sub_i, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (negative[j_add_i] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                negative[j_add_i] = make_shared&lt;Line&gt;(j_add_i, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (puzzle[i][j]) &#123; <span class="comment">// black</span></span><br><span class="line">                positive[j_sub_i]-&gt;same_color_neighbors.<span class="built_in">push_back</span>(</span><br><span class="line">                    negative[j_add_i]);</span><br><span class="line">                negative[j_add_i]-&gt;same_color_neighbors.<span class="built_in">push_back</span>(</span><br><span class="line">                    positive[j_sub_i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                positive[j_sub_i]-&gt;different_color_neighbors.<span class="built_in">push_back</span>(</span><br><span class="line">                    negative[j_add_i]);</span><br><span class="line">                negative[j_add_i]-&gt;different_color_neighbors.<span class="built_in">push_back</span>(</span><br><span class="line">                    positive[j_sub_i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;shared_ptr&lt;Line&gt;&gt; seen;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;direction : &#123;positive, negative&#125;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : direction) &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = p.second;</span><br><span class="line">            <span class="keyword">if</span> (seen.<span class="built_in">find</span>(node) == seen.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                set&lt;shared_ptr&lt;Line&gt;&gt; white, black;</span><br><span class="line">                white.<span class="built_in">insert</span>(node);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">dfs</span>(node, white, black)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += <span class="built_in">min</span>(white.<span class="built_in">size</span>(), black.<span class="built_in">size</span>());</span><br><span class="line">                seen.<span class="built_in">insert</span>(white.<span class="built_in">begin</span>(), white.<span class="built_in">end</span>());</span><br><span class="line">                seen.<span class="built_in">insert</span>(black.<span class="built_in">begin</span>(), black.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">pullze</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            string row;</span><br><span class="line">            cin &gt;&gt; row;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[j] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    pullze[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pullze[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="built_in">solve</span>(pullze);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现过程中，需要注意的点有：</p>
<ul>
<li>如何存储和构造Graph。</li>
<li>DFS解法时，需要遍历所有的节点。因为整个图是可以分为多个联通子图的。只从一个root开始dfs得到的染色不完整。</li>
</ul>
<h2 id="C-Elevanagram"><a href="#C-Elevanagram" class="headerlink" title="C. Elevanagram"></a>C. Elevanagram</h2><p>小测试集时，<code>0 &lt;= A_i &lt;= 20</code>，可以使用回溯法，尝试所有的正负号分配方式。</p>
<p>时间复杂度：O(A_i ^ 9), 算上剪枝，复杂度会更低些。<br>空间复杂度：O(9).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">ll plus_max;</span><br><span class="line">ll s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">const</span> vector&lt;ll&gt; &amp;A, ll index, ll plus, ll accu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (plus &gt; plus_max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plus == plus_max) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> ((accu - (s - accu)) % <span class="number">11</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        ll need_plus = plus_max - plus;</span><br><span class="line">        <span class="keyword">if</span> (need_plus &gt; A[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            accu += need_plus;</span><br><span class="line">            <span class="keyword">return</span> ((accu - (s - accu)) % <span class="number">11</span>) == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ll num = index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="built_in">min</span>(A[index], plus_max - plus); i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">backtracking</span>(A, index - <span class="number">1</span>, plus + i, accu + num * i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> vector&lt;ll&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    s = std::<span class="built_in">accumulate</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    plus_max = s / <span class="number">2</span> + s % <span class="number">2</span>;</span><br><span class="line">    s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        s += A[i] * (i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">backtracking</span>(A, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">A</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">0</span>; iCase &lt; T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">solve</span>(A);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2020 round A</title>
    <url>/2020/03/22/kick-start-2020-round-A/</url>
    <content><![CDATA[<p>新一年的kick start有了些许变化：</p>
<ol>
<li>所有测试结果正确与否立即返回。之前是大的数据集的测试结果赛后才能看到。相当于是降低了难度，减少了参赛者失误的代价。之前发生一点失误的话，大数据集的分数就没了。现在相当于是增加了一次罚时。</li>
<li>题目从3到变成了4道，时间不变，增加了一道送分题。</li>
</ol>
<p>Rank 570. 因为大家都是100分，所以最后比拼的都是时间。因为比赛是12:00~15:00, 所以我中间花了半个小时去吃饭。另外每个题目都不是一遍做对，都通过<code>printf</code>进行调试，花了不少时间。最快的大佬们都是20min就做完了。</p>
<p>下个月约起来round B呀！4月19号早上7点。</p>
<p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ffc7">round A 题目地址</a></p>
<h2 id="Allocation"><a href="#Allocation" class="headerlink" title="Allocation"></a>Allocation</h2><p>刚开始以为是一道简单的背包问题，后来发现是更简单的贪心问题。因为是要求购买房子数目的最大值，而不是价值的最大值，或者说 房子的价值都为1. 所以贪心即可。简而言之，送分的签到题。<br>把房子按照售价从小到大排序，先买便宜的房子。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(<span class="number">100005</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, B;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; B;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">begin</span>() + N);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; N &amp;&amp; B &gt;= A[index]) &#123;</span><br><span class="line">            B -= A[index];</span><br><span class="line">            ++ans;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为贪心的时候忘记检查<code>index &lt; n</code>了，导致一次WA罚时。</p>
<h2 id="Plates"><a href="#Plates" class="headerlink" title="Plates"></a>Plates</h2><p>动态规划。<br>状态转移方程：<br>第i个stack，取走j个盘子，得到的最大Beaty value和。<br><code>dp[i][j] = max&#123;dp[i-1][x] + top_sum[j - x] for x in [0, j]&#125;</code>。</p>
<p>时间复杂度: O(N * P * P) 50 * 1500 * 1500,<br>空间复杂度: O(N * P) 50 * 1500 -&gt; O(P) 1500.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1505</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">line</span><span class="params">(<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, K, P;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; K &gt;&gt; P;</span><br><span class="line">        <span class="built_in">fill</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; ++j) &#123;</span><br><span class="line">                cin &gt;&gt; line[j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                    line[j] += line[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = P; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">int</span> max_dp = dp[j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = j - <span class="number">1</span>; x &gt;= <span class="number">0</span> &amp;&amp; j - x - <span class="number">1</span> &lt; K; --x) &#123;</span><br><span class="line">                    max_dp = <span class="built_in">max</span>(max_dp, dp[x] + line[j - x - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] = max_dp;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; dp[j] &lt;&lt; &quot;, &quot;;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; dp[P] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Workout"><a href="#Workout" class="headerlink" title="Workout"></a>Workout</h2><p>对于<code>K == 1</code>的情况，可以直接采用贪心的策略，将最大的间隔等分。</p>
<p>对于<code>K &gt; 1</code>的情况，可以采取将<code>最优化问题转成判定问题</code>的思路解决。<br>最优化问题为：求最小的difficulty。<br>判定问题为：<code>difficulty == x</code>可否实现, 时间复杂度为<code>O(N * K)</code>。<br>然后判定问题的解的分布为: <code>... F F F T T T ...</code>，我们要找到第一个<code>T</code>。<br>采用二分法，搜索区间为<code>[1, max(M_i) = 1^9]</code>, 时间复杂度为<code>O(log 1e9)</code>。<br>故，总的有：<br>时间复杂度: O(N * K * log 1e9),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">M</span><span class="params">(<span class="number">1e5</span> + <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, K;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; M[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> determine = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> used = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> difference = M[i + <span class="number">1</span>] - M[i];</span><br><span class="line">                <span class="keyword">while</span> (difference &gt; x) &#123;</span><br><span class="line">                    ++used;</span><br><span class="line">                    <span class="keyword">if</span> (used &gt; K)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    difference -= x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> deter = <span class="built_in">determine</span>(mid);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; mid &lt;&lt; &quot;: &quot; &lt;&lt; deter &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (deter) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; lo &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bundling"><a href="#Bundling" class="headerlink" title="Bundling"></a>Bundling</h2><p>Tire + DFS + Greedy的思路。</p>
<p>因为需要用到共同前缀，所以我们可以用Tire预处理字符串。<br>用DFS搜索Trie，尝试尽量深地凑成一个group，这样得到的score更大。</p>
<p>时间复杂度: O(characters.size()), 2 * 10 ^ 6.<br>空间复杂度: O(characters.size()).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> passby = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> destination = <span class="number">0</span>;</span><br><span class="line">    array&lt;shared_ptr&lt;Trie&gt;, <span class="number">26</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_tire</span><span class="params">(shared_ptr&lt;Trie&gt; root, <span class="keyword">const</span> string &amp;s, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    ++root-&gt;passby;</span><br><span class="line">    <span class="keyword">if</span> (index == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ++root-&gt;destination;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data[s[index] - <span class="string">&#x27;A&#x27;</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        root-&gt;data[s[index] - <span class="string">&#x27;A&#x27;</span>] = make_shared&lt;Trie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build_tire</span>(root-&gt;data[s[index] - <span class="string">&#x27;A&#x27;</span>], s, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, K;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">        <span class="keyword">auto</span> root = make_shared&lt;Trie&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            string s;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            <span class="built_in">build_tire</span>(root, s, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// return left number</span></span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">int</span></span>(shared_ptr&lt;Trie&gt;, <span class="keyword">int</span>)&gt; dfs = [&amp;](shared_ptr&lt;Trie&gt; r,</span><br><span class="line">                                                       <span class="keyword">int</span> depth) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> now = r-&gt;destination;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                now += <span class="built_in">dfs</span>(r-&gt;data[i], depth + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// cout &lt;&lt;  depth &lt;&lt; &quot;: &quot; &lt;&lt; char(&#x27;A&#x27; + i) &lt;&lt; &quot;: &quot; &lt;&lt; now &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans += depth * (now / K);</span><br><span class="line">            <span class="keyword">return</span> now % K;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2020 round B</title>
    <url>/2020/04/19/kick-start-2020-round-B/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>ID</th>
<th>score</th>
<th>rank</th>
<th>Bike Tour</th>
<th>Bus Routes</th>
<th>Robot Path Coding</th>
<th>Wandering Robot</th>
<th>Time</th>
</tr>
</thead>
<tbody><tr>
<td>YoungForest</td>
<td>74</td>
<td>524</td>
<td>5 + 7</td>
<td>10 + 13</td>
<td>11 + 16</td>
<td>14 + 0</td>
<td>1:35:18</td>
</tr>
</tbody></table>
<p>去年一共参加了6轮kickstart，成功拿到Google今年的实习邀请。可惜的是，由于疫情的原因，谷歌中国的暑期实习项目全部取消了。今年为了秋招名额，仍需继续参加kickstart。今天的round B轮次虽然在早上7点，但仍然有很多同学参加。遗憾的是，最后一题的时间复杂度过高，大的Test set TLE了。</p>
<h2 id="Bike-Tour"><a href="#Bike-Tour" class="headerlink" title="Bike Tour"></a>Bike Tour</h2><p>签到题。遍历一遍mountains, 寻找比前后都高的位置即可。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mountains</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; mountains[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mountains[i] &gt; mountains[i - <span class="number">1</span>] &amp;&amp;</span><br><span class="line">                mountains[i] &gt; mountains[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bus-Routes"><a href="#Bus-Routes" class="headerlink" title="Bus Routes"></a>Bus Routes</h2><p>贪心。从后向前，选择每趟公交最晚的那班。</p>
<p>时间复杂度：O(N), 我这里使用了尾递归的写法，和迭代一样，不需要额外的空间。<br>空间复杂度：O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">schedule</span><span class="params">(<span class="number">1005</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        ll D;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; D;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; schedule[i];</span><br><span class="line">        &#125;</span><br><span class="line">        function&lt;<span class="built_in">ll</span>(<span class="keyword">int</span>, ll)&gt; f = [&amp;](<span class="keyword">int</span> index, ll d) -&gt; ll &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in"><span class="keyword">return</span></span> (d / schedule[index]) * schedule[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">f</span>(index - <span class="number">1</span>, (d / schedule[index]) * schedule[index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">f</span>(N<span class="number">-1</span>, D) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Robot-Path-Decoding"><a href="#Robot-Path-Decoding" class="headerlink" title="Robot Path Decoding"></a>Robot Path Decoding</h2><p>类似编译器支持函数调用，我们可以用一个栈存储父程序的状态。</p>
<p>时间复杂度：O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        string instructions;</span><br><span class="line">        cin &gt;&gt; instructions;</span><br><span class="line">        pair&lt;ll, ll&gt; shift = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        stack&lt;ll&gt; st;</span><br><span class="line">        stack&lt;pair&lt;ll, ll&gt;&gt; st_shift;</span><br><span class="line">        <span class="keyword">char</span> digit = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : instructions) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                st.<span class="built_in">push</span>(digit - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                st_shift.<span class="built_in">push</span>(shift);</span><br><span class="line">                shift = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: &#123;</span><br><span class="line">                ll X = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">auto</span> before_shift = st_shift.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st_shift.<span class="built_in">pop</span>();</span><br><span class="line">                before_shift.first =</span><br><span class="line">                    (before_shift.first + X * shift.first + <span class="number">12</span> * mod) % mod;</span><br><span class="line">                before_shift.second =</span><br><span class="line">                    (before_shift.second + X * shift.second + <span class="number">12</span> * mod) % mod;</span><br><span class="line">                shift = before_shift;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">                shift.second = (shift.second - <span class="number">1</span> + mod) % mod;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                shift.second = (shift.second + <span class="number">1</span>) % mod;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                shift.first = (shift.first + <span class="number">1</span>) % mod;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                shift.first = (shift.first - <span class="number">1</span> + mod) % mod;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digit = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; shift.first + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; shift.second + <span class="number">1</span></span><br><span class="line">             &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Wandering-Robot"><a href="#Wandering-Robot" class="headerlink" title="Wandering Robot"></a>Wandering Robot</h2><p>本题比赛时我只做出了小的case，大的数据会TLE。<br>思路比较简单，用DP计算走到每个格子的概率。<br><code>dp[i][j] = 0.5 * dp[i-1][j] + 0.5 * dp[i][j-1]</code>.<br>然后算走到hole上边和左边的概率和，*0.5就是掉到洞里的概率。为了避免处理下边界和右边界的特殊情况，当hole触底时，我们可以通过向左扩展hole，把一定落在hole中的概率提前拦截。当hole触右时，也是类似的处理。</p>
<p>时间复杂度：(W * T),<br>空间复杂度：O(W).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_WIDTH = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(MAX_WIDTH)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> W, H, L, U, R, D;</span><br><span class="line">        cin &gt;&gt; W &gt;&gt; H &gt;&gt; L &gt;&gt; U &gt;&gt; R &gt;&gt; D;</span><br><span class="line">        --L;</span><br><span class="line">        --U;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (D == H &amp;&amp; R == W) &#123;</span><br><span class="line">            ans = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (D == H) &#123;</span><br><span class="line">                <span class="comment">// 触底</span></span><br><span class="line">                L = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (R == W) &#123;</span><br><span class="line">                <span class="comment">// 触右</span></span><br><span class="line">                U = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U == <span class="number">0</span> &amp;&amp; L == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAX_WIDTH; ++j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            dp[j] = <span class="number">0.5</span> * dp[j] + <span class="number">0.5</span> * dp[j - <span class="number">1</span>];</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            dp[j] = <span class="number">0.5</span> * dp[j - <span class="number">1</span>];</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            dp[j] = <span class="number">0.5</span> * dp[j];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[j] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (L &gt; <span class="number">0</span> &amp;&amp; i &gt;= U &amp;&amp; i &lt; D) &#123;</span><br><span class="line">                        ans += <span class="number">0.5</span> * dp[L - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (U &gt; <span class="number">0</span> &amp;&amp; i == U - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = L; j &lt; R; ++j) &#123;</span><br><span class="line">                            ans += <span class="number">0.5</span> * dp[j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; (<span class="number">1</span> - ans) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个重要的观察是，可以通过组合数的方式求解prop(i, j): 从零点走到(i, j)的概率，0-index.<br>prop(i, j) = 0.5 ^ (the length path to (i, j)) * 可能路径的数量<br>= 0.5 ^ (i + j) * Combination(i + j, j)</p>
<p>为了快速计算组合数，我们可以预计算log(x!), 然后利用公式:</p>
<p>$$ 2^{log_2(n! / (k! \times (n-k)!) / 2^n)} = 2^{log_2 n! - log_2 k! - log_2 (n-k)! - n} $$</p>
<p>时间复杂度: O(W + H),<br>空间复杂度: O(W).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_WIDTH = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> logfactor[<span class="number">2</span> * MAX_WIDTH];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">CombinationDivide2N</span><span class="params">(ll n, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">powl</span>(<span class="number">2</span>, logfactor[n] - logfactor[m] - logfactor[n-m] - n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="comment">// preprocess log(x!)</span></span><br><span class="line">    logfactor[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * MAX_WIDTH; ++i) &#123;</span><br><span class="line">        logfactor[i] = logfactor[i<span class="number">-1</span>] + <span class="built_in">log2l</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dp = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) -&gt; <span class="keyword">double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">CombinationDivide2N</span>(i + j, j);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> W, H, L, U, R, D;</span><br><span class="line">        cin &gt;&gt; W &gt;&gt; H &gt;&gt; L &gt;&gt; U &gt;&gt; R &gt;&gt; D;</span><br><span class="line">        --L;</span><br><span class="line">        --U;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (W &gt; MAX_WIDTH || H &gt; MAX_WIDTH) &#123;</span><br><span class="line">            ans = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (D == H &amp;&amp; R == W) &#123;</span><br><span class="line">            ans = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (D == H) &#123;</span><br><span class="line">                <span class="comment">// 触底</span></span><br><span class="line">                L = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (R == W) &#123;</span><br><span class="line">                <span class="comment">// 触右</span></span><br><span class="line">                U = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U == <span class="number">0</span> &amp;&amp; L == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (U &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; R; ++i) &#123;</span><br><span class="line">                        ans += <span class="number">0.5</span> * <span class="built_in">dp</span>(i, U - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (L &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = U; i &lt; D; ++i) &#123;</span><br><span class="line">                        ans += <span class="number">0.5</span> * <span class="built_in">dp</span>(L - <span class="number">1</span>, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; (<span class="number">1</span> - ans) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2020 round C</title>
    <url>/2020/05/18/kick-start-2020-round-C/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>ID</th>
<th>score</th>
<th>rank</th>
<th>Bike Tour</th>
<th>Bus Routes</th>
<th>Robot Path Coding</th>
<th>Wandering Robot</th>
<th>Time</th>
</tr>
</thead>
<tbody><tr>
<td>YoungForest</td>
<td>74</td>
<td>524</td>
<td>5 + 7</td>
<td>10 + 13</td>
<td>11 + 16</td>
<td>14 + 0</td>
<td>1:35:18</td>
</tr>
</tbody></table>
<p>上个月因为Round B结果还不错，收到了Google CN HR的Congraduation邮件。本月再接再厉，为了进入Google的梦想而努力。</p>
<h2 id="A-Countdown"><a href="#A-Countdown" class="headerlink" title="A. Countdown"></a>A. Countdown</h2><p>One pass. 寻找countdown的模式。由于开始数字一定为K，所以countdown的过程中如果失败了的话，可以直接从失败的位置继续寻找。</p>
<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, K;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mountains</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; mountains[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mountains[i] == K) &#123;</span><br><span class="line">                <span class="keyword">int</span> need = K - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (i + j &lt; N &amp;&amp; need &gt;= <span class="number">1</span> &amp;&amp; mountains[i+j] == need) &#123;</span><br><span class="line">                    ++j;</span><br><span class="line">                    --need;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (need == <span class="number">0</span>) ++ans;</span><br><span class="line">                i = i + j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Stable-Wall"><a href="#B-Stable-Wall" class="headerlink" title="B. Stable Wall"></a>B. Stable Wall</h2><p>题目本身比较难懂。但实质就是一个拓扑排序的问题，下面的必须先放。<br>这里需要注意一个corner case：只有一行的情况。<br>因为我第一版的代码，更新<code>seen</code>是在判断上下层关系时更新的。如果只有一行的话，就会忽略第一行的字母。<br>把<code>seen</code>单独拿出来更新就可以了。</p>
<p>时间复杂度: O(R * C * 26),<br>空间复杂度: O(R * C + 26).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> R, C;</span><br><span class="line">        cin &gt;&gt; R &gt;&gt; C;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">rows</span><span class="params">(R)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; rows[i];</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="comment">// 拓扑排序</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, unordered_set&lt;<span class="keyword">char</span>&gt;&gt; out;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, unordered_set&lt;<span class="keyword">char</span>&gt;&gt; in;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; seen;</span><br><span class="line">        queue&lt;<span class="keyword">char</span>&gt; zeroIn;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">                seen.<span class="built_in">insert</span>(rows[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; R; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> down = rows[i + <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">char</span> up = rows[i][j];</span><br><span class="line">                <span class="keyword">if</span> (down == up)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                out[down].<span class="built_in">insert</span>(up);</span><br><span class="line">                in[up].<span class="built_in">insert</span>(down);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : seen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[c].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                zeroIn.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!zeroIn.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">char</span> base = zeroIn.<span class="built_in">front</span>();</span><br><span class="line">            zeroIn.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(base);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> up : out[base]) &#123;</span><br><span class="line">                in[up].<span class="built_in">erase</span>(base);</span><br><span class="line">                <span class="keyword">if</span> (in[up].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    zeroIn.<span class="built_in">push</span>(up);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span></span><br><span class="line">             &lt;&lt; (ans.<span class="built_in">size</span>() == seen.<span class="built_in">size</span>() ? ans : <span class="string">&quot;-1&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Perfect-Subarray"><a href="#C-Perfect-Subarray" class="headerlink" title="C. Perfect Subarray"></a>C. Perfect Subarray</h2><p>使用前缀和来快速求子数组和。然后用hashmap存储之前的前缀和。对于当前的前缀和遍历所有的平方数，寻找之前的前缀和。由于该题目会卡常数，所以需要用到一些竞赛用的技巧。<br>如：</p>
<ul>
<li>unordered_map可以用reserve直接扩充为最大可能的大小；</li>
<li>用数组代替hashmap, 下标有负数时，整体偏移一个常数.</li>
</ul>
<p>时间复杂度: O(N * sqrt(MAXSUM)) = O(N * 3000),<br>空间复杂度: O(N + MAXSUM).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> ll MAXSQRT = <span class="number">3163</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mxN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> seen[<span class="number">2</span>*<span class="number">110</span>*mxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> mid = <span class="number">105</span> * mxN + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> presum = <span class="number">0</span>;</span><br><span class="line">	    <span class="built_in">memset</span>(seen, <span class="number">0</span>, <span class="keyword">sizeof</span> seen);</span><br><span class="line">        seen[presum + mid] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> A;</span><br><span class="line">            cin &gt;&gt; A;</span><br><span class="line">            presum += A;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> squareI = <span class="number">0</span>; squareI &lt;= MAXSQRT; ++squareI) &#123;</span><br><span class="line">                ans += seen[mid + presum - squareI*squareI];</span><br><span class="line">            &#125;</span><br><span class="line">            ++seen[mid + presum];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Candies"><a href="#D-Candies" class="headerlink" title="D. Candies"></a>D. Candies</h2><p>题目operation有2种，分别为求区间和和更新某个值。十分适合用线段树解决。因为sweet score的定义不同于普通的求和，所以我们可以通过2个线段树的到sweet score. 分别维护 +1, -1, +1, … 和 +1, -2, +3, …。然后queryRange时，后者减去前者的某个倍数，再乘以+1/-1即可。</p>
<p>在此，感谢<a href="https://www.youtube.com/watch?v=rYBtViWXYeI">花花的线段树模版</a>，让我可以快速A掉此题。</p>
<p>时间复杂度: O(N log N),<br>空间复杂度: O(N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_ptr&lt;SegmentTreeNode&gt; left = <span class="literal">nullptr</span>, right = <span class="literal">nullptr</span>;</span><br><span class="line">    ll start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    ll val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(ll value, ll start_, ll end_): <span class="built_in">val</span>(value), <span class="built_in">start</span>(start_), <span class="built_in">end</span>(end_) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegmentTreeNode</span>(ll start_, ll end_): <span class="built_in">start</span>(start_), <span class="built_in">end</span>(end_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> unique_ptr&lt;SegmentTreeNode&gt; <span class="title">buildTree</span><span class="params">(<span class="keyword">const</span> vector&lt;ll&gt;&amp; nums, ll i, ll j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span> make_unique&lt;SegmentTreeNode&gt;(nums[i], i, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">auto</span> ret = make_unique&lt;SegmentTreeNode&gt;(i, j);</span><br><span class="line">            ret-&gt;left = <span class="built_in">buildTree</span>(nums, i, mid);</span><br><span class="line">            ret-&gt;right = <span class="built_in">buildTree</span>(nums, mid + <span class="number">1</span>, j);</span><br><span class="line">            ret-&gt;val = ret-&gt;left-&gt;val + ret-&gt;right-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">queryRange</span><span class="params">(ll i, ll j)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == start &amp;&amp; j == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> left-&gt;<span class="built_in">queryRange</span>(i, j);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> right-&gt;<span class="built_in">queryRange</span>(i, j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> left-&gt;<span class="built_in">queryRange</span>(i, mid) + right-&gt;<span class="built_in">queryRange</span>(mid + <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll index, ll value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == index &amp;&amp; index == end) &#123;</span><br><span class="line">            val = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt;= index) &#123;</span><br><span class="line">                left-&gt;<span class="built_in">update</span>(index, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right-&gt;<span class="built_in">update</span>(index, value);</span><br><span class="line">            &#125;</span><br><span class="line">            val = left-&gt;val + right-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll iCase = <span class="number">1</span>; iCase &lt;= T; ++iCase) &#123;</span><br><span class="line">        ll N, Q;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">nums</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                nums[i] *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> positiveNegtive = SegmentTreeNode::<span class="built_in">buildTree</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            nums[i] *= (i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> multiTree = SegmentTreeNode::<span class="built_in">buildTree</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll q = <span class="number">0</span>; q &lt; Q; ++q) &#123;</span><br><span class="line">            string op;</span><br><span class="line">            cin &gt;&gt; op;</span><br><span class="line">            ll start, end;</span><br><span class="line">            cin &gt;&gt; start &gt;&gt; end;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&quot;Q&quot;</span>) &#123;</span><br><span class="line">                ans += ((start % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span> ) * (multiTree-&gt;<span class="built_in">queryRange</span>(start<span class="number">-1</span>,end <span class="number">-1</span>) - (start - <span class="number">1</span>) * positiveNegtive-&gt;<span class="built_in">queryRange</span>(start<span class="number">-1</span>, end<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="number">0</span>;</span><br><span class="line">                positiveNegtive-&gt;<span class="built_in">update</span>(start<span class="number">-1</span>, ((start % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>) * end);</span><br><span class="line">                multiTree-&gt;<span class="built_in">update</span>(start<span class="number">-1</span>, ((start % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>) * start * end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; iCase &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2021 round A</title>
    <url>/2021/03/22/kick-start-2021-round-A/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>ID</th>
<th>score</th>
<th>rank</th>
<th>K-Goodness String</th>
<th>L Shaped Plots</th>
<th>Rabbit House</th>
<th>Checksum</th>
<th>Penalty Time</th>
</tr>
</thead>
<tbody><tr>
<td>YoungForest</td>
<td>56</td>
<td>1295</td>
<td>5 + 7</td>
<td>8 + 12</td>
<td>9 + 15</td>
<td>0</td>
<td>1:40:55</td>
</tr>
</tbody></table>
<p>久违的参加了KickStart比赛。之前2年还因为想去Google的原因一直坚持打，不过人算不如天算，因为疫情原因实习和秋招都直接凉了。2年多参加了10+场比赛也“白”打了。<br>今年参加真的是全凭兴趣。结果排名果然1000+。之前基本都是几百。<br>不得说，从去年开始，KickStart简单也友好了很多。之前经常只能做出来1道半题。后来为了增加参赛范围，3题变四题，整体难度也降下来了。</p>
<span id="more"></span>

<h2 id="K-Goodness-String"><a href="#K-Goodness-String" class="headerlink" title="K-Goodness String"></a>K-Goodness String</h2><p>签到题。统计字符串的goodness score，可知无论是增一还是减一的最小操作都是1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, K;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i - <span class="number">1</span>] != s[N - i + <span class="number">1</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(K - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">solve</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>
<h2 id="L-Shaped-Plots"><a href="#L-Shaped-Plots" class="headerlink" title="L Shaped Plots"></a>L Shaped Plots</h2><p>统计一个方向的L，其他方向的L可以通过 上下/左右翻转 和 旋转 共8种情况得到。<br>用动态规划的思想更新当前位置左边的长度和上边的长度，求的以当前位置为拐点的L的数目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    cin &gt;&gt; R &gt;&gt; C;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">matrix</span>(R, vector&lt;<span class="keyword">bool</span>&gt; (C));</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            matrix[i][j] = (x == <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> reverseLeftRight = [&amp;]() -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; m : matrix) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> reverseUpDown = [&amp;]() -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R - <span class="number">1</span> - i; ++i) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[R - <span class="number">1</span> - i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> flip = [&amp;]() -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">newMatrix</span>(C, vector&lt;<span class="keyword">bool</span>&gt;(R));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">                newMatrix[j][i] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix = <span class="built_in">move</span>(newMatrix);</span><br><span class="line">        <span class="built_in">swap</span>(R, C);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> one = [&amp;]() -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(R, vector&lt;<span class="keyword">int</span>&gt; (C));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j]) &#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> up = dp[i][j] / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">int</span> could = <span class="built_in">min</span>(up, left);</span><br><span class="line">                    <span class="keyword">if</span> (could &gt; <span class="number">1</span>) ans += could - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = <span class="number">0</span>;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> two = [&amp;]() -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans += <span class="built_in">one</span>();</span><br><span class="line">        <span class="built_in">reverseLeftRight</span>();</span><br><span class="line">        ans += <span class="built_in">one</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> four = [&amp;]() -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        ans += <span class="built_in">two</span>();</span><br><span class="line">        <span class="built_in">reverseUpDown</span>();</span><br><span class="line">        ans += <span class="built_in">two</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans += <span class="built_in">four</span>();</span><br><span class="line">    <span class="built_in">flip</span>();</span><br><span class="line">    ans += <span class="built_in">four</span>();</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">solve</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(8 * R * C)<br>空间复杂度: O(R*C).</p>
<h2 id="Rabbit-House"><a href="#Rabbit-House" class="headerlink" title="Rabbit House"></a>Rabbit House</h2><p>BFS. 相邻位置差最多为1，从最高的cells开始搜索。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vector&lt;pii&gt; directions = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R, C;</span><br><span class="line">    cin &gt;&gt; R &gt;&gt; C;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">matrix</span>(R, vector&lt;ll&gt; (C));</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;pii&gt;&gt; cells;</span><br><span class="line">    ll x;</span><br><span class="line">    ll maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; matrix[i][j];</span><br><span class="line">            cells[matrix[i][j]].<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">            maxHeight = <span class="built_in">max</span>(maxHeight, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;pii&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : cells[maxHeight]) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll height = maxHeight;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; s; ++x) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [i, j] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (pii d : directions) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> ni = i + d.first;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> nj = j + d.second;</span><br><span class="line">                <span class="keyword">if</span> (ni &gt;= <span class="number">0</span> &amp;&amp; ni &lt; R &amp;&amp; nj &gt;= <span class="number">0</span> &amp;&amp; nj &lt; C) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[ni][nj] &gt;= height) <span class="keyword">continue</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(ni, nj);</span><br><span class="line">                    ans += height - <span class="number">1</span> - matrix[ni][nj];</span><br><span class="line">                    matrix[ni][nj] = height;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : cells[height<span class="number">-1</span>]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        --height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">solve</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(R * C),<br>空间复杂度: O(R * C).</p>
<p>需要注意的2点是：</p>
<ul>
<li>BFS时，需要每次把高度相同的cells也加入队中。这些也是下次遍历的起点之一。</li>
<li>另外最后的结果大于32位数，需要<code>long long</code>避免overflow的WA。<br>我也因此多了3次WA罚时。</li>
</ul>
<h2 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h2><p>比赛到最后一题已经非常累了。LeetCode周赛1小时+KickStart3小时，如此高强度的脑力活动，对人的精力已经是十分大的消耗了。因此，最后一题时我脑子已经不如一开始的清醒了。思考了一段时间后就放弃了。事实上，暴力法拿个小数据的分数对我平时的水平来说还是做的到的。</p>
<p>赛后补题, 解法参考官方的Analysis。</p>
<h3 id="暴力法-Test-Set-1"><a href="#暴力法-Test-Set-1" class="headerlink" title="暴力法 Test Set 1"></a>暴力法 Test Set 1</h3><p>枚举所有的花费集合，判断是否可以推断出全部的棋盘。<br>判断是否可以推断出全部元素可以使用BFS来进行，从行列唯一元素开始遍历，依次增加元素。其实DFS也行。</p>
<p>时间复杂度: O(2^(N^2) * N ^ 2).</p>
<h3 id="破环法-Test-Set-2"><a href="#破环法-Test-Set-2" class="headerlink" title="破环法 Test Set 2"></a>破环法 Test Set 2</h3><p>以行列号为节点，空缺元素为边，可以将原矩阵转换成一个二分图。行在一边，列在一边。<br>单独的节点表示 该行/列的所有元素已知，可以直接忽略。<br>节点度为1表示 该行/列只有一个未知元素，可以通过checksum推断，因此可以直接删掉。<br>剩下的图组成一个无向有环权重图。</p>
<p>原问题转换成 以最小代价删去一定的边，使得原图无环。<br>可以采用贪心算法。从小到大遍历边，如果在环内，就删掉。判断是否在环内可以用暴力DFS解决。不通过这个边，看是否有另外一条路径从该边的一个节点到另一个节点。</p>
<p>时间复杂度: 遍历所有剩下的边 * 判断环 = O(N ^ 2 * N ^ 2) = O(N^4).</p>
<p>贪心算法的正确性证明参考 <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">最小生成树 Kruskal 算法</a>.</p>
<h3 id="最大生成树-Test-Set-3"><a href="#最大生成树-Test-Set-3" class="headerlink" title="最大生成树 Test Set 3"></a>最大生成树 Test Set 3</h3><p>在解法2的基础上，事实上，我们可以通过最大生成树算法快速得到最后的状态。</p>
<p>时间复杂度: Prim O(N^2), Kruskal O(N^2 * log N).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> tii = tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> comp_cnt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UF</span>(<span class="keyword">int</span> _n): <span class="built_in">n</span>(_n), <span class="built_in">comp_cnt</span>(_n), <span class="built_in">fa</span>(_n), <span class="built_in">sz</span>(_n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">iota</span>(fa.<span class="built_in">begin</span>(), fa.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">findset</span>(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">findset</span>(x);</span><br><span class="line">        y = <span class="built_in">findset</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sz[x] &lt; sz[y]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            --comp_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">findset</span>(x);</span><br><span class="line">        y = <span class="built_in">findset</span>(y);</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="comment">// construct the 2-partical graph</span></span><br><span class="line">    vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">graph</span>(<span class="number">2</span> * N);</span><br><span class="line">    vector&lt;tii&gt; edges;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                graph[i].<span class="built_in">push_back</span>(&#123;j + N, x&#125;);</span><br><span class="line">                graph[j + N].<span class="built_in">push_back</span>(&#123;i, x&#125;);</span><br><span class="line">                edges.<span class="built_in">emplace_back</span>(x, i, j + N);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), greater&lt;&gt;());</span><br><span class="line">    <span class="function">UF <span class="title">uf</span><span class="params">(<span class="number">2</span>*N)</span></span>;</span><br><span class="line">    ll cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">connected</span>(get&lt;<span class="number">1</span>&gt;(e), get&lt;<span class="number">2</span>&gt;(e))) &#123;</span><br><span class="line">            cost += get&lt;<span class="number">0</span>&gt;(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uf.<span class="built_in">unite</span>(get&lt;<span class="number">1</span>&gt;(e), get&lt;<span class="number">2</span>&gt;(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = <span class="built_in">solve</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我采用了Krusal, 因为写起来更好实现些。</p>
<p>时间复杂度: O(N^2 * log N^2),<br>空间复杂度: O(N^2).</p>
]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>kick start 2021 round B</title>
    <url>/2021/04/20/kick-start-2021-round-B/</url>
    <content><![CDATA[<p>比赛时间是北京的19号上午7点到10点，因为恰好下午2点要交毕设初稿。最近忙着一直在写大论文。因此并未参加Round B. 现如今自己已经过了校招的年纪，打Kick Start纯粹是为了娱乐。<br>赛后补题。</p>
<p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b">比赛题目链接</a></p>
<h2 id="Increasing-Substring"><a href="#Increasing-Substring" class="headerlink" title="Increasing Substring"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882">Increasing Substring</a></h2><p>签到题。DP，只需要和前一个字符比大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N ;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i] &gt; s[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N),<br>空间复杂度: O(N) -&gt; O(1). 虽然我的实现是O(N)的，但其实<code>dp</code>数组是没必要存的，只关心前一个的值。</p>
<h2 id="Longest-Progression"><a href="#Longest-Progression" class="headerlink" title="Longest Progression"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a3a5">Longest Progression</a></h2><p>遇到WA，是因为C++类型的原因。列在这里引以为戒。<br>因为类型转换的原因，size() 和 -1比较时，-1永远大。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">Cmp</span>&gt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; out, <span class="keyword">const</span> unordered_set&lt;T, Cmp&gt;&amp; a) &#123;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;&#123;&quot;</span>; <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : a) &#123; out &lt;&lt; (first ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>); out &lt;&lt; v; first = <span class="number">0</span>;&#125; out &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">Cmp</span>&gt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; out, <span class="keyword">const</span> unordered_map&lt;U, T, Cmp&gt;&amp; a) &#123;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;&#123;&quot;</span>; <span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : a) &#123; out &lt;&lt; (first ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>); out &lt;&lt; p.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; p.second; first = <span class="number">0</span>;&#125; out &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N ;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">3</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(N)</span></span>;</span><br><span class="line">    diff[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        diff[i] = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hi = N + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">auto</span> binary = [&amp;](ll lo, ll hi, function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">const</span> ll)&gt; predicate) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="comment">// return first true</span></span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            ll mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">predicate</span>(mid)) &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> pred = [&amp;](<span class="keyword">const</span> ll x) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, unordered_set&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, unordered_set&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; reverseCnt; <span class="comment">// cnt-&gt;value, cnt-&gt;count</span></span><br><span class="line">        <span class="keyword">auto</span> addCnt = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            cnt[diff[i]].<span class="built_in">insert</span>(i);</span><br><span class="line">            reverseCnt[cnt[diff[i]].<span class="built_in">size</span>()].<span class="built_in">insert</span>(diff[i]);</span><br><span class="line">            reverseCnt[cnt[diff[i]].<span class="built_in">size</span>() - <span class="number">1</span>].<span class="built_in">erase</span>(diff[i]);</span><br><span class="line">            <span class="keyword">if</span> (reverseCnt[cnt[diff[i]].<span class="built_in">size</span>() - <span class="number">1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                reverseCnt.<span class="built_in">erase</span>(cnt[diff[i]].<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> eraseCnt = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> i) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; first = cnt[diff[i]];</span><br><span class="line">            first.<span class="built_in">erase</span>(first.<span class="built_in">find</span>(i));</span><br><span class="line">            reverseCnt[cnt[diff[i]].<span class="built_in">size</span>() + <span class="number">1</span>].<span class="built_in">erase</span>(diff[i]);</span><br><span class="line">            <span class="keyword">if</span> (reverseCnt[cnt[diff[i]].<span class="built_in">size</span>() + <span class="number">1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                reverseCnt.<span class="built_in">erase</span>(cnt[diff[i]].<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (first.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                cnt.<span class="built_in">erase</span>(diff[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            reverseCnt[cnt[diff[i]].<span class="built_in">size</span>()].<span class="built_in">insert</span>(diff[i]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; x; ++i) &#123;</span><br><span class="line">            <span class="built_in">addCnt</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> lastIdx) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; lastIdx &lt;&lt; &quot; ... &quot; &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; maxDiffIndex &lt;&lt; &quot; &quot; &lt;&lt; maxDiffValue &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">auto</span> it = reverseCnt.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> maxDiffValue = it-&gt;first;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> maxDiffIndex = *(it-&gt;second.<span class="built_in">begin</span>());</span><br><span class="line">            <span class="keyword">if</span> (maxDiffValue == x - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maxDiffValue == x - <span class="number">2</span> || maxDiffValue == x - <span class="number">3</span>) &#123;</span><br><span class="line">                vector&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">                index.<span class="built_in">reserve</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : cnt) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p.first != maxDiffIndex) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; idx : p.second) &#123;</span><br><span class="line">                            index.<span class="built_in">push_back</span>(idx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (maxDiffValue == x - <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index[<span class="number">0</span>] == lastIdx || index[<span class="number">0</span>] == lastIdx - x + <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxDiffValue == x - <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index[<span class="number">1</span>] &lt; index[<span class="number">0</span>]) &#123;</span><br><span class="line">                        <span class="built_in">swap</span>(index[<span class="number">0</span>], index[<span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (index[<span class="number">0</span>] + <span class="number">1</span> != index[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[index[<span class="number">1</span>]] - nums[index[<span class="number">0</span>] - <span class="number">1</span>] == maxDiffIndex * <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;Debug: &quot; &lt;&lt; maxDiffValue &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(x<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// if check</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;before: &quot; &lt;&lt; cnt ;</span></span><br><span class="line">            <span class="built_in">eraseCnt</span>(i - x + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">addCnt</span>(i);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;after: &quot; &lt;&lt; cnt &lt;&lt; &quot; !!! &quot;;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// for (int i = 4; i &lt; hi; ++i) &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; pred(i) &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">binary</span>(lo, hi, pred) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>();</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N log N log N),<br>空间复杂度: O(N).</p>
<p>按理说 <code>N = 10 ^ 5</code> 不会超时，然而大的case还是TLE了。可能是被卡常数了。<br>看了官方题解，时间复杂度是O(N)。多了两个log还是不行呀。</p>
<h2 id="Consecutive-Primes"><a href="#Consecutive-Primes" class="headerlink" title="Consecutive Primes"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a8e6">Consecutive Primes</a></h2><h2 id="Truck-Delivery"><a href="#Truck-Delivery" class="headerlink" title="Truck Delivery"></a><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a885">Truck Delivery</a></h2>]]></content>
      <categories>
        <category>KickStart</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>快手实习生面试</title>
    <url>/2018/04/30/kuaishou-intern-interview/</url>
    <content><![CDATA[<p>感谢@lxc师兄的内推和面试建议，我有幸可以参加快手推荐组算法实习生的面试，并最终通过面试被录取。<br>虽然实习生的面试可能相对简单，但是我认为还是有参考价值的。<br>刷实习算是一种最终找到好工作，进入梦想公司的途径吧（不能算是捷径，我实习的2份工作还是很累的。快手是我的第二份实习。）。<br>现在实习终于稳定下来，毕设论文也还有一段时间才deadline，恰好抽出时间总结一下自己的面试和实习。<br>希望可以指导到自己之后找其他实习或者是正式工作:)</p>
<span id="more"></span>

<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><p>我总共经历2轮面试，耗时近2个小时。<br>总体感觉是准备的不很充分，很多地方有待提高。</p>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>面试官是一个胖胖的小哥哥，很友善，面试也很认真。<br>我参加实习后，经常在开会和吃饭的时候遇到他，感觉很亲切；我们不在一个小组，但在同一大组。</p>
<p>面试内容：</p>
<ul>
<li>给定一个数组，找到和最大的连续序列，返回和；</li>
<li>翻转句子：如 today is wednesday! =&gt; wesdnesday is today!</li>
<li>SQL相关：left join, right join, inner join区别；partition了解不。</li>
<li>机器学习相关：准确率和召回率的定义</li>
</ul>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>面试官是一个严肃的工程师，给我的印象是反应很快，可能是leader类的人物。<br>但可惜的是，我入职之后在大组没有见过他。</p>
<ul>
<li>内存特别小时，在大量的数中找到数m的位置。</li>
<li>a = b时，b有可能在哪里获取？寄存器、cache、Memory、外存</li>
<li>一个已排好序的数组，循环左移k位(k未知)，找到数m的位置。</li>
<li>n个台阶，可以走1步或2步… 这个题他先问我做过吗？我说做过，就没再让我做。</li>
<li>一颗二叉树，每个节点存一个数，找到两个数的最近公共父节点。</li>
<li>多进程与多线程区别；</li>
<li>java、C++ 多进程通信使用；</li>
<li>java、C++ 网络通信 socket库使用。（这2个我没答好）</li>
<li>机器学习的了解程度，损失函数是否研究过。</li>
</ul>
<h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><p>经过这次面试，我对面试的准备内容更加明确了：</p>
<ul>
<li>数据结构和算法是基础，必须好好复习和刷题的。</li>
<li>SQL、机器学习和Hadoop只是是锦上添花的技能。</li>
<li>手写代码和简答是面试的主要内容。</li>
</ul>
<p>因为事实上，我sql、机器学习、多线程的问题答得都很差，只有算法题马马虎虎答得还可以，都写出来了，虽然中间出现过一些错误而且耗时可能比较长（尤其是手写第一题的时候，还没进入状态，多花了些时间）。</p>
<p>参考师兄的建议，我认为如下的准备路径和方式比较高效（我也还在准备当中）：</p>
<ul>
<li>数据结构和算法：cos226+算法第四版，the elements of interview</li>
<li>sql: sql必知必会，<a href="http://www.runoob.com/sql/sql-constraints.html">runoob</a></li>
<li>多线程：Java并发编程实践</li>
<li>机器学习：周志华的“西瓜书”</li>
</ul>
<h1 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h1><p>之前因为毕设的原因，还犹豫过到底要不要接受实习offer。<!--和陪奶奶--><br>经过咨询师兄和权衡利弊，我最终还是接受了offer，于4月19日入职。<!--被奶奶劝导--><br>这份offer的待遇是：每天300，管午饭、下午茶和晚饭，水果牛奶雪糕随便吃。<br>事实上是：<br>每天税前300，实习生按劳务所得交税，超过800的部分要交给国家20%。<br>午饭晚饭还是很棒的，尤其是午饭的自助餐，每次都吃撑。<br>下午茶很简单，一个牛皮纸袋里有饮料、水果和零食，与想象中的有差距，但还是很使人满足的；我经常会剩一些带回去吃。</p>
<p>从工作中的点点滴滴中，我可以感受到<br>快手是一家技术很好、牛人很多的公司，现在在迅速扩张之中，几乎每周组内都有人入职（因此我才被录取？）。<br>带我的2个mentor人也都很nice，我从工作中学习和成长了很多。</p>
<!--
工作内容有：
- 使用pyplot进行数据可视化
- hive sql进行数据预处理
-->]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>kuaishou</tag>
      </tags>
  </entry>
  <entry>
    <title>latex 使用过程中遇到的问题</title>
    <url>/2018/03/27/latex-problems/</url>
    <content><![CDATA[<p>笔者毕业设计论文的撰写使用了latex工具，遇到了许多问题，在此总结一下。</p>
<h2 id="pdf无法正常显示"><a href="#pdf无法正常显示" class="headerlink" title="pdf无法正常显示"></a>pdf无法正常显示</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>经过xelatex编译成功地文档无法正常显示pdf图片，显示的是一片空白。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a><a href="http://tieba.baidu.com/p/4191389769?traceid=">原因</a></h3><p>pdf文件的版本问题。查看其版本为1.7，xelatex默认按照1.5进行编译。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>xelatex %.tex，此处加上–output-driver=”xdvipdfmx -V7”。即修改msmake.bat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xelatex %mythesis%</span><br><span class="line"><span class="comment"># =&gt;</span></span><br><span class="line">xelatex --output-driver=<span class="string">&quot;xdvipdfmx -V7&quot;</span> %mythesis%</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>tex</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS写入ntfs解决方案</title>
    <url>/2019/11/11/mac-write-ntfs-solution/</url>
    <content><![CDATA[<p>使用Mac系统确实存在一些不方便的地方，比如 写入 NTFS的硬盘或U盘。默认情况下，MAC 只支持读取NTFS。不过只要你有勇气折腾，解决方案还是很简单的。</p>
<h2 id="最推荐方法"><a href="#最推荐方法" class="headerlink" title="最推荐方法"></a>最推荐方法</h2><p><a href="https://mounty.app/">Mounty for NTFS</a></p>
<p>优点：免费，小巧<br>缺点：不hack，其实就是命令行的包装。有些同学可能更喜欢命令行的方式。</p>
<h2 id="最hack的方法"><a href="#最hack的方法" class="headerlink" title="最hack的方法"></a>最hack的方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo umount <span class="string">&quot;/Volumes/Seagate Expansion Drive&quot;</span></span><br><span class="line">sudo mount -t ntfs -o rw,auto,nobrowse /dev/disk3s1 ~/ntfs-volume</span><br></pre></td></tr></table></figure>

<p>reference: <a href="https://mounty.app/">mounty</a></p>
<p>经过一段时间的斗争，我还是采用了安装第三方应用的推荐方法。因为命令行确实经常忘记或是输错，每次都要重新Google，与我使用Mac系统想要的优雅方便不符。</p>
]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>将博客园中的随笔迁移到Hexo</title>
    <url>/2016/11/22/move-posts-from-cnblogs-to-Hexo/</url>
    <content><![CDATA[<p>有关如何将其他博客上的文章迁移到<code>Hexo</code>上, <a href="https://hexo.io/docs/migration.html">官方文档</a>给出了一些指引. 我也是根据官方文档进行了将自己之前在博客园中的随笔迁移到新博客上的尝试. 这个过程中遇到过一些问题, 再此给出解决方法.</p>
<span id="more"></span>
<h2 id="未安装迁移插件"><a href="#未安装迁移插件" class="headerlink" title="未安装迁移插件"></a>未安装迁移插件</h2><p>博客园需要用rss迁移, 我根据文档, <code>$ npm install hexo-migrator-rss --save</code> 安装了相关的插件, 但在运行迁移命令<code>$ hexo migrate rss &lt;source&gt;</code>时, 报出了如下错误:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">undefined migrator plugin is not installed.</span><br><span class="line">Installed migrator plugins:</span><br><span class="line"></span><br><span class="line">For more <span class="built_in">help</span>, you can check the online docs: http://hexo.io/</span><br></pre></td></tr></table></figure>

<p>我在<a href="http://stackoverflow.com/questions/34025076/when-running-hexo-migrate-rss-it-prompt-undefined-migrator-plugin-is-not-insta">stackoverflow</a>上找到了答案. 原来是需要在博客所在的目录下运行安装插件命令<code>$ npm install hexo-migrator-rss --save</code>才可以. 看来还是我不熟悉nodejs的原因, 因为nodejs的包管理安装默认是局部的, 安装在当前文件夹下的.</p>
<p>在博客所在目录下重新安装”hexo-migrator-rss”插件, 问题解决.</p>
<h2 id="迁移后的文章只有摘要和超链接"><a href="#迁移后的文章只有摘要和超链接" class="headerlink" title="迁移后的文章只有摘要和超链接"></a>迁移后的文章只有摘要和超链接</h2><p>成功迁移后, 我兴奋地立即查看了迁移结果, 结果发现, 迁移的文章只有摘要和链接到博客园原文章的超链接, 就想下图一样. 这显然不是我想要的.</p>
<p><img src="https://cloud.githubusercontent.com/assets/13612111/20493077/5f16663e-b052-11e6-9a0f-256d35ca6110.png" alt="迁移不完全"></p>
<p>可以发现这是由于博客园导出的rss就是这样的. 通过观察, 我发现rss的链接只是一个包含文章信息的<code>xml</code>文件, 也就是说, 如果我们可以得到有完整文章信息的<code>xml</code>文件就可以了. 恰好博客园的备份功能可以提供这样的文件. 将rss链接换为备份文件的链接, 在运行迁移命令就可以将完整的文章迁移到Hexo了. 下面是完整迁移的效果.</p>
<p><img src="https://cloud.githubusercontent.com/assets/13612111/20493198/cc799b42-b052-11e6-9a0d-28f2e3f8e207.png" alt="迁移完全"></p>
<p>不过这样的迁移还是丢失了标签这样的信息, 不尽如人意.</p>
<h2 id="奇怪的格式问题"><a href="#奇怪的格式问题" class="headerlink" title="奇怪的格式问题"></a>奇怪的格式问题</h2><p>迁移成功后发现, 有两篇文章的格式变得很奇怪, 正文都很正常, 但引用, 插入代码的地方就会排版很乱. 但另一篇却很完美. 通过观察迁移的<code>xml</code>文件内容发现, 那两篇文章的内容是html格式的, 而另一篇是<code>Markdown</code>格式的. 这时我才想起, 最初的两篇随笔是用博客园推荐的<code>TinyMCE编辑器</code>编写的, 后来才转投<code>Markdown</code>的. 所以, Hexo当然不能完美的支持.</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>硕士3年复盘</title>
    <url>/2021/07/11/my-3-years-master/</url>
    <content><![CDATA[<p>本科毕业时，我写了4年的总结：<a href="https://youngforest.github.io/2018/10/03/my-4-years-college/">大学4年复盘</a>. 现在转眼之间3年过去了，我已研究生毕业，即将进入职场。</p>
<p>虽然经历了半年延毕，但最后还是有惊无险的成功毕业了。上周完成了去武汉的毕业旅行，周末回到北京搬家和准备入职。带着对未来美好的期望，我踌躇满志。</p>
<h2 id="硕士3年"><a href="#硕士3年" class="headerlink" title="硕士3年"></a>硕士3年</h2><p>3年前，因为本科成绩优异。我最后走上了保研这条看似光鲜亮丽的路。<br>虽然经历了诸多坎坷和焦虑，但我并不后悔这样的选择。<br>对于我这样的小镇做题家，这样的结果和发展道路属实更加稳妥，风险更低，收益也相对可观。</p>
<p>回顾研究生这3年，我有很多事情没有干成功。</p>
<p>研一上被老板派去文远知行实习，工作还算辛苦和圆满，但最后不欢而散。其实一开始就不愿意去，迫于牛老板的淫威。见<a href="https://www.douban.com/note/694767558/">我的吐槽</a>。短期挣到了每月3k的工资，长期浪费了时间。<br>研一下转做水科院项目，因为甲方扯皮和技术储备不足，最后成了一个深坑，不了了之了。<br>研一除了帮牛老板干活外，还需要上课。把毕业需要的学分都修完。因为时间精力分散和重要程度降低的原因，我成绩并没本科好。不过也没人在乎这个成绩。<br>研二下+研三，一直在写小论文和大论文。小论文修改数十次，投稿3次，2次被拒，一次被老板嫌弃会议级别而撤稿，均以失败告终。大论文被老板多次贬低，吓的毕不了业。然而答辩时，和其他同学一对比，发现自己的工作做的其实很不错。</p>
<p>也干成了自己想干的一些事儿。</p>
<p>研二上去比利时交换，体验了一下留学生活，并且把欧洲几乎玩了一个遍。事后证明，这确实是很幸运的。因为第二年，就爆发了全球性的新冠疫情。旅游变成了一项不可能的活动，尤其是出国旅行。<br>在交换的过程中，与npy相识、相知、最后相恋。也算是一段美妙的姻缘。<br>研二暑假通过亚马逊的远程实习，之后顺利拿到了亚马逊的offer。也算是稍稍弥补了因为突如其来的疫情而不能去谷歌的遗憾。</p>
<h2 id="未来憧憬"><a href="#未来憧憬" class="headerlink" title="未来憧憬"></a>未来憧憬</h2><p>马上就要进入职场，成为一名光荣的打工人了。<br>给自己职业规划的几点忠告：</p>
<p><strong>做一个靠谱的人。</strong><br>工作后不能再像读书时那样放任自由了。很多时候都应付牛老师，自己并没有听老师的话。然而这样确实利大于弊。一则我并不喜爱科研，读论文、写论文 对我来说如同上坟。二则我摸鱼多出的时间也并没有荒废，而是用来做自己喜欢的事情，比如刷算法题、学习C++。这些事情也更好地帮助我完成了自己的目标：找到一份好的工作。而听牛老师的话对他的好处更多，对我的好处更少。三则我们毕业没有论文要求。虽然在牛老师的恐吓中，我尝试发了3次小论文，2次被拒，1次老师嫌会议不好，撤稿了。最后勉强搞了一篇专利。毕业答辩的时候才发现，其他同学的毕业设计很多都做的比我差多了，大约相当于我本科时的水平。之前每天担忧毕不了业，都是牛老板吓我们，我们自己吓自己，能把自己吓死了。其实毕业要求并没有想象的高。也可以理解，因为虽然北航6系优秀的同学很多，我们实验室也卷的很，但我们的水平还是处于总体中上的。研究生的最后一年，我的知识和经验相对成熟后，我才了解到，自己可能被PUA了。只有让学生恐慌，觉得自己不行，牛老师才能更好地掌握他的权力。<br>然而，工作之后又是另外一番场景。毕竟拿钱办事儿，经理作为你的老板也不会像父母和老师那样惯着你了。靠谱作为一项我认为工作最重要的品质。让经理放心把任务交给你，同事和你合作时更舒心。对职业成长和发展都十分有好处。</p>
<p><strong>学会攒钱储蓄和投资理财。</strong><br>下周入职，但是发现入职前半个月已经几乎花光了积蓄，不得不向父亲要钱。大头是租房，其次是毕业旅行，然后是配置生活用品，包括家具、调味品、厨具，这些花费很多都超出我的预计。当我意识到危险的时候，信用卡已经欠款33k了。虽然我之前储蓄了4w, 但是因为对支出的预计不足，我有12k放在了理财里，一时拿不出来。因此在下个月10号信用卡出账单前，大概有6k的缺口。本来想向女朋友借一些钱周转一下。但本身金额比较大，女朋友又是一个小财迷。走投无路之下，只能找爸爸要钱了。他甚至连我的银行卡号都没有。我很多年没有直接要钱了，一直靠自己生活。通过实习和学校发补助攒钱。我之前预料到一毕业会比较需要钱，因此攒了4w，但没想到这么缺钱。成年人的生活真是太难了。<br>之前尝试买基金，但基本上都以亏钱为主，做了韭菜。但也因此成长了不少，算是入门了投资理财。<br>因为之后我打算去欧洲/北美发展，不想在国内卷了。一开始刚去的时候，肯定还是需要花费一大笔钱做周转。<br>以后买房、买车、娶老婆、养孩子，都需要钱，因此需要早日开始准备。</p>
<p><strong>注重职业发展。</strong><br>读了19年书，现在正式进入打工人行列。相比之下，打工的时间可能更长，预计40年。因此，需要好好规划一下，有一个好的开始，不断积累，产生复利效应。<br>当前的职业规划是：一直做SDE，做到SDE3以上。在大厂工作。去欧洲/美帝生活。<br>根据我的职业规划，现在要做的主要有3件事儿：1. 提高自己的SDE素质，面向工作和面试；2. 英语口语；3. 锻炼身体。</p>
<h2 id="岁月是把杀猪刀"><a href="#岁月是把杀猪刀" class="headerlink" title="岁月是把杀猪刀"></a>岁月是把杀猪刀</h2><p>最后附上自己读研前和读研后的2张照片，再次感叹岁月是把杀猪刀。3年过去了。分别是22岁和25岁的我。</p>
<p><img src="/images/%E9%9D%92%E5%B2%9B%E6%B5%B7%E8%BE%B9.jpg" alt="本科毕业旅行在青岛海边"></p>
<p><img src="/images/%E7%89%9B%E8%80%81%E5%B8%88%E5%92%8C%E6%9D%A8%E6%A3%AE.jpeg" alt="硕士毕业和导师的合影"></p>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>大学4年复盘</title>
    <url>/2018/10/03/my-4-years-college/</url>
    <content><![CDATA[<p>2014年9月，我误打误撞来到了北航计算机学院。没想到“侯门一入深如海，从此萧郎是路人“，从一个从没有接触过代码的小鲜肉，成长为未来的工程师。这四年的时光是我技术和三观成长的重要阶段，可以说，大学塑造了之后的我。其中，有值得肯定的部分，也有我现在一心想要摒弃的缺点。</p>
<p>北航的课程以基础扎实著称。计算机科学的基础课程：计算机组成原理、操作系统、编译原理、计算机网络，分别分布大二大三在4个学期，每学期这些基础课都属于重课，需要花费大量的精力。现在看来，重视这些基础课程简直太正确了。我大四参加了多场实习面试和实习，深刻体会到这些基础在面试和工作中的重要程度。只是当时大多数学生的motivation不足，并不能理解学院的良苦用心。我自认为在学院学习成绩名列前茅，奖学金和各种证书也拿了一大把。但对于这些cs基础，并不敢叫嚣自己理解了，更多地是谦虚地告诉自己，很多还需要补习。年轻的时候欠下的帐迟早要还的。这四年来，貌似学了很多，其实学到很少。其实，最好的学习方法是，在学院的课程配合下，主动地进行学习。阅读每个topic的扩展材料，而不是老师把材料的链接放在ppt上，自己连下载都不下载。多多上网搜集信息，泡图书馆。</p>
<p>虽然平时经常和朋友们吐槽课程设置不合理，但我不得不承认，计算机学院的很多本科课程的设置还是极其合理并富有前瞻性的，尤其是结合其他高校的课程设置来看。北航计算机学院全国第三的排名也并非浪得虚名。比如，大一上的大学计算机基础就是教python，更可怕的是，是几乎所有专业的同学都要学，不限于计算机，还有人文、经济、数学、飞行器。后来写的代码多了，才知道掌握python确实是必要的。尤其是15年后，机器学习大火之后。python是机器学习的必备语言。而据我所知，并没有其他高校从14年就将python设置为全校的必修课。<br>大一的时候，我们要上很多课，其中大多数是数学课，编程课程每学期只有一两节。每门数学课还都是大课重课，需要花费很多的精力。包括 数学分析、高等代数、概率与统计这些基础课程，也有 离散数学、集合论、图论 这些和计算机相关的数学课。当时大家都笑称，“进错了专业，其实是数学系”。之前有过编程经验的同学更是无法理解，因为他们选择计算机专业时就期待着更多实践课程，可以动手写代码。现在看来，对数学课的重视一点也不为过。只是当初too young, too naive，无法理解老师们的良苦用心。真的就像大一时候班主任告诉我们的一样，基础数学课的有用程度是 概率统计 &gt; 线性代数 &gt; 微积分。后来接触机器学习后，才知道数学真TMD重要。年轻的时候总是认为自己很牛逼，知道自己需要什么，不需要什么；认为学院很傻逼，老师很古板。其实呀，真正傻逼的还是自己。</p>
<p>大学期间究竟要不要参加各类比赛呢？我认为完全没必要，除非你对该比赛有强烈的兴趣，或者比赛的经历和奖项可以给你带来足够的收益。<br>从现在看来，我参加比赛的经历并未获得足够的收益，反而投入了一部分时间和经历。<br>我大学期间参加过各种各样的比赛，主要集中于学科竞赛和编程比赛。首先是数学建模竞赛，估计是很多大学生都有机会参与的。我曾经和2位同学一起参加了2016年的美赛和国赛。现在看来是一件蛮可笑的事情。我们之前没有任何关于建模的数学基础和写作训练，试图水一个奖项，最后当然竹篮打水一场空。诚然很多同学也是熬夜几天，水了一个二等奖，但这个奖项的收益有多大呢？美赛几乎都是中国人在参加，大家也知道奖项并不能证明你的能力。大一上数学分析的时候，杨小远老师就说，她在数学学院招收研究生的时候，发现很多人都有美赛的奖项，但面试一问就露馅了，数学和建模能力一般。获奖更多的是抱大腿和比赛本身的水分。<br>所以，我认为，很多时候，奖项只是锦上添花的东西，更重要的是，你在准备比赛和参加比赛的过程中，收获的能力和成长。<br>我在大二的时候，也参加过大学生数学竞赛（非数学类）。在竞赛的培训期间，因为太难了，很多材料都只做了不到1/3。就是这样，我竟意外地获得了全国三等奖。但实话说，这个奖项对我没多大作用（当然对评奖学金是有用的），而且我在准备竞赛的时候并没有全力以赴，收获到的能力和成长都是有限的。</p>
<p>大学期间，我一直没想明白自己以后要做什么。没有清晰的目标，就没有细致的规划。很多机会其实也就这样错过了，机会总是留给有准备的人的。这样时间不能说是浪费掉了，但却没有被高效利用起来。大一大二大三一直在上课。由于高考的失利阴云一直笼罩在我的心里，我到了大学仍然学习很认真，生怕落后。大三到了决定出路的时候，自己才发现周围少部分同学早早地准备了出国、保研、工作，此时正是丰收前的最后冲刺。而我像大多数人一样，匆匆忙忙地度过了大学的前几年。我由于成绩不错，被老师鼓动保研了。<br>就像很多游戏里的职业系统一样，玩家达到某一等级后，就可以选择不同的职业，专学该职业的技能，购买该职业的装备。有经验的玩家会早早准备着这一步，可能从0级就决定好之后的职业了。然后向着这个职业修炼，因此技能点和金钱一点也不浪费。而我就像新手玩家一样，早期由于晋升道路很明显和固定，一路打怪升级，由于天赋玩的还不错。但到了选择职业这一步，就蒙蔽了。货比三家，还是选择了人数最多的职业。心想，选的人多自然有其道理。进入职业后，由于前期的专项积累不够，与有经验的玩家有差距甚至是被吊打，也不足为奇了。</p>
<p>大四在外实习了一年，接触了业界的不少前辈。从75后到80后，还有不少90后。通过比较和自己在实验室的生活，我发现自己更适合和喜欢工作。我本身性格内向，对数理也很感兴趣，大学接触编程后，也是兴趣盎然。相比很多同学对编程的不温不火，甚至排斥，我对编程可以算是热爱了。大二折腾了一年，自学了Linux、git、鼓捣个人博客、网站。这些折腾到后来给了我丰厚的回报，尤其是Linux和git 2项，在之后的工作学习中有大量的使用。数学上的优势也让我可以接触到算法岗的工作。但由于没有丝毫准备，当时的我并不能放弃读研，转而工作。因为程序员的短缺，我本科毕业找到一份看上去还不错的工作不难。但并不能找到顶尖的工作。程序员也分很多种，前端、后端，架构、算法。我也不清楚其中的差别，莽莽撞撞地去工作很危险。所以，我就打算继续读研了。趁着读研期间的学生身份，多出去实习几次。一是可以体验不同的工种，找到自己适合的；二是可以锻炼自己的能力，丰富简历内容，为明后年找工作做准备。</p>
<p>以上，就是我大学四年的复盘。主要集中在学习和人生规划方面。因为我认为这些才是大学生需要主要思考的问题。<br>我的大学生活绝不能算是成功，相反，与身边优秀的人相比，可以算是失败了。所以，这篇文章，更多的是教训、而不是经验。希望自己以后可以引以为戒。</p>
<h2 id="岁月是把杀猪刀"><a href="#岁月是把杀猪刀" class="headerlink" title="岁月是把杀猪刀"></a>岁月是把杀猪刀</h2><p>岁月是把杀猪刀，有些人千刀万剐，有些人刀枪不入。</p>
<p><img src="/images/junxun.jpg" alt="入学军训"></p>
<p><img src="/images/biye.jpeg" alt="毕业前夕"></p>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
  </entry>
  <entry>
    <title>英伦游学所见所思</title>
    <url>/2016/08/25/my-britain-trip/</url>
    <content><![CDATA[<p>今年暑假，有幸参加我航高等工程学院和剑桥东方交流会联合承办的英国交流营。该交流营为期两周，内容充实，形式多样，让我深刻了解了英国的人文文化和中国人留学情况，圆满完成自己行前的目标。接下来，我就整个整理进行整理，分享给大家，希望对大家有所帮助。</p>
<span id="more"></span>

<p>这是我第一次有机会出国，也算是人生的一个标志事件，自己的心情也是十分激动的，半个学期都在期待这次交流。去英国前，英国脱欧公投，以几百万的微弱优势脱欧成功，首相卡梅隆辞职，英镑暴跌10%，我们又无形中省了一笔钱。经过几个月的行前筹备，我们终于踏上了这块离家乡八千公里的国度，开始为期两周的游学。所谓游学，既有紧张的环英之旅，从南到北，又从北到南，逛了很多自然人文景观；又有在剑桥的5天充实的学习生活，杜伦大学的一晚借宿，爱丁堡大学的参观游览，曼彻斯特大学的交流学习，伦敦大学的两天体会。14天的交流营，从希思罗机场到希思罗机场，可以说整个人都被洗脑了。被洗脑的原因有很多，我在下面分几个方面细细道来。</p>
<p>关于留学方面。这次团队19位学生，其中包括3名博士，3名研究生，13名本科生；大多人都是抱着以后留学的打算来的。虽然每个人的志向不同，留学的目标也不都是英国，但来到这里可以参观体会很多英国著名的大学，了解这里的留学政策和留学生情况。在每个大学，我们基本上都有该校的学生做为导师，引领我们更好地了解这个大学，这些人有的是中国留学生，还有一个就是北航的，有些是其他国家的，比如在剑桥的墨西哥留学生朱莉。尤其是在剑桥大学呆的这5天，上午剑桥东方交流会会邀请剑桥的一些大牛教授给我们上各种专业、文化课程，虽然这些课程上课的过程不一定和剑桥真实情况完全一样，但却足够让我们体验到像剑桥这样的世界一流大学的上课是怎样的。他们还邀请到剑桥的招生办负责人，给我们介绍剑桥的留学情况，细心解答我们提出的各种问题。下午，我们一般都是各种参观交流和文化体验，像punting，参观著名的三一学院、圣约翰学院、国王学院，参观语言中心。我们在一天晚上还观看了国王学院学生演出的莎士比亚的四大喜剧之一的《皆大欢喜》。虽然看不懂戏剧的内容，但在草地上冻了2个小时的经历还是令我印象深刻。尤其让我印象深刻的是参观了卡文迪许实验室。卡文迪许实验室可谓物理学史上最著名的实验室，一直以来作为物理人的圣地。之前我一直有误解，认为卡文迪许实验室是为了纪念钮称测量万有引力常量的那个卡文迪许而建造的，所以被命名为“卡文迪许实验室”。来到这里才知道，卡文迪许实验室是剑桥大学的一位校长威廉·卡文迪许捐资建造的，所以以出资人的姓氏命名；值得一提的是，威廉·卡文迪许是测量万有引力常量的亨利·卡文迪许的近亲，同属声名显赫的卡文迪许家族。这座建成于1874年的物理实验室，先后培养出催生了近30位诺贝尔奖学者，拥有大量足以影响人类进步的重要科学成果，包括发现电子、中子、发现原子核的结构、发现DNA的双螺旋结构等，为人类的科学发展作出了举足轻重的贡献。我们怀着崇敬的心情在新的卡文迪许实验室外进行了合影留恋活动，以纪念在此的交流活动和受到的洗礼。这次交流活动时间虽然比较短，但让我受益颇丰，坚定了我留学的信念，也交到了很多志同道合的朋友，使我在前行的道路上感到不再孤单。</p>
<p>英国的食物是世界出名的糟糕。有多糟糕呢？你可以在大街上找到各种菜，中国菜、印度菜、泰国菜、墨西哥菜、意大利菜、法国菜……唯独没有英国自己的餐馆。唯一比较有特色的炸鱼薯条，简直连肯德基的炸鸡和薯条都比不上。难怪在英留学的中国留学生都学会了自己做菜，外面吃贵不说，还吃不到什么好的。直到我们亲身体验了两周的英国食物之后，才对此有了深深的认同。几乎每日的全英早餐给我们每个人都留下了深刻的印象。刚开始的时候，大家还很新鲜，认为味道还不错，样式很多，还极富有营养价值；不过吃了几日，就有些受不了。原来全英早餐的意思是，全英国每天都吃。现在回国吃到包子豆浆、油条豆腐脑，别提多幸福了。</p>
<p>在文化方面，我也受到了很大的震撼。</p>
<p>我们在英期间恰值里约奥运会，可以看得出，英国人对于奥运会的热情还是很高的。在我们参观庄园的时候，遇到一个英国人，他见我是中国人面孔，就问我是哪里来的？我说中国。他就很高兴地说中国在奥运会表现很棒，又列举了跳水、体操、乒乓球、举重等中国很强的大项，赞美之声不绝于口。当时中国金牌榜还是排名第二的，我们在英呆的第二周，英国的金牌数量超过中国，并一直保持到了奥运会结束。在travelodge住宿的3天晚上，我每天晚上的娱乐活动都是看电视，看英国的电视都说些什么。BBC-1整天都在播放关于奥运会的节目，BBC相当于国内的CCTV，可见媒体对于奥运会的关注程度。在英国的各个酒吧中，奥运会和足球是永恒的主题。不过英国媒体和大众多关注自行车、赛艇这样的英国强势项目，其他的关注比较少，这与国内很相似，我们国内关注的也多是本国的传统优势项目。</p>
<p>英国的绅士文化。英国作为一个老牌的资本主义国家，曾经是日不落帝国，掌握世界霸权长达一个世纪，如今虽无往日风光，但也是资本主义强国，仅次于美日德。众所周知，英国资产阶级革命是一场不彻底的、妥协的革命，不仅保留了王室，还保留了很大一部分贵族的存在，这些新贵族如今形成了独特的乡绅文化。英国人，不论什么情况下，都要说“Thank you”，这种谢谢已经不止是谢谢的意思了，更多的是一种文化，很多时候让我们不知所措，也好跟着说”Thank you“。英国人喜欢排队，这是我们在旅途过程中感受很深的，所谓”queue文化”。他们喜欢排队，很多时候会不自觉排队，有时候感觉挺可笑的。</p>
<p>英国的气候。我们从小从教课书中获得的印象是，英国永远在下雨。来到这里后，得知并不是这样，或者说不准确。据留学生说，英国的天更多的是”grey”，更像多云。有太阳的天是少数，当晴天的时候，英国人就会都出来，坐在草坪上晒太阳，然后一天什么都不干。我们都称之为“腐朽的资本主义“。英国人从来不打伞，因为很多时候不需要，英国的雨下起来一般都不大，而且下的时间不长，打起伞来比较纠结，不如不打。</p>
<p>苏格兰。英格兰、苏格兰、不列颠、大不列颠、英国……这些名字可能大多数中国人可能并不十分清楚谁是谁，而苏格兰和英格兰几百年的爱恨情仇，倒是被中国人调侃的很多。我们这次的行程有一部分就是在苏格兰完成的。在苏格兰，你绝对看不到英国的Union Jack旗，取而代之的是苏格兰自己的旗子。苏格兰甚至还有苏格兰银行印发自己的钱币，“就是不花你的钱 ”。苏格兰前些阵子还在闹独立，进行独立公投，首相卡梅伦哭着请求苏格兰不要离开，不过最后投票的结果还是留在英国了。在此次脱欧公投中，苏格兰大多选择留欧，理由是：凡是英格兰支持的，我们都反对；凡是英格兰反对的，我们都支持。苏格兰和伦敦一起，成为留欧阵营。无奈苏格兰人比较少，并未影响局势，脱欧后，又有了苏格兰打算先脱英，再加入欧盟的传言。从文化上，苏格兰和英格兰的差别也比较大。苏格兰虽然没有自己的语言，都说英语，但他们的口音确实也独树一帜。苏格兰有自己的文化，苏格兰小短裙、苏格兰风琴、苏格兰诗人……被中国人所熟知的《哈利波特》的作者，J·K 罗琳就是在苏格兰爱丁堡的大象咖啡馆完成。在世界杯和欧洲杯上，苏格兰和英格兰也都是有自己的球队的。总之，来到苏格兰确实看到了别样的英国。</p>
<p>英国的两周体验生活到现在已经结束了，虽然时差还没倒过来，就急着写了这篇总结。在英交流结束的时候，大家都很不舍，从互相不认识的彬彬有礼，到彼此熟知的促膝长谈，不过毕竟大家都在北航，以后还有很多机会相聚；而那些英国的可爱的人们，以后恐怕很难再见了。可爱巨大的胖司机，小巧玲珑的juile，爱丁堡和牛津的导师们，还有孔老师和高老师，我们在一起拥有了一段很美好的回忆，我会永远记住你们的。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><img src="/images/britain.jpg" alt="在贝克街221B和&quot;卷福&quot;的合影"><br>在贝克街221B和”卷福”的合影。因为中国游客比较多，他可是会说中文哒。获得合影许可后，我说“Thank you”，他礼貌地回了句“举手之劳”。</p>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>trvalling</tag>
      </tags>
  </entry>
  <entry>
    <title>我的沙航故事</title>
    <url>/2016/05/25/my-shahe-story/</url>
    <content><![CDATA[<p>还有一个半月就要离开沙河这个“破”地方了，没想到在这里已经呆了将近两年，所以现在写我的沙航故事最合适不过了。</p>
<p>回头看看自己从小鲜肉沦为了老腊肉，当初对大学生活的新鲜感早已消失殆尽，变为日复一日地为课业忙碌，有时候真的想改变改变自己的状态，过上自己曾经憧憬的大学生活，但在面对大的体制，才感到自己的渺小和无助，只能以“为了国家民族的利益”聊以安慰。在这里我不想过多吐槽，只想和大家分享一下在沙航的这两年经历，给后来人一个参考，也给自己留一个log，方便以后查看。</p>
<span id="more"></span>

<p>我来自离北京很近的地方——山西，和大家一样，我也是经历高考过来的，至于高考和报志愿的琐碎本身就可以另写一本书，所以我在这里不予赘述。初来沙航的时候，我像所有新生一样对大学生活充满了向往，只怪当初太天真，相信了高中老师画的大饼。一开始，按照自己对理想大学生活的想象，我参加了很多的学生组织，包括社团和学生会。很多组织的活动我在后来慢慢地不参与了，也就自动退出了，唯独保持了在校学生会的存在。说到校学生会，这个也可以写一本书，其中的机缘巧合，人情世故绝对可以吸引人们的眼球，回头看看，现在在学生会的关系成为我仅剩不多的与外系的交流通道，尤其在成为死宅男之后，这样的机会更是弥足珍贵，不过马上由于地理的原因就要退部了，想想还有点舍不得呢。虽然我之后也参加了一些志愿活动和“猪脚”工作，认识了很多有趣的人，但这样长达2年的学生工作还是只此一个。至于我怎样成为宅男的，那是后话。</p>
<p>我决定拿一整段话，来说我在北航的学习，因为它完全毁了我理想的大学生活。首先，大学中要学的东西真的很多，自己刚开始也是按部就班地学，但仍感到力不从心，直到经历过很多次“烤漆”之后，我仍不相信自己具有“一周一学期，一天一门课”的能力（好吧，我承认自己平时没有好好学习）。其次，当你适应这种快速学习后，发现有些课业的学习并不止于此，尤其是在计算机科学这个领域，很多实验需要调试，即使你设计的很好，但仍无法避免bug，当你碰到“蜜汁”错误的时候，除了“相信自己的代码是对的”之外，“多喝热水，重启试试，不行就分”也不失是一种方法，讲真，重启有的时候真的可以解决很多“蜜汁”错误。最后，谈谈大家在大学都爱谈的“自主学习”，如何利用自己的空闲时间。在大学，除了完成必要的课业任务，大家还真的各干各的，把很多时间花在奇怪的地方。写小说的有之，整天写代码的有之，一天到晚玩游戏的有之，整天呆在自习室的有之。有人说“在哈佛，社交、睡觉、学习，只能选两样。大多数人放弃了睡觉。”在北航虽然没那么严重，但也存在时间分配问题。像我这样爱睡觉的宝宝，只好放弃社交了（好吧，我承认我又在为自己的宅找借口了）。两年来，我别的不敢说比的过舍友们，但在睡觉上，无论是时间还是频率，我要称第二，没人敢自称第一。</p>
<p>大学时光已经快要度过一半了，另一半注定要由于升学或就业的压力，有些变味，受制于现实。现在想想，还是在沙河的两年最无忧无虑，最纯了。<br>过去值得留恋，现在值得珍惜，未来值得期待。</p>
<p>总之，开心就好。</p>
<p><img src="/images/shaheheying.jpg" alt="小班合影"></p>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
  </entry>
  <entry>
    <title>Optimize Cortana in Searching Local files and Folders</title>
    <url>/2017/08/12/optimize-cortana-in-searching-local-files-and-folders/</url>
    <content><![CDATA[<h2 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description"></a>Problem description</h2><p>When I used the Cortana, the personal assistant of Windows 10, I found that it is confusing that searching<br>function worked badly sometimes but well sometimes. To improve my productivity, I googled this problem and<br>encounter a good solution.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.windowscentral.com/how-add-new-cortana-search-file-locations-windows-10">https://www.windowscentral.com/how-add-new-cortana-search-file-locations-windows-10</a></p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>owncloud setup on server</title>
    <url>/2017/08/20/owncloud-setup-on-server/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://owncloud.org/">owncloud</a>是一个私有云解决方案，可以替代百度云。其提供企业版和个人版，个人可以利用服务器搭建个人版的owncloud。官网提供了多种服务器端解决方案。其中，自己编译可以获得最新版的owncloud；owncloud也提供了各大发行版软件库的<a href="https://download.owncloud.org/download/repositories/stable/owncloud/">二进制安装包</a>，更方便快速，更适合个人的应用。</p>
<span id="more"></span>
<h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><p>腾讯云的一台云主机。操作系统版本为Ubuntu 14.04.5 LTS (GNU/Linux 3.13.0-105-generic x86_64)。</p>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="安装owncloud"><a href="#安装owncloud" class="headerlink" title="安装owncloud"></a>安装owncloud</h3><p><a href="https://download.owncloud.org/download/repositories/stable/owncloud/">通过apt库安装owncloud</a>。同时会安装很多依赖包，如apache2，php环境等。</p>
<h3 id="启动apache服务"><a href="#启动apache服务" class="headerlink" title="启动apache服务"></a>启动apache服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service httpd start</span><br></pre></td></tr></table></figure>

<h3 id="管理和设置owncloud"><a href="#管理和设置owncloud" class="headerlink" title="管理和设置owncloud"></a>管理和设置owncloud</h3><p>在浏览器的地址栏输入<code>ip/owncloud</code>或<code>域名/owncloud</code>，设置好管理员账户和密码就好了。</p>
<h4 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h4><p><a href="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html">参考</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql --user=root --password</span><br></pre></td></tr></table></figure>

<h2 id="Client-install"><a href="#Client-install" class="headerlink" title="Client install"></a>Client install</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3>]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Owncloud</tag>
      </tags>
  </entry>
  <entry>
    <title>pkg-config</title>
    <url>/2019/03/17/pkg-config/</url>
    <content><![CDATA[<p>最近在学习<a href="https://github.com/google/googletest">google-test</a>的使用和源码，在<code>make install</code>的时候发现除了向<code>/usr/local/</code>中安装了头文件，<code>/usr/lib/</code>中安装了shared library外，还向<code>/usr/local/lib/pkgconfig/</code>中安装了2个<code>.pc</code>文件。所以说，这个pkg-config是个什么东西呢？</p>
<p>从一份<a href="https://people.freedesktop.org/~dbn/pkg-config-guide.html">Guide</a>中，我们可以发现<code>pkg-config</code>的所有有用的基本信息。</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>现代的计算机系统使用很多层的组件以向用户提供API。一个很大的难点在于如何合适地将这些不同层的组件整合起来。<code>pkg-config</code>这一工具收集了安装在系统上的库的metadata, 用户可以很方便地查看这些metadata。比如，google-test安装的其中一个pc文件<code>gtest.pc</code>的内容是：</p>
<p>包含使用gtest库的所有信息，如头文件安装位置、shared library的位置，编译时需要的编译选项。可以说，使用gtest看这些metadata就够了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prefix=$&#123;pcfiledir&#125;/../..</span><br><span class="line">libdir=$&#123;prefix&#125;/lib</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line"></span><br><span class="line">Name: gtest</span><br><span class="line">Description: GoogleTest (without main() function)</span><br><span class="line">Version: 1.9.0</span><br><span class="line">URL: https://github.com/google/googletest</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lgtest </span><br><span class="line">Cflags: -I$&#123;includedir&#125; -DGTEST_HAS_PTHREAD=1 </span><br></pre></td></tr></table></figure>

<p>计算机系统上没有一个如<code>pkg-config</code>的metadata系统的话，定位和获得系统提供的服务的细节将会很难。<br>对于一个开发者，安装你的包的时候同时安装<code>pkg-config</code>将会极大地方便你的API被用户使用。</p>
<p><code>pkg-config</code>最主要的使用是当程序编译和链接一个库的时候提供必要的细节。这些元信息被存储在<code>pkg-config</code>文件中。这些文件以<code>.pc</code>为后缀，存放在<code>pkg-config</code>工具知道的特定路径里。<br>一个<code>.pc</code>文件中包含2种信息，metadata keywords和freeform variables。<br>前者以keyword开头，后接冒号和value，如“Name: gtest”。<br>后者用=连接变量的值和名字，如”prefix=…”。<br>keywords是由<code>pkg-config</code>定义和导出的。<br>variables不是必须的，但是可以被用来表示<code>pkg-config</code>没有涉及的信息 或是 被keywords使用以增加keywords定义的灵活性。</p>
<p>一个pc文件最好对应一个library文件。文件名(除了后缀)也最好相同。</p>
<p>最重要的metadata域是Requires, Requires.private, Cflags, Libs 和 Libs.private。它们可以被外部的工程用来编译和链接到这个library。优先使用private域，以避免暴露不必要的库给用户。如果用户不不直接使用requires library的symbols，就不应该直接链接到该库。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>对CPU 内存 硬盘读写 网络 进行压力测试</title>
    <url>/2017/01/14/pressure-test-to-CPU-memory-disk-network-IO/</url>
    <content><![CDATA[<p>近来实验室的师兄有个需求, 写4个小程序, 分别对内存, CPU, 硬盘, 网络进行压力测试, 要求测试程序有压力档位可以调, 比如压力可以分为大, 中, 小. 二话不说, 撸起袖子加油干. 需求很简单, 但实现起来却并不简单, 笔者边学习, 边写程序, 才勉强完成任务. </p>
<span id="more"></span>
<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>Ubuntu 14.04</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>受<a href="https://book.douban.com/subject/3004255/">编程之美</a>的第一章”让CPU占有率曲线听你指挥”启发, 我很快地完成了对CPU的压力测试程序.</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>确定一个小周期, 笔者的周期设置为100, 这个值可以通过改变PIECE的值来改变, 周期为 100 * PIECE.</p>
<p>在每个周期中, stress%的时间用于一个死循环, 剩下 (100-stress)%的时间usleep(注意sleep和usleep的区别).</p>
<h4 id="程序源代码"><a href="#程序源代码" class="headerlink" title="程序源代码"></a>程序源代码</h4><script src="https://gist.github.com/YoungForest/04080ae9ad932aa1fd7211c05e93b197.js"></script>

<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 程序名 stress    <span class="comment"># 其中 0&lt;=stress&lt;=100</span></span><br><span class="line">$ <span class="comment"># 例子</span></span><br><span class="line">$ gcc cpu_benchmark.c -o cpu_benchmark.out</span><br><span class="line">$ cpu_benchmark.out 50</span><br></pre></td></tr></table></figure>
<h2 id="硬盘读写"><a href="#硬盘读写" class="headerlink" title="硬盘读写"></a>硬盘读写</h2><p>对硬盘进行读写的压力测试, 我是分别通过两个程序实现的.</p>
<h3 id="硬盘读操作"><a href="#硬盘读操作" class="headerlink" title="硬盘读操作"></a>硬盘读操作</h3><h4 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h4><p>与CPU的压力测试类似, 在一个周期(1s)里, 先从硬盘里读取特定大小(speed)的数据, 周期的剩余时间sleep.</p>
<h4 id="程序源代码-1"><a href="#程序源代码-1" class="headerlink" title="程序源代码"></a>程序源代码</h4><script src="https://gist.github.com/YoungForest/9faaa24df53b3e78d27c18155ee26384.js"></script>

<h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 disk_read.py 硬盘名 level    <span class="comment"># 其中level可以是0, 1, 2, 3</span></span><br><span class="line">$ <span class="comment"># 例子</span></span><br><span class="line">$ python3 disk_read.py /dev/vda 2</span><br></pre></td></tr></table></figure>

<h3 id="硬盘写操作"><a href="#硬盘写操作" class="headerlink" title="硬盘写操作"></a>硬盘写操作</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>硬盘写操作的压力测试与读操作类似. 在一个周期内(1s)向一个文件中写入特定大小的数据, 之后删掉, 在周期的剩余时间内sleep.</p>
<p>为了向文件中写数据, 笔者使用了命令<br><code>dd if=/dev/zero of=/path/to/targetfile bs=1024k count=speed conv=fdatasync &gt; /dev/null 2&gt; /dev/null</code>.<br>该命令从/dev/zero中读取数据(其实是无效数据, /dev/zero 经常被作为初始化文件的数据源), 写入到/path/to/targetfile中. 为了不使<code>dd</code>产生的错误输出和标准输出影响本程序的可读性, 使用重定向了. /dev/null 是一个黑洞设备, 可以向其输入任何数据而不会产生坏的影响.</p>
<h4 id="程序源代码-2"><a href="#程序源代码-2" class="headerlink" title="程序源代码"></a>程序源代码</h4><script src="https://gist.github.com/YoungForest/0b3fdfbe15821b32991d9d48a9122290.js"></script>

<h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 disk_write.py 硬盘名 level    <span class="comment"># 其中level可以是0, 1, 2, 3</span></span><br><span class="line">$ <span class="comment"># 例子</span></span><br><span class="line">$ python3 disk_write.py /dev/vda 2</span><br></pre></td></tr></table></figure>

<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>对内存的测试, 笔者的师兄向笔者介绍了<a href="https://linux.die.net/man/8/memtester"><code>memtester</code></a>这个程序. 具体安装及使用方法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="comment"># 安装</span></span><br><span class="line">$ sudo apt-get install memtester</span><br><span class="line">$ <span class="comment"># 从PHYSADDR处分配MEMORY大小的内存, 测试ITERATIONS次.</span></span><br><span class="line">$ sudo memtester [-p PHYSADDR] &lt;MEMORY&gt; [ITERATIONS]</span><br></pre></td></tr></table></figure>

<p>一般情况下, 不需要指定PHYSADDR, 因为可能将其他进程占用的内存破坏掉, 存在一定的危险性.</p>
<p>利用<code>memtester</code>这个程序, 笔者进行简单加工, 就完成了需求.</p>
<h4 id="程序源代码-3"><a href="#程序源代码-3" class="headerlink" title="程序源代码"></a>程序源代码</h4><script src="https://gist.github.com/YoungForest/73875763467c9cd1eeccad3496a18398.js"></script>

<h4 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 memory_benchmark.py &lt;MEMORY&gt; [ITERATIONS]</span><br><span class="line">$ <span class="comment"># 例子</span></span><br><span class="line">$ python3 memory_benchmark.py 3m 10</span><br><span class="line">$ python3 memory_benchmark.py 2m </span><br></pre></td></tr></table></figure>

<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>师兄的需求是需要公网压力测试, 查找了很多资料, 大多数工具都是测网速的, 而不是可以指定上下行速率进行测试. 幸运的是, 找了几天之后, 终于找到一个工具<code>iperf</code>可以勉强完成任务.</p>
<h4 id="基本思路-2"><a href="#基本思路-2" class="headerlink" title="基本思路"></a>基本思路</h4><p>一台机器作为服务器, 另一台机器作为客户端, 客户端向服务器发包, 服务器接受, 连接使用UDP连接. 这也就是说, 如果没有服务器的话, 客户端仍然可以对网络上行进行压力测试; 但没有客户端, 服务器则没法对网络下行进行压力测试. 简单地说, 服务器(下行)是被动的, 客户端(上行)是主动的, 没人收包仍然可以狂发包, 但没人发包, 无论如何是收不到包的.</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install iperf</span><br></pre></td></tr></table></figure>

<h4 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h4><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><p>启动服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iperf -s</span><br></pre></td></tr></table></figure>

<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iperf -c 服务器ip -b 压力值</span><br><span class="line">$ <span class="comment"># 比如:</span></span><br><span class="line">$ iperf -c 123.206.61.77 -b 11m</span><br></pre></td></tr></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.binarytides.com/linux-commands-monitor-network/">Linux下如何监控网络</a><br><a href="https://www.linux.com/learn/five-funny-little-linux-network-testers-and-monitors">Linux网络测试和监控</a><br><a href="http://tuxtweaks.com/2014/11/linux-network-speed-test/?utm_source=tuicool&utm_medium=referral">[Linux] 局域网中测试网速</a></p>
]]></content>
      <categories>
        <category>Laboratory</category>
      </categories>
      <tags>
        <tag>benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>论推荐系统如何改造和奴役你的思维</title>
    <url>/2018/07/03/recommender-systems-of-popular-apps/</url>
    <content><![CDATA[<p>应园子的邀请，我撰写了一篇关于现今流行的内容app的推荐系统的研究与讨论的文章。<br>事情的起因是这样：<br>园子同学是知乎的重度用户，曾经有一段时间每天画在刷知乎的时间超过1个小时，其三观深受知乎的影响。<br>我提醒她：</p>
<pre><code>不是知乎主动改造你的三观；
而是根据知乎的推荐，你越刷只会加深自己的固有倾向。
比如，你是一个比较右的人，推荐系统最后推的都是你愿意点进去看的。
增加用户花在产品上的时间是推荐系统的目标，而不是解决用户的问题￼。这样想想是不是挺可怕的
这样的推荐系统就会导致，你最后只会看到你自己想看的东西。
</code></pre>
<p>园子顿时对推荐系统产生了浓厚的兴趣，并“报复”我：</p>
<pre><code>要不我给你布置个任务吧：正好你最近在研究推荐系统，要不你查查资料，看看目前各大内容APP的推荐系统都是怎么做的，有哪些思路，整理成一篇文章怎么样￼￼
</code></pre>
<span id="more"></span>

<p>促使我整理2个月来的实习经验，以及查阅大量公开的资料。<br>最后总结成为这篇对各大内容APP的推荐系统的研究文章。<br>本文的目标群众是每天与推荐系统打交道（使用各大内容APP）但又对推荐系统一无所知的同学。</p>
<p>首先，根据app下载量和对园子的影响力，我认为各大内容APP有：</p>
<ul>
<li>知乎</li>
<li>网易云音乐</li>
<li>快手</li>
<li>淘宝</li>
</ul>
<p>本文还用了很多来自：Netflix, Amazon, Google News, Facebook 这些国外大厂的例子对推荐系统加以说明，因为这些app虽然国内的同学不熟悉，但在推荐系统业内属于引领者。</p>
<h2 id="推荐系统的2大类"><a href="#推荐系统的2大类" class="headerlink" title="推荐系统的2大类"></a>推荐系统的2大类</h2><h3 id="基于内容的过滤"><a href="#基于内容的过滤" class="headerlink" title="基于内容的过滤"></a>基于内容的过滤</h3><p>此种过滤只依赖于item的数据。<br>在一个推荐系统中，被推荐和消费的就是item。如：在今日头条这样的新闻客户端中，一条新闻就是一个item，知乎 -&gt; 一个回答, 网易云音乐 -&gt; 一首歌，快手 -&gt; 一个短视频，淘宝 -&gt; 一个商品。<br>根据用户填的问卷信息（针对新用户。一般新用户进入一个应用时，都会选择一些自己的兴趣），或者根据用户的评分（针对老用户。老用户会产生很多评分，或其他action，体现出其兴趣），我们发现他对民谣感兴趣，我们就继续给他推荐其它他未消费过的民谣类歌曲。<br>这里的民谣只是一个tag，表示歌曲的类型，除此之外可能还有歌手名等tag可以利用。</p>
<h3 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h3><p>此种过滤依赖于其他用户的数据。<br>协同过滤基于这样的假设：与你类似的用户喜欢的东西，可能你也会喜欢。<br>这就跟你朋友推荐给你的东西与一个陌生人推荐给你的东西相比，更可能符合你的胃口。因为你的朋友在一定程度上是与你相像的，拥有一些共同的标签。而且根据心理学的研究，人们也倾向于与与自己更像的人交朋友。<br>协同过滤的原理简而言之就是，找到一群和你相像的用户，把他们喜欢或消费过的item推荐给你。<br>“相像”的定义有许多，一般会综合考虑用户的基础信息和行为信息。<br>比如：<br>如果你的基础信息中有“年龄24岁，女人”，Netflix会把24岁的女人看的多的片子也推给你。<br>行为信息在Amazon上的体现就是：“你买了A，大部分买了A的用户，同样也买了B，你要不要买B”。</p>
<p>在拥有大量用户的情况下，协同过滤的效果是要好于基于内容过滤的。<br>其原因可以归咎为：用户自己也不能很确切地定义自己喜欢什么，然而身体是诚实的。这也说成是大数据会比你更了解你。<br>而且在协同过滤的帮助下，app在你的调教下会越用越好用，越用越舒心，你花在其上的时间也越来越多。<br>这对老用户的粘性是非常强的。不过反过来说，当你一段时间不使用该app后，你会发现其推荐的内容就不像之前那样符合你的口味了。</p>
<p>当然基于内容的过滤也是很有用。尤其是当一个新用户刚刚登录，还未产生很多动作和基础信息来找到和他相像的人的时候。<br>吸引新用户是十分重要的，特别是在一个app快速成长的时期。<br>相对应的，业内会有1日留存率，3日留存率，7日留存率还表示推荐系统对新用户的吸引程度。</p>
<h2 id="各大内容app使用的推荐系统"><a href="#各大内容app使用的推荐系统" class="headerlink" title="各大内容app使用的推荐系统"></a>各大内容app使用的推荐系统</h2><p>各个厂用的主要推荐算法基本都属于协同过滤的那一大类，由于应用场景的不尽相同（新闻、商品、音乐、电影），使用的算法也不一样。<br>为了实现冷启动（新用户刚使用时获得比较好的推荐效果），各个厂也会使用基于内容的过滤和基于规则的推荐。<br>由于推荐系统都是基于内容的公司的核心竞争力，完全公开的是没有的。<br>而且据一位业界专家所说，每个厂使用的推荐算法基本相同，都是公开的那些；不一样的只是参数、数据和规则；最后推荐的结果也趋于一致。<br>我们只能在不同的应用场景下进行一些猜测，比如，在内容为音乐的网易云音乐会使用什么样的推荐算法。</p>
<h3 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h3><p>知乎的内容以文字为主，现在还加入了很多视频的内容。<br>作为一个“高素质”人群的问答社区，知乎问题的分类和描述都比较清晰，这有利于更好的推荐。<br>分析知乎在推荐页给我的推荐内容，知乎的推荐以回答为主，之外还有少量的live和广告。<br>由于我对live了解不多，这里主要猜测一下“回答”的推荐过程。<br>最开始知乎的首页是 推荐 和 关注 放在一起的，现在分开了，又加了热门这一页面。<br>通过推荐页的提示“关注话题获取精准内容推荐”，可以看出，推荐页的内容主要依据的是你关注的话题。这相当于是基于内容过滤的场景。<br>从结果来看，向我推荐的回答大多是我显式选择的关注话题或者是于此相关的话题（如下图2所示：话题之间有父子、相关等关系），</p>
<p><img src="/assets/zhihu-recommend-page.jpg" alt="推荐页"></p>
<p><img src="/assets/zhihu-topic-page.jpg" alt="相关话题页"></p>
<h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><p>网易云音乐的推荐可以分为3个板块：私人FM，每日推荐，推荐歌单。</p>
<p><img src="/assets/netease-music-homepage.jpg" alt="网易云音乐推荐模块"></p>
<p>私人FM有3个主要操作：</p>
<ul>
<li>喜欢</li>
<li>删除</li>
<li>跳过</li>
</ul>
<p>除此之外还有一些其他的隐式操作，如 完整听完一首歌曲，调节进度条，看评论时长等可以利用。<br>我们可以将这些行为分为2大类：喜欢和不喜欢。<br>根据程度不同，可以赋给不同操作不同的喜欢值。<br>如显式地点击喜欢和完整地听完这首歌都代表喜欢，不过前者更强一点，可以赋给更高的喜欢值。<br>用户对播放的歌曲产生的所有操作最后求和可以得到用户对这首歌的喜欢程度。<br>用户在听过一段时间私人FM之后，会产生一系列的操作。<br>我们就可以得到用户听过的所有的歌曲的喜欢程度。<br>利用这些信息，再通过协同过滤的一些经典算法，就可以向用户推荐他没有听过的歌曲了。<br>所以说，私人FM听的越多，推荐效果会越好。</p>
<p>每日推荐一般会与你最近听过的歌曲有关。也就是说，歌曲的兴趣对今天推荐的影响随时间衰减比较快。<br>比如，你昨天听了电音，比较喜欢，接连听了几首，可能还“喜欢”了一些。今天的每日推荐就会推更多的电音给你。</p>
<p>推荐歌单算是比较容易推荐的一个板块。因为歌单都是专家或是爱好者组建的，将很多歌曲按照某一标准归为一类。每个歌单还都有自己的标签可以利用。如摇滚、英伦、另类、独立。这些标签都是区分性很强的。<br>在向我推荐的歌单里，一般包含几首我“喜爱”的歌曲。由此可见，推荐歌单使用了“我喜欢的音乐”中的信息。如果几首你喜欢的音乐同时出现在一个歌单中，那么很大程度上可以预测，这个歌单中的其他音乐也会被你喜欢。</p>
<h3 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h3><p>快手作为一个短视频平台，每天用户会产生大量的视频。视频相对而言是不那么好推荐的，因为</p>
<ul>
<li>视频内的语义现在用机器理解还是很困难的</li>
<li>被推荐的内容几乎都是冷启动的，也就是说要争取推荐最新上传的视频</li>
</ul>
<p>在这种情况下，快手可能使用了标签这一信息作为推荐的主要依据。<br>用户上传的视频可以被用户自己打上各种标签：社会摇，炫技，教程，小吃等。<br>依靠这些标签把用户和视频聚成不同的类。这样新上传的视频就可以利用用户在老视频上产生的操作了。</p>
<h3 id="淘宝"><a href="#淘宝" class="headerlink" title="淘宝"></a>淘宝</h3><p>淘宝作为一个c2c的电商平台，推荐系统的指标与其他b2c电商（如 亚马逊）有所不同。<br>评价一个推荐系统好坏的指标中有一个是对冷门产品的发掘能力，即对<a href="https://baike.baidu.com/item/%E9%95%BF%E5%B0%BE%E6%95%88%E5%BA%94">长尾</a>的尾端进行推荐。<br>使用推荐系统将冷门产品的商家和顾客联系起来是淘宝的一个卖点，因为淘宝上的商品实在太多了。没有你买不到，只有你想不到。<br>根据亚马逊公开的一些信息，电商系统的推荐系统核心可以用一句话概括：买了商品A的人，同样也买了B，你买B呀？</p>
<h2 id="为什么说推荐系统在改造和奴役你的思维"><a href="#为什么说推荐系统在改造和奴役你的思维" class="headerlink" title="为什么说推荐系统在改造和奴役你的思维"></a>为什么说推荐系统在改造和奴役你的思维</h2><p>对于一个内容app的推荐系统来说，推荐好不好的指标最后都会反应在用户停留在该app上的时间。<br>在互联网上网人数趋于饱和的情况下，整个市场用户时间数不会像之前那样快速增长，如何抢夺用户宝贵的时间就成个各个内容推荐系统的目标。<br>为了让你停留在本应用的时间增加，各大内容app可谓用心良苦。<br>如知乎现在移动端网站会向app内导流。之前即使用户不登陆、在移动端网页上也可以享受到所有的信息。<br>现在在移动端网页上只能看到一个回答的开始部分，想要浏览完整部分就不许下载并进入知乎的app才可以。<br>很大程度上降低了用户体验。比如我的朋友经常会分享一些知乎上的回答或问题给我，我必须点击多次用app打开才能看到完整信息，很是不爽。<br>今日头条之前也因为三俗内容被政府多次约谈。就是因为相比其他的新闻，低俗、色情的东西更容易吸引网民们的眼球。<br>就像本文最开始谈到的那样，推荐系统为了增加用户停留的时间。只会一味地迎合用户的喜好，无论用户的喜好是否正确。<br>整个过程就是一个正反馈。你思想比较右，推荐系统会推符合你口味的内容，加深你的兴趣。<br>对一个成年人来说，还有甄别内容和选择平台的能力。<br>对于广大的未成年人，无疑会是一种误导。再加上现在互联网内容的监管并不是很完善。为了利益，推荐系统推给未成年人的不会是正能量，只会是娱乐导向、甚至低俗的内容。这对未成年人的思想塑造会有很不好的影响。</p>
<p>其实很多成年人又成熟多少呢？想想你被推荐的内容，想想你花在这些内容app上的时间。<br>在此引用一句古话：“良药苦口利于病，忠言逆耳利于行”。然而作为推荐系统，只会给你说好听的，你喜欢听的。<br>在潜移默化之中，你的思想已经被推荐系统所改造和奴役了。</p>
<p>依赖于推荐系统的内容也是一种懒惰的表现。相比 主动去获取信息，直接接受推荐系统的内容 要容易、愉快的多。但要记住，懒惰是有代价的，你的思想将不可避免地变得狭隘。</p>
<h2 id="如何避免推荐系统的恶果"><a href="#如何避免推荐系统的恶果" class="headerlink" title="如何避免推荐系统的恶果"></a>如何避免推荐系统的恶果</h2><h3 id="多读书"><a href="#多读书" class="headerlink" title="多读书"></a>多读书</h3><p>无论知乎给你怎样的错觉，书本上的内容在质量上还是高的多。<br>我最近读了一本斌卡的《一平米健身》，相比知乎上的健身类回答，内容的质量要高的多。<br>毕竟相比在网络上写个回答来说，出书的门槛和花费的精力要多的多。<br>尤其是，书本上还承载着互联网之前人们的原创思想。这是知乎上所没有的。当然，经过不断搬运，许多”知乎er”把书本上的知识运用在回答中。不过这些都是经过加工和断章取义的，也有不少从某本书上搬一段话就获得高赞的案例。</p>
<h3 id="与优秀的人交朋友"><a href="#与优秀的人交朋友" class="headerlink" title="与优秀的人交朋友"></a>与优秀的人交朋友</h3><p>与优秀的人交朋友，聊天，比起把时间花在追随大v的言论要有用的多。<br>我总认为，一个人在互联网上呈现给你的是他想给你看的部分，不完全。<br>相比之下，虽然面对面的交流也通常是会掩盖本性的，但这种信息交互是双向的，而非通过follow关系的单向信息输出。<br>而且，不知道大家有没有这样的感觉。与优秀的人交流时，自己会花更多的精力去思考，而非听完就完事儿了。在知乎这些平台上，看完之后的热度保持的并不长久。</p>
<h3 id="接触不同的内容，才能够塑造一个完整的三观"><a href="#接触不同的内容，才能够塑造一个完整的三观" class="headerlink" title="接触不同的内容，才能够塑造一个完整的三观"></a>接触不同的内容，才能够塑造一个完整的三观</h3><p>不要只看自己喜欢的，也要听取不同的声音。党同伐异是人类的天性。如果你不刻意去避免这一人性上的缺点的话，推荐系统会像一个谄媚的奸臣一样，只说你想听的，而你可能就会想历史上的昏君一样，荒废了朝政。广开言路，逆耳忠言才是明君应有的表现。<br>比方说，当你听到与你不同的言论，不要先想着反驳对方，试着想想为什么对方会这样想？<br>每个人的想法都是其经历和体验的体现，没有相应的经历，很难会理解一些不一样的事情。这个时候不要着急去反驳对方，而是试着丰富自己的阅历。<br>之前说的2条“多读书、与优秀的人交朋友”都是丰富自己阅历的高效途径。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>希望大家作为一个成年人，拥有一个独立的三观，不要被推荐系统和自己的懒惰而奴役。</p>
]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>recursion</title>
    <url>/2019/02/11/recursion/</url>
    <content><![CDATA[<p>本文根据LeetCode上的教程 <a href="https://leetcode.com/explore/learn/card/recursion-i/">Introduction to Algorithms - Recursion I</a> 整理而成。目的在于帮助笔者自己更熟悉“递归”这一重要的编程概念，如果能够同时对他人产生帮助，那更好不过了。</p>
<p>本文的结构和LeetCode上的完全相同，分为 简介、递归原则、复现关系、备忘录、复杂度分析、总结 6个部分。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本Card的目的，回答以下问题：</p>
<ol>
<li>什么是递归？递归如何工作？</li>
<li>如何递归地解决一个问题？</li>
<li>如何分析一个递归算法的时间复杂度和空间复杂度？</li>
<li>如何以一种更好的方式应用递归？</li>
</ol>
<h2 id="递归的原理"><a href="#递归的原理" class="headerlink" title="递归的原理"></a>递归的原理</h2><p>每次递归函数调用自身，都将给定问题变为子问题。递归过程一直继续指导子问题可以不通过进一步递归就可以直接解决。</p>
<p>递归函数避免无限递归的必要属性：</p>
<ol>
<li>递归结束条件(<strong>base cases</strong>)</li>
<li>一套规则(<strong>recurrence relation</strong>)，可以将所有其他的cases规约为base cases。</li>
</ol>
<p>递归函数中可以有多个地方调用本身。</p>
<h3 id="例子-翻转字符串"><a href="#例子-翻转字符串" class="headerlink" title="例子 翻转字符串"></a>例子 翻转字符串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printReverse</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!*str) <span class="keyword">return</span>;  <span class="comment">// base case</span></span><br><span class="line">    <span class="built_in">printReverse</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(*str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>如果一个问题存在递归解法，我们就可以遵循下列步骤去实现它。</p>
<p>我们定义该问题为函数<code>F(x)</code>可以实现，其中<code>X</code>是函数的输入，同时表示了问题的范围。</p>
<p>在函数<code>F(X)</code>中，我们实现以下步骤：</p>
<ol>
<li>将问题拆分成更小的范围，$x_1 \belong X, x_2 \belong X, …, x_n \belong X$.</li>
<li>递归调用函数<code>F(x_1), F(x_2), ..., F(x_n)</code>以解决<code>X</code>的子问题。</li>
<li>最后，处理子问题的解，组合成对应<code>X</code>的解。</li>
</ol>
<h2 id="Recurrence-Relation"><a href="#Recurrence-Relation" class="headerlink" title="Recurrence Relation"></a>Recurrence Relation</h2><p>定义：一个问题的解和其子问题的解之间的关系。</p>
<h3 id="例子：Pascal’s-Triangle"><a href="#例子：Pascal’s-Triangle" class="headerlink" title="例子：Pascal’s Triangle"></a>例子：Pascal’s Triangle</h3><p>定义：杨辉三角是一系列数字组成三角形的形状。在杨辉三角中，每行最左和最右的数字永远是1. 对于剩余的数字，每个数字是它前一行正上方2个数字之和。</p>
<p>用数学公式表达出来就是，Recurrence Relation为<br>$f(i, j) = f(i-1, j-1) + f(i-1, j),$</p>
<p>base cases为：<br>$f(i, j) = 1, if j = 1 or j = i$.</p>
<p>其中，$f(i, j)$表示第i行第j个数。</p>
<h2 id="Memoization-备忘录"><a href="#Memoization-备忘录" class="headerlink" title="Memoization 备忘录"></a>Memoization 备忘录</h2><h3 id="递归过程中重复的计算"><a href="#递归过程中重复的计算" class="headerlink" title="递归过程中重复的计算"></a>递归过程中重复的计算</h3><p>递归解法常常是十分<strong>符合直觉</strong>和<strong>容易编码</strong>的。但大多数时候，在递归过程中，重复计算导致了性能上的损失。</p>
<p><strong>备忘录法(Memoization)</strong><br>即是一个通用的避免重复计算的技术。<br>是的，这个词没有拼错，不是Memorization。</p>
<p>定义：为了避免重复计算，我们可以在一个cache中存储中间子问题的结果，以便之后再次使用它们的时候不需要重复计算。</p>
<p>备忘录的实现可以通过hashmap实现。尤其是在OOP中，利用装饰器可以实现通用的Memoization。</p>
<h3 id="例子-斐波那契数"><a href="#例子-斐波那契数" class="headerlink" title="例子 斐波那契数"></a>例子 斐波那契数</h3><p><a href="https://leetcode.com/articles/climbing-stairs/">斐波那契数的多种解法</a>，其中有时间复杂度为O(log n)的<strong>Binets法</strong>和<strong>公式法</strong>，令人印象十分深刻.</p>
<h2 id="Complexity-Analysis-复杂度分析"><a href="#Complexity-Analysis-复杂度分析" class="headerlink" title="Complexity Analysis 复杂度分析"></a>Complexity Analysis 复杂度分析</h2><p>递归算法的复杂度有时候不是显而易见的，要通过一些套路分析。</p>
<p>尾递归是一种特殊的技术，可以消减递归栈的使用，优化空间复杂度，使其和迭代算法相同。</p>
<h3 id="Time-Complexity-时间复杂度"><a href="#Time-Complexity-时间复杂度" class="headerlink" title="Time Complexity 时间复杂度"></a>Time Complexity 时间复杂度</h3><p>递归算法的时间复杂度为：<br>O(T) = R * O(s),<br>其中，R为递归调用的数量，O(s)为每次递归调用产生的计算复杂度。<br>一般来说，R更难算一点，O(s)的计算和非递归算法的时间复杂度分析一样。</p>
<p>借助execution tree的技术，我们可以更好地分析递归调用的数量。<br>execution tree是展示具体情况下递归调用流的一棵树，每个节点代表一次调用，节点上的值表示调用时的参数。<br>这棵树的节点数目就是R。</p>
<p>需要特别注意的是，当使用Memoization技术时，execution tree的变化。</p>
<h3 id="Space-Complexity-空间复杂度"><a href="#Space-Complexity-空间复杂度" class="headerlink" title="Space Complexity 空间复杂度"></a>Space Complexity 空间复杂度</h3><p>递归算法的空间使用主要分为2部分：</p>
<ol>
<li>recursion related</li>
<li>non-recursion related </li>
</ol>
<h4 id="recursion-related"><a href="#recursion-related" class="headerlink" title="recursion related"></a>recursion related</h4><p>学过编译原理的我们都知道，每次函数调用都要在栈上压入：</p>
<ol>
<li>函数的返回地址</li>
<li>函数参数</li>
<li>函数的本地变量</li>
</ol>
<p>递归算法的函数调用栈的深度是从初始case到base case.</p>
<h4 id="non-recursion-related"><a href="#non-recursion-related" class="headerlink" title="non-recursion related"></a>non-recursion related</h4><p>全局变量使用的空间，主要在堆上分配。比如，memoization 要使用的hashmap。</p>
<h3 id="Tail-Recursion-尾递归"><a href="#Tail-Recursion-尾递归" class="headerlink" title="Tail Recursion 尾递归"></a>Tail Recursion 尾递归</h3><p>尾递归是一种递归调用是递归函数的最后指令，而且函数中只有一个递归调用。</p>
<p>尾递归的一个很好的例子。注意，non_tail_recursion在最后的递归调用后还有计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper_non_tail_recursion</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> [] ls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= ls.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// not a tail recursion because it does some computation after the recursive call returned.</span></span><br><span class="line">    <span class="keyword">return</span> ls[start] + helper_non_tail_recursion(start+<span class="number">1</span>, ls);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum_non_tail_recursion</span><span class="params">(<span class="keyword">int</span> [] ls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ls == <span class="keyword">null</span> || ls.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper_non_tail_recursion(<span class="number">0</span>, ls);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//---------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper_tail_recursion</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> [] ls, <span class="keyword">int</span> acc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= ls.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this is a tail recursion because the final instruction is the recursive call.</span></span><br><span class="line">    <span class="keyword">return</span> helper_tail_recursion(start+<span class="number">1</span>, ls, acc+ls[start]);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum_tail_recursion</span><span class="params">(<span class="keyword">int</span> [] ls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ls == <span class="keyword">null</span> || ls.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper_tail_recursion(<span class="number">0</span>, ls, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾递归消除递归栈的原理：<br>编译器知道在从callee中返回之后，会立刻再次返回，不需要再利用函数调用栈中保存的数据。只需要一个栈帧就可以了，所有层共用一个栈帧，所以返回时可以跳过整个递归栈。</p>
<p>并不是所有语言的编译器都支持尾递归优化的。比如，C, C++支持，而Python, Java不支持。</p>
<p>尾递归通常也不是那么好实现。需要<br>递归调用只出现在最后一个指令，如果需要调用多个函数，或是对返回值进行计算，就没法尾递归了。</p>
<p>而且细心的同学可以发现尾递归和迭代(loop)的相似之处。事实上，有些函数式编程语言甚至不支持loop，只有递归，完全可以实现迭代。因为我们平时使用loop居多，尾递归很少。如果需要写尾递归时（一般是在一些面试的要求中），可以先写loop版本的代码。然后试着把其中的局部变量更新改成尾递归中的参数，往往就可以写出优雅的（但对于大多数人可读性并不高）的尾递归代码了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决递归问题的套路：</p>
<ol>
<li>定义递归函数</li>
<li>写下recurrence relation和base case</li>
<li>使用Memoization消除重复计算，如果存在的话</li>
<li>如果可能的话，使用尾递归实现递归算法，以消减空间复杂度</li>
</ol>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>商汤见习计算机视觉实习生</title>
    <url>/2018/12/09/sensetime-intern-interview/</url>
    <content><![CDATA[<p>上周给在商汤实习的同学发了简历，和HR约了本周四的面试，周五就又接到HR的电话，商议Offer的事宜。不得不说，商汤招聘的效率还是很高的。这也从另一个侧面反应出，其十分缺人手的事实。很多商汤的同学都在询问我，有没有其他的同学可以推荐过来实习。<br>商汤校友被誉为“北航实验室”。因为其招聘了大量的北航实习生，正式员工很多也是实习生直接转正的，本科的时候，就有几乎一个班都在那里实习。<br>而我面试的时候，推我的是我的一个一直在那里实习的同学，一面的面试官是我大三编译实验课的助教，二三面的面试官也都是我的本科同学。可以说，如果你是北航的学生，那么进入商汤会比其他学校容易很多。</p>
<p>我面的组是”商汤研究院基础技术与工具组“，算是在研究院里偏工程的组了。总体的面试过程还是很硬核，很高能的。好几次我都以为自己不行了，好在面试官及时给出一些hint，帮助我走下去。下面，我记录一下3个面试的流程。</p>
<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>一面面试官是此组的lead，今年刚刚毕业转正。我一直觉得他很眼熟，后来和同学交流过后才想起来，这不是2年前检查我编译实验的助教哥哥嘛！</p>
<p>因为是lead给自己招人，所以一面总体上节奏很紧，内容也很充实。依次问了我职业规划、项目经历和2道算法题。<br>职业规划主要是与将来实习工作内容相关，从超级硬核的嵌入式和操作系统，到优化深度学习框架和库，再到优化计算机视觉的策略和算法。<br>项目经历主要问了我的2次实习和毕业设计，并问了我对之前的哪部分工作和实习最感兴趣。我当然把之前的实习都表扬了一边，然后再比较出自己对快手的实习最喜欢了。从和面试官的问答过程中我感受到，他对面试者是否真的想做某件工作、是否对其感兴趣很看重。</p>
<p>算法题有2道：</p>
<ol>
<li>给出一个01串，给出0和1数目相等的最长子串的长度。比如’00100110011’的最长字串的长度为10.</li>
<li>有1-n个路灯，对其进行n次操作，第i次操作为将编号是i的倍数的路灯状态取反。初始状态为都灭，问对于给定的n，最后有几盏灯是亮的。</li>
</ol>
<p>都不算很难的题目，虽然没能一下子解决，但最后都在面试官的hint下成功解决了。表现的不算太好，也不算很差。想解法的时候一度感觉自己要凉了，要丢人了。好在问题本身不是很难，经过更多的思考和尝试还是解答出来了。只有第一道题要求手写代码了，我用Python很快写完了。我用二维列表实现的桶，面试官指出，用Map难道不是更优雅吗？第二题解法过于简单，没必要写代码。</p>
<p>经验总结就是，虽然我代码能力还行，LeetCode也刷了有100道Easy难度的题目，但并没有形成自己的一套解题的流程，也没有对于每一类问题的归纳总结，可以快速地找出合适的算法。<br>更多的是依靠灵感和尝试。比如第一道题，我最开始一筹莫展，但再尝试几次后，偶然想到可以先把前缀和计算出来(遇0减一，遇1加一)，之后就迎刃而解了。和LeetCode上一些字符串比较的问题很像。<br>这种依靠灵感和尝试的解决方案，首先不是每次都奏效，如果状态不好，可能就不行了；其次是不靠谱，做题的时候心里没谱，对于题目能不能成功解决心惊胆战的。<br>所以，在面对未来更多的面试和dream job之前，形成自己稳定可靠的解题流程是必要的。</p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>二面的面试官是我的本科同学，但平时交流并不多，他属于比较geek的类型。<br>这位同学刚开始比较不善言辞，问我一面都面了什么，会写什么。我判断他作为面试官的经历其实也不多，并不擅长。稍稍有些放松和欣喜。<br>不过很快，他真的是用技术教我重新做人了。慢慢熟悉起来之后，他也进入了面试的状态。从操作系统(从shell敲入命令到程序被执行中间发生了什么，进程的建立过程)问到编译器(编译的过程，每一步的细节)，从编译优化(循环展开)问到CPython的实现(全局变量的处理，Python是如何运行的)，看到我用过Django，又问我框架的实现，model的实现。问我哪门语言比较熟，我说Python，就问了我很多Python实现的问题。问我看过什么Python的大型项目的代码吗？我只好汗颜地说没有。</p>
<p>整场面试除了刚开始几分钟比较轻松外，后面的节奏越来越快。每个问题都是越来越深入，直到我实在回答不上来为止。<br>应对这种类型的面试，我只能说，<strong>CSAPP</strong>和<strong>SICP</strong>的真的很重要。虽然我都只看了几章，但硬是凭着不深的记忆硬扯。比如Python的运行过程，我之前根本没有了解过。刚开始只说是解释运行，对方要求更详细些，从开始到运行完毕的过程是怎样的？我想Lisp也是解释语言，就把老早之前在SICP上看过的Lisp运行过程说了下。面试后我查了查Python的运行过程，惊喜地发现真的差不多。CSAPP对编译和进程有很深入的介绍，如果对这2章更熟一点，我面试时一定会更从容。没有读过大型项目的源码也是我的短板。说实话，真的没有多少人读过很多大型项目的源码。但是我们是要向大牛看齐的，多读读源码，才能成为更优秀的程序员。</p>
<h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>三面的面试官也是我的本科同学，稍微还熟悉些。最后一面由不同组的同学负责，被称为跨组面试。防止有组内私自招收不合格员工的情况发生。<br>既然比较熟，面试过程就比较轻松了。先是依次问了项目经历，之后又问了1道语言题和一道算法题。</p>
<p>语言题涉及到Python的闭包，<br>就是理解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">lambda</span> x: x + i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + i</span><br><span class="line"></span><br><span class="line">[func1(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<p>的区别。<br>不知道多少年前看过廖雪峰Python的教程上闭包相关的内容，只有些许印象，平时也不用。只记得变量<code>i</code>有时会变化，产生意料之外的结果，比如前者。好在在面试官的hint下有惊无险。</p>
<p>算法题是关于DP的，<br>给定<code>n &lt;= 20, a_i &lt; 100, 整数s</code>，求解有多少种正负号的填法使得等式成立$$ \sum_i^{n} \pm a_i = s $$</p>
<p>我给出解法后，面试官又问，构造表的时候s为负数时怎么办？</p>
<h2 id="后记-感悟"><a href="#后记-感悟" class="headerlink" title="后记 | 感悟"></a>后记 | 感悟</h2><p>有一个清晰的职业规划和技能方向是十分重要的。平时和师兄聊天的时候可以说自己也不知道做啥，不知道对啥最感兴趣。但面试时这样说肯定就gg了，最好最自己有比较清晰的认识，知道自己的兴趣，职业规划，当然这些和面试职位的需求相符那就更好了。如果不相符的话，大概率也会gg，搞不好还会被喷（参考我5月时面试face++的面试经历，在我的博客上可以找到<a href="https://youngforest.github.io/2018/08/14/face-interview/%EF%BC%89%E3%80%82">https://youngforest.github.io/2018/08/14/face-interview/）。</a></p>
<p>今年算法岗大火，以至于供过于求。算法岗也处于程序员鄙视链的上游，薪水也比研发岗高一些。<br>但我结合自己的经历和体验，发现自己还是对写代码比较感兴趣，写出更优雅，performance更高的代码，满足用户的需求，产生impact。我就很开心和满足了。虽然做程序员很辛苦，但是我很开心。没必要追求别人认为好的职业(鄙视链大概是：研究员 &gt; 算法岗 &gt; 研发岗 &gt; 其他)。<br>我以后也会顺着研发这个方向规划自己的职业，学习必要技能的。</p>
<p>我曾经给好友说过，“我想写一辈子代码”。现在仍然是这样，而且更加坚定了。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>sensetime</tag>
      </tags>
  </entry>
  <entry>
    <title>山东游记</title>
    <url>/2018/09/14/shandong-trip/</url>
    <content><![CDATA[<p>8月21号 至 8月28号，带着自我放逐的心情，我去山东玩了7天。小时候（2008年）曾跟着爸爸和旅行团来过山东旅游，经典的旅游城市，包括青岛、烟台、威海 和 隔海相望的大连，都逛了一圈。当时年纪尚小，天真烂漫，只觉得不用上学，来到陌生的地方旅游，十分有趣。如今十年过去了，同样的景点，却有不一样的心情和感受。</p>
<p>此次旅行是临时决定的。之前同学叫着去重庆做毕业旅行，我由于种种原因没去成。8月中旬后，经历了情感上的波折和三毛流浪文学的洗脑，恰好有山东的同学(我们可以称之为“女声男”，因为其声音特别有雌性)邀请我去山东一起玩。我便答应了。希望通过此次旅行让心情好过一点，让匆忙的旅行占据自己的大脑，不去想不该想的苦恼。</p>
<span id="more"></span>

<p>办完了学校的事情，买了21号晚上的硬座票，踏上6个小时去济南的火车。到达济南后，我在火车站对面的一家“潼关肉夹馍”，补充了些能量；更重要的是给手机充了电。因为前半年摔了几次手机，可能是什么硬件坏掉了，手机掉电比较快，不像之前可以一撑撑一天。这家店再次证明了：火车站周边的饭店果然味道很差。之后赶往济南汽车站，坐上去 莱芜 的流水车。跟随女声男的指示，我在张家洼下了车。他来接我的时候，手机只有1%的电量了。由于舟车劳顿，我先在女声男的卧室里睡了一觉。中午一起吃他妈妈做的饭。饭菜味道很一般，但还算丰盛。下午去市区，逛了超市，看了场电影《快把我哥带走》。莱芜确实是个生活很方便的地方。路上车也不多，各种基础设施和娱乐场所都很多。晚上，在张家洼吃火锅。之后女声男开车，载着我和他妈前往北边的雪野湖，看水、散步。去的过程中，我的膀胱爆炸。我们直接在路边停车，解决了膀胱的压力。回到家里，我们又和色长、涂导开了2局农药，才睡觉。</p>
<p>行程的第二天。我们按照计划去泰山玩。从莱芜坐流水车到泰安，然后换乘公交到泰山脚下。公交车还坐反了方向，坐了一站下车后。我指着身后的山说：咱们傻逼了，应该冲着山的方向走。从11点开始爬山，花了近5个小时终于登顶。开始登山的时候还发生了一件有趣的事情。女声男打算买个自拍杆，拍照更方便些。买下后才发现，我的米6没有3.5mm的耳机孔，他的Max屏幕太大，装不上。好说歹说，店家才给我们退了。作为五岳之首，泰山吸引了全国各地的游客前来，登泰山的游客很多。海拔1532.7米，孔子讲“登东山而小鲁，登泰山而小天下”。登上山顶，眺望山下，才发现，登泰山只能小泰安。后来想想，地球是圆的，登珠穆朗玛峰都不可能小天下。泰山景区的建设也完善。全程都是很宽的台阶，说是登山，其实全称都在爬台阶。每隔一段就有个休息点，一般有食物和水，还有各种纪念品。下山按照计划，乘坐缆车到山腰的中天门，再坐中巴到山下。缆车真是排队半小时，下山5分钟。之后坐拼车回莱芜，准备明早去烟台莱州看海，顺便找另一个同学玩。值得说的一点是，山东不愧是经济发达的东部省份，生活各种方便。乘车、买门票、坐缆车都可以使用移动支付。当然，出门玩还是需要带现金的。比如坐中巴就只能用现金。</p>
<p><img src="/assets/taishan.jpg" alt="泰山"></p>
<p>行程的第三天。由于没买到去莱州的汽车票，我们临时改变行程，去了旅游城市 青岛。开始了青岛3日游。青岛不愧是旅游城市，各种吃喝玩乐和景点建设的十分齐全。在这里，我真正体会到旅游的热情。第一天，体验了青岛的公交、参观了啤酒博物馆、在海滨第一浴场游了泳。青岛的公交车司机素质比北京不知道高到哪里去，对乘客和游客很友善。北京的司机师傅可能是平时压力比较大吧，总是没有好脸色给乘客。啤酒博物馆里，我们参观了青岛啤酒的历史和生产线。品尝了正宗的“原浆”和“纯生”青岛啤酒。下午在海滨第一浴场游泳。好在不是周末，人虽多，但还没有到下饺子的盛况。脚踩在细软的沙滩上，沐浴着和睦的阳光；沉浸在被阳光晒得十分暖和的海水中，享受海浪的冲击和海风的吹拂…美滋滋。当然也品尝到不少海水的苦涩。</p>
<p><img src="/assets/pijiubowuguan.jpg" alt="啤酒博物馆"></p>
<p><img src="/assets/haibindiyiyuchang.jpg" alt="海滨第一浴场"></p>
<p>青岛的第二天。<br>一大早，去八大处风景区，见识了权贵住的别墅，在公主楼前徘徊了半天。然后去旁边的海边赶海。所谓赶海就是，趁着落潮的时候，在充满礁石的海边捡各种海鲜。由于技艺不精、工具不全和时候比较晚，自然收获不多。甚至还在海里摔了一跤。这里还遇到了在岩石上照婚纱照的情侣，和照全家福的青岛人。不得不说，这里风景真心不错。大海、蓝天、城市、市民，形成一幅和谐的画面。<br>然后打车去了 海军博物馆，参观了“坚船利炮”。核潜艇由于人太多，没有上去“开”。<br>沿着海岸线，我们出发去“监狱”。路上随便找了个店，吃了些饺子。德国监狱 更多的是爱国主义教育。宣传日占时期，日本法西斯的暴行。有趣的是，在买票的时候，售票员由于和我们聊天，还被其他游客diss了。售票员检查我们的学生证，发现已经毕业一个月了，但看到是“北京航空航天大学”，说是她女儿想上这所学校，开飞机。问了问分数线的情况。我们一个山西考生，一个上海考生，自然不知道山东(高考大省)的情况。而且我航也不是培养开飞机人才的呀！所以就瞎说一通，混了个半价门票。<br>参观完监狱后，我们沿着海边一直走，来到了栈桥。这个地方我依稀有些印象，10年前也曾经来过。不过如今已经物是人非，我也不是曾经的我了。女声男嫌桥上人太多，就没有上去。我一个人转了20分钟，在桥头伫立了一会儿，看着大海和远方的城市、山丘，陷入了对往日的沉思。在栈桥上，可以看到上午参观过的海军博物馆。我们相当于一直在沿着海岸线走。<br>晚上我们又来到栈桥，坐在桥头的石头上，享受着海风尽情地吹拂。在海边吹风时，看到明月当空，还是会想起她。<br>我们还在中山街逛了一遍，吃了小吃，参观了各种礼品店。小小破费一晚。</p>
<p><img src="/assets/gongzhulou.jpg" alt="公主楼"></p>
<p><img src="/assets/ganhai.jpg" alt="赶海"></p>
<p><img src="/assets/haijunbowuguan.jpg" alt="海军博物馆"></p>
<p>青岛的第三天。<br>参观了酒店附近的天主教堂、劈材院、建设银行旧址。我们的酒店就在老城区，离中山街、栈桥都特别近。<br>进入天主教堂时，里面的主教在宣扬天主教认同的夫妻关系，我们还见证了6个教徒入教。人民生活在苦难中，向宗教寻求慰藉。<br>劈材院是一个小吃街。由于我们是上午去的，没什么人，店铺也开的不多。<br>然后坐公交去汽车站，乘大巴回莱芜。<br>回到莱芜又在张家洼村的院子里吃了露天的烧烤。</p>
<p><img src="/assets/tianzhujiaotang.jpg" alt="教堂"></p>
<p><img src="/assets/pichaiyuan.jpg" alt="劈柴院"></p>
<p>行程第六天–济南。<br>由于女声男感冒了（另一个原因是太宅了），我只好一个人去济南玩。<br>坐汽车到济南，直奔提前订好的青旅(济南滨湖青年旅舍)。这是我第一次独自住青旅，也是第一次在国内住青旅。这家青旅的优点在于位置好，紧邻大明湖畔。一个10人间的混住房间，但只有我和一个大叔住。大叔是个有趣的人。他来济南的目的是躲避花粉。他工作在辽宁。每年入秋会南下，避免过敏。今年去过北京和石家庄，最后来到济南，感觉这里空气不错，就找了家青旅（相对酒店便宜的多），打算住上十几天。我下午出去玩的时候，他在床上躺着，晚上10点回来的时候，还在床上躺着。第二天早上我出去玩的时候，他还躺着。中午我回来退宿和他道别时，他还躺着。不是在睡觉，就是在玩手机。<br>济南的景点比较有限，也比较集中。由于交通更方便的原因，我第一天下午和晚上逛了 大明湖、五龙潭、趵突泉、泉城广场、芙蓉街。晚饭在芙蓉街吃小吃，吃到撑。济南作为泉城，水真多。我甚至看到马路边上的井盖都在咕咕地向外冒水(而女生男听说了，分析说更可能是城市排水系统出了问题)。慕名而去的趵突泉，其实一般，只有3股大泉咕咕的往外冒，早已不复当年盛况。据说曾今还停过水，近年来政府治理地下水位，才重新复涌。</p>
<p><img src="/assets/daminghu.jpg" alt="大明湖"></p>
<p><img src="/assets/wulongtan.jpg" alt="五龙潭"></p>
<p><img src="/assets/baotuquan.jpg" alt="趵突泉"></p>
<p>行程第七天–千佛山。<br>济南必去的地方有3个：大明湖、跑突泉、千佛山。千佛山在城市的南郊，所以我安排在了第二天上午。千佛山不算高，也不难爬。我一个半小时上去，一个小时下来，在山顶休息了半小时。登上千佛山，可以俯瞰整个济南。千佛山上还有很多佛教和道教的庙宇、雕塑。我不是很懂，大多数景点也只是走马观花而过。<br>回青旅的路上吃了济南名吃–把子肉。确实挺好吃的，肥而不腻。我点了一片肉，一碗米饭，就这样吃了。<br>济南到临汾只有一辆直达车，全程5个小时多，向北途径石家庄、太原，才向南到达临汾。济南西站远离市区，坐公交坐了一个半小时才到，中间还需要换乘。</p>
<p>晚上8点抵达临汾西站，结束了7天的旅行。</p>
<p><img src="/assets/qianfoshan.jpg" alt="登千佛山而小济南"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>离开富庶的东部强省山东，回到破败的中部弱省山西。没有对比就没有伤害。十年前，不知道父亲过来旅行时，没有被这些感染，产生走出山西的想法吗？如果是那样的话，作为儿子的我，现在一定会过的更好吧。而我还没有见识过足够的地方，自己也不知道将来会待在哪里。起码北京这个城市没有产生让我特别想长期居住在这里的想法。趁年轻，多走一走，多看一看，再做决定吧。</p>
<p>我在青岛时会想，自己老了(也不一定要十分老，但起码要财务自由)以后，就每一年换一个地方住。租上一年的房子，和自己爱的人一起探索这个地方。体验不同的工作和生活。这样的话，这一生一定会更精彩。</p>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>trvalling</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言分割字符串 - YoungForest</title>
    <url>/2016/10/11/slipt-string-by-C/</url>
    <content><![CDATA[<p>【摘要】最近在做一道C语言题目的时候需要用到分割字符串，本来想自己手写的，也不会很麻烦，但想到其他语言都有分割字符串的库函数，C语言怎么会没有呢？所以，在网上搜了一搜，果然有这样的函数，还是很好用的，在此总结。 在C语言手册中可以很方便地查到strtok的用法，要注意的一点是，除了首次调用时，第一个参数要传 <a href="http://www.cnblogs.com/YoungForest/p/5950994.html">阅读全文</a></p>
]]></content>
  </entry>
  <entry>
    <title>ssh免密登陆服务器</title>
    <url>/2018/05/08/ssh-login-remote-server-without-password/</url>
    <content><![CDATA[<p>以下命令仅针对Unix-like系统。<br>Windows是不需要这样的解决方法的，Windows下很多类Putty工具都可以选择”记住密码”来实现免密登陆。<br>我在Mac上没有找到类似记住密码的解决方案，但使用Key事实上是更安全的一种方式。</p>
<span id="more"></span>

<h2 id="step1-生成rsa密钥对"><a href="#step1-生成rsa密钥对" class="headerlink" title="step1: 生成rsa密钥对"></a>step1: 生成rsa密钥对</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<h2 id="step2-上传rsa公钥到服务器"><a href="#step2-上传rsa公钥到服务器" class="headerlink" title="step2: 上传rsa公钥到服务器"></a>step2: 上传rsa公钥到服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub | ssh -p 26757 root@138.128.193.150 <span class="string">&#x27;cat &gt;&gt; .ssh/authorized_keys&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="step3-更改权限"><a href="#step3-更改权限" class="headerlink" title="step3: 更改权限"></a>step3: 更改权限</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 26757 root@138.128.193.150 <span class="string">&quot;chmod 700 .ssh; chmod 640 .ssh/authorized_keys&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="step4-success"><a href="#step4-success" class="headerlink" title="step4: success!"></a>step4: success!</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 26757 root@138.128.193.150</span><br></pre></td></tr></table></figure>

<p>reference:<br><a href="https://www.tecmint.com/ssh-passwordless-login-using-ssh-keygen-in-5-easy-steps/">ssh-passwordless-login-using-ssh-keygen-in-5-easy-steps</a></p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>个性化sublime</title>
    <url>/2017/01/18/sublime-personlize/</url>
    <content><![CDATA[<p><strong>[摘要]</strong> <a href="https://www.sublimetext.com/">sublime text3</a>是一款强大的editor, 我从大二下开始正式使用, 经过半年的不断摸索, 将sublime配置成为个性化的editor, 满足了我日常编码的大部分需求.</p>
<h3 id="为不同的语言进行不同的配置"><a href="#为不同的语言进行不同的配置" class="headerlink" title="为不同的语言进行不同的配置"></a>为不同的语言进行不同的配置</h3><p>首先, 打开该语言的任意个文件, <code>Sublime Text 3 -&gt; Preferences -&gt; Settings - Syntax Specific</code>进入该语言设置文件, 修改设置文件并保存即可.</p>
<p><a href="http://mlo.io/blog/2012/08/23/language-specific-indents-sublime.html">参考: 为不同语言设置不同缩进</a></p>
<h3 id="Color-Scheme"><a href="#Color-Scheme" class="headerlink" title="Color Scheme"></a>Color Scheme</h3><p>sublime text 3 默认的主题是<code>Monokai(dark)</code>, 感觉还是挺养眼的, 但缺点是markdown的支持特别差. 我还比较喜欢的另一个主题<code>Solarized(dark)</code>也是这样, 默认提供的<code>Solarized</code>与在vim中的体验相去甚远. 所以我通过<code>Package Contorl</code>安装了<code>Solarized Color Scheme</code>这个主题, 与vim对照如下, 还是比较养眼.</p>
<p><img src="../assets/sublime-solarized-optimized.PNG" alt="Solarized optimized for sublime"></p>
<p><img src="../assets/vim-solarized.PNG" alt="Solarized for vim"></p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>微软苏州面试</title>
    <url>/2018/06/01/suzhou-microsoft-interview/</url>
    <content><![CDATA[<p>在@lxc师兄的内推下，我有幸可以前往 苏州微软，面试O365部门的暑期实习生。虽然最后失败了，但从这次失败的经历中，我学习到很多。<br>总结在此，为未来的找实习和工作做准备。</p>
<span id="more"></span>

<h1 id="面试环节"><a href="#面试环节" class="headerlink" title="面试环节"></a>面试环节</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ul>
<li>尾递归，斐波那契（不会）</li>
<li>合并2个列表</li>
<li>makefile 编译顺序确定</li>
<li>memcpy的实现方式和安全问题</li>
</ul>
<h3 id="用尾递归优化递归斐波那契数列"><a href="#用尾递归优化递归斐波那契数列" class="headerlink" title="用尾递归优化递归斐波那契数列"></a>用尾递归优化递归斐波那契数列</h3><p>斐波那契数列大家应该都很熟悉，高中数学课本上提到的经典递归数列。<br>其数学定义为：<br>$$<br>f_n = \begin{cases}<br>f_{n-1} + f_(n-2) &amp; \quad \text{if } n &gt; 2 \<br>1 &amp; \quad \text{if } n = 0, 1<br>\end{cases}<br>$$</p>
<p>根据数学递推式，很容易地可以写出递归版的斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>根据函数调用的原理，每次需要递归调用2次本函数，当参数为n时，需要的栈帧的数目为O(2^n)。<br>可以利用尾递归来优化这个问题。<br>尾递归是<a href="https://en.wikipedia.org/wiki/Tail_call">尾调用</a>的一种递归调用形式。<br>我对尾递归的理解是<br>函数式编程中使用函数调用以实现循环的方式。<br>所以，首先给出内存占用为O(1)的斐波那契数列循环实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    f_n_sub_1 = <span class="number">1</span></span><br><span class="line">    f_n_sub_2 = <span class="number">0</span></span><br><span class="line">    i = n</span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span>:</span><br><span class="line">        f_n_sub_1, f_n_sub_2 = f_n_sub_1 + f_n_sub_2, f_n_sub_1</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> f_n_sub_1</span><br></pre></td></tr></table></figure>

<p>从循环实现可以看出，整个循环实现需要2个变量(f_n_sub_1和f_n_sub_2)来记录中间的结果，<br>一个循环变量(i)以控制循环次数(即循环结束条件)。<br>将这些变量当作函数的参数即可得到尾递归版本的斐波那契数列实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">n, ret1, ret2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ret1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> func(n - <span class="number">1</span>, ret2, ret1 + ret2)</span><br><span class="line">    <span class="keyword">return</span> func(n, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="memcpy的实现方式和安全性问题"><a href="#memcpy的实现方式和安全性问题" class="headerlink" title="memcpy的实现方式和安全性问题"></a>memcpy的实现方式和安全性问题</h3><p>也是一个字节一个字节的复制。不是我想当然的认为一整块一整块的复制，这样会更快。<br>回忆计算机组成原理的知识：<br>CPU和Memory之间由总线连接，一次（一个时钟周期）只能读取和写入一个字的数据。</p>
<p>安全性：很不安全。<br>回忆操作系统的知识：进程的内存空间映射到物理内存。<br>直接一个一个字节从低到高地复制粘贴容易覆盖到其他指针指到的数据（破坏了其他指针的数据）甚至本身的数据。</p>
<p>比如memcpy一个大小为200字节的指针(地址100)到地址200，会把自己的数据(200-300)的部分先覆盖掉，之后的copy就都是错的。（这是面试官给出的解释，但我后来发现，这点是不一定不成立的。因为之后我查了一些标准库中memcpy的实现，这种情况下可能会采用自后向前复制的方法防止覆盖要复制的数据。<br><a href="https://github.com/gcc-mirror/gcc/blob/master/libgcc/memcpy.c">无保护措施的gcc</a><br><a href="https://blog.csdn.net/laoyang360/article/details/8020409">有保护措施</a><br>）</p>
<h3 id="面试官指点"><a href="#面试官指点" class="headerlink" title="面试官指点"></a>面试官指点</h3><p>面试时在Notepad里写代码，在纸上写代码，和在白板上写，<br>容易程度或方便程度是：<br>白板 &gt; 纸 &gt; Notepad</p>
<p>被告知面试题目后，首先要考虑清楚初始条件和具体要求，不清楚的一定要和面试官问清楚，不要上来就写。<br>否则后来发现歧义，再问时就晚了。</p>
<h3 id="其他收获"><a href="#其他收获" class="headerlink" title="其他收获"></a>其他收获</h3><p>有时间一定要好好看看SICP，函数式编程的尾递归在其中就有讲。<br>面试官估计也读过。</p>
<h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ul>
<li>求树的最深度</li>
<li>最大和的链</li>
<li>可以拐弯的最大和的链</li>
<li>数组权重最大的重新排序（不会）</li>
</ul>
<h3 id="其他收获-1"><a href="#其他收获-1" class="headerlink" title="其他收获"></a>其他收获</h3><p>在面试时，ACM选手有天然的优势。<br>该面试官本科时，可能玩过ACM，因为他说“数组权重”那道题是他上学时自己出得。</p>
<p>p.s. 面试官说他也毕业不久。</p>
<h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>周二去苏州参加完面试后，周五出结果，约了第二周周二的视频面试。<br>说实话，视频面试前我还真有点紧张，而且由于学校出了点状况，上午才知道下午有视频面试。<br>仓促之前，也没有午睡，休息好。面试之前特别困。<br>好在真正到面试时，肾上腺素上升，不困了。</p>
<p>三面的面试官也很nice。<br>听说我熟悉SQL，就出了一道SQL题目给我。</p>
<p>类似教务管理系统。有3张表：学生（学号，姓名），课程表（课程ID，课程名），选课表（学号，课程ID，成绩）。<br>查询每个学生的数学成绩和语文成绩，结果为（姓名，数学成绩，语文成绩）。<br>刚开始假设每个学生都选了数学和语文，后来取消了这个假设（考察outer join）。</p>
<h2 id="第二道题"><a href="#第二道题" class="headerlink" title="第二道题"></a>第二道题</h2><p>第二道题目考察<a href="https://en.wikipedia.org/wiki/IEEE_754#Rounding_rules">IEEE的一种round实现</a>。</p>
<p>首先，列出一些数字，让我观察规律。<br>在面试官的引导下，我猜测出来了：四舍六入五看下一位。<br>之后使用C语言实现这一ieee_round。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>No Hire.</p>
<blockquote>
<p>很遗憾，Lead面试官最后给的是No Hire。他认为你编写代码能力不稳固。你的优点是思考能力很强，缺点是不善于展现和询问，不能从错误中获取新的解决办法，今后需要加强这方面。</p>
<p>希望你研究生期间继续努力，欢迎再加入苏州微软。</p>
</blockquote>
<p>Lead面试官的眼光还是蛮准的，给出的建议的是一针见血的。我会继续努力，早日达到微软爸爸的要求的。</p>
<p>除此之外，一开始说好的报销火车票最后也没给报，经济上还损失了1200￥。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>实现terminal代理</title>
    <url>/2016/11/02/terminal-proxy-configuration/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>作为一名Linuxer，熟练使用终端是一项必备技能，但终端中有时下载安装功能速度很慢，令人崩溃.我自然而然想到了可否加个代理,提高速度。我之前一直用shadowsocks,浏览器使用switchyProxy,实现了初步的科学上网。那么,终端中是否有类似的工具呢？答案是肯定的。通过科学搜索，我成功解决了terminal中的科学上网问题，在此总结一下，希望可以帮到大家。</p>
<span id="more"></span>
<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><p>shadowsocks, polipo</p>
<h3 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h3><p><a href="https://shadowsocks.org/en/download/clients.html">Download and Install Client</a></p>
<h4 id="Install-Command-line-Client"><a href="#Install-Command-line-Client" class="headerlink" title="Install Command-line Client"></a>Install Command-line Client</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install shadowsocks</span><br><span class="line">apt-get install shadowsocks-libev</span><br><span class="line">cpan Net::Shadowsocks</span><br></pre></td></tr></table></figure>
<p>shadowsocks的配置可以参考<a href="http://bblove.me/2015/03/09/use-ss/">这篇文章</a>, 我很久之前配置的,这里就不回忆了(忘得差不多了).</p>
<p>让我们直接从polipo开始吧.</p>
<h3 id="polipo"><a href="#polipo" class="headerlink" title="polipo"></a>polipo</h3><p>polipo有多种安装方式,可以使用Python的包管理工具pip直接安装,也可以用各个操作系统的包管理工具安装.我更推荐后者,因为个人认为这样更好管理罢了.这里以Ubuntu为例.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-cache search polipo</span><br><span class="line"></span><br><span class="line">adzapper - proxy advertisement zapper add-on</span><br><span class="line">polipo - lightweight, caching web proxy</span><br><span class="line">polipo-dbg - debug package for polipo</span><br></pre></td></tr></table></figure>
<p>第二个包就是给我们这些小白使用的,安装它</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install polipo</span><br></pre></td></tr></table></figure>

<p>安装好之后默认自启的,<br>我们要先修改它的配置文件(/etc/polipo/config):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logSyslog = true</span><br><span class="line">logFile = /var/log/polipo/polipo.log</span><br><span class="line">logLevel = 4 # 没有这句话的话`sudo polipo -v`会出现无法查看log文件的情况</span><br><span class="line"></span><br><span class="line">socksParentProxy = &quot;localhost:1080&quot; # 这里假设shadowsocks的local port为1080</span><br><span class="line">socksProxyType = socks5 # 是不是和SwitchyProxy的设置很像?</span><br></pre></td></tr></table></figure>

<p>具体各个配置选项可以参考文件<code>/usr/share/doc/polipo/examples/config.sample</code>.</p>
<p>配置好之后,我们需要重启polipo服务(每次修改配置文件需要重启服务才能加载)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service polipo stop;</span><br><span class="line">sudo service polipo start;</span><br></pre></td></tr></table></figure>
<p>或者直接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service polipo restart;</span><br></pre></td></tr></table></figure>

<p>可以用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo polipo -v</span><br></pre></td></tr></table></figure>
<p>查看具体各个配置项,可以看到我们之前的更改生效了.</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>配置完成后,怎么才知道自己是否已经可以科学上网了呢?<br>可以使用以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~$ curl -i http://ip.cn</span><br><span class="line">当前 IP：60.xxx.xxx.x 来自：中国北京北京 xxx/电信</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~$ http_proxy=http://localhost:8123 curl -i http://ip.cn # polipo的默认端口为8123,如有需要可以自行改动</span><br><span class="line">当前 IP：xxx.xxx.xxx.xx0 来自：美国加利福尼亚州洛杉矶</span><br></pre></td></tr></table></figure>
<p>这样就算成功了.</p>
<p>最近发现”ip.cn”这个网站不能用了，500访问错误。可以将其替换为“ipinfo.io/ip”就可以了i，这是另一个返回你的公网IP的网站。<br>还有一些其他的网站提供类似的返回IP的服务:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl ifconfig.me</span><br><span class="line">curl icanhazip.com</span><br><span class="line">curl ipecho.net/plain</span><br><span class="line">curl ifconfig.co</span><br></pre></td></tr></table></figure>

<p>从浏览器中获得自己公网IP的方法:</p>
<ul>
<li><a href="https://www.google.com/search?q=what%20is%20my%20IP%20address">Google</a></li>
<li><a href="https://duckduckgo.com/?q=ip">DuckDuckGo</a></li>
<li><a href="https://www.wolframalpha.com/input/?i=what+is+my+ip+address">Wolframalpha</a>, 推荐</li>
</ul>
<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>每次都打这么长的命令<code>http_proxy=http://localhost:8123</code>着实不是我们想要的,为了方便使用,可以在终端键入<code>export http_proxy=http://localhost:8123</code>,表示对该终端所有命令生效;或者更进一步,在.bashrc中加入<code>export http_proxy=http://localhost:8123</code>,每次启动终端时自动执行.如果不想要每次都走代理,可以像我一样,在.bashrc中加入<code>alias hp=&quot;http_proxy=http://localhost:8123&quot;</code>,每次需要代理时,只需要在命令前面加<code>hp </code>就好了.</p>
<h2 id="为git配置代理"><a href="#为git配置代理" class="headerlink" title="为git配置代理"></a>为git配置代理</h2><p>git clone的速度很是感人, 只有几十k, 为git配置代理也是很简单的.</p>
<p>Add the following setting to the http items of .gitconfig files.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[http]</span><br><span class="line">proxy = &lt;address of the proxy server&gt;:&lt;port of the proxy server&gt;</span><br></pre></td></tr></table></figure>

<p>You can also configure it using the following config command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &lt;address of the proxy server&gt;:&lt;port of the proxy server&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://gist.github.com/chuyik/02d0d37a49edc162546441092efae6a1">ssh形式连接Github</a></p>
<p>在终端中尽情享受科学上网吧!</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>不同时间戳总结 - YoungForest</title>
    <url>/2016/09/28/timestamp-summary/</url>
    <content><![CDATA[<p>【摘要】最近在实验室帮师兄做一些项目，遇到各种没见过的时间戳，在此总结一下。 Unix时间 关于这个时间，大家一般都比较了解，记录了从1970年1月1日0时0分0秒开始到现在的总秒数。 这篇文章中有关于Unix时间和各种常用时间的关系，在这里分享一下。 Window NT时间 The 18-digit Ac <a href="http://www.cnblogs.com/YoungForest/p/5915074.html">阅读全文</a></p>
]]></content>
  </entry>
  <entry>
    <title>pair 作为 unordered_map unordered_set 的键值 C++</title>
    <url>/2020/05/27/unordered-map-hash-pair-c/</url>
    <content><![CDATA[<p>今天在做<a href="https://atcoder.jp/contests/abc168/tasks/abc168_e">一道AtCoder的题目</a>，有个test case一直TLE。研究这个测试用例和其他用例的区别，苦思不得其解。后来把unordered_map换成map就过了。虽然在小数据集上hashmap和treemap区别不大，但数据量大的话，hashmap还是好些。所以最佳实践是，在不需要排序特性时，就用hashmap。<br>而且之前也从来没有遇到过hashmap比treemap效果差这么多的原因。最后花了一上午时间，才定位到是我的 pair 的hash函数实现太糟糕了。因为C++ STL中并没有pair的hash特化，所以如果想把pair当作键用在unordered_map中的话，就需要自己实现hash函数。我直接从网上抄了一个实现, 直接将 <code>std::hash&lt;T&gt;()(pair.first) ^ std::hash&lt;U&gt;()(pair.second)</code>。为了避免误人子弟，我就不贴代码了。正是抄的这个实现害苦我了，hash函数碰撞严重，导致效率低下。令人惊讶的是，这种错误的实现遍布全网，无论是中文的还是英文的。我从犄角旮旯（<a href="https://stackoverflow.com/questions/20590656/error-for-hash-function-of-pair-of-ints">stackoverflow问题</a>的评论区中）里才找到问题所在和正确的实现。所以特意总结此博文，避免更多的同学踩坑。</p>
<blockquote>
<p>std::hash<T>()(x.first) ^ std::hash<T>()(x.second); - that’s a spectacularly collision-prone way to hash a pair, as every pair with two identical value hashes to 0, and every pair {a, b} hashes the same as {b, a}. For vaguely demanding use, much better to find a hash_combine function and employ that.</p>
</blockquote>
<p>惊讶的是，一看到这个评论，我就像中电一样。忽然记起，多年前，当我还是一只小白时，读《C++ 标准库（第二版）》时，作者就已经给出了绝佳的解决方案。我匆忙翻出珍藏的《C++ 标准库（第二版）》的unordered_map对应章节，“7.9.2 Creating and Controlling Unordered Container”，把任意结构hash化的代码搬出来，模版如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">// from boost (functional/hash):</span></span><br><span class="line"><span class="comment">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash_combine</span><span class="params">(std::<span class="keyword">size_t</span> &amp;seed, <span class="keyword">const</span> T &amp;val)</span> </span>&#123;</span><br><span class="line">    seed ^= std::hash&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed &lt;&lt; <span class="number">6</span>) + (seed &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// auxiliary generic functions to create a hash value using a seed</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span> &amp;seed, <span class="keyword">const</span> T &amp;val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span> &amp;seed, <span class="keyword">const</span> T &amp;val, <span class="keyword">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">    <span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::<span class="keyword">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="keyword">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class="line">    std::<span class="keyword">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair_hash</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">    <span class="function">std::<span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash_val</span>(p.first, p.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;</span><br><span class="line">    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也有Tuple版本的hash实现，我更新回答在了<a href="https://stackoverflow.com/a/62035742/6393787">StackOverflow</a>。有需要的同学可以自取+点赞。</p>
<p>修改了hash_pair的实现后，我如愿地AC了。一个hash函数的错误，我花了一上午时间解决。并由此从多年前的学习经验中获益。当时我苦读《C++标准库》时，并没有对这段代码特别注意。由此可见，多读书总是没坏处的。</p>
<p>平时因为Google搜索很方便，遇到问题总是倾向于简单地 复制粘贴。通常情况下，问题就解决了。这样固然可以更快地完成任务，效果也不错。但这种不求甚解的思想对自己的成长是十分不利的。所以需要遇到问题深入钻研（当然是在时间足够的情况下），多读一些经典的书。很多问题和解决方案，经典的书本都已给出了。读书也更能启发自己思考和成长。本次的pair的 unordered_map实践就是最好的证明。</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>hash</tag>
        <tag>unordered_map</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode include 万能头文件 bits/stdc++.h</title>
    <url>/2020/05/18/vscode-include-bits-stdc-h/</url>
    <content><![CDATA[<p>最近经常打kickstart需要include万能头文件<code>bits/stdc++.h</code>，然而，我喜爱的编辑器vs code总是不能正确地找到该头文件，会有红色波浪线表示错误。作为程序员的我完全不能忍受，所以尝试解决该问题。在网络上搜了很多解决方案，大多数并不能直接地解决我的问题。所以，我总结自己的解决方案于此，方便各位取用。</p>
<p>编程环境:<br>g++ 9.1.0, Mac 10.14.2, vs code 1.45.1</p>
<p>总的思路是:</p>
<ol>
<li>寻找gcc编译器头文件的路径,</li>
<li>更改VS Code设置，让其用上面的路径可以找到<code>bits/stdc++.h</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc-9 -v -E -x c++ -</span><br></pre></td></tr></table></figure>

<p><img src="/images/vscode-include-bits-stdc-h/gcc-include-path.png" alt="gcc include path"></p>
<p>图中所示，就是编译器默认找的路径顺序。将这些路径全部加到vscode的includePath里。</p>
<p><img src="/images/vscode-include-bits-stdc-h/vscode-include-path.png" alt="vscode-include-path"></p>
<p><img src="/images/vscode-include-bits-stdc-h/vscode-settings.png" alt="vscode-settings"></p>
<p>Done!</p>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>Work With Two Github Accounts Simultaneously</title>
    <url>/2017/12/12/work-with-two-github-accounts/</url>
    <content><![CDATA[<p>笔者3个月前来到<a href="http://www.oushu.io/">偶数科技公司</a>实习，学习工作都用公司配的Mac。一分价钱一分货，Mac确实比自己15年买的5000RMB的HP好用多了。所以除了工作之外，学习和实验室的任务也渐渐迁移到Mac上。现在遇到的一个比较棘手的问题是，如何使自己工作的GitHub账号与个人的账号不冲突，同时方便地使用。</p>
<p>在查阅过相关资料后，我实现了如下的解决方案。</p>
<span id="more"></span>
<p>全局默认使用公司的账号，对于需要公司账号的地方不做任何处理。</p>
<p>个人的仓库进行特殊处理。</p>
<ol>
<li>在本地创建ssh密钥</li>
<li>在个人GitHub设置中配置ssh公钥</li>
<li>修改~/.ssh/config<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Personal github user</span><br><span class="line">Host github.ys</span><br><span class="line">        HostName github.com</span><br><span class="line">        User git</span><br><span class="line">        IdentityFile ~/.ssh/id_rsa_personal_github</span><br></pre></td></tr></table></figure></li>
<li>clone仓库时，使用ssh链接，并将<code>github.com</code>替换为<code>github.ys</code></li>
<li>对于已有的仓库，更改<code>.git/config</code>的“remote”项，链接与4中相同</li>
<li>配置local commit。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.email yangsen758@foxmail.com</span><br><span class="line">git config user.name YoungForest</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>为了使<code>hexo</code>可以自动deploy，需要更改hexo下的<code>_config.yml</code>文件中repo链接，类似clone。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.ys:YoungForest/youngforest.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯 微信事业部 暑期实习生 面试</title>
    <url>/2020/03/11/Tencent-WeChat-backend-intern-interview/</url>
    <content><![CDATA[<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>time: 2020-03-11 10:28:43</p>
<p>上周HR联系沟通了下意向工作城市，但是没约具体面试时间。</p>
<p>昨晚8点半忽然接到广东深圳的电话，问是否方便，直接开始了面试（惊不惊喜，刺不刺激？）。面试官网还不太好，中间出了不少问题。比如手撕代码时，对方网站内容不能及时刷新。</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="分布式、深度学习"><a href="#分布式、深度学习" class="headerlink" title="分布式、深度学习"></a>分布式、深度学习</h3><p>BN层，dropout。如何计算？<br>BN: mean, valence。</p>
<p>单机训练 和 多机训练 区别。</p>
<p>多机训练时，如何把各个单机得到的loss reduce下。</p>
<p>数据并行训练 和 模型并行训练。</p>
<p>百亿级特征训练。百亿级是指？</p>
<h3 id="语言基础-C"><a href="#语言基础-C" class="headerlink" title="语言基础 C++"></a>语言基础 C++</h3><p>hashtable实现</p>
<p>shared_ptr, unique_ptr, weak_ptr 区别</p>
<p>move语义</p>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><p>二叉树深度。</p>
<p>二维数组，横竖都非递减，寻找目标值。<code>O(m + n)</code>。<a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/">leetcode240</a></p>
<h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><p>问题：贵组的工作内容，为何问如此多深度学习和分布式的问题？</p>
<p>答：大规模分布式训练框架，技术栈：C++，Python</p>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>time: 2020-03-17 21:59:18</p>
<p>等了一周，终于等来了第一个复试。和上次面我的面试官是同组的。应该是因为技术栈比较契合，所以被分布式训练框架组把简历给捞出来了。</p>
<p>首先问了很多项目和实习经历相关的内容。比如最有挑战性的任务，遇到的困难，怎么解决的？我按照传说中的STAR方法回答了，但是面试官好像并不是很满意。我平时最不擅长讲这些，面试多了也学会一点。还是手撕代码来的干脆和直接（以Google为代表，上来就是干），就像八股文一样，也好准备。</p>
<p>基础知识:</p>
<ul>
<li>shared_ptr, unique-ptr的区别</li>
<li>死锁的必要条件和解决方法</li>
<li>TCP，UDP的区别</li>
<li>TCP如何保证可靠</li>
</ul>
<p>分布式：</p>
<ul>
<li>pytorch的架构、类和C++接口的封装，语言之间的调用</li>
<li>多机多卡训练如何更新参数</li>
</ul>
<p>算法题：</p>
<p>给定一个很长的有序数组，和另一个无序数组，将无序数组插入有序数组中，需要保证结果仍然有序。</p>
<p>Given sorted vector sorted_a and unsorted vector b;   size of a is about 1G<br>vector<int> sorted_a;<br>vector<int> b;<br>insert b to sorted_a as fast as possible, result sorted_a should be sorted, too.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSortedVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; sorted_a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sorted_a.<span class="built_in">emtpy</span>() || b.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> a_tail = sorted_a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b_tail = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        sorted_a.<span class="built_in">resize</span>(sorted_a.<span class="built_in">size</span>() + b.<span class="built_in">size</span>()); <span class="comment">// 可能有 sorted_a.size()</span></span><br><span class="line">        <span class="keyword">int</span> after_tail = sorted_a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a_tail &gt;= <span class="number">0</span> &amp;&amp; b_tail &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sorted_a[a_tail] &gt; b[b_tail]) &#123;</span><br><span class="line">            sorted_a[after_tail] = sorted_a[a_tail];</span><br><span class="line">            --a_tail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sorted_a[after_tail] = b[b_tail];</span><br><span class="line">            --b_tail;</span><br><span class="line">        &#125;</span><br><span class="line">        --after_tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b_tail &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sorted_a[after_tail] = b[b_tail];</span><br><span class="line">        --b_tail;</span><br><span class="line">        --after_tail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Time: O(a.size() + b.size() * log b.size())<br>Space: O(1)</p>
<p>写完代码后让我不停的优化，提示不是在时间复杂度级别的优化。我找了好几处（上面的代码是我的最终版本），最后才让面试官满意。</p>
<h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1><p>time: 2020-03-19 09:06:13</p>
<p>昨天下午刚刚结束二面，今天下午接到HR的电话，约了晚上8点的面试。通过牛客网的平台，视频面试+手撕代码。共1个小时20分钟。</p>
<p>上来简短的自我介绍之后就开始了手撕代码了，我喜欢。共4道题目,都不难，LeetCode Easy/Medium水平。就是前2题一定要用C写比较不舒服。</p>
<p>手撕了50min代码，开始基础知识问答，包括操作系统、计算机网络、数据库、数据结构等。面试官那里估计有一个问题列表，问的很快，很多。我回答后就记下些什么。我没有准备过计算机基础的面试内容，全靠本科时认真学习残留下来的那些知识。大多数都足够了。印象深刻的只有没答上来的：</p>
<ul>
<li>TCP 拥塞控制 和 流量控制 的区别和实现</li>
<li>数据库中 聚簇索引 和 普通索引的区别</li>
<li>IO的异步、阻塞、多路复用 的区别</li>
</ul>
<p>接下来又问了之前的实习和项目经历。我写了5个，问了3个，问的还很细。</p>
<p>问完之后，面试官很干脆的就结束了面试。我从高强度的面试状态中久久不能恢复。</p>
<p>3次面试2次都是晚上进行，加班状态可以看到。只有3面的面试官开了视频，看到大佬的发际线，我感觉自己实力实在太弱了。</p>
<h1 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h1><p>time: 2020-03-19 23:53:31</p>
<p>昨天晚上刚刚结束了三面，今天早上收到四面的电话，约了晚上的面试。</p>
<p>上来先刚了3道算法题，我喜欢。</p>
<p>- 递增循环整数数组，从里面找出最小的元素</p>
<ul>
<li>在二叉排序树上面找出第3大的节点</li>
<li>打印变长为n的回形矩阵</li>
</ul>
<p>然后就问了项目和实习经历，快手的2个项目和HAWQ修改BUG的经历。</p>
<p>问了面试官，join.qq.com上的状态为什么只有1次面试的状态。<br>答曰：同一个候选人，会被不同的组挑到，然后面试。怪不得1面、2面 和 3面、4面无论是面试风格、问题、还是平台都有所区别。</p>
<p>1、2面是明显的分布式框架组的。3、4面可能不是，忘记问了。</p>
<p>下午还参加了微软SWE intern的面试，当时就觉得凉了，晚上果然收到Thank you Letter. 一首凉凉送给自己。秋招加油，再接再厉！</p>
<h1 id="五面"><a href="#五面" class="headerlink" title="五面"></a>五面</h1><p>time: 2020-03-20 17:40:42</p>
<p>今天面完米哈游后，正在做快手的评测，忽然收到要半个小时后5点的电话面试。</p>
<p>说实话，面到第五面我已经心力交瘁了，想要疯狂吐槽了。不过五面十分简单，只持续了15min。</p>
<p>自我介绍 + 项目 + 计算机基础。</p>
<p>计算机基础问了三、四面我没答上来的问题，应该是故意的。不过好在我每次面试完都会进行总结，复习没答上来的知识。</p>
<p>你认为你的优点和缺点是啥？</p>
<ul>
<li>优点：计算机基础扎实、算法没问题</li>
<li>缺点：不适合科研，创新、创造能力不足</li>
</ul>
<p>之前实习换公司的原因。<br>可以实习的时间和方式？</p>
<p>接下来等HR面。</p>
<p>他是 微信搜索服务 组的。三、四面 也是。前2面是分布式框架组的，无论是面试方式还是内容都有所不同。他说应该是 分布式训练框架组 我没过，然后简历释放出来给了他们组。他只能看到三、四面的面试评价，跨组的就是不透明的。我确实对分布式训练的基础知识和经验不足。<br>我也能理解为啥要有5次面试了。</p>
<h1 id="七面"><a href="#七面" class="headerlink" title="七面"></a>七面</h1><p>time: 2020-03-31 19:22:14</p>
<p>上周三约了HR面试，闲聊了半天，和技术面的套路差别很大。因为我说我实习想在北京，所以又约了这周一（今天）下午的一次北京同事的技术面试。北京这边应该就只有一个技术面试，还有HR面试。</p>
<p>视频面试采用牛客网平台，分为 项目、算法、数据结构、计算机基础。</p>
<h2 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h2><blockquote>
<p>逛街<br>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。<br>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住）<br>输入描述<br>输入第一行将包含一个数字n，代表楼的栋数，接下来的一行将包含n个数字wi(1&lt;=i&lt;=n)，代表每一栋楼的高度。<br>1&lt;=n&lt;=100000;<br>1&lt;=wi&lt;=100000;<br>输出描述<br>输出一行，包含空格分割的n个数字vi，分别代表小Q在第i栋楼时能看到的楼的数量。<br>示例1<br>输入<br>6<br>5 3 8 3 2 5<br>输出<br>3 3 5 4 4 4<br>说明<br>当小Q处于位置3时，他可以向前看到位置2,1处的楼，向后看到位置4,6处的楼，加上第3栋楼，共可看到5栋楼。当小Q处于位置4时，他可以向前看到位置3处的楼，向后看到位置5,6处的楼，加上第4栋楼，共可看到4栋楼。</p>
</blockquote>
<p>LeetCode medium难度，秒杀，正反使用2次单调递减栈即可。需要注意的是，看到的楼包括当前楼，所以当前楼会正反计算2次，最后需要减1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">height</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">auto</span> process = [&amp;](<span class="keyword">int</span> i) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; height[s.<span class="built_in">top</span>()] &lt;= height[i])  &#123;</span><br><span class="line">            <span class="keyword">int</span> t = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            ++ans[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">        ans[i] += s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">process</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">process</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        -- ans[i]; <span class="comment">// delete repeated self(count twice)</span></span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>设计一个支持序列化和反序列话的HashMap。我之前没有接触过类似问题，了解过一些序列化的知识。就设计了一个 线型探查版 的hashmap, 因为这样所有数据都可以存储在一个数组中，方便序列化。</p>
<p>为了方便实现，并没有考虑泛化和扩容，虽然提前和面试官沟通过。面试官还是抨击了线型探查对空间利用有问题，说是单个bucket中有过多元素时会有问题。对此我并不苟同，然后有讨论了半天。最后他有怼我说，没别人实现的好，insert时没有考虑扩容。因为我之前已经和他沟通过不考虑扩容和泛化以简化问题。对此，面试官不免有些为了怼而怼的嫌疑，我是并不信服的。我问他别人怎么实现，主流方法如何？他只是说没有标准答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashMap</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> capity = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    array&lt;<span class="keyword">int</span>, capity&gt; data;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NOT_EXIST = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">HashMap</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(data.<span class="built_in">data</span>(), capity * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">searilize</span><span class="params">(<span class="keyword">const</span> string&amp; file_name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把data内容写到文件中</span></span><br><span class="line">        <span class="function">std::ofstream <span class="title">fout</span> <span class="params">(file_name, std::fstream::binary)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span>&amp; d = <span class="keyword">static_cast</span>&lt;array&lt;<span class="keyword">char</span>, capity*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)&gt;&gt;(data)</span><br><span class="line">        std::<span class="built_in">copy</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), std::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(fout));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">const</span> string&amp; file_name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把文件内容读到data中</span></span><br><span class="line">        <span class="function">std::ifstream <span class="title">input</span><span class="params">(file_name, std::ios::binary )</span></span>;</span><br><span class="line">        std::<span class="built_in">copy</span>( </span><br><span class="line">            std::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(input), </span><br><span class="line">            std::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;( ),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;array&lt;<span class="keyword">char</span>, capity*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)&gt;&gt;(data).<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashcode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">int</span> bucket = hashcode &amp; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bucket; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> data[i + (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data[i] == NOT_EXIST) &#123;</span><br><span class="line">                <span class="keyword">return</span> NOT_EXIST;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NOT_EXIST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashcode = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">int</span> bucket = hashcode &amp; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bucket; i &lt; <span class="number">1</span> &lt;&lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == NOT_EXIST || data[i] == key) &#123;</span><br><span class="line">                data[i] = key;</span><br><span class="line">                data[i + (<span class="number">1</span> &lt;&lt; <span class="number">6</span>)] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算机基础-1"><a href="#计算机基础-1" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul>
<li>多态。构造函数不能虚函数，析构函数可以虚函数。</li>
<li>并发了解。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>自己的优点：<br>我讲了 基础扎实、算法好 （刷题多）。<br>他讲了他对刷题的看法。虽然不排斥刷题，但说了很多ACM选手的问题，工程实现考虑不周。感觉他有很多怨言呀。</p>
<p>他还问了为什么本科时成绩好，研究生时不那么好？<br>我如实说了，研究生成绩不重要。</p>
<p>面试官小哥哥早年也在北航读过书，最后我还聊了一下我实验室的现状。</p>
<h1 id="八面-又一次迷一般的面试-差评"><a href="#八面-又一次迷一般的面试-差评" class="headerlink" title="八面 又一次迷一般的面试 差评"></a>八面 又一次迷一般的面试 差评</h1><p>time: 2020-04-13 12:59:03</p>
<p>今天(4.13)上午11:30接到电话，随即开展了40min的面试。根本没有提前约我的时间，让我手头的很多事情都中断了。而且他说之前他们组的同事应该已经给我一面了。但是之前腾讯的7次面试都是别的组面的。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>自我介绍，项目介绍。</p>
<p>各种C++的容器的API的问题，时间复杂度。</p>
<p>竟然让我设计一个推荐系统，我内心…只是简单说了下一些常见的推荐算法的实现。</p>
<h2 id="2道算法题"><a href="#2道算法题" class="headerlink" title="2道算法题"></a>2道算法题</h2><blockquote>
<ol>
<li>实现 strcpy 拷贝字符串</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* source, <span class="keyword">const</span> <span class="keyword">char</span>* destination)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="literal">NULL</span> || destination == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (source[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; source + i != destination) &#123;</span><br><span class="line">        destination[i] = source[i];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>10亿个整型，查找其中不重复的数字</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findUnique</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;    <span class="comment">// 4G</span></span><br><span class="line">    bitset&lt;1 &lt;&lt; 32&gt; seen;    <span class="comment">// 4G</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : v) &#123;</span><br><span class="line">        seen.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(i));</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans; <span class="comment">// 4 G = 10亿 * 4</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; seen.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!seen[i]) &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试官是 微信kitcup推荐系统组的。我直接提意见说下次面试提前约，这次十分仓促，状态也不好。<br>这个面试官的态度也是我遇到过的最差的一批，多次和他沟通时，他说“不要问我”。很多问题问的也是不明所以，给他差评。真想投诉他。</p>
<h1 id="九面"><a href="#九面" class="headerlink" title="九面"></a>九面</h1><p>本次面试大概只持续了10min，问了一道“判断链表是否是回文”的算法题。要求时间复杂度O(N), 空间复杂度O(1)。LeetCode medium难度吧。</p>
<p>之后问我，看到我之前面了腾讯很多次，都到HR面了。为什么没有签？我说是因为工作地点冲突的原因。我期望在北京，他们组都在深圳。面试官说，那我也是面深圳的岗位。你填报志愿填的服从调剂。然后也没必要继续面下去了。史上最快的面试！！😂</p>
<p>我之后去官网看了下，还真是，重新改了下，不服从调剂了。希望北京的组能捞起我。不知道组里的工程师能不能定向捞人呀，不然可以联系一下在腾讯工作的同学和师兄。</p>
<h1 id="4-26-笔试"><a href="#4-26-笔试" class="headerlink" title="4.26 笔试"></a>4.26 笔试</h1><p>TX的笔试难度还是挺大的，尤其是第2题和第3题。不过TX并不生产算法题，它只是算法题的搬运工。</p>
<h2 id="2-寻找2个点集中最近的对"><a href="#2-寻找2个点集中最近的对" class="headerlink" title="2. 寻找2个点集中最近的对"></a>2. 寻找2个点集中最近的对</h2><p><a href="https://www.acwing.com/problem/content/121/">原题链接</a><br>大雪菜提供了<a href="https://www.acwing.com/video/96/">视频讲解</a>。简而言之，就是把2个点集的点分别做个标记，然后利用一个点集内找最近对的算法（不同标记的点，相当于无穷远）。<a href="https://www.geeksforgeeks.org/closest-pair-of-points-using-divide-and-conquer-algorithm/">一个点集内找最近对</a>就是一个十分经典的问题了，采用分治可以解决。</p>
<p>时间复杂度: O(N log N), 空间复杂度: O(N).</p>
<h2 id="2-卡牌翻转"><a href="#2-卡牌翻转" class="headerlink" title="2. 卡牌翻转"></a>2. 卡牌翻转</h2><p><a href="https://atcoder.jp/contests/keyence2020/tasks/keyence2020_d">原题 Swap and Flip</a></p>
<p>动态规划。DP[mask][i]表示mask中的牌在最左边，第i个牌在这些牌中的最后，保证非降的最小操作数。<br><img src="https://uploadfiles.nowcoder.com/images/20200428/407266647_1588073288778_01811641BAED0EC338B3EE5B829175F4" alt="图片说明" title="图片标题"><br>时间复杂度: O(n^2 * 2^n),<br>空间复杂度: O(n * 2 ^ n)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">B</span><span class="params">(N)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>((<span class="number">1</span> &lt;&lt; N), vector&lt;<span class="keyword">int</span>&gt;(N, INF));</span><br><span class="line">    <span class="comment">// dp[mask][i]: the minimum operation when cards in mask are in leftmost and the ith card is in the end</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        dp[<span class="number">1</span> &lt;&lt; i][i] = <span class="number">0</span>;  <span class="comment">// there is no card in leftmost whose id larger than i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; N); ++s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((s &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;                  <span class="comment">// i is not in state</span></span><br><span class="line">            <span class="keyword">int</span> c = __builtin_popcount(s); <span class="comment">// card number in s</span></span><br><span class="line">            <span class="keyword">int</span> value_i = (c % <span class="number">2</span>) == (i % <span class="number">2</span>) ? B[i] : A[i];</span><br><span class="line">            <span class="keyword">int</span> cost = c; <span class="comment">// the number of card in s, whose id is larger than j</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((s &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    --cost;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// j is in state already</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> value_j = (j % <span class="number">2</span>) == (c % <span class="number">2</span>) ? A[j] : B[j];</span><br><span class="line">                <span class="keyword">if</span> (value_j &gt;= value_i) &#123;</span><br><span class="line">                    dp[s | (<span class="number">1</span> &lt;&lt; j)][j] =</span><br><span class="line">                        <span class="built_in">min</span>(dp[s | (<span class="number">1</span> &lt;&lt; j)][j], dp[s][i] + cost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans &gt;= INF ? <span class="number">-1</span> : ans;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>intern</tag>
        <tag>Tencent</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode biweekly contest 56</title>
    <url>/2021/07/12/LeetCode-biweekly-contest-56/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (5)</th>
<th>Q3 (5)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>998 / 10896</td>
<td>YoungForest</td>
<td>18</td>
<td>1:27:14</td>
<td>0:02:33</td>
<td>0:13:25</td>
<td>1:17:14  2</td>
<td>null</td>
</tr>
</tbody></table>
<p>现在双周赛的参赛人数都快赶上周赛了。</p>
<h2 id="1925-Count-Square-Sum-Triples"><a href="#1925-Count-Square-Sum-Triples" class="headerlink" title="1925. Count Square Sum Triples"></a>1925. Count Square Sum Triples</h2><p>签到题，暴力枚举所有的组合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countTriples</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, c+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, b+<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> a * a + b * b == c * c:</span><br><span class="line">                        <span class="keyword">if</span> a == b: ans += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>: ans += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(N^3),<br>空间复杂度: O(1).</p>
<h2 id="1926-Nearest-Exit-from-Entrance-in-Maze"><a href="#1926-Nearest-Exit-from-Entrance-in-Maze" class="headerlink" title="1926. Nearest Exit from Entrance in Maze"></a>1926. Nearest Exit from Entrance in Maze</h2><p>寻找最近的出口。标准的BFS。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nearestExit</span>(<span class="params">self, maze: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], entrance: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        q = deque()</span><br><span class="line">        start = (entrance[<span class="number">0</span>], entrance[<span class="number">1</span>])</span><br><span class="line">        visited.add(start)</span><br><span class="line">        q.append(start)</span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        directions = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]</span><br><span class="line">        rows = <span class="built_in">len</span>(maze)</span><br><span class="line">        cols = <span class="built_in">len</span>(maze[<span class="number">0</span>])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">exitCell</span>(<span class="params">cell</span>):</span></span><br><span class="line">            <span class="keyword">return</span> (cell[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> cell[<span class="number">0</span>] == rows - <span class="number">1</span> <span class="keyword">or</span> cell[<span class="number">1</span>] == <span class="number">0</span> <span class="keyword">or</span> cell[<span class="number">1</span>] == cols - <span class="number">1</span>) <span class="keyword">and</span> maze[cell[<span class="number">0</span>]][cell[<span class="number">1</span>]] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> cell != start </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            s = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(s):</span><br><span class="line">                current = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> exitCell(current): <span class="keyword">return</span> step</span><br><span class="line">                <span class="keyword">for</span> di, dj <span class="keyword">in</span> directions:</span><br><span class="line">                    ni = di + current[<span class="number">0</span>]</span><br><span class="line">                    nj = dj + current[<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> ni &gt;= <span class="number">0</span> <span class="keyword">and</span> ni &lt; rows <span class="keyword">and</span> nj &gt;= <span class="number">0</span> <span class="keyword">and</span> nj &lt; cols <span class="keyword">and</span> maze[ni][nj] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">and</span> (ni, nj) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add((ni, nj))</span><br><span class="line">                        q.append((ni,nj))</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(m * n),<br>空间复杂度: O(m * n).</p>
<h2 id="1927-Sum-Game"><a href="#1927-Sum-Game" class="headerlink" title="1927. Sum Game"></a>1927. Sum Game</h2><p>贪心。<br>尽量先取问好少的那边（直到取完），Alice尽量让差变大，Bob尽量让差变小。</p>
<p>想法是好的，但我最后写的又臭又长，在比赛结束前13分钟才Accept。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumGame</span>(<span class="params">self, num: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(num)</span><br><span class="line">        leftSum = <span class="number">0</span></span><br><span class="line">        rightSum = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> num[i] == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> i &gt;= n // <span class="number">2</span>: right += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i &gt;= n // <span class="number">2</span>: rightSum += <span class="built_in">ord</span>(num[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>: leftSum += <span class="built_in">ord</span>(num[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        total = right + left</span><br><span class="line">        <span class="comment"># print (&#x27;total: &#x27;, total)</span></span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span> == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        alice = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            <span class="keyword">if</span> alice:</span><br><span class="line">                <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> (right != <span class="number">0</span> <span class="keyword">and</span> left &gt; right): <span class="comment"># pick right</span></span><br><span class="line">                    <span class="keyword">if</span> leftSum &lt;= rightSum <span class="keyword">or</span> rightSum + <span class="number">9</span> &gt; leftSum:</span><br><span class="line">                        rightSum += <span class="number">9</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        rightSum += <span class="number">0</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> right == <span class="number">0</span> <span class="keyword">or</span> left &lt; right: <span class="comment"># pick left</span></span><br><span class="line">                    <span class="keyword">if</span> leftSum &gt;= rightSum <span class="keyword">or</span> leftSum + <span class="number">9</span> &gt; rightSum:</span><br><span class="line">                        leftSum += <span class="number">9</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        leftSum += <span class="number">0</span></span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> leftSum == rightSum:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">elif</span> leftSum &gt; rightSum:</span><br><span class="line">                        leftSum += <span class="number">9</span></span><br><span class="line">                        left -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        rightSum += <span class="number">9</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">or</span> (right != <span class="number">0</span> <span class="keyword">and</span> left &gt; right): <span class="comment"># pick right</span></span><br><span class="line">                    <span class="keyword">if</span> leftSum &gt; rightSum:</span><br><span class="line">                        rightSum +=  <span class="number">9</span> <span class="keyword">if</span> (leftSum - rightSum &gt; <span class="number">9</span>) <span class="keyword">else</span> leftSum - rightSum</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        rightSum += <span class="number">0</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> right == <span class="number">0</span> <span class="keyword">or</span> left &lt; right: <span class="comment"># pick left</span></span><br><span class="line">                    <span class="keyword">if</span> leftSum &lt; rightSum:</span><br><span class="line">                        leftSum += <span class="number">9</span> <span class="keyword">if</span> (rightSum - leftSum &gt; <span class="number">9</span>) <span class="keyword">else</span> rightSum - leftSum</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        leftSum += <span class="number">0</span></span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">            <span class="comment"># print (left, leftSum, rightSum, right)</span></span><br><span class="line">                </span><br><span class="line">            alice = <span class="keyword">not</span> alice</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> leftSum != rightSum</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(num.length),<br>空间复杂度: O(num.length).</p>
<h2 id="1928-Minimum-Cost-to-Reach-Destination-in-Time"><a href="#1928-Minimum-Cost-to-Reach-Destination-in-Time" class="headerlink" title="1928. Minimum Cost to Reach Destination in Time"></a>1928. Minimum Cost to Reach Destination in Time</h2><p>也是一道经典的题目。在限制时间的情况下，花费最小。</p>
<p><a href="https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time/solution/gui-ding-shi-jian-nei-dao-da-zhong-dian-n3ews/">国服官方的DP解</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 249</title>
    <url>/2021/07/11/LeetCode-weekly-contest-249/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>74 / 12832</td>
<td>YoungForest</td>
<td>19</td>
<td>1:06:48</td>
<td>0:02:44</td>
<td>0:07:11</td>
<td>0:37:44</td>
<td>1:01:48 🐞1</td>
</tr>
</tbody></table>
<p>周赛博客更新一不小心就鸽了3周。因为最近毕业+入职，确实比较忙。中间因为毕业旅行，甚至罕见地鸽了一次周赛和双周赛。<br>本周算是入职亚马逊之后的第一周，全球排名也惊喜地达到了74名。仔细算算，自己上次周赛进前100名还是243场，也就是大概一个半月前的时间了。<br>本周后2题都是hard，确实容易拉开距离。</p>
<p>因为我国服rating达到了2460，我担心掉分，因此最近基本都在美服玩耍。美服是个2330的“小号”，基本很难掉分。</p>
<h2 id="1929-Concatenation-of-Array"><a href="#1929-Concatenation-of-Array" class="headerlink" title="1929. Concatenation of Array"></a>1929. Concatenation of Array</h2><p>签到题。Straight forward。Python竟然可以一行<code>return nums + nums</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getConcatenation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span> * n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans[i] = ans[i+n] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(n),<br>空间复杂度: O(n).</p>
<h2 id="1930-Unique-Length-3-Palindromic-Subsequences"><a href="#1930-Unique-Length-3-Palindromic-Subsequences" class="headerlink" title="1930. Unique Length-3 Palindromic Subsequences"></a>1930. Unique Length-3 Palindromic Subsequences</h2><p>因为回文串的长度比较短，只有3. 因此，最多有26*26种回文串。可以用中间和两侧的字符表示这个回文串。<br>因为是subsequence，需要用<code>cntLeft</code>和<code>cntRight</code>维护两侧字符是否满足要求。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPalindromicSubsequence</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">seen</span>(<span class="number">26</span>, vector&lt;<span class="keyword">bool</span>&gt;(<span class="number">26</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cntRight</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            ++cntRight[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cntLeft</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            --cntRight[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cntRight[i - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; cntLeft[i - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!seen[c - <span class="string">&#x27;a&#x27;</span>][i - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                        seen[c - <span class="string">&#x27;a&#x27;</span>][i - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cntLeft[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(26*s.length),<br>空间复杂度: O(26 * 26).</p>
<h2 id="1931-Painting-a-Grid-With-Three-Different-Colors"><a href="#1931-Painting-a-Grid-With-Three-Different-Colors" class="headerlink" title="1931. Painting a Grid With Three Different Colors"></a>1931. Painting a Grid With Three Different Colors</h2><p>算是<a href="https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/">1411. Number of Ways to Paint N × 3 Grid</a>的升级版。<br>行数从3变成了1-5，但思想不变，仍然是 3进制的bit_mask + dp。</p>
<p>用3进制bit_mask表示每一列的颜色状态，从上一列的颜色排列数量得到新的一列的数量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">colorTheGrid</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pow3m = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m; ++x) &#123;</span><br><span class="line">            pow3m *= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> ok = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m; ++x) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i % <span class="number">3</span>) == (j % <span class="number">3</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i /= <span class="number">3</span>;</span><br><span class="line">                j /= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> isLegal = [&amp;](<span class="keyword">int</span> i) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; m; ++x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == last) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                last = i % <span class="number">3</span>;</span><br><span class="line">                i /= <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">match</span>(pow3m);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">legal</span><span class="params">(pow3m)</span></span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (pow3m); ++i) &#123;</span><br><span class="line">              legal[i] = <span class="built_in">isLegal</span>(i);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (pow3m); ++i) &#123;</span><br><span class="line">              <span class="comment">// cout &lt;&lt; legal[i] &lt;&lt; &quot; &quot; &lt;&lt; endl;</span></span><br><span class="line">              <span class="keyword">if</span> (!legal[i]) <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (pow3m); ++j) &#123;</span><br><span class="line">                  <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;....&quot;;</span></span><br><span class="line">                  <span class="keyword">if</span> (!legal[j]) <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;****&quot;;</span></span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">ok</span>(i, j)) &#123;</span><br><span class="line">                      match[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                      <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;;&quot;;</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(pow3m, vector&lt;<span class="keyword">int</span>&gt; (n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; (pow3m); ++mask) &#123;</span><br><span class="line">            <span class="keyword">if</span> (legal[mask])</span><br><span class="line">                dp[mask][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; dp[mask][0] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; (pow3m); ++mask) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!legal[mask]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> left : match[mask]) &#123;</span><br><span class="line">                    dp[mask][i] = (dp[mask][i] + dp[left][i<span class="number">-1</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; dp[mask][i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; (pow3m); ++mask) &#123;</span><br><span class="line">            <span class="keyword">if</span> (legal[mask])</span><br><span class="line">                ans = (ans + dp[mask][n<span class="number">-1</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(3^m^2 + n*3^m),<br>空间复杂度: O(n * 3^m).</p>
<h2 id="1932-Merge-BSTs-to-Create-Single-BST"><a href="#1932-Merge-BSTs-to-Create-Single-BST" class="headerlink" title="1932. Merge BSTs to Create Single BST"></a>1932. Merge BSTs to Create Single BST</h2><p>算法不难，但是实现起来比较复杂，corner case也容易fail。<br>根据题目描述，找到每个根和叶子的对应，进行合并操作。<br>最后还得检查是否是BST。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">tuple&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// is BST, max value, min value</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;<span class="literal">true</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        tuple&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret = &#123;<span class="literal">true</span>, root-&gt;val, root-&gt;val&#125;;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">auto</span> l = <span class="built_in">solve</span>(root-&gt;left);</span><br><span class="line">            get&lt;<span class="number">0</span>&gt;(ret) = get&lt;<span class="number">0</span>&gt;(ret) &amp;&amp; get&lt;<span class="number">0</span>&gt;(l) &amp;&amp; root-&gt;val &gt; get&lt;<span class="number">1</span>&gt;(l);</span><br><span class="line">            get&lt;<span class="number">2</span>&gt;(ret) = <span class="built_in">min</span>(get&lt;<span class="number">2</span>&gt;(ret), get&lt;<span class="number">2</span>&gt;(l));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">auto</span> r = <span class="built_in">solve</span>(root-&gt;right);</span><br><span class="line">            get&lt;<span class="number">0</span>&gt;(ret) = get&lt;<span class="number">0</span>&gt;(ret) &amp;&amp; get&lt;<span class="number">0</span>&gt;(r) &amp;&amp; root-&gt;val &lt; get&lt;<span class="number">2</span>&gt;(r);</span><br><span class="line">            get&lt;<span class="number">1</span>&gt;(ret) = <span class="built_in">max</span>(get&lt;<span class="number">1</span>&gt;(ret), get&lt;<span class="number">1</span>&gt;(r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get&lt;<span class="number">0</span>&gt;(<span class="built_in">solve</span>(root));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span>(root-&gt;left) + <span class="built_in">count</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">canMerge</span><span class="params">(vector&lt;TreeNode*&gt;&amp; trees)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = trees.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;TreeNode*, TreeNode*&gt; leaves;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, TreeNode*&gt; value2leaf;</span><br><span class="line">        vector&lt;TreeNode*&gt; equalLeaves;</span><br><span class="line">        <span class="keyword">bool</span> bad = <span class="literal">false</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*, TreeNode*)&gt; dfs = [&amp;](TreeNode* root, TreeNode* parent) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            seen.<span class="built_in">insert</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value2leaf.<span class="built_in">find</span>(root-&gt;val) != value2leaf.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    bad = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                leaves[root] = parent;</span><br><span class="line">                value2leaf[root-&gt;val] = root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(root-&gt;left, root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(root-&gt;right, root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> root : trees) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root, <span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> (bad) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* ans = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> root : trees) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = value2leaf.<span class="built_in">find</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (it == value2leaf.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                ans = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> leaf = it-&gt;second;</span><br><span class="line">                <span class="keyword">auto</span> parent = leaves[leaf];</span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;left &amp;&amp; parent-&gt;left-&gt;val == root-&gt;val) &#123;</span><br><span class="line">                    parent-&gt;left = root;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;right &amp;&amp; parent-&gt;right-&gt;val == root-&gt;val) &#123;</span><br><span class="line">                    parent-&gt;right = root;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isValidBST</span>(ans)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">count</span>(ans) != seen.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(trees.length),<br>空间复杂度: O(trees.length).</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode weekly contest 250</title>
    <url>/2021/07/19/LeetCode-weekly-contest-250/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Rank</th>
<th>Name</th>
<th>Score</th>
<th>Finish Time</th>
<th>Q1 (3)</th>
<th>Q2 (4)</th>
<th>Q3 (6)</th>
<th>Q4 (6)</th>
</tr>
</thead>
<tbody><tr>
<td>192 / 13694</td>
<td>YoungForest</td>
<td>18</td>
<td>1:22:27</td>
<td>0:03:20</td>
<td>0:09:15  🐞1</td>
<td>0:28:08</td>
<td>1:07:27  🐞2</td>
</tr>
</tbody></table>
<p>连续2周成绩还不错，前200。导致美服小号rating都要上2400了，以后打起来会更加需要小心翼翼。</p>
<h2 id="1935-Maximum-Number-of-Words-You-Can-Type"><a href="#1935-Maximum-Number-of-Words-You-Can-Type" class="headerlink" title="1935. Maximum Number of Words You Can Type"></a>1935. Maximum Number of Words You Can Type</h2><p>签到题。字符串问题用Python果然没错。光<code>split</code>这一项就值得。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canBeTypedWords</span>(<span class="params">self, text: <span class="built_in">str</span>, brokenLetters: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        broken = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> brokenLetters:</span><br><span class="line">            broken.add(i)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ok</span>(<span class="params">word</span>):</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> broken:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> text.split(<span class="string">&#x27; &#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> ok(word):</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(text.length),<br>空间复杂度: O(text.length + 26).</p>
<h2 id="1936-Add-Minimum-Number-of-Rungs"><a href="#1936-Add-Minimum-Number-of-Rungs" class="headerlink" title="1936. Add Minimum Number of Rungs"></a>1936. Add Minimum Number of Rungs</h2><p>贪心，如果够不到下一级，就在最远的距离上加一个。<br>需要注意，不能一级一级加，而是用除法一次加完中间缺少的。否则，会TLE（我也因此罚时5min）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addRungs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; rungs, <span class="keyword">int</span> dist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; rungs.<span class="built_in">size</span>(); ++idx) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> i = rungs[idx];</span><br><span class="line">            <span class="keyword">if</span> (i - last &lt;= dist) &#123;</span><br><span class="line">                last = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += (i - last - <span class="number">1</span>) / dist;</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(rungs.length),<br>空间复杂度: O(1).</p>
<h2 id="1937-Maximum-Number-of-Points-with-Cost"><a href="#1937-Maximum-Number-of-Points-with-Cost" class="headerlink" title="1937. Maximum Number of Points with Cost"></a>1937. Maximum Number of Points with Cost</h2><p>很明显的一道动态规划题目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = points[i][j] + max(dp[i-1][k] - abs(k-j) for k in range(n))</span><br></pre></td></tr></table></figure>
<p>然而直接莽的话，时间复杂度是 O(m * n ^ 2). 显然会TLE。需要优化。<br>上一行根据 abs的正负，可以分为<br>前面的 dp[i-1] - (j - k) = dp[i-1] + k - j,<br>后面的 dp[i-1] - (k - j) = dp[i-1] - k + j.<br>可以使用2个TreeSet记录前后的 dp + k 和 dp - k，并在j更新的时候，更新这2个TreeSet.<br>这样时间复杂度降为: O(m * n). </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = points[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;ll&gt; (n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// i == 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = points[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            multiset&lt;ll&gt; before, after;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                after.<span class="built_in">insert</span>(dp[i<span class="number">-1</span>][k] - k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                ll add = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (before.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    add = *after.<span class="built_in">rbegin</span>() + j;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (after.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    add = *before.<span class="built_in">rbegin</span>() - j;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    add = <span class="built_in">max</span>(*before.<span class="built_in">rbegin</span>() - j, *after.<span class="built_in">rbegin</span>() + j);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], points[i][j] + add);</span><br><span class="line">                <span class="keyword">auto</span> it = after.<span class="built_in">find</span>(dp[i<span class="number">-1</span>][j] - j);</span><br><span class="line">                after.<span class="built_in">erase</span>(it);</span><br><span class="line">                before.<span class="built_in">insert</span>(dp[i<span class="number">-1</span>][j] + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">back</span>().<span class="built_in">begin</span>(), dp.<span class="built_in">back</span>().<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(m * n)，<br>空间复杂度: O(m * n). 其实也可以降为O(n), 但写起来稍微麻烦些，对AC也没必要.</p>
<h2 id="1938-Maximum-Genetic-Difference-Query"><a href="#1938-Maximum-Genetic-Difference-Query" class="headerlink" title="1938. Maximum Genetic Difference Query"></a>1938. Maximum Genetic Difference Query</h2><p>Trie + backtracking + 离线计算。<br>Trie用来快速计算最大XOR，backtracking用来维护从根到当前节点的路径和更新Trie，离线计算用以得到query的答案。</p>
<p>使用cpp需要注意Trie的实现方式。<br>本题用<code>shared_ptr</code>会TLE，raw pointer + delete也会TLE。<br>删了delete才AC，这是逼我内存泄漏呀。<br>不过本题因为可以使用<code>cnt</code>表示节点状态，实际上也并不需要真正删除节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_BIT = <span class="number">17</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        array&lt;TrieNode*, 2&gt; children;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTrie</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num, TrieNode* root, <span class="keyword">const</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> b = (num &gt;&gt; index) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;children[b] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            root-&gt;children[b] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;children[b]-&gt;cnt++;</span><br><span class="line">        <span class="built_in">buildTrie</span>(num, root-&gt;children[b], index - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eraseTrie</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num, TrieNode* root, <span class="keyword">const</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> b = (num &gt;&gt; index) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// if (root-&gt;children[b] == nullptr) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; num &lt;&lt; &quot;:&quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//     root-&gt;children[b] = make_shared&lt;TrieNode&gt;();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">eraseTrie</span>(num, root-&gt;children[b], index - <span class="number">1</span>);</span><br><span class="line">        root-&gt;children[b]-&gt;cnt--;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;children[b]-&gt;cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// delete root-&gt;children[b];</span></span><br><span class="line">            root-&gt;children[b] = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxGeneticDifference</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parents, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = parents.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">children</span>(n);</span><br><span class="line">        <span class="keyword">int</span> rootNode = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parents[i] == <span class="number">-1</span>) rootNode = i;</span><br><span class="line">            <span class="keyword">else</span> children[parents[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">offQueies</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; m; ++index) &#123;</span><br><span class="line">            offQueies[queries[index][<span class="number">0</span>]].<span class="built_in">push_back</span>(&#123;queries[index][<span class="number">1</span>], index&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// shared_ptr&lt;TrieNode&gt; root = make_shared&lt;TrieNode&gt;();</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        <span class="keyword">auto</span> maxXOR = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> val) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">auto</span> current = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = MAX_BIT; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> b = (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;children[<span class="number">1</span> - b]) &#123;</span><br><span class="line">                    ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                    current = current-&gt;children[<span class="number">1</span> - b];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    current = current-&gt;children[b];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> <span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&amp;)&gt; dfs = [&amp;](<span class="keyword">const</span> <span class="keyword">int</span> current, vector&lt;<span class="keyword">int</span>&gt;&amp; path) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> p : offQueies[current]) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = get&lt;<span class="number">0</span>&gt;(p);</span><br><span class="line">                <span class="keyword">int</span> index = get&lt;<span class="number">1</span>&gt;(p);</span><br><span class="line">                ans[index] = <span class="built_in">maxXOR</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; current &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> child : children[current]) &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(child);</span><br><span class="line">                <span class="built_in">buildTrie</span>(child, root, MAX_BIT);</span><br><span class="line">                <span class="built_in">dfs</span>(child, path);</span><br><span class="line">                <span class="built_in">eraseTrie</span>(path.<span class="built_in">back</span>(), root, MAX_BIT);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        path.<span class="built_in">push_back</span>(rootNode);</span><br><span class="line">        <span class="built_in">buildTrie</span>(rootNode, root, MAX_BIT);</span><br><span class="line">        <span class="built_in">dfs</span>(rootNode, path);</span><br><span class="line">        <span class="built_in">eraseTrie</span>(path.<span class="built_in">back</span>(), root, MAX_BIT);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: O(log (max(val_i)) * (parents.length + queries.length)),<br>空间复杂度: O(parents.length), Trie的空间消耗其实是个等比数列求和。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Competitive Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>武汉游记 暨硕士毕业旅行</title>
    <url>/2021/07/02/Wuhan-trip/</url>
    <content><![CDATA[<p>终于毕业了，筹划了许久的毕业旅行也正式提上议程。因为要等npy考完试，而且入职前要回来，最好还有几天休息和置办家具。我和npy只有1周时间旅行。共去了3个地方，山西临汾-&gt;湖北武汉-&gt;湖北随州。<br>目的大概是见我的家长，看望npy十年没见的奶奶。</p>
<h1 id="6-24-Day-0"><a href="#6-24-Day-0" class="headerlink" title="6/24 Day 0"></a>6/24 Day 0</h1><p>这天领毕业证，收拾宿舍并退宿，送走了舍友，晚上等npy考完试，然后去十里堡看房。回学校取旅行行李，然后去火车站附近的酒店。洗漱完就已经1点多了，亲热好久才睡觉。毕竟距上次开房已经2个半月了，还是npy生日出去的。</p>
<h1 id="6-25-Day-1"><a href="#6-25-Day-1" class="headerlink" title="6/25 Day 1"></a>6/25 Day 1</h1><p>中午睡到11点。打车去北京西站，虽然离得很近，但还是开车前10分钟才上了车。<br>坐D2003到达襄汾西站。爸爸和小爸来接，一起去风情街的油粉饭馆吃了饭，妈妈和姐姐也来了。</p>
<h1 id="6-26-Day-2"><a href="#6-26-Day-2" class="headerlink" title="6/26 Day 2"></a>6/26 Day 2</h1><p>第二天早上在家吃饭，随后2辆车带npy去龙树峪玩。爬山，走了玻璃桥和石头滑梯。<br>中午回村里接上奶奶，再回城里尉村拉面馆吃大餐。<br>下午回家休息了2个小时，开车带npy去市里的商场玩。吃了美食城的麻辣拌。</p>
<h1 id="6-27-Day-3"><a href="#6-27-Day-3" class="headerlink" title="6/27 Day 3"></a>6/27 Day 3</h1><p>上午在家做饭吃。本来打算做焖面，但因为我买错了豆角。最后做了西红柿鸡蛋手擀面吃。</p>
<p>吃完饭稍事休息，爸爸开车送我们去机场。<br>乘坐飞机傍晚到达武汉天河机场，坐地铁到汉口站，在附近的宾馆留宿。</p>
<p>晚上去万松园，吃了生煎、牛肉粉、臭干子。<br>逛了中山公园，和旁边的商场。不过因为9点半商场要关门，只在一楼拍了一些照片。</p>
<p>初到武汉就品尝到江城的威力，早上下了暴雨，虽然我们晚上到了之后没雨。但十分潮湿和炎热，再加上武汉的吃的都辣，走两步路身上就全湿了，真是要了我亲命了。</p>
<h1 id="6-28-Day-4"><a href="#6-28-Day-4" class="headerlink" title="6/28 Day 4"></a>6/28 Day 4</h1><p>中午在火车站旁吃了热干面，还不错。坐高铁去随州南。npy姑姑和姑父接站。随后去村里爷爷奶奶家坐，并吃了晚饭。晚上姑父接我们回市里宾馆住。吃了小笼包子和水果酸奶。因为晚上没吃饱。农村的饭菜还是顶不住，出于礼貌和饥饿吃了一些。</p>
<h1 id="6-29-Day-5"><a href="#6-29-Day-5" class="headerlink" title="6/29 Day 5"></a>6/29 Day 5</h1><p>早上赶早，吃了襄阳牛杂面，喝了米酒。随后去爷爷奶奶家继续坐了一上午，和爷爷奶奶告别。<br>中午回市里吃小龙虾（虾子）。姑姑请客，真过瘾。<br>下午坐高铁回武汉，还住原来的宾馆。</p>
<p>出站时遇到了网红“罗翔老师”，合影发朋友圈。</p>
<p>晚上去“户部巷”小吃街，吃了</p>
<p>走了著名的武汉长江大桥。没成想过了桥，到了汉阳，这里都是大马路。而且晚上快12点了，也没公交，和小黄车。打车回了汉口站。大家还是尽量不要步行去一些奇怪的地方。还好出租车特别多，否则真的绝望。</p>
<h1 id="6-30-Day-6"><a href="#6-30-Day-6" class="headerlink" title="6/30 Day 6"></a>6/30 Day 6</h1><p>江汉大道</p>
<h1 id="7-1-Day-7"><a href="#7-1-Day-7" class="headerlink" title="7/1 Day 7"></a>7/1 Day 7</h1><p>G520一大早回北京。到学校搬家，晚上去宜家购置家具，又花了2400大洋。</p>
<p>旅行真是花钱，搬家也是。</p>
]]></content>
      <categories>
        <category>dairy</category>
      </categories>
      <tags>
        <tag>trvalling</tag>
      </tags>
  </entry>
</search>
