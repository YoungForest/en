{
    "version": "https://jsonfeed.org/version/1",
    "title": "YoungForest's blog • All posts by \"leetcode\" category",
    "description": "佛系更新；生活、学习",
    "home_page_url": "https://youngforest.github.io",
    "items": [
        {
            "id": "https://youngforest.github.io/2021/08/15/LeetCode-weekly-contest-254/",
            "url": "https://youngforest.github.io/2021/08/15/LeetCode-weekly-contest-254/",
            "title": "LeetCode weekly contest 254",
            "date_published": "2021-08-15T03:40:36.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (4)</th>\n<th>Q3 (6)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>616 / 13755</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>1:28:25</td>\n<td>0:03:14</td>\n<td>0:08:43</td>\n<td>0:37:17  🐞4</td>\n<td>1:03:25  🐞1</td>\n</tr>\n</tbody></table>\n<p>一不小心，周赛博客又鸽了3周。虽然我一直在参加周赛，但赛后经常忘记总结和复盘。平日里对刷题也放松了练习。平时打卡不是让npy刷，就是抄之前的提交。毕竟自己做了1300+的题，经常出的题都是我做过的。<br>主要还是工作后生活丰富了许多，刷题和周赛的优先级降低不少。多场双周赛我都鸽了，快活的诱惑太大了。</p>\n<h2 id=\"1967-Number-of-Strings-That-Appear-as-Substrings-in-Word\"><a href=\"#1967-Number-of-Strings-That-Appear-as-Substrings-in-Word\" class=\"headerlink\" title=\"1967. Number of Strings That Appear as Substrings in Word\"></a>1967. Number of Strings That Appear as Substrings in Word</h2><p>签到题。字符串问题用<code>Python</code> So easy。可惜我Q3没有坚持用<code>Python</code>，否则这周免打卡也是极有可能的。距500名差10min。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numOfStrings</span>(<span class=\"params\">self, patterns: <span class=\"type\">List</span>[<span class=\"built_in\">str</span>], word: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> patterns:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> s <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">                ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(sum(patterns[i].length * word.length)),<br>空间复杂度: O(1).</p>\n<h2 id=\"1968-Array-With-Elements-Not-Equal-to-Average-of-Neighbors\"><a href=\"#1968-Array-With-Elements-Not-Equal-to-Average-of-Neighbors\" class=\"headerlink\" title=\"1968. Array With Elements Not Equal to Average of Neighbors\"></a>1968. Array With Elements Not Equal to Average of Neighbors</h2><p>贪心。这道题答案并不唯一，但我看到大多数人的思路和我一样。<br>即 大 小 间隔插，保证2侧的数都大于/小于中间的数。自然可以保证平均数也大于/小于中间的数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">rearrangeArray</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; l &lt;= r; i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            ans[i] = nums[l++];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l &lt;= r)</span><br><span class=\"line\">                ans[i+<span class=\"number\">1</span>] = nums[r--];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n log n),<br>空间复杂度: O(n).</p>\n<h2 id=\"1969-Minimum-Non-Zero-Product-of-the-Array-Elements\"><a href=\"#1969-Minimum-Non-Zero-Product-of-the-Array-Elements\" class=\"headerlink\" title=\"1969. Minimum Non-Zero Product of the Array Elements\"></a>1969. Minimum Non-Zero Product of the Array Elements</h2><p>贪心，尽量分成大的数和小的数, 即 1 * (2^p - 2) * 1 * (2^p - 2) * … * (2^p - 1).<br>前面共<code>(2^p - 2) / 2</code>组数。</p>\n<p>证明见<a href=\"https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements/solution/tan-xin-ji-qi-shu-xue-zheng-ming-by-endl-uumv/\">link</a></p>\n<p>WA 3 + Runtime Error 1 发。</p>\n<p>WA 1: 计算<code>2^p</code>不应加MOD，应直接计算。<br>WA 2: 不加MOD的pow写错了，因为直接复制的加MOD函数，因此调用的是原函数，忘记更新成新函数。<br>Runtime Error: 乘法越界。超过long long, 出现在base过大的情况下。（事实上可以先将base取模克服这种情况，无奈比赛时我心态已崩。直接转了python，没有细追究原因和解决方案。<br>WA 3: 无奈转成Python, 但是因为又是复制原来的代码再改，在整除的地方有个地方忘改了又WA一发。而且python自带 带模的快速幂，其他语言都需要自欺实现。</p>\n<p>教训：比赛时复制粘贴再改代码要小心，可能疏漏一些地方没改。如果方便的话，不如重写一边。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minNonZeroProduct</span>(<span class=\"params\">self, p: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        MOD = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">        x = (<span class=\"number\">2</span>**p)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((x - <span class=\"number\">1</span>) * <span class=\"built_in\">pow</span>(x - <span class=\"number\">2</span>, ((x - <span class=\"number\">2</span>) // <span class=\"number\">2</span>), MOD)) % MOD</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1970-Last-Day-Where-You-Can-Still-Cross\"><a href=\"#1970-Last-Day-Where-You-Can-Still-Cross\" class=\"headerlink\" title=\"1970. Last Day Where You Can Still Cross\"></a>1970. Last Day Where You Can Still Cross</h2><p>并查集。Penetration，Princeton CS226讲Union-Find的练习题。<br>不同的是，如果正向填水的话，unite的操作要向8个方向尝试。<br>当然也可以反向扣水，这时连陆地是4个方向。<br>注意需要采用dummy node连接边缘的层。</p>\n<p>另外一种常见的做法是，BFS + Binary search，有些暴力。虽然也能过，但时间复杂度会差很多。<br>O(log(rows * cols) * rows * cols).</p>\n<p>Runtime Error 1发。</p>\n<p>居然把行列坐标转换成一维坐标写错了，导致数组越界，debug了好久。<br>理应是<code>r*col+c</code>, 写成了<code>r*row+c</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UF</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; fa;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; sz;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> comp_cnt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">UF</span>(<span class=\"keyword\">int</span> _n): <span class=\"built_in\">n</span>(_n), <span class=\"built_in\">comp_cnt</span>(_n), <span class=\"built_in\">fa</span>(_n), <span class=\"built_in\">sz</span>(_n, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">iota</span>(fa.<span class=\"built_in\">begin</span>(), fa.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findset</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fa[x] == x ? x : fa[x] = <span class=\"built_in\">findset</span>(fa[x]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unite</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">            x = <span class=\"built_in\">findset</span>(x);</span><br><span class=\"line\">            y = <span class=\"built_in\">findset</span>(y);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x != y) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sz[x] &lt; sz[y]) &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">swap</span>(x, y);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fa[y] = x;</span><br><span class=\"line\">                sz[x] += sz[y];</span><br><span class=\"line\">                --comp_cnt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">connected</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">            x = <span class=\"built_in\">findset</span>(x);</span><br><span class=\"line\">            y = <span class=\"built_in\">findset</span>(y);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x == y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">latestDayToCross</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> row, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> col, vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; cells)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">nums</span>(row, vector&lt;<span class=\"keyword\">int</span>&gt;(col, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"function\">UF <span class=\"title\">uf</span><span class=\"params\">(row * col + <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; direcionts = &#123;</span><br><span class=\"line\">            &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, </span><br><span class=\"line\">            &#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> L = row * col;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> R = row * col + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cells.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> r = cells[i][<span class=\"number\">0</span>] - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> c = cells[i][<span class=\"number\">1</span>] - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; r &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class=\"line\">            nums[r][c] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; r &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                uf.<span class=\"built_in\">unite</span>(r * col + c, L);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; r &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == col - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                uf.<span class=\"built_in\">unite</span>(r * col + c, R);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; r &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; d : direcionts) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dr = d[<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> dc = d[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> nr = dr + r;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> nc = dc + c;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nr &gt;= <span class=\"number\">0</span> &amp;&amp; nr &lt; row &amp;&amp; nc &gt;= <span class=\"number\">0</span> &amp;&amp; nc &lt; col) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// cout &lt;&lt; &quot;xx: &quot; &lt;&lt; nr &lt;&lt; &quot;, &quot; &lt;&lt; nc &lt;&lt; endl;</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nums[nr][nc] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        uf.<span class=\"built_in\">unite</span>(r * col + c, nr * col + nc);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (uf.<span class=\"built_in\">connected</span>(L, R)) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(rows * cols),<br>空间复杂度: O(rows * cols).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/07/19/LeetCode-weekly-contest-250/",
            "url": "https://youngforest.github.io/2021/07/19/LeetCode-weekly-contest-250/",
            "title": "LeetCode weekly contest 250",
            "date_published": "2021-07-19T01:20:38.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (4)</th>\n<th>Q3 (6)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>192 / 13694</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>1:22:27</td>\n<td>0:03:20</td>\n<td>0:09:15  🐞1</td>\n<td>0:28:08</td>\n<td>1:07:27  🐞2</td>\n</tr>\n</tbody></table>\n<p>连续2周成绩还不错，前200。导致美服小号rating都要上2400了，以后打起来会更加需要小心翼翼。</p>\n<h2 id=\"1935-Maximum-Number-of-Words-You-Can-Type\"><a href=\"#1935-Maximum-Number-of-Words-You-Can-Type\" class=\"headerlink\" title=\"1935. Maximum Number of Words You Can Type\"></a>1935. Maximum Number of Words You Can Type</h2><p>签到题。字符串问题用Python果然没错。光<code>split</code>这一项就值得。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canBeTypedWords</span>(<span class=\"params\">self, text: <span class=\"built_in\">str</span>, brokenLetters: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        broken = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> brokenLetters:</span><br><span class=\"line\">            broken.add(i)</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ok</span>(<span class=\"params\">word</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> word:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> broken:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> text.split(<span class=\"string\">&#x27; &#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ok(word):</span><br><span class=\"line\">                ans += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(text.length),<br>空间复杂度: O(text.length + 26).</p>\n<h2 id=\"1936-Add-Minimum-Number-of-Rungs\"><a href=\"#1936-Add-Minimum-Number-of-Rungs\" class=\"headerlink\" title=\"1936. Add Minimum Number of Rungs\"></a>1936. Add Minimum Number of Rungs</h2><p>贪心，如果够不到下一级，就在最远的距离上加一个。<br>需要注意，不能一级一级加，而是用除法一次加完中间缺少的。否则，会TLE（我也因此罚时5min）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">addRungs</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; rungs, <span class=\"keyword\">int</span> dist)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>; idx &lt; rungs.<span class=\"built_in\">size</span>(); ++idx) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i = rungs[idx];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i - last &lt;= dist) &#123;</span><br><span class=\"line\">                last = i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += (i - last - <span class=\"number\">1</span>) / dist;</span><br><span class=\"line\">                last = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(rungs.length),<br>空间复杂度: O(1).</p>\n<h2 id=\"1937-Maximum-Number-of-Points-with-Cost\"><a href=\"#1937-Maximum-Number-of-Points-with-Cost\" class=\"headerlink\" title=\"1937. Maximum Number of Points with Cost\"></a>1937. Maximum Number of Points with Cost</h2><p>很明显的一道动态规划题目。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[i][j] = points[i][j] + max(dp[i-1][k] - abs(k-j) for k in range(n))</span><br></pre></td></tr></table></figure>\n<p>然而直接莽的话，时间复杂度是 O(m * n ^ 2). 显然会TLE。需要优化。<br>上一行根据 abs的正负，可以分为<br>前面的 dp[i-1] - (j - k) = dp[i-1] + k - j,<br>后面的 dp[i-1] - (k - j) = dp[i-1] - k + j.<br>可以使用2个TreeSet记录前后的 dp + k 和 dp - k，并在j更新的时候，更新这2个TreeSet.<br>这样时间复杂度降为: O(m * n). </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> ll = <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">maxPoints</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m = points.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = points[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;ll&gt;&gt; <span class=\"built_in\">dp</span>(m, vector&lt;ll&gt; (n, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// i == 0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j] = points[<span class=\"number\">0</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            multiset&lt;ll&gt; before, after;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n; ++k) &#123;</span><br><span class=\"line\">                after.<span class=\"built_in\">insert</span>(dp[i<span class=\"number\">-1</span>][k] - k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                ll add = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (before.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                    add = *after.<span class=\"built_in\">rbegin</span>() + j;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (after.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                    add = *before.<span class=\"built_in\">rbegin</span>() - j;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    add = <span class=\"built_in\">max</span>(*before.<span class=\"built_in\">rbegin</span>() - j, *after.<span class=\"built_in\">rbegin</span>() + j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dp[i][j] = <span class=\"built_in\">max</span>(dp[i][j], points[i][j] + add);</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> it = after.<span class=\"built_in\">find</span>(dp[i<span class=\"number\">-1</span>][j] - j);</span><br><span class=\"line\">                after.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">                before.<span class=\"built_in\">insert</span>(dp[i<span class=\"number\">-1</span>][j] + j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"built_in\">max_element</span>(dp.<span class=\"built_in\">back</span>().<span class=\"built_in\">begin</span>(), dp.<span class=\"built_in\">back</span>().<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(m * n)，<br>空间复杂度: O(m * n). 其实也可以降为O(n), 但写起来稍微麻烦些，对AC也没必要.</p>\n<h2 id=\"1938-Maximum-Genetic-Difference-Query\"><a href=\"#1938-Maximum-Genetic-Difference-Query\" class=\"headerlink\" title=\"1938. Maximum Genetic Difference Query\"></a>1938. Maximum Genetic Difference Query</h2><p>Trie + backtracking + 离线计算。<br>Trie用来快速计算最大XOR，backtracking用来维护从根到当前节点的路径和更新Trie，离线计算用以得到query的答案。</p>\n<p>使用cpp需要注意Trie的实现方式。<br>本题用<code>shared_ptr</code>会TLE，raw pointer + delete也会TLE。<br>删了delete才AC，这是逼我内存泄漏呀。<br>不过本题因为可以使用<code>cnt</code>表示节点状态，实际上也并不需要真正删除节点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_BIT = <span class=\"number\">17</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TrieNode</span> &#123;</span></span><br><span class=\"line\">        array&lt;TrieNode*, 2&gt; children;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">buildTrie</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num, TrieNode* root, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> b = (num &gt;&gt; index) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;children[b] == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            root-&gt;children[b] = <span class=\"keyword\">new</span> <span class=\"built_in\">TrieNode</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        root-&gt;children[b]-&gt;cnt++;</span><br><span class=\"line\">        <span class=\"built_in\">buildTrie</span>(num, root-&gt;children[b], index - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">eraseTrie</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> num, TrieNode* root, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> b = (num &gt;&gt; index) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// if (root-&gt;children[b] == nullptr) &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     cout &lt;&lt; num &lt;&lt; &quot;:&quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"comment\">//     root-&gt;children[b] = make_shared&lt;TrieNode&gt;();</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">eraseTrie</span>(num, root-&gt;children[b], index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root-&gt;children[b]-&gt;cnt--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;children[b]-&gt;cnt == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// delete root-&gt;children[b];</span></span><br><span class=\"line\">            root-&gt;children[b] = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">maxGeneticDifference</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; parents, vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = parents.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m = queries.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">children</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rootNode = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parents[i] == <span class=\"number\">-1</span>) rootNode = i;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> children[parents[i]].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(m)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">using</span> pii = pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;;</span><br><span class=\"line\">        vector&lt;vector&lt;pii&gt;&gt; <span class=\"built_in\">offQueies</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; m; ++index) &#123;</span><br><span class=\"line\">            offQueies[queries[index][<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(&#123;queries[index][<span class=\"number\">1</span>], index&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// shared_ptr&lt;TrieNode&gt; root = make_shared&lt;TrieNode&gt;();</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> root = <span class=\"keyword\">new</span> <span class=\"built_in\">TrieNode</span>();</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> maxXOR = [&amp;](<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> val) -&gt; <span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> current = root;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = MAX_BIT; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> b = (val &gt;&gt; i) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (current-&gt;children[<span class=\"number\">1</span> - b]) &#123;</span><br><span class=\"line\">                    ans += (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">                    current = current-&gt;children[<span class=\"number\">1</span> - b];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    current = current-&gt;children[b];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        function&lt;<span class=\"built_in\"><span class=\"keyword\">void</span></span>(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>, vector&lt;<span class=\"keyword\">int</span>&gt;&amp;)&gt; dfs = [&amp;](<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> current, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; path) -&gt; <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> p : offQueies[current]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> val = get&lt;<span class=\"number\">0</span>&gt;(p);</span><br><span class=\"line\">                <span class=\"keyword\">int</span> index = get&lt;<span class=\"number\">1</span>&gt;(p);</span><br><span class=\"line\">                ans[index] = <span class=\"built_in\">maxXOR</span>(val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; current &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> child : children[current]) &#123;</span><br><span class=\"line\">                path.<span class=\"built_in\">push_back</span>(child);</span><br><span class=\"line\">                <span class=\"built_in\">buildTrie</span>(child, root, MAX_BIT);</span><br><span class=\"line\">                <span class=\"built_in\">dfs</span>(child, path);</span><br><span class=\"line\">                <span class=\"built_in\">eraseTrie</span>(path.<span class=\"built_in\">back</span>(), root, MAX_BIT);</span><br><span class=\"line\">                path.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; path;</span><br><span class=\"line\">        path.<span class=\"built_in\">push_back</span>(rootNode);</span><br><span class=\"line\">        <span class=\"built_in\">buildTrie</span>(rootNode, root, MAX_BIT);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(rootNode, path);</span><br><span class=\"line\">        <span class=\"built_in\">eraseTrie</span>(path.<span class=\"built_in\">back</span>(), root, MAX_BIT);</span><br><span class=\"line\">        path.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(log (max(val_i)) * (parents.length + queries.length)),<br>空间复杂度: O(parents.length), Trie的空间消耗其实是个等比数列求和。</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/07/12/LeetCode-biweekly-contest-56/",
            "url": "https://youngforest.github.io/2021/07/12/LeetCode-biweekly-contest-56/",
            "title": "LeetCode biweekly contest 56",
            "date_published": "2021-07-12T10:20:27.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>998 / 10896</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>1:27:14</td>\n<td>0:02:33</td>\n<td>0:13:25</td>\n<td>1:17:14  2</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<p>现在双周赛的参赛人数都快赶上周赛了。</p>\n<h2 id=\"1925-Count-Square-Sum-Triples\"><a href=\"#1925-Count-Square-Sum-Triples\" class=\"headerlink\" title=\"1925. Count Square Sum Triples\"></a>1925. Count Square Sum Triples</h2><p>签到题，暴力枚举所有的组合。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">countTriples</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, c+<span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, b+<span class=\"number\">1</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> a * a + b * b == c * c:</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> a == b: ans += <span class=\"number\">1</span></span><br><span class=\"line\">                        <span class=\"keyword\">else</span>: ans += <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N^3),<br>空间复杂度: O(1).</p>\n<h2 id=\"1926-Nearest-Exit-from-Entrance-in-Maze\"><a href=\"#1926-Nearest-Exit-from-Entrance-in-Maze\" class=\"headerlink\" title=\"1926. Nearest Exit from Entrance in Maze\"></a>1926. Nearest Exit from Entrance in Maze</h2><p>寻找最近的出口。标准的BFS。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">nearestExit</span>(<span class=\"params\">self, maze: <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">str</span>]], entrance: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        visited = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">        q = deque()</span><br><span class=\"line\">        start = (entrance[<span class=\"number\">0</span>], entrance[<span class=\"number\">1</span>])</span><br><span class=\"line\">        visited.add(start)</span><br><span class=\"line\">        q.append(start)</span><br><span class=\"line\">        step = <span class=\"number\">0</span></span><br><span class=\"line\">        directions = [(<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"number\">1</span>), (-<span class=\"number\">1</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, -<span class=\"number\">1</span>)]</span><br><span class=\"line\">        rows = <span class=\"built_in\">len</span>(maze)</span><br><span class=\"line\">        cols = <span class=\"built_in\">len</span>(maze[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exitCell</span>(<span class=\"params\">cell</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (cell[<span class=\"number\">0</span>] == <span class=\"number\">0</span> <span class=\"keyword\">or</span> cell[<span class=\"number\">0</span>] == rows - <span class=\"number\">1</span> <span class=\"keyword\">or</span> cell[<span class=\"number\">1</span>] == <span class=\"number\">0</span> <span class=\"keyword\">or</span> cell[<span class=\"number\">1</span>] == cols - <span class=\"number\">1</span>) <span class=\"keyword\">and</span> maze[cell[<span class=\"number\">0</span>]][cell[<span class=\"number\">1</span>]] == <span class=\"string\">&#x27;.&#x27;</span> <span class=\"keyword\">and</span> cell != start </span><br><span class=\"line\">        <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">            s = <span class=\"built_in\">len</span>(q)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(s):</span><br><span class=\"line\">                current = q.popleft()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> exitCell(current): <span class=\"keyword\">return</span> step</span><br><span class=\"line\">                <span class=\"keyword\">for</span> di, dj <span class=\"keyword\">in</span> directions:</span><br><span class=\"line\">                    ni = di + current[<span class=\"number\">0</span>]</span><br><span class=\"line\">                    nj = dj + current[<span class=\"number\">1</span>]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ni &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> ni &lt; rows <span class=\"keyword\">and</span> nj &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> nj &lt; cols <span class=\"keyword\">and</span> maze[ni][nj] == <span class=\"string\">&#x27;.&#x27;</span> <span class=\"keyword\">and</span> (ni, nj) <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> visited:</span><br><span class=\"line\">                        visited.add((ni, nj))</span><br><span class=\"line\">                        q.append((ni,nj))</span><br><span class=\"line\">            step += <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(m * n),<br>空间复杂度: O(m * n).</p>\n<h2 id=\"1927-Sum-Game\"><a href=\"#1927-Sum-Game\" class=\"headerlink\" title=\"1927. Sum Game\"></a>1927. Sum Game</h2><p>贪心。<br>尽量先取问好少的那边（直到取完），Alice尽量让差变大，Bob尽量让差变小。</p>\n<p>想法是好的，但我最后写的又臭又长，在比赛结束前13分钟才Accept。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumGame</span>(<span class=\"params\">self, num: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(num)</span><br><span class=\"line\">        leftSum = <span class=\"number\">0</span></span><br><span class=\"line\">        rightSum = <span class=\"number\">0</span></span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        right = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> num[i] == <span class=\"string\">&#x27;?&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i &gt;= n // <span class=\"number\">2</span>: right += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>: left += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> i &gt;= n // <span class=\"number\">2</span>: rightSum += <span class=\"built_in\">ord</span>(num[i]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>: leftSum += <span class=\"built_in\">ord</span>(num[i]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">        total = right + left</span><br><span class=\"line\">        <span class=\"comment\"># print (&#x27;total: &#x27;, total)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> total % <span class=\"number\">2</span> == <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        alice = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(total):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> alice:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> left == <span class=\"number\">0</span> <span class=\"keyword\">or</span> (right != <span class=\"number\">0</span> <span class=\"keyword\">and</span> left &gt; right): <span class=\"comment\"># pick right</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> leftSum &lt;= rightSum <span class=\"keyword\">or</span> rightSum + <span class=\"number\">9</span> &gt; leftSum:</span><br><span class=\"line\">                        rightSum += <span class=\"number\">9</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        rightSum += <span class=\"number\">0</span></span><br><span class=\"line\">                    right -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> right == <span class=\"number\">0</span> <span class=\"keyword\">or</span> left &lt; right: <span class=\"comment\"># pick left</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> leftSum &gt;= rightSum <span class=\"keyword\">or</span> leftSum + <span class=\"number\">9</span> &gt; rightSum:</span><br><span class=\"line\">                        leftSum += <span class=\"number\">9</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        leftSum += <span class=\"number\">0</span></span><br><span class=\"line\">                    left -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> leftSum == rightSum:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> leftSum &gt; rightSum:</span><br><span class=\"line\">                        leftSum += <span class=\"number\">9</span></span><br><span class=\"line\">                        left -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        rightSum += <span class=\"number\">9</span></span><br><span class=\"line\">                        right -= <span class=\"number\">1</span></span><br><span class=\"line\">                        </span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> left == <span class=\"number\">0</span> <span class=\"keyword\">or</span> (right != <span class=\"number\">0</span> <span class=\"keyword\">and</span> left &gt; right): <span class=\"comment\"># pick right</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> leftSum &gt; rightSum:</span><br><span class=\"line\">                        rightSum +=  <span class=\"number\">9</span> <span class=\"keyword\">if</span> (leftSum - rightSum &gt; <span class=\"number\">9</span>) <span class=\"keyword\">else</span> leftSum - rightSum</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        rightSum += <span class=\"number\">0</span></span><br><span class=\"line\">                    right -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> right == <span class=\"number\">0</span> <span class=\"keyword\">or</span> left &lt; right: <span class=\"comment\"># pick left</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> leftSum &lt; rightSum:</span><br><span class=\"line\">                        leftSum += <span class=\"number\">9</span> <span class=\"keyword\">if</span> (rightSum - leftSum &gt; <span class=\"number\">9</span>) <span class=\"keyword\">else</span> rightSum - leftSum</span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        leftSum += <span class=\"number\">0</span></span><br><span class=\"line\">                    left -= <span class=\"number\">1</span></span><br><span class=\"line\">                    </span><br><span class=\"line\">            <span class=\"comment\"># print (left, leftSum, rightSum, right)</span></span><br><span class=\"line\">                </span><br><span class=\"line\">            alice = <span class=\"keyword\">not</span> alice</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> leftSum != rightSum</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(num.length),<br>空间复杂度: O(num.length).</p>\n<h2 id=\"1928-Minimum-Cost-to-Reach-Destination-in-Time\"><a href=\"#1928-Minimum-Cost-to-Reach-Destination-in-Time\" class=\"headerlink\" title=\"1928. Minimum Cost to Reach Destination in Time\"></a>1928. Minimum Cost to Reach Destination in Time</h2><p>也是一道经典的题目。在限制时间的情况下，花费最小。</p>\n<p><a href=\"https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time/solution/gui-ding-shi-jian-nei-dao-da-zhong-dian-n3ews/\">国服官方的DP解</a></p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/07/11/LeetCode-weekly-contest-249/",
            "url": "https://youngforest.github.io/2021/07/11/LeetCode-weekly-contest-249/",
            "title": "LeetCode weekly contest 249",
            "date_published": "2021-07-11T09:54:25.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (4)</th>\n<th>Q3 (6)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>74 / 12832</td>\n<td>YoungForest</td>\n<td>19</td>\n<td>1:06:48</td>\n<td>0:02:44</td>\n<td>0:07:11</td>\n<td>0:37:44</td>\n<td>1:01:48 🐞1</td>\n</tr>\n</tbody></table>\n<p>周赛博客更新一不小心就鸽了3周。因为最近毕业+入职，确实比较忙。中间因为毕业旅行，甚至罕见地鸽了一次周赛和双周赛。<br>本周算是入职亚马逊之后的第一周，全球排名也惊喜地达到了74名。仔细算算，自己上次周赛进前100名还是243场，也就是大概一个半月前的时间了。<br>本周后2题都是hard，确实容易拉开距离。</p>\n<p>因为我国服rating达到了2460，我担心掉分，因此最近基本都在美服玩耍。美服是个2330的“小号”，基本很难掉分。</p>\n<h2 id=\"1929-Concatenation-of-Array\"><a href=\"#1929-Concatenation-of-Array\" class=\"headerlink\" title=\"1929. Concatenation of Array\"></a>1929. Concatenation of Array</h2><p>签到题。Straight forward。Python竟然可以一行<code>return nums + nums</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">getConcatenation</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(<span class=\"number\">2</span> * n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            ans[i] = ans[i+n] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n),<br>空间复杂度: O(n).</p>\n<h2 id=\"1930-Unique-Length-3-Palindromic-Subsequences\"><a href=\"#1930-Unique-Length-3-Palindromic-Subsequences\" class=\"headerlink\" title=\"1930. Unique Length-3 Palindromic Subsequences\"></a>1930. Unique Length-3 Palindromic Subsequences</h2><p>因为回文串的长度比较短，只有3. 因此，最多有26*26种回文串。可以用中间和两侧的字符表示这个回文串。<br>因为是subsequence，需要用<code>cntLeft</code>和<code>cntRight</code>维护两侧字符是否满足要求。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countPalindromicSubsequence</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">bool</span>&gt;&gt; <span class=\"built_in\">seen</span>(<span class=\"number\">26</span>, vector&lt;<span class=\"keyword\">bool</span>&gt;(<span class=\"number\">26</span>, <span class=\"literal\">false</span>));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cntRight</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s) &#123;</span><br><span class=\"line\">            ++cntRight[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cntLeft</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s) &#123;</span><br><span class=\"line\">            --cntRight[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> i = <span class=\"string\">&#x27;a&#x27;</span>; i &lt;= <span class=\"string\">&#x27;z&#x27;</span>; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cntRight[i - <span class=\"string\">&#x27;a&#x27;</span>] &gt; <span class=\"number\">0</span> &amp;&amp; cntLeft[i - <span class=\"string\">&#x27;a&#x27;</span>] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!seen[c - <span class=\"string\">&#x27;a&#x27;</span>][i - <span class=\"string\">&#x27;a&#x27;</span>]) &#123;</span><br><span class=\"line\">                        ++ans;</span><br><span class=\"line\">                        seen[c - <span class=\"string\">&#x27;a&#x27;</span>][i - <span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++cntLeft[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(26*s.length),<br>空间复杂度: O(26 * 26).</p>\n<h2 id=\"1931-Painting-a-Grid-With-Three-Different-Colors\"><a href=\"#1931-Painting-a-Grid-With-Three-Different-Colors\" class=\"headerlink\" title=\"1931. Painting a Grid With Three Different Colors\"></a>1931. Painting a Grid With Three Different Colors</h2><p>算是<a href=\"https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/\">1411. Number of Ways to Paint N × 3 Grid</a>的升级版。<br>行数从3变成了1-5，但思想不变，仍然是 3进制的bit_mask + dp。</p>\n<p>用3进制bit_mask表示每一列的颜色状态，从上一列的颜色排列数量得到新的一列的数量。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">colorTheGrid</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pow3m = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; m; ++x) &#123;</span><br><span class=\"line\">            pow3m *= <span class=\"number\">3</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ok = [&amp;](<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j) -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; m; ++x) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((i % <span class=\"number\">3</span>) == (j % <span class=\"number\">3</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                i /= <span class=\"number\">3</span>;</span><br><span class=\"line\">                j /= <span class=\"number\">3</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> isLegal = [&amp;](<span class=\"keyword\">int</span> i) -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> last = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; m; ++x) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i % <span class=\"number\">3</span> == last) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                last = i % <span class=\"number\">3</span>;</span><br><span class=\"line\">                i /= <span class=\"number\">3</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">match</span>(pow3m);</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">legal</span><span class=\"params\">(pow3m)</span></span>;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (pow3m); ++i) &#123;</span><br><span class=\"line\">              legal[i] = <span class=\"built_in\">isLegal</span>(i);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (pow3m); ++i) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// cout &lt;&lt; legal[i] &lt;&lt; &quot; &quot; &lt;&lt; endl;</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!legal[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">              <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; (pow3m); ++j) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;....&quot;;</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (!legal[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                  <span class=\"comment\">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;****&quot;;</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (<span class=\"built_in\">ok</span>(i, j)) &#123;</span><br><span class=\"line\">                      match[i].<span class=\"built_in\">push_back</span>(j);</span><br><span class=\"line\">                      <span class=\"comment\">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;;&quot;;</span></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(pow3m, vector&lt;<span class=\"keyword\">int</span>&gt; (n, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> mask = <span class=\"number\">0</span>; mask &lt; (pow3m); ++mask) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (legal[mask])</span><br><span class=\"line\">                dp[mask][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; dp[mask][0] &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> mask = <span class=\"number\">0</span>; mask &lt; (pow3m); ++mask) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!legal[mask]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> left : match[mask]) &#123;</span><br><span class=\"line\">                    dp[mask][i] = (dp[mask][i] + dp[left][i<span class=\"number\">-1</span>]) % MOD;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// cout &lt;&lt; dp[mask][i] &lt;&lt; &quot; &quot;;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> mask = <span class=\"number\">0</span>; mask &lt; (pow3m); ++mask) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (legal[mask])</span><br><span class=\"line\">                ans = (ans + dp[mask][n<span class=\"number\">-1</span>]) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans % MOD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(3^m^2 + n*3^m),<br>空间复杂度: O(n * 3^m).</p>\n<h2 id=\"1932-Merge-BSTs-to-Create-Single-BST\"><a href=\"#1932-Merge-BSTs-to-Create-Single-BST\" class=\"headerlink\" title=\"1932. Merge BSTs to Create Single BST\"></a>1932. Merge BSTs to Create Single BST</h2><p>算法不难，但是实现起来比较复杂，corner case也容易fail。<br>根据题目描述，找到每个根和叶子的对应，进行合并操作。<br>最后还得检查是否是BST。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode *right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\">tuple&lt;<span class=\"keyword\">bool</span>, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; <span class=\"title\">solve</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// is BST, max value, min value</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> &#123;<span class=\"literal\">true</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        tuple&lt;<span class=\"keyword\">bool</span>, <span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; ret = &#123;<span class=\"literal\">true</span>, root-&gt;val, root-&gt;val&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> l = <span class=\"built_in\">solve</span>(root-&gt;left);</span><br><span class=\"line\">            get&lt;<span class=\"number\">0</span>&gt;(ret) = get&lt;<span class=\"number\">0</span>&gt;(ret) &amp;&amp; get&lt;<span class=\"number\">0</span>&gt;(l) &amp;&amp; root-&gt;val &gt; get&lt;<span class=\"number\">1</span>&gt;(l);</span><br><span class=\"line\">            get&lt;<span class=\"number\">2</span>&gt;(ret) = <span class=\"built_in\">min</span>(get&lt;<span class=\"number\">2</span>&gt;(ret), get&lt;<span class=\"number\">2</span>&gt;(l));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> r = <span class=\"built_in\">solve</span>(root-&gt;right);</span><br><span class=\"line\">            get&lt;<span class=\"number\">0</span>&gt;(ret) = get&lt;<span class=\"number\">0</span>&gt;(ret) &amp;&amp; get&lt;<span class=\"number\">0</span>&gt;(r) &amp;&amp; root-&gt;val &lt; get&lt;<span class=\"number\">2</span>&gt;(r);</span><br><span class=\"line\">            get&lt;<span class=\"number\">1</span>&gt;(ret) = <span class=\"built_in\">max</span>(get&lt;<span class=\"number\">1</span>&gt;(ret), get&lt;<span class=\"number\">1</span>&gt;(r));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get&lt;<span class=\"number\">0</span>&gt;(<span class=\"built_in\">solve</span>(root));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">count</span>(root-&gt;left) + <span class=\"built_in\">count</span>(root-&gt;right) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">canMerge</span><span class=\"params\">(vector&lt;TreeNode*&gt;&amp; trees)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = trees.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        unordered_map&lt;TreeNode*, TreeNode*&gt; leaves;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"keyword\">int</span>, TreeNode*&gt; value2leaf;</span><br><span class=\"line\">        vector&lt;TreeNode*&gt; equalLeaves;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> bad = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        unordered_set&lt;<span class=\"keyword\">int</span>&gt; seen;</span><br><span class=\"line\">        function&lt;<span class=\"built_in\"><span class=\"keyword\">void</span></span>(TreeNode*, TreeNode*)&gt; dfs = [&amp;](TreeNode* root, TreeNode* parent) -&gt; <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">            seen.<span class=\"built_in\">insert</span>(root-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value2leaf.<span class=\"built_in\">find</span>(root-&gt;val) != value2leaf.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    bad = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                leaves[root] = parent;</span><br><span class=\"line\">                value2leaf[root-&gt;val] = root;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">dfs</span>(root-&gt;left, root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;right) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">dfs</span>(root-&gt;right, root);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> root : trees) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(root, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bad) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode* ans = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> root : trees) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> it = value2leaf.<span class=\"built_in\">find</span>(root-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it == value2leaf.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ans != <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">                ans = root;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> leaf = it-&gt;second;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> parent = leaves[leaf];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (parent-&gt;left &amp;&amp; parent-&gt;left-&gt;val == root-&gt;val) &#123;</span><br><span class=\"line\">                    parent-&gt;left = root;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent-&gt;right &amp;&amp; parent-&gt;right-&gt;val == root-&gt;val) &#123;</span><br><span class=\"line\">                    parent-&gt;right = root;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ans) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">isValidBST</span>(ans)) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">count</span>(ans) != seen.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(trees.length),<br>空间复杂度: O(trees.length).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/06/16/LeetCode-biweekly-contest-54/",
            "url": "https://youngforest.github.io/2021/06/16/LeetCode-biweekly-contest-54/",
            "title": "LeetCode biweekly contest 54",
            "date_published": "2021-06-15T17:36:43.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>120 / 12076</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>1:19:33</td>\n<td>0:03:17</td>\n<td>0:09:23 🐞1</td>\n<td>0:26:15</td>\n<td>1:04:33 🐞2</td>\n</tr>\n</tbody></table>\n<p>继续保持好成绩，尤其是最后一题，还是挺难的。刚开始没有思路甚至想放弃，但最后还是靠自己的思考解决了难题。</p>\n<h2 id=\"1893-Check-if-All-the-Integers-in-a-Range-Are-Covered\"><a href=\"#1893-Check-if-All-the-Integers-in-a-Range-Are-Covered\" class=\"headerlink\" title=\"1893. Check if All the Integers in a Range Are Covered\"></a>1893. Check if All the Integers in a Range Are Covered</h2><p>签到题。对于<code>[right, right]</code>中每一个数，判断是否被<code>ranges</code>中的某个区间包含。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isCovered</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; ranges, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> cover = [&amp;](<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i) -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; range : ranges) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> l = range[<span class=\"number\">0</span>], r = range[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (l &lt;= i &amp;&amp; i &lt;= r) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">cover</span>(i)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O((right - left) * ranges.length),<br>空间复杂度: O(1).</p>\n<h2 id=\"1894-Find-the-Student-that-Will-Replace-the-Chalk\"><a href=\"#1894-Find-the-Student-that-Will-Replace-the-Chalk\" class=\"headerlink\" title=\"1894. Find the Student that Will Replace the Chalk\"></a>1894. Find the Student that Will Replace the Chalk</h2><p>先求前缀和，把k和和取余数，可以定位到最后一轮的遍历。然后用二分搜索寻找恰好大于k的位置，即为需要更换粉笔的学生。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> ll = <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">chalkReplacer</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; chalk, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = chalk.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">presum</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        presum[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            presum[i+<span class=\"number\">1</span>] = presum[i] + chalk[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &gt;= presum.<span class=\"built_in\">back</span>()) &#123;</span><br><span class=\"line\">            k = k % presum.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// the first index, presum[i] &gt; k</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> it = <span class=\"built_in\">upper_bound</span>(presum.<span class=\"built_in\">begin</span>(), presum.<span class=\"built_in\">end</span>(), k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">distance</span>(presum.<span class=\"built_in\">begin</span>(), it) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N + log N), N = chalk.length,<br>空间复杂度: O(chalk.length).</p>\n<p>需要注意数据范围，计算前缀和时可能会<code>int</code>溢出。我也因此Runtime Error一次。换成<code>long long</code>就好了。LeetCode最近坑溢出的case越来越多了，以后遇到需要先预估一下最大的值，该用<code>long long</code>用<code>long long</code>.</p>\n<h2 id=\"1895-Largest-Magic-Square\"><a href=\"#1895-Largest-Magic-Square\" class=\"headerlink\" title=\"1895. Largest Magic Square\"></a>1895. Largest Magic Square</h2><p>暴力法：从大到小枚举所有的正方形，计算所有行、列、对角的和，判断是否相等。唯一的优化是采用前缀和，快速计算行列和。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">largestMagicSquare</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m = grid.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">presumLeft</span>(m, vector&lt;<span class=\"keyword\">int</span>&gt;(n + <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            presumLeft[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                presumLeft[i][j+<span class=\"number\">1</span>] = presumLeft[i][j] + grid[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">presumUp</span>(m + <span class=\"number\">1</span>, vector&lt;<span class=\"keyword\">int</span>&gt;(n));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">            presumUp[<span class=\"number\">0</span>][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">                presumUp[i+<span class=\"number\">1</span>][j] = presumUp[i][j] + grid[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;](<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> j, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> k) -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> target = presumLeft[i][j+k] - presumLeft[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> row = <span class=\"number\">1</span>; row &lt; k; ++row) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (target != presumLeft[i+row][j+k] - presumLeft[i+row][j]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> col = <span class=\"number\">0</span>; col &lt; k; ++col) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (target != presumUp[i+k][j+col] - presumUp[i][j+col]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> diagonal = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>; row &lt; k; ++row) &#123;</span><br><span class=\"line\">                    diagonal += grid[i+row][j+row];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (diagonal != target) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> diagonal = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>; row &lt; k; ++row) &#123;</span><br><span class=\"line\">                    diagonal += grid[i+row][j+k<span class=\"number\">-1</span>-row];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (diagonal != target) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"built_in\">min</span>(n, m); k &gt; <span class=\"number\">0</span>; --k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i + k &lt;= m &amp;&amp; j + k &lt;= n &amp;&amp; <span class=\"built_in\">check</span>(i, j, k)) <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N^4),<br>空间复杂度: O(N^2).</p>\n<h2 id=\"1896-Minimum-Cost-to-Change-the-Final-Value-of-Expression\"><a href=\"#1896-Minimum-Cost-to-Change-the-Final-Value-of-Expression\" class=\"headerlink\" title=\"1896. Minimum Cost to Change the Final Value of Expression\"></a>1896. Minimum Cost to Change the Final Value of Expression</h2><p>递归，根据 &amp; | 和 子表达式的值 进行分类，寻找最小cost。<br>括号的处理需要提前用栈，找到所有的配对。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minOperationsToFlip</span>(<span class=\"params\">self, expression: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(expression)</span><br><span class=\"line\">        leftPair = &#123;&#125;</span><br><span class=\"line\">        left = <span class=\"number\">0</span></span><br><span class=\"line\">        leftStack = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> expression[i] == <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">                left -= <span class=\"number\">1</span></span><br><span class=\"line\">                leftPair[i] = leftStack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> expression[i] == <span class=\"string\">&#x27;(&#x27;</span>:</span><br><span class=\"line\">                left += <span class=\"number\">1</span></span><br><span class=\"line\">                leftStack.append(i)</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span>(<span class=\"params\">i, j</span>):</span></span><br><span class=\"line\">            <span class=\"comment\"># [i, j)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i + <span class=\"number\">1</span> == j: <span class=\"comment\"># 0, 1</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> expression[i] == <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> expression[j-<span class=\"number\">1</span>] == <span class=\"string\">&#x27;)&#x27;</span>:</span><br><span class=\"line\">                    leftIndex = leftPair[j-<span class=\"number\">1</span>]</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> leftIndex == i: <span class=\"keyword\">return</span> dp(i+<span class=\"number\">1</span>,j-<span class=\"number\">1</span>)</span><br><span class=\"line\">                    pivot = leftIndex - <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"comment\"># 0, 1</span></span><br><span class=\"line\">                    pivot = j - <span class=\"number\">2</span></span><br><span class=\"line\">                    </span><br><span class=\"line\">                <span class=\"keyword\">if</span> expression[pivot] == <span class=\"string\">&#x27;0&#x27;</span> <span class=\"keyword\">or</span> expression[pivot] == <span class=\"string\">&#x27;1&#x27;</span>: pivot -= <span class=\"number\">1</span></span><br><span class=\"line\">                leftResult, leftCost = dp(i, pivot)</span><br><span class=\"line\">                rightResult, rightCost = dp(pivot+<span class=\"number\">1</span>, j)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> expression[pivot] == <span class=\"string\">&#x27;|&#x27;</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> leftResult == <span class=\"literal\">False</span> <span class=\"keyword\">and</span> rightResult == <span class=\"literal\">False</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">False</span>, <span class=\"built_in\">min</span>(leftCost, rightCost)</span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> leftResult == <span class=\"literal\">True</span> <span class=\"keyword\">and</span> rightResult == <span class=\"literal\">False</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">True</span>, <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> leftResult == <span class=\"literal\">False</span> <span class=\"keyword\">and</span> rightResult == <span class=\"literal\">True</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">True</span>, <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">True</span>, <span class=\"built_in\">min</span>(leftCost + <span class=\"number\">1</span>, rightCost + <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> expression[pivot] == <span class=\"string\">&#x27;&amp;&#x27;</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> leftResult == <span class=\"literal\">False</span> <span class=\"keyword\">and</span> rightResult == <span class=\"literal\">False</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">False</span>, <span class=\"built_in\">min</span>(leftCost + <span class=\"number\">1</span>, rightCost + <span class=\"number\">1</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> leftResult == <span class=\"literal\">True</span> <span class=\"keyword\">and</span> rightResult == <span class=\"literal\">False</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">False</span>, <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">elif</span> leftResult == <span class=\"literal\">False</span> <span class=\"keyword\">and</span> rightResult == <span class=\"literal\">True</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">False</span>, <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">True</span>, <span class=\"built_in\">min</span>(leftCost, rightCost)</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(expression))[<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/06/13/LeetCode-weekly-contest-245/",
            "url": "https://youngforest.github.io/2021/06/13/LeetCode-weekly-contest-245/",
            "title": "LeetCode weekly contest 245",
            "date_published": "2021-06-13T09:28:42.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1904 / 12724</td>\n<td>YoungForest</td>\n<td>12</td>\n<td>1:39:20</td>\n<td>0:02:52</td>\n<td>1:24:20 🐞 3</td>\n<td>0:21:30</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<p>零神大数据：<br>1897,Redistribute Characters to Make All Strings Equal,redistribute-characters-to-make-all-strings-equal,1309.1422268153<br>1898,Maximum Number of Removable Characters,maximum-number-of-removable-characters,1912.8440554296<br>1899,Merge Triplets to Form Target Triplet,merge-triplets-to-form-target-triplet,1635.6879273926<br>1900,The Earliest and Latest Rounds Where Players Compete,the-earliest-and-latest-rounds-where-players-compete,2454.7653333657</p>\n<p>今天的周赛翻车了。第二题一开始算错时间复杂度了，一直妄图找到更优算法。之后看到80人提交才重新审视二分暴力的时间复杂度，竟然是没问题的。实现过程中又遇到1次WA（判断子序列时，相等字符忘记更新<code>s</code>的下标了），2次TLE（标记remove下标不能用<code>unordered_set</code>, 而要用<code>vector</code>。算是被卡常数了)。这周又要残酷打卡了，幸运的是，因为前2周的成绩比较好，本周残酷榜更新后我的排名不降反升。</p>\n<h2 id=\"1897-Redistribute-Characters-to-Make-All-Strings-Equal\"><a href=\"#1897-Redistribute-Characters-to-Make-All-Strings-Equal\" class=\"headerlink\" title=\"1897. Redistribute Characters to Make All Strings Equal\"></a>1897. Redistribute Characters to Make All Strings Equal</h2><p>签到题。本质是判断所有的字符是否可以平均分配到n个单词中。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">makeEqual</span><span class=\"params\">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = words.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cnt</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; word : words) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : word) &#123;</span><br><span class=\"line\">                ++cnt[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : cnt) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % n != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(sum(words[i].length)),<br>空间复杂度: O(1).</p>\n<h2 id=\"1898-Maximum-Number-of-Removable-Characters\"><a href=\"#1898-Maximum-Number-of-Removable-Characters\" class=\"headerlink\" title=\"1898. Maximum Number of Removable Characters\"></a>1898. Maximum Number of Removable Characters</h2><p>最优化问题转判定问题（双指针判断是否是子序列），二分搜索。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> ll = <span class=\"keyword\">int</span>;</span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">bool</span>&gt; mark = vector&lt;<span class=\"keyword\">bool</span>&gt;(<span class=\"number\">1e5</span>);</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximumRemovals</span><span class=\"params\">(string s, string p, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; removable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = removable.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> binary = [&amp;](ll lo, ll hi, function&lt;<span class=\"built_in\"><span class=\"keyword\">bool</span></span>(<span class=\"keyword\">const</span> ll)&gt; predicate) -&gt; <span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">                ll mid = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!<span class=\"built_in\">predicate</span>(mid)) &#123;</span><br><span class=\"line\">                    hi = mid;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lo;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; s.size() &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">binary</span>(<span class=\"number\">0</span>, n + <span class=\"number\">1</span>, [&amp;](<span class=\"keyword\">const</span> ll x) -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">                mark[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; x; ++i) &#123;</span><br><span class=\"line\">                mark[removable[i]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> pi = <span class=\"number\">0</span>, si = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (pi &lt; p.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (si &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; (mark[si] || s[si] != p[pi])) ++si;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (si == s.<span class=\"built_in\">size</span>()) </span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// cout &lt;&lt; x &lt;&lt; &quot;:false&quot;  &lt;&lt; endl;</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// if (s[si] != p[pi]) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span></span><br><span class=\"line\">                ++si;</span><br><span class=\"line\">                ++pi;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; x &lt;&lt; &quot;:true &quot;&lt;&lt; si   &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(log removable.length * (s.length + p.length)),<br>空间复杂度: O(s.length).</p>\n<p>本题有个坑是说，标记<code>s</code>中哪些位置被标记时，不能用<code>unordered_set</code>（即使加<code>reserve</code>)，会超时。可以用<code>vector&lt;bool&gt;</code>。算是被卡常数了。</p>\n<h2 id=\"1899-Merge-Triplets-to-Form-Target-Triplet\"><a href=\"#1899-Merge-Triplets-to-Form-Target-Triplet\" class=\"headerlink\" title=\"1899. Merge Triplets to Form Target Triplet\"></a>1899. Merge Triplets to Form Target Triplet</h2><p>因为每次合并操作是去最大值，因此，只要有一个数大于<code>target</code>的<code>triplet</code>不能用。<br>所以把剩下可以用的都合并了，看能不能达到<code>target</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">mergeTriplets</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; triplets, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cnt</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; v : triplets) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v[i] == target[i] &amp;&amp; v[(i + <span class=\"number\">1</span>) % <span class=\"number\">3</span>] &lt;= target[(i + <span class=\"number\">1</span>) % <span class=\"number\">3</span>] &amp;&amp; v[(i + <span class=\"number\">2</span>) % <span class=\"number\">3</span>] &lt;= target[(i + <span class=\"number\">2</span>) % <span class=\"number\">3</span>]) &#123;</span><br><span class=\"line\">                    ++cnt[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt[i] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(triplets.length),<br>空间复杂度: O(1).</p>\n<h2 id=\"1900-The-Earliest-and-Latest-Rounds-Where-Players-Compete\"><a href=\"#1900-The-Earliest-and-Latest-Rounds-Where-Players-Compete\" class=\"headerlink\" title=\"1900. The Earliest and Latest Rounds Where Players Compete\"></a>1900. The Earliest and Latest Rounds Where Players Compete</h2><p>TNL~</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/06/06/LeetCode-weekly-contest-244/",
            "url": "https://youngforest.github.io/2021/06/06/LeetCode-weekly-contest-244/",
            "title": "LeetCode weekly contest 244",
            "date_published": "2021-06-06T07:37:26.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>142 / 14467</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>0:51:13</td>\n<td>0:05:21</td>\n<td>0:09:54</td>\n<td>0:30:19</td>\n<td>0:46:13 🐞1</td>\n</tr>\n</tbody></table>\n<p>下午约了 <a href=\"http://leetcode.com/ddoudle\">残酷东神</a> 吃饭，一个rating 2700+的大佬。他本科浙大，在加拿大读研。这个暑假来北京旷视实习。因此我们有机会线下面基。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1886-Determine-Whether-Matrix-Can-Be-Obtained-By-Rotation\"><a href=\"#1886-Determine-Whether-Matrix-Can-Be-Obtained-By-Rotation\" class=\"headerlink\" title=\"1886. Determine Whether Matrix Can Be Obtained By Rotation\"></a>1886. Determine Whether Matrix Can Be Obtained By Rotation</h2><p>签到题。旋转3次 加上 原始 共4种状态，分别比较。旋转的话就是另外的一个LeetCode经典题目了，in-place还是实现起来比较复杂的。但因为n比较小，而且是签到题，我直接用了辅助数组。虽然时间复杂度上去了，但实现起来简单多了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; cp = mat;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = mat.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                cp[j][n<span class=\"number\">-1</span>-i] = mat[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mat = <span class=\"built_in\">move</span>(cp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">findRotation</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; mat, vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mat == target) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">rotate</span>(mat);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mat == target) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(4 * n * n),<br>空间复杂度: O(n * n).</p>\n<h2 id=\"1887-Reduction-Operations-to-Make-the-Array-Elements-Equal\"><a href=\"#1887-Reduction-Operations-to-Make-the-Array-Elements-Equal\" class=\"headerlink\" title=\"1887. Reduction Operations to Make the Array Elements Equal\"></a>1887. Reduction Operations to Make the Array Elements Equal</h2><p>理解整个减小的过程可以发现，每个数减到最小的操作数目其实等于小于他的元素（去除重复元素）的数目。<br>因此，先排序，再One pass 统计“小于他的元素”数目之和。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reductionOperations</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> add = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt; nums[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                ++add;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += add;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1888-Minimum-Number-of-Flips-to-Make-the-Binary-String-Alternating\"><a href=\"#1888-Minimum-Number-of-Flips-to-Make-the-Binary-String-Alternating\" class=\"headerlink\" title=\"1888. Minimum Number of Flips to Make the Binary String Alternating\"></a>1888. Minimum Number of Flips to Make the Binary String Alternating</h2><p>观察有：<br>操作1的数目不限。也就是说 我们可以遍历所有位置，假设它是开头，枚举开头分别是0/1的2种情况，然后统计之后和之前的不符合预期的数量。<br>统计“之前和之后不符合预期的数量” 这个操作可以通过维护之前/之后 奇偶位置 0/1 的数量 O(1)实现。</p>\n<p>因为奇偶问题，“之前不符合预期的数量”需要分开讨论。<br>发现在偶数长度下，开头位置其实是无所谓的。这时可以进一步简化问题。<br>奇数长度下，还是需要枚举每个开头位置才行。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minFlips</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cnt</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">                cnt[i % <span class=\"number\">2</span>] += (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> half = n / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">min</span>(half - cnt[<span class=\"number\">0</span>] + cnt[<span class=\"number\">1</span>], cnt[<span class=\"number\">0</span>] + half - cnt[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"built_in\">after</span>(<span class=\"number\">2</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">                after[i % <span class=\"number\">2</span>] += (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">before</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ans = numeric_limits&lt;<span class=\"keyword\">int</span>&gt;::<span class=\"built_in\">max</span>();</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> half = n / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> now = i % <span class=\"number\">2</span>;</span><br><span class=\"line\">                ans = <span class=\"built_in\">min</span>(ans, half + <span class=\"number\">1</span> - after[now] - before[<span class=\"number\">1</span>-now] + after[<span class=\"number\">1</span>-now] + before[now]); <span class=\"comment\">// 1 begin</span></span><br><span class=\"line\">                ans = <span class=\"built_in\">min</span>(ans, after[now] + before[<span class=\"number\">1</span>-now] + half - after[<span class=\"number\">1</span>-now] - before[now]); <span class=\"comment\">// 0 begin</span></span><br><span class=\"line\">                after[i % <span class=\"number\">2</span>] -= (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">                before[i % <span class=\"number\">2</span>] += (s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1889-Minimum-Space-Wasted-From-Packaging\"><a href=\"#1889-Minimum-Space-Wasted-From-Packaging\" class=\"headerlink\" title=\"1889. Minimum Space Wasted From Packaging\"></a>1889. Minimum Space Wasted From Packaging</h2><p>本题的暴力解法很容易想：<br>遍历所有的<code>boxes</code>； 对于每一个供应商，再遍历所有的包裹；对于每一个包裹，找到仅大于它的盒子做包装。时间复杂度为：O(m * n * log m). 显然会TLE。</p>\n<p>题目中给了数据范围，其中一个值得我们特别关注: <code>sum(boxes[j].length) &lt;= 10^5</code>。<br>也就是说，我们完全可以枚举每一个盒子，找到用它的包裹（可以通过二分搜索，找到它能装的最大包裹的位置。除了比它小的盒子装的，剩下就是它装的。）。然后通过前缀和快速计算空余空间。<br>时间复杂度为：`O(sum(boxes[j].length) * log n + n log n)，恰好符合要求。</p>\n<p>因为最大空余空间是<code>max(boxes[i][j]) * packges.length = 10 ^ 10</code>, 因此<code>int</code>会溢出，需要使用<code>long long</code>.</p>\n<p>最后，千万不要忘记MOD。我因此WA一次。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> ll = <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ll MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minWastedSpace</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; packages, vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; boxes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(packages.<span class=\"built_in\">begin</span>(), packages.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = packages.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">presum</span><span class=\"params\">(n+<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        presum[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            presum[i+<span class=\"number\">1</span>] = presum[i] + packages[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll ans = numeric_limits&lt;ll&gt;::<span class=\"built_in\">max</span>();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m = boxes.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; b : boxes) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">sort</span>(b.<span class=\"built_in\">begin</span>(), b.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            <span class=\"keyword\">int</span> lastIdx = <span class=\"number\">0</span>;</span><br><span class=\"line\">            ll current = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j : b) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> it = <span class=\"built_in\">upper_bound</span>(packages.<span class=\"built_in\">begin</span>(), packages.<span class=\"built_in\">end</span>(), j);</span><br><span class=\"line\">                <span class=\"keyword\">const</span> ll d = <span class=\"built_in\">distance</span>(packages.<span class=\"built_in\">begin</span>(), it);</span><br><span class=\"line\">                <span class=\"keyword\">const</span> ll width = d - lastIdx;</span><br><span class=\"line\">                current += width * j - (presum[d] - presum[lastIdx]);</span><br><span class=\"line\">                lastIdx = d;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b.<span class=\"built_in\">back</span>() &lt; packages.<span class=\"built_in\">back</span>()) &#123; <span class=\"comment\">// can not fit</span></span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans = <span class=\"built_in\">min</span>(ans, current);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ans == numeric_limits&lt;ll&gt;::<span class=\"built_in\">max</span>()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> ans % MOD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(sum(boxes[j].length) * log n + n log n),<br>空间复杂度: O(n).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/05/30/LeetCode-weekly-contest-243/",
            "url": "https://youngforest.github.io/2021/05/30/LeetCode-weekly-contest-243/",
            "title": "LeetCode weekly contest 243",
            "date_published": "2021-05-30T09:22:10.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>95 / 12835</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>1:19:18</td>\n<td>0:02:50</td>\n<td>0:11:21</td>\n<td>0:36:27  🐞1</td>\n<td>1:04:18 🐞2</td>\n</tr>\n</tbody></table>\n<p>零神大数据：<br>1880,Check if Word Equals Summation of Two Words,check-if-word-equals-summation-of-two-words,1187.1641565458<br>1881,Maximum Value after Insertion,maximum-value-after-insertion,1381.2168789318<br>1882,Process Tasks Using Servers,process-tasks-using-servers,1979.1112273597<br>1883,Minimum Skips to Arrive at Meeting On Time,minimum-skips-to-arrive-at-meeting-on-time,2587.8725248485</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1880-Check-if-Word-Equals-Summation-of-Two-Words\"><a href=\"#1880-Check-if-Word-Equals-Summation-of-Two-Words\" class=\"headerlink\" title=\"1880. Check if Word Equals Summation of Two Words\"></a>1880. Check if Word Equals Summation of Two Words</h2><p>签到题。按题目要求转换字符串到数字，再进行判断。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isSumEqual</span>(<span class=\"params\">self, firstWord: <span class=\"built_in\">str</span>, secondWord: <span class=\"built_in\">str</span>, targetWord: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">toDigit</span>(<span class=\"params\">w</span>):</span></span><br><span class=\"line\">            ans = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> w:</span><br><span class=\"line\">                ans = ans * <span class=\"number\">10</span> + <span class=\"built_in\">ord</span>(i) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> toDigit(firstWord) + toDigit(secondWord) == toDigit(targetWord)</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>\n<h2 id=\"1881-Maximum-Value-after-Insertion\"><a href=\"#1881-Maximum-Value-after-Insertion\" class=\"headerlink\" title=\"1881. Maximum Value after Insertion\"></a>1881. Maximum Value after Insertion</h2><p>贪心。正数时插入到第一个比x小的数，负数时插入到第一个比x大的数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxValue</span>(<span class=\"params\">self, n: <span class=\"built_in\">str</span>, x: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">str</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># insert into the position where the first digit &lt; x</span></span><br><span class=\"line\">        <span class=\"comment\"># negative first &gt; x</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, <span class=\"built_in\">len</span>(n)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">ord</span>(n[i]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;0&#x27;</span>) &gt; x:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> n[:i] + <span class=\"built_in\">str</span>(x) + n[i:]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n + <span class=\"built_in\">str</span>(x)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(n)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"built_in\">ord</span>(n[i]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;0&#x27;</span>) &lt; x:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> n[:i] + <span class=\"built_in\">str</span>(x) + n[i:]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n + <span class=\"built_in\">str</span>(x)</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>\n<h2 id=\"1882-Process-Tasks-Using-Servers\"><a href=\"#1882-Process-Tasks-Using-Servers\" class=\"headerlink\" title=\"1882. Process Tasks Using Servers\"></a>1882. Process Tasks Using Servers</h2><p>直接暴力模拟即可。使用优先队列维护空闲服务器，等待任务和释放时间。<br>模拟时需要注意时间不能1单位1单位地进行，而是只进行那些有事件发生的时刻。<br>即任务开始等待，服务器释放。<br>需要注意时间的大小可能会超过<code>int</code>, 用<code>long long</code>更保险些。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> ll = <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> pii = pair&lt;ll, ll&gt;;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">assignTasks</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; servers, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; tasks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// brute-force: (m + n) * log n</span></span><br><span class=\"line\">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; freeServers, releaseTime;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; servers.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            freeServers.<span class=\"built_in\">emplace</span>(servers[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        priority_queue&lt;<span class=\"keyword\">int</span>, vector&lt;<span class=\"keyword\">int</span>&gt;, greater&lt;&gt;&gt; waitTasks;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m = tasks.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(m)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            waitTasks.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!releaseTime.<span class=\"built_in\">empty</span>() &amp;&amp; releaseTime.<span class=\"built_in\">top</span>().first &lt;= i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> idx = releaseTime.<span class=\"built_in\">top</span>().second;</span><br><span class=\"line\">                freeServers.<span class=\"built_in\">emplace</span>(servers[idx], idx);</span><br><span class=\"line\">                releaseTime.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!freeServers.<span class=\"built_in\">empty</span>() &amp;&amp; !waitTasks.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> idx = waitTasks.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                waitTasks.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> [weight, serverIdx] = freeServers.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                freeServers.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                ans[idx] = serverIdx;</span><br><span class=\"line\">                releaseTime.<span class=\"built_in\">emplace</span>(i + tasks[idx], serverIdx);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll current = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!releaseTime.<span class=\"built_in\">empty</span>() &amp;&amp; !waitTasks.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> idx = releaseTime.<span class=\"built_in\">top</span>().second;</span><br><span class=\"line\">            current = releaseTime.<span class=\"built_in\">top</span>().first;</span><br><span class=\"line\">            freeServers.<span class=\"built_in\">emplace</span>(servers[idx], idx);</span><br><span class=\"line\">            releaseTime.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!releaseTime.<span class=\"built_in\">empty</span>() &amp;&amp; releaseTime.<span class=\"built_in\">top</span>().first &lt;= current) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> idx = releaseTime.<span class=\"built_in\">top</span>().second;</span><br><span class=\"line\">                current = releaseTime.<span class=\"built_in\">top</span>().first;</span><br><span class=\"line\">                freeServers.<span class=\"built_in\">emplace</span>(servers[idx], idx);</span><br><span class=\"line\">                releaseTime.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!freeServers.<span class=\"built_in\">empty</span>() &amp;&amp; !waitTasks.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> idx = waitTasks.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                waitTasks.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> [weight, serverIdx] = freeServers.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                freeServers.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                ans[idx] = serverIdx;</span><br><span class=\"line\">                releaseTime.<span class=\"built_in\">emplace</span>(current + tasks[idx], serverIdx);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O((m + n) * log n),<br>空间复杂度: O(m + n).</p>\n<h2 id=\"1883-Minimum-Skips-to-Arrive-at-Meeting-On-Time\"><a href=\"#1883-Minimum-Skips-to-Arrive-at-Meeting-On-Time\" class=\"headerlink\" title=\"1883. Minimum Skips to Arrive at Meeting On Time\"></a>1883. Minimum Skips to Arrive at Meeting On Time</h2><p>动态规划。<br>dp(i, k)表示，从dist0到i（inclusive），k次休息，结束的最早时间。<br>状态转移方程为<br>dp(i, k) = min(<br>    dp(i-1, k) + .. 最后一站不休息<br>    dp(i-1, k-1) + .. 最后一站休息<br>)，<br>然后使用二分搜索找到最小的k使得 dp(n-1, k) &lt;= hoursBefore.<br>（其实不用二分也行，从小到大遍历寻找也行。因为时间复杂度瓶颈不在这里，而在计算dp那里）。</p>\n<p>最近经常遇到动态规划的题目，之前在找状态转移方程时，时间复杂度总是超。试图利用枚举最后一个休息位置发生在何处。正确的做法应该是，只枚举最后一站是否休息。可以将时间复杂度降一个n.</p>\n<p>本题有个坑是浮点数精度，我因此WA了2次。<br>解决方法有二:</p>\n<ol>\n<li>增加err, 我这里用了10^-9, 在大多数情况下都是够了。</li>\n<li>转换成整型。可能需要用<code>long long</code>。在本题中就是把所有的 时间 * speed 用来表示距离，这种解决方案不存在精度丢失。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSkips</span>(<span class=\"params\">self, dist: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], speed: <span class=\"built_in\">int</span>, hoursBefore: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(dist)</span><br><span class=\"line\">        err = <span class=\"number\">10</span>**-<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"meta\">        @cache</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span>(<span class=\"params\">i, k</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dist[<span class=\"number\">0</span>] / speed</span><br><span class=\"line\">            <span class=\"keyword\">if</span> k == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"comment\"># no relax</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ceil(dp(i-<span class=\"number\">1</span>, <span class=\"number\">0</span>) - err) + dist[i] / speed</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == k:</span><br><span class=\"line\">                <span class=\"comment\"># relax all</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> dp(i-<span class=\"number\">1</span>, k-<span class=\"number\">1</span>) + dist[i] / speed</span><br><span class=\"line\">            <span class=\"comment\"># not relax + relax</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">min</span>(ceil(dp(i-<span class=\"number\">1</span>, k) - err) + dist[i] / speed, dp(i-<span class=\"number\">1</span>, k-<span class=\"number\">1</span>) + dist[i] / speed)</span><br><span class=\"line\">                       </span><br><span class=\"line\">        lo = <span class=\"number\">0</span></span><br><span class=\"line\">        hi = n</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> dp(n-<span class=\"number\">1</span>, n-<span class=\"number\">1</span>) &gt; hoursBefore + err: <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> lo &lt; hi:</span><br><span class=\"line\">            mid = lo + (hi - lo) // <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> dp(n-<span class=\"number\">1</span>, mid) &lt;= hoursBefore + err: <span class=\"comment\"># -err?</span></span><br><span class=\"line\">                hi = mid</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> lo == n: <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>: <span class=\"keyword\">return</span> lo</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n ^ 2),<br>空间复杂度: O(m ^ 2).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/05/30/LeetCode-biweekly-contest-53/",
            "url": "https://youngforest.github.io/2021/05/30/LeetCode-biweekly-contest-53/",
            "title": "LeetCode biweekly contest 53",
            "date_published": "2021-05-30T03:44:44.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>219 / 12291</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>0:57:45</td>\n<td>0:19:12</td>\n<td>0:22:21</td>\n<td>0:46:08</td>\n<td>0:57:45</td>\n</tr>\n</tbody></table>\n<p>因为今天陪npy去参加斯巴达比赛，早上不到6点就起了，在外奔波了一天。<br>比赛前想着休息一下子，就打算睡20min。没想到太累了，闹铃响了自己给关了。因此迟到了10+min，否则我排名还可以更高些。题目不难，也不简单，属于出的比较好的。</p>\n<p>零神大数据<br>1876,Substrings of Size Three with Distinct Characters,substrings-of-size-three-with-distinct-characters,1248.7224675206<br>1877,Minimize Maximum Pair Sum in Array,minimize-maximum-pair-sum-in-array,1301.3817574010<br>1878,Get Biggest Three Rhombus Sums in a Grid,get-biggest-three-rhombus-sums-in-a-grid,1897.5516652727<br>1879,Minimum XOR Sum of Two Arrays,minimum-xor-sum-of-two-arrays,2145.1839952670</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1876-Substrings-of-Size-Three-with-Distinct-Characters\"><a href=\"#1876-Substrings-of-Size-Three-with-Distinct-Characters\" class=\"headerlink\" title=\"1876. Substrings of Size Three with Distinct Characters\"></a>1876. Substrings of Size Three with Distinct Characters</h2><p>签到题。因为子字符串长度是确定长度（3）。因此可以用一个滑动窗口枚举所有的长度为3的子串，判断是否每个字符都只出现一次。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">countGoodSubstrings</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cnt</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> ok = [&amp;]() -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : cnt) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">3</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ++cnt[s[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        ++cnt[s[<span class=\"number\">1</span>] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        ++cnt[s[<span class=\"number\">2</span>] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">ok</span>()) ++ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            ++cnt[s[i] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">            --cnt[s[i - <span class=\"number\">3</span>] - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">ok</span>()) ++ans;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n),<br>空间复杂度: O(1).</p>\n<h2 id=\"1877-Minimize-Maximum-Pair-Sum-in-Array\"><a href=\"#1877-Minimize-Maximum-Pair-Sum-in-Array\" class=\"headerlink\" title=\"1877. Minimize Maximum Pair Sum in Array\"></a>1877. Minimize Maximum Pair Sum in Array</h2><p>贪心，让大的和小的组合。<br>可以让最大和最小，同时让最小和最大。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minPairSum</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// greedy: match largest and smallest</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, nums[l++] + nums[r--]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N log N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1878-Get-Biggest-Three-Rhombus-Sums-in-a-Grid\"><a href=\"#1878-Get-Biggest-Three-Rhombus-Sums-in-a-Grid\" class=\"headerlink\" title=\"1878. Get Biggest Three Rhombus Sums in a Grid\"></a>1878. Get Biggest Three Rhombus Sums in a Grid</h2><p>枚举所有的菱形，然后维护最大的3个菱形和即可。<br>我的枚举方式是，枚举菱形的中心和4个顶点到中心的距离。<br>计算菱形和可以通过前缀和presum O(1)计算。因此总的时间复杂度是 O(N^3). N最大值是100，恰好满足条件。</p>\n<p>后来发现LeetCode把题目的数据范围从100改到了50.之前听说比赛时有人用N^4的暴力方法过了，我以为会赛后rejudge 的，没想到人家直接改体面。让所有人都过了。可能是懒得rejudge了，还得加数据量大的case。改数据范围多省事儿。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">getBiggestThree</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// x := Rhombus number: m * n * m</span></span><br><span class=\"line\">        <span class=\"comment\">// time: x log x</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> m = grid.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">presum</span>(m + <span class=\"number\">1</span>, vector&lt;<span class=\"keyword\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt; <span class=\"built_in\">presum2</span>(m + <span class=\"number\">1</span>, vector&lt;<span class=\"keyword\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                presum[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = presum[i][j] + grid[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                presum2[i+<span class=\"number\">1</span>][j] = presum2[i][j+<span class=\"number\">1</span>] + grid[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        set&lt;<span class=\"keyword\">int</span>&gt; s;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                s.<span class=\"built_in\">insert</span>(grid[i][j]);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> len = <span class=\"number\">1</span>; i - len &gt;= <span class=\"number\">0</span> &amp;&amp; j - len &gt;= <span class=\"number\">0</span> &amp;&amp; i + len &lt; m &amp;&amp; j + len &lt; n; ++len) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> rhombus = presum[i+<span class=\"number\">1</span>][j+len+<span class=\"number\">1</span>] - presum[i-len][j]</span><br><span class=\"line\">                        + presum[i+len+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] - presum[i][j-len]</span><br><span class=\"line\">                        + presum2[i+len+<span class=\"number\">1</span>][j] - presum2[i][j+len+<span class=\"number\">1</span>]</span><br><span class=\"line\">                        + presum2[i+<span class=\"number\">1</span>][j-len] - presum2[i-len][j+<span class=\"number\">1</span>]</span><br><span class=\"line\">                        - grid[i-len][j] - grid[i][j+len] - grid[i][j-len] - grid[i+len][j];</span><br><span class=\"line\">                    s.<span class=\"built_in\">insert</span>(rhombus);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = s.<span class=\"built_in\">rbegin</span>(); it != s.<span class=\"built_in\">rend</span>() &amp;&amp; i &lt; <span class=\"number\">3</span>; ++it, ++i) &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(*it);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>菱形数目<code>x = m * n * min(m,n)</code>,<br>时间复杂度: O(x log x),<br>空间复杂度: O(x + m * n)。因为只需要维护最大的3个菱形和，可优化到 -&gt; O(m*n).</p>\n<h2 id=\"1879-Minimum-XOR-Sum-of-Two-Arrays\"><a href=\"#1879-Minimum-XOR-Sum-of-Two-Arrays\" class=\"headerlink\" title=\"1879. Minimum XOR Sum of Two Arrays\"></a>1879. Minimum XOR Sum of Two Arrays</h2><p>经典 DP + Bitmask.</p>\n<p>一开始想到暴力的枚举所有排列，时间复杂度是 排列数 n! = 14!。一定会超时。<br>根据数据规模<code>n = 14</code>可以推测 需要使用bitmask.</p>\n<p>定义dp(i, mask) 表示 nums1[i:] 和 nums2 中的子集mask 的最小异或和。<br>状态转移方程为：暴力尝试 nums[i]与mask中每一个可以的取值进行组合，取最小的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minimumXORSum</span>(<span class=\"params\">self, nums1: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], nums2: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># time: n * n * 2 ^ n</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(nums2)</span><br><span class=\"line\"><span class=\"meta\">        @cache</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span>(<span class=\"params\">i, mask</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt;= <span class=\"built_in\">len</span>(nums1): <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            ans = <span class=\"built_in\">float</span>(<span class=\"string\">&#x27;inf&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((<span class=\"number\">1</span> &lt;&lt; j) &amp; mask) == <span class=\"number\">0</span>: <span class=\"keyword\">continue</span></span><br><span class=\"line\">                ans = <span class=\"built_in\">min</span>(ans, (nums1[i] ^ nums2[j]) + dp(i+<span class=\"number\">1</span>, mask ^ (<span class=\"number\">1</span> &lt;&lt; j)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(<span class=\"number\">0</span>, (<span class=\"number\">1</span> &lt;&lt; n) - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n * n * 2 ^ n)  = 14 * 14 * 2^14 = 3211264,<br>空间复杂度: O(n * 2^ n).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/05/23/LeetCode-weekly-contest-242/",
            "url": "https://youngforest.github.io/2021/05/23/LeetCode-weekly-contest-242/",
            "title": "LeetCode weekly contest 242",
            "date_published": "2021-05-23T02:30:24.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>165 / 12400</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>1:07:14</td>\n<td>0:03:22 🐞1</td>\n<td>0:16:01 🐞1</td>\n<td>0:27:41  🐞1</td>\n<td>0:52:14</td>\n</tr>\n</tbody></table>\n<p>提前40min AK。虽然因为粗心大意，前三题每题WA一次，导致15min罚时，但好的一点是这周应该不用每天残酷打卡了。正好全力以赴，准备周三的硕士论文答辩。<br>三年的硕士生涯全靠周三一天了，毕其功于一役，加油，Forest！</p>\n<h2 id=\"1869-Longer-Contiguous-Segments-of-Ones-than-Zeros\"><a href=\"#1869-Longer-Contiguous-Segments-of-Ones-than-Zeros\" class=\"headerlink\" title=\"1869. Longer Contiguous Segments of Ones than Zeros\"></a>1869. Longer Contiguous Segments of Ones than Zeros</h2><p>签到题。统计连续字串的长度，更新最长长度即可。</p>\n<p>因为更新最长长度的代码写错位置，写到了if的分支里，WA了一次。应该无论如何都要更新，所以要写在外面。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkZeroOnes</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">longest</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> last = <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != last) &#123;</span><br><span class=\"line\">                last = c;</span><br><span class=\"line\">                length = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ++length;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            longest[c - <span class=\"string\">&#x27;0&#x27;</span>] = <span class=\"built_in\">max</span>(longest[c - <span class=\"string\">&#x27;0&#x27;</span>], length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> longest[<span class=\"number\">1</span>] &gt; longest[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1870-Minimum-Speed-to-Arrive-on-Time\"><a href=\"#1870-Minimum-Speed-to-Arrive-on-Time\" class=\"headerlink\" title=\"1870. Minimum Speed to Arrive on Time\"></a>1870. Minimum Speed to Arrive on Time</h2><p>直接暴力二分怼。之前总结的binary search模版很好用。基本只需要改几行代码就行了。</p>\n<p>因为浮点数精度WA了一次。<code>10^-5</code> 不够小，建议以后都用<code>10^-9</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> ll = <span class=\"keyword\">int</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minSpeedOnTime</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; dist, <span class=\"keyword\">double</span> hour)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hi = <span class=\"number\">1e7</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// f f f t t t</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> binary = [&amp;](ll lo, ll hi, function&lt;<span class=\"built_in\"><span class=\"keyword\">bool</span></span>(<span class=\"keyword\">const</span> ll)&gt; predicate) -&gt; <span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// return first true</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">                ll mid = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">predicate</span>(mid)) &#123;</span><br><span class=\"line\">                    hi = mid;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lo;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> pred = [&amp;](<span class=\"keyword\">const</span> ll x) -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">double</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i + <span class=\"number\">1</span> &lt; dist.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">                ans += (dist[i] + x - <span class=\"number\">1</span>) / x;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += dist[i] / <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">double</span>&gt;(x);</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans &lt;= hour + <span class=\"number\">1e-9</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ll ans = <span class=\"built_in\">binary</span>(lo, hi, pred);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ans &gt;= hi) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(log dist[i] * dist.length) = log 10^5 * 10^5,<br>空间复杂度: O(1).</p>\n<h2 id=\"1871-Jump-Game-VII\"><a href=\"#1871-Jump-Game-VII\" class=\"headerlink\" title=\"1871. Jump Game VII\"></a>1871. Jump Game VII</h2><p>很容易想到暴力的N^2解法。<br>从头开始遍历，如果是0的话，更新之后所有可以到达的位置。<br>时间复杂度为: s.length * (maxJump - minJump) = 10% * 10^5.</p>\n<p>优化的方向是“更新之后所有可以到达的位置”。显然，这步更新因为有很多重复的更新，因此花费很多。但是，我们考虑每次其实是更新一个区间（range），而且区间的大小相等，而且区间总是向右移动的。因此，我们发现，更新区间并不需要遍历minJump…maxJump，只需要从maxJump向前开始遍历，如果和之前已经更新过的区间重合了，就直接break结束更新就好了。因为每个位置最多被更新一次，因此时间复杂度是 s.length.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canReach</span><span class=\"params\">(string s, <span class=\"keyword\">int</span> minJump, <span class=\"keyword\">int</span> maxJump)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// brute-force: s.length * (maxJump - minJump) = 10^5 * 10^5</span></span><br><span class=\"line\">        <span class=\"comment\">// better: s.length * 1</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">bool</span>&gt; <span class=\"title\">reachable</span><span class=\"params\">(n, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        reachable[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// &lt;= reach</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (reachable[i]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"built_in\">min</span>(maxJump, n - <span class=\"number\">1</span> - i); j &gt;= minJump; --j) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (reachable[i + j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        reachable[i + j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s[n<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; reachable[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(s.length),<br>空间复杂度: O(s.length).</p>\n<h2 id=\"1872-Stone-Game-VIII\"><a href=\"#1872-Stone-Game-VIII\" class=\"headerlink\" title=\"1872. Stone Game VIII\"></a>1872. Stone Game VIII</h2><p>类似之前的Stone Game，这种最优玩法的题目大多数属于 动态规划问题。<br>即通过搜索所有可能的选择，找到最优结果。过程中有很多重复子问题，因此需要使用动态规划。</p>\n<p>最优化目标是(Alice’s score - Bob’s score)，Alice想要最大化，Bob想要最小化。其实都是最大化（我的分数 - 对方的分数）。<br>另外，观察到操作的结果其实是石头的和，因此需要提前计算前缀和数组。<br>问题转化成，从前缀和[i:]中挑一个数，使得的分数差最大；之后的后手只能从被挑的位置之后挑。<br>定义<br>dp(i) 为从前缀和[i:]中挑一个数的最大分数差，<br>则状态转移方程为：<br>dp(i) = max(presum[j] + dp(j + 1) for j in range(i,)).<br>时间复杂度为 O(N^2), 显然超时。</p>\n<p>然而，在状态转移方程中其实还有重叠子问题, for loop max可以只计算一次，因此可以进一步优化到 O(N).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stoneGameVIII</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// presum</span></span><br><span class=\"line\">        <span class=\"comment\">// i = 0</span></span><br><span class=\"line\">        <span class=\"comment\">// pick i, ..., n - 1</span></span><br><span class=\"line\">        <span class=\"comment\">// time: n ^ 2</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = stones.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">presum</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        presum[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            presum[i+<span class=\"number\">1</span>] = presum[i] + stones[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxDp = numeric_limits&lt;<span class=\"keyword\">int</span>&gt;::<span class=\"built_in\">min</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n + <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        dp[n+<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n; i &gt;= <span class=\"number\">2</span>; --i) &#123; <span class=\"comment\">// 这里需要注意结束条件，因为第一次挑选不能不合并或只合并第一个，因此presum[0],presum[1]是没用的。</span></span><br><span class=\"line\">            maxDp = <span class=\"built_in\">max</span>(maxDp, presum[i] - dp[i + <span class=\"number\">1</span>]);</span><br><span class=\"line\">            dp[i] = maxDp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxDp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(N).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/05/16/LeetCode-biweekly-contest-52/",
            "url": "https://youngforest.github.io/2021/05/16/LeetCode-biweekly-contest-52/",
            "title": "LeetCode biweekly contest 52",
            "date_published": "2021-05-16T11:13:00.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2217 / 10364</td>\n<td>YoungForest</td>\n<td>12</td>\n<td>0:51:47</td>\n<td>0:05:11</td>\n<td>0:51:47</td>\n<td>0:29:51</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<span id=\"more\"></span>\n\n<h2 id=\"1859-Sorting-the-Sentence\"><a href=\"#1859-Sorting-the-Sentence\" class=\"headerlink\" title=\"1859. Sorting the Sentence\"></a>1859. Sorting the Sentence</h2><p>字符串问题用<code>python</code>。虽然题目不难，就是分割字符串，按照指定内容排序，但实现起来还是比想象中复杂的。好在Python中有很多方便的API和数据结构可以灵活使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sortSentence</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">str</span>:</span></span><br><span class=\"line\">        words = s.split(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>(<span class=\"params\">word</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"built_in\">int</span>(word[-<span class=\"number\">1</span>:]), word[<span class=\"number\">0</span>:-<span class=\"number\">1</span>])</span><br><span class=\"line\">        tuples = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(f, words))</span><br><span class=\"line\">        tuples.sort()</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f2</span>(<span class=\"params\">a, t</span>):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> a + <span class=\"string\">&#x27; &#x27;</span> + t[<span class=\"number\">1</span>] </span><br><span class=\"line\">        <span class=\"keyword\">return</span> reduce(f2, tuples, <span class=\"string\">&#x27;&#x27;</span>)[<span class=\"number\">1</span>:]</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(s.length),<br>空间复杂度: O(s.length).</p>\n<h2 id=\"1860-Incremental-Memory-Leak\"><a href=\"#1860-Incremental-Memory-Leak\" class=\"headerlink\" title=\"1860. Incremental Memory Leak\"></a>1860. Incremental Memory Leak</h2><p>本来是想用等差数列求和+解方程，O(1)解决的。但事实上实现和解方程还是太复杂了。到最后也没做出来。做完第3题后，回过来算了一下暴力的时间复杂度: O(sqrt(2^32)) = 65536. 居然如此低，果然第二题还是不能想复杂了，直接暴力怼多好。</p>\n<p>暴力模拟题目中描述的内存占用过程。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">memLeak</span><span class=\"params\">(<span class=\"keyword\">int</span> m1, <span class=\"keyword\">int</span> m2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> t = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (m1 &gt;= t || m2 &gt;= t) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m1 &gt;= m2) &#123;</span><br><span class=\"line\">                m1 -= t;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                m2 -= t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;t, m1, m2&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(sqrt(memory1 + memory2)),<br>空间复杂度: O(1).</p>\n<h2 id=\"1861-Rotating-the-Box\"><a href=\"#1861-Rotating-the-Box\" class=\"headerlink\" title=\"1861. Rotating the Box\"></a>1861. Rotating the Box</h2><p>了解了掉落的本质，会发现，只需要统计每个障碍物/地面左面到上个障碍物的石头有多少个即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"keyword\">char</span>&gt;&gt; <span class=\"built_in\">rotateTheBox</span>(vector&lt;vector&lt;<span class=\"keyword\">char</span>&gt;&gt;&amp; box) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> rows = box.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cols = box[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"keyword\">char</span>&gt;&gt; <span class=\"built_in\">ans</span>(cols, vector&lt;<span class=\"keyword\">char</span>&gt;(rows, <span class=\"string\">&#x27;.&#x27;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; rows; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> stoneCnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; cols; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (box[i][j] == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">                    ++stoneCnt;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (box[i][j] == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// fall down</span></span><br><span class=\"line\">                    ans[j][rows - <span class=\"number\">1</span> - i] = <span class=\"string\">&#x27;*&#x27;</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= stoneCnt; ++k) &#123;</span><br><span class=\"line\">                        ans[j - k][rows - <span class=\"number\">1</span> - i] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    stoneCnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>; k &lt;= stoneCnt; ++k) &#123;</span><br><span class=\"line\">                ans[cols - k][rows - <span class=\"number\">1</span> - i] = <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(m * n),<br>空间复杂度: O(m * n).</p>\n<h2 id=\"1862-Sum-of-Floored-Pairs\"><a href=\"#1862-Sum-of-Floored-Pairs\" class=\"headerlink\" title=\"1862. Sum of Floored Pairs\"></a>1862. Sum of Floored Pairs</h2><p>没啥好想法。首先尝试了暴力解，枚举所有的对：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumOfFlooredPairs</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        MOD = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">                ans += nums[j] // nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans % MOD</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N^2), TLE，<br>空间复杂度: O(1).</p>\n<p>尝试使用二分查找优化，寻找每一个数的倍数范围。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sumOfFlooredPairs</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = nums.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                ans = (ans + last) % MOD;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            last = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; nums[i] * j &lt;= MAX; ++j) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> l = <span class=\"built_in\">lower_bound</span>(nums.<span class=\"built_in\">begin</span>() + i, nums.<span class=\"built_in\">end</span>(), nums[i] * j);</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> r = <span class=\"built_in\">lower_bound</span>(l, nums.<span class=\"built_in\">end</span>(), nums[i] * (j + <span class=\"number\">1</span>));</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> x = <span class=\"built_in\">distance</span>(l, r);</span><br><span class=\"line\">                last = (last + x * j) % MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = (ans + last) % MOD;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N log N log N), 虽然有2个循环嵌套，但第二个其实是个调和级数。不过仍然TLE了。<br>空间复杂度: O(1).</p>\n<p>还是看零神的题解把：<br><a href=\"https://leetcode-cn.com/problems/sum-of-floored-pairs/solution/xiang-xia-qu-zheng-shu-dui-he-by-leetcod-u3eg/\">前缀和优化</a>。<br>可以少一个log.</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/05/16/LeetCode-weekly-contest-241/",
            "url": "https://youngforest.github.io/2021/05/16/LeetCode-weekly-contest-241/",
            "title": "LeetCode weekly contest 241",
            "date_published": "2021-05-16T10:42:19.000Z",
            "content_html": "<p>本周周赛和双周赛都翻车了，开始残酷打卡之旅。</p>\n<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>717 / 11572</td>\n<td>YoungForest</td>\n<td>12</td>\n<td>0:23:51</td>\n<td>0:05:35</td>\n<td>0:17:33</td>\n<td>0:23:51</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<span id=\"more\"></span>\n\n<h2 id=\"1863-Sum-of-All-Subset-XOR-Totals\"><a href=\"#1863-Sum-of-All-Subset-XOR-Totals\" class=\"headerlink\" title=\"1863. Sum of All Subset XOR Totals\"></a>1863. Sum of All Subset XOR Totals</h2><p>签到题。暴力回溯，枚举所有的子集。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">subsetXORSum</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        function&lt;<span class=\"built_in\"><span class=\"keyword\">void</span></span>(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>)&gt; backtracking = [&amp;](<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> current) -&gt; <span class=\"keyword\">void</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == nums.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                ans += current;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// use this</span></span><br><span class=\"line\">                <span class=\"built_in\">backtracking</span>(i + <span class=\"number\">1</span>, current ^ nums[i]);</span><br><span class=\"line\">                <span class=\"comment\">// not use this</span></span><br><span class=\"line\">                <span class=\"built_in\">backtracking</span>(i + <span class=\"number\">1</span>, current);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(2^n),<br>空间复杂度: O(n).</p>\n<h2 id=\"1864-Minimum-Number-of-Swaps-to-Make-the-Binary-String-Alternating\"><a href=\"#1864-Minimum-Number-of-Swaps-to-Make-the-Binary-String-Alternating\" class=\"headerlink\" title=\"1864. Minimum Number of Swaps to Make the Binary String Alternating\"></a>1864. Minimum Number of Swaps to Make the Binary String Alternating</h2><p>首先统计’0/1’的数目，看是否可以形成交替。<br>再尝试2种交替方式，1在前/0在前。<br>重点在于只需要关心不符合的数量即可，不需要考虑具体怎么交换。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minSwaps</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cnt</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : s) &#123;</span><br><span class=\"line\">            ++cnt[c - <span class=\"string\">&#x27;0&#x27;</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(cnt[<span class=\"number\">0</span>] - cnt[<span class=\"number\">1</span>]) &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> first : <span class=\"string\">&quot;01&quot;</span>s) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt.<span class=\"built_in\">at</span>(first - <span class=\"string\">&#x27;0&#x27;</span>) + <span class=\"number\">1</span> == cnt.<span class=\"built_in\">at</span>(<span class=\"string\">&#x27;1&#x27;</span> - first)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s[i] != first) &#123;</span><br><span class=\"line\">                    ++current;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = <span class=\"built_in\">min</span>(ans, current);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(s.length),<br>空间复杂度: O(1).</p>\n<p>需要注意的是, </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> first : <span class=\"string\">&quot;01&quot;</span>s)</span><br></pre></td></tr></table></figure>\n<p>一定不能写成。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> first : <span class=\"string\">&quot;01&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>因为前者是 字符串常量（string literal），后者是C语言里的静态字符串，会有<code>\\n</code>结尾的。</p>\n<h2 id=\"1865-Finding-Pairs-With-a-Certain-Sum\"><a href=\"#1865-Finding-Pairs-With-a-Certain-Sum\" class=\"headerlink\" title=\"1865. Finding Pairs With a Certain Sum\"></a>1865. Finding Pairs With a Certain Sum</h2><p>首先观察数据规模，发现<code>nums1.length</code>小，但<code>nums2.length</code>大。考虑对小的做遍历，大的<code>hash</code>优化。<br>使用一个反向hashtable记录<code>nums2</code> 值-&gt;index 的映射。</p>\n<p>时间复杂度:</p>\n<ul>\n<li>构造: O(nums2.length),</li>\n<li>add: O(1),</li>\n<li>count: O(nums1.length).<br>空间复杂度: O(nums2.length).</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FindSumPairs</span> &#123;</span></span><br><span class=\"line\">    vector&lt;<span class=\"keyword\">int</span>&gt; nums1, nums2;</span><br><span class=\"line\">    unordered_map&lt;<span class=\"keyword\">int</span>, unordered_set&lt;<span class=\"keyword\">int</span>&gt;&gt; m;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">FindSumPairs</span>(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; _nums1, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; _nums2): <span class=\"built_in\">nums1</span>(<span class=\"built_in\">move</span>(_nums1)), <span class=\"built_in\">nums2</span>(<span class=\"built_in\">move</span>(_nums2)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums2.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            m[nums2[i]].<span class=\"built_in\">insert</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// O(1)</span></span><br><span class=\"line\">        m[nums2[index]].<span class=\"built_in\">erase</span>(index);</span><br><span class=\"line\">        nums2[index] += val;</span><br><span class=\"line\">        m[nums2[index]].<span class=\"built_in\">insert</span>(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"keyword\">int</span> tot)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// O(nums1.length)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : nums1) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> it = m.<span class=\"built_in\">find</span>(tot - i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it != m.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                ans += it-&gt;second.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your FindSumPairs object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * FindSumPairs* obj = new FindSumPairs(nums1, nums2);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj-&gt;add(index,val);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj-&gt;count(tot);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"1866-Number-of-Ways-to-Rearrange-Sticks-With-K-Sticks-Visible\"><a href=\"#1866-Number-of-Ways-to-Rearrange-Sticks-With-K-Sticks-Visible\" class=\"headerlink\" title=\"1866. Number of Ways to Rearrange Sticks With K Sticks Visible\"></a>1866. Number of Ways to Rearrange Sticks With K Sticks Visible</h2><p>本题我只想到了N^3的解法。<br>使用动态规划，状态转移方程为</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(k - <span class=\"number\">1</span>, i):</span><br><span class=\"line\">    ans = (ans + dp(j, k - <span class=\"number\">1</span>) * f2(i-<span class=\"number\">1</span>, j)) % MOD</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n<p>即从高向低考虑，因为最高的一定可以被看见。枚举第i个木棍放的位置，剩下i-1个木棍需要抽一些放在i之后，之后的是一个枚举数。<br>从时间复杂度上一定会超时，事实上果然如此，尽管我试图尽力从常数上优化。<br>下面给出我最后超时的代码。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOD = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"meta\">@cache</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>(<span class=\"params\">i</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &lt;= <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>: <span class=\"keyword\">return</span> (i * f(i - <span class=\"number\">1</span>)) % MOD</span><br><span class=\"line\"><span class=\"meta\">@cache</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f2</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a == b: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>: <span class=\"keyword\">return</span> (a * f2(a - <span class=\"number\">1</span>, b)) % MOD</span><br><span class=\"line\"><span class=\"meta\">@cache</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span>(<span class=\"params\">i: <span class=\"built_in\">int</span>, k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># [1:i], see k woods</span></span><br><span class=\"line\">    <span class=\"comment\"># print(i, k)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &lt; k: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> i == k: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"comment\"># put i first and other after</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(i - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(k - <span class=\"number\">1</span>, i):</span><br><span class=\"line\">            <span class=\"comment\"># put i first and [j+1, i-1] after</span></span><br><span class=\"line\">            <span class=\"comment\"># pick num woods before</span></span><br><span class=\"line\">            <span class=\"comment\"># num = i - 1 - (j + 1) + 1</span></span><br><span class=\"line\">            <span class=\"comment\"># C_i^num * num!</span></span><br><span class=\"line\">            <span class=\"comment\"># C(n,m)=n!/((n-m)!*m!)（m≤n）</span></span><br><span class=\"line\">            <span class=\"comment\"># print(&#x27;add&#x27;, dp(j, k - 1), (factorial(i) // factorial(i - num)))</span></span><br><span class=\"line\">            ans = (ans + dp(j, k - <span class=\"number\">1</span>) * f2(i-<span class=\"number\">1</span>, j)) % MOD</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rearrangeSticks</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span>, k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(n, k)</span><br></pre></td></tr></table></figure>\n\n<p>我参考了一些题解，确实是递推公式有问题。<br>其实从不同的角度都可以得到这个公式。</p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/solution/qia-you-k-gen-mu-gun-ke-yi-kan-dao-de-pa-0c3g/\">能不能看到最后一根木棍</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/solution/zhuan-huan-cheng-di-yi-lei-si-te-lin-shu-2y1k/\">第一类斯特林数</a></li>\n</ul>\n<p>小修我TLE的代码就OK了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">rearrangeSticks</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span>, k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        MOD = <span class=\"number\">10</span>**<span class=\"number\">9</span> + <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"meta\">        @cache</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span>(<span class=\"params\">i: <span class=\"built_in\">int</span>, k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">            <span class=\"comment\"># [1:i], see k woods</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; k: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> i == k: <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> k == <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"comment\"># last wood can be seen, it must be `i`. dp(i-1, k - 1)</span></span><br><span class=\"line\">                <span class=\"comment\"># last wood can not be seen, (i - 1) * dp(i - 1, k)</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> (dp(i-<span class=\"number\">1</span>, k - <span class=\"number\">1</span>) + (i - <span class=\"number\">1</span>) * dp(i - <span class=\"number\">1</span>, k)) % MOD</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp(n, k)</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/05/09/LeetCode-weekly-contest-240/",
            "url": "https://youngforest.github.io/2021/05/09/LeetCode-weekly-contest-240/",
            "title": "LeetCode weekly contest 240",
            "date_published": "2021-05-09T09:18:34.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>272 / 11577</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>1:15:29</td>\n<td>0:04:46</td>\n<td>0:14:19</td>\n<td>0:47:06</td>\n<td>1:10:29  1</td>\n</tr>\n</tbody></table>\n<p>这周五一假期+大论文查重。心情被大论文折麽的十分焦虑，再坚持2周，挺过答辩就好了。<br>等过了答辩，让我干啥都行。</p>\n<p>前几周因为国服自己的rating太高，不敢打了，怕掉分。转战了美服，现在把美服也打到2350了。rating也过高了。之后打算再次转战国服，因为最近新一年的招聘迫近，国服赞助商礼物比较丰厚。虽然去年只有几次排名足够靠前，拿到奖品，但好歹有个奖励，有比较小的期望。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1854-Maximum-Population-Year\"><a href=\"#1854-Maximum-Population-Year\" class=\"headerlink\" title=\"1854. Maximum Population Year\"></a>1854. Maximum Population Year</h2><p>签到题。暴力枚举每个可能的年份。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximumPopulation</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; logs)</span> </span>&#123;</span><br><span class=\"line\">        map&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; cnt;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; v : logs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = v[<span class=\"number\">0</span>]; i &lt; v[<span class=\"number\">1</span>]; ++i) &#123;</span><br><span class=\"line\">                ++cnt[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxYear = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; p : cnt) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.second &gt; maxValue) &#123;</span><br><span class=\"line\">                maxYear = p.first;</span><br><span class=\"line\">                maxValue = p.second;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxYear;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(logs.length * MAX(death_i - birth_i)) = O(100 * 100),<br>空间复杂度: O(MAX(death_i - birth_i)).</p>\n<h2 id=\"1855-Maximum-Distance-Between-a-Pair-of-Values\"><a href=\"#1855-Maximum-Distance-Between-a-Pair-of-Values\" class=\"headerlink\" title=\"1855. Maximum Distance Between a Pair of Values\"></a>1855. Maximum Distance Between a Pair of Values</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDistance</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums1.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> it = <span class=\"built_in\">upper_bound</span>(nums2.<span class=\"built_in\">begin</span>() + i, nums2.<span class=\"built_in\">end</span>(), nums1[i], greater&lt;&gt;());</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"built_in\">distance</span>(nums2.<span class=\"built_in\">begin</span>() + i, <span class=\"built_in\">prev</span>(it))));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(nums1.length * log nums2.length),<br>空间复杂度: O(1).</p>\n<p>本题也可以用双指针做，i 指向nums1的位置，j 指向nums2的位置。<br>向右遍历 i，更新j。不变量是 j &gt;= i &amp;&amp; nums[j] &lt; nums[i].<br>时间复杂度是 O(nums1.length + nums2.length).<br>代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxDistance</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; i &lt; nums1.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &lt; nums2.<span class=\"built_in\">size</span>() &amp;&amp; (j &lt; i || nums2[j] &gt;= nums1[i])) ++j;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, j - <span class=\"number\">1</span> - i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1856-Maximum-Subarray-Min-Product\"><a href=\"#1856-Maximum-Subarray-Min-Product\" class=\"headerlink\" title=\"1856. Maximum Subarray Min-Product\"></a>1856. Maximum Subarray Min-Product</h2><p>类似BFS，从数值大的元素开始遍历，尝试合并左右区间。<br>具体实现需要 维护区间左右边界、最小值、区间和。可以采用类似并查集的思路。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> ll = <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ll MOD = <span class=\"number\">1e9</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxSumMinProduct</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">// iterate from max to min</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">s</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">right</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">left</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">minV</span><span class=\"params\">(n, INF)</span></span>;</span><br><span class=\"line\">        multimap&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>, greater&lt;&gt;&gt; index;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            index.<span class=\"built_in\">insert</span>(&#123;nums[i], i&#125;);</span><br><span class=\"line\">            minV[i] = nums[i];</span><br><span class=\"line\">            left[i] = i;</span><br><span class=\"line\">            right[i] = i;</span><br><span class=\"line\">            s[i] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; p : index) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i = p.second;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> ll minValue = p.first;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; minV[i<span class=\"number\">-1</span>] &gt;= minValue) &#123;</span><br><span class=\"line\">                left[i] = left[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">                s[i] += s[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; n &amp;&amp; minV[i+<span class=\"number\">1</span>] &gt; minValue) &#123;</span><br><span class=\"line\">                right[i] = right[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">                s[i] += s[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            minV[right[i]] = minValue;</span><br><span class=\"line\">            minV[left[i]] = minValue;</span><br><span class=\"line\">            right[left[i]] = right[i];</span><br><span class=\"line\">            left[right[i]] = left[i];</span><br><span class=\"line\">            s[left[i]] = s[i];</span><br><span class=\"line\">            s[right[i]] = s[i];</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, s[i] * minValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans % MOD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n * log n),<br>空间复杂度: O(n).</p>\n<p>赛后经残酷群友讨论，<br>类似的题目有：<br><a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">LC 84. Largest Rectangle in Histogram</a>. 区别在于 84 是 最小值*子数组长度。本题是 最小值*子数组和。</p>\n<h2 id=\"1857-Largest-Color-Value-in-a-Directed-Graph\"><a href=\"#1857-Largest-Color-Value-in-a-Directed-Graph\" class=\"headerlink\" title=\"1857. Largest Color Value in a Directed Graph\"></a>1857. Largest Color Value in a Directed Graph</h2><p>拓扑排序。同时 遍历到每一个节点时，更新能到它的路径中每种颜色最大的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">largestPathValue</span>(<span class=\"params\">self, colors: <span class=\"built_in\">str</span>, edges: <span class=\"type\">List</span>[<span class=\"type\">List</span>[<span class=\"built_in\">int</span>]]</span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(colors)</span><br><span class=\"line\">        m = <span class=\"built_in\">len</span>(edges)</span><br><span class=\"line\">        indegree = [<span class=\"number\">0</span>] * n</span><br><span class=\"line\">        graph = defaultdict(<span class=\"built_in\">list</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> edges:</span><br><span class=\"line\">            indegree[e[<span class=\"number\">1</span>]] += <span class=\"number\">1</span></span><br><span class=\"line\">            graph[e[<span class=\"number\">0</span>]].append(e[<span class=\"number\">1</span>])</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># topo sort</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span>(<span class=\"params\">root</span>):</span></span><br><span class=\"line\">            ans = [<span class=\"number\">0</span>] * <span class=\"number\">26</span></span><br><span class=\"line\">            ans[<span class=\"built_in\">ord</span>(colors[root]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> graph[root]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> n <span class=\"keyword\">in</span> path: <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">                x = dfs(n, path)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> x <span class=\"keyword\">is</span> <span class=\"literal\">None</span>: <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">26</span>):</span><br><span class=\"line\">                    ans[i] += x[i]</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        ans = -<span class=\"number\">1</span></span><br><span class=\"line\">        q = collections.deque()</span><br><span class=\"line\">        seen = <span class=\"number\">0</span></span><br><span class=\"line\">        cnt = [[<span class=\"number\">0</span>] * <span class=\"number\">26</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span> (n)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> indegree[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                cnt[i][<span class=\"built_in\">ord</span>(colors[i]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)] += <span class=\"number\">1</span></span><br><span class=\"line\">                q.append(i)</span><br><span class=\"line\">                seen += <span class=\"number\">1</span></span><br><span class=\"line\">                ans = <span class=\"built_in\">max</span>(ans, <span class=\"built_in\">max</span>(cnt[i]))</span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">while</span> q:</span><br><span class=\"line\">            front = q.popleft()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> graph[front]:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">26</span>):</span><br><span class=\"line\">                    cnt[i][x] = <span class=\"built_in\">max</span>(cnt[i][x], cnt[front][x])</span><br><span class=\"line\">                indegree[i] -= <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> indegree[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    q.append(i)</span><br><span class=\"line\">                    cnt[i][<span class=\"built_in\">ord</span>(colors[i]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)] += <span class=\"number\">1</span></span><br><span class=\"line\">                    ans = <span class=\"built_in\">max</span>(ans, <span class=\"built_in\">max</span>(cnt[i]))</span><br><span class=\"line\">                    seen += <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">        <span class=\"keyword\">if</span> seen == n: <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n + m),<br>空间复杂度: O(n + m).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/05/02/LeetCode-biweekly-contest-51/",
            "url": "https://youngforest.github.io/2021/05/02/LeetCode-biweekly-contest-51/",
            "title": "LeetCode biweekly contest 51",
            "date_published": "2021-05-02T03:52:18.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (4)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>150 / 9378</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>0:32:04</td>\n<td>0:05:26</td>\n<td>0:07:22</td>\n<td>0:11:24</td>\n<td>0:32:04</td>\n</tr>\n</tbody></table>\n<p>手速场。最近手速已大不如从前，最后一题也因为不熟练花费了比较多的时间。<br>其实，手速场中，所有题目的算法其实都不难，想到正确的解法很快，但迅速实现 + bug free就考验每位程序员的功力了。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1844-Replace-All-Digits-with-Characters\"><a href=\"#1844-Replace-All-Digits-with-Characters\" class=\"headerlink\" title=\"1844. Replace All Digits with Characters\"></a>1844. Replace All Digits with Characters</h2><p>签到题。按照题目要求完成即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">shift</span><span class=\"params\">(<span class=\"keyword\">char</span> c, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c + x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">replaceDigits</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; s.<span class=\"built_in\">size</span>(); i += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            s[i] = <span class=\"built_in\">shift</span>(s[i<span class=\"number\">-1</span>], s[i] - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1845-Seat-Reservation-Manager\"><a href=\"#1845-Seat-Reservation-Manager\" class=\"headerlink\" title=\"1845. Seat Reservation Manager\"></a>1845. Seat Reservation Manager</h2><p>因为每次都找最小的座位号，同时有<code>insert</code>(<code>unreserve</code>)的操作。显然需要使用 <code>priority_queue</code>优先队列/Heap 实现这一需求。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SeatManager</span> &#123;</span></span><br><span class=\"line\">    priority_queue&lt;<span class=\"keyword\">int</span>, vector&lt;<span class=\"keyword\">int</span>&gt;, greater&lt;&gt;&gt; pq;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">SeatManager</span>(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            pq.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reserve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ans = pq.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unreserve</span><span class=\"params\">(<span class=\"keyword\">int</span> seatNumber)</span> </span>&#123;</span><br><span class=\"line\">        pq.<span class=\"built_in\">push</span>(seatNumber);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your SeatManager object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * SeatManager* obj = new SeatManager(n);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj-&gt;reserve();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj-&gt;unreserve(seatNumber);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度:</p>\n<ul>\n<li>SeatManager: O(n),</li>\n<li>reserve: O(log n),</li>\n<li>unreserve: O(log n).<br>空间复杂度: O(n).</li>\n</ul>\n<h2 id=\"1846-Maximum-Element-After-Decreasing-and-Rearranging\"><a href=\"#1846-Maximum-Element-After-Decreasing-and-Rearranging\" class=\"headerlink\" title=\"1846. Maximum Element After Decreasing and Rearranging\"></a>1846. Maximum Element After Decreasing and Rearranging</h2><p>贪心。<br>观察2种操作 <code>Decrease</code> 和 <code>Rearrange</code> 可以发现，<br>其实只需要<code>Reagrrage</code>一次，<code>Decrease</code>时，优先减小的。因为大的减起来一定可以包括小的，但小的不行。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maximumElementAfterDecrementingAndRearranging</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(arr.<span class=\"built_in\">begin</span>(), arr.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &gt; last) &#123;</span><br><span class=\"line\">                arr[i] = last + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                arr[i] = last;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            last = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n log n + n),<br>空间复杂度: O(1).</p>\n<h2 id=\"1847-Closest-Room\"><a href=\"#1847-Closest-Room\" class=\"headerlink\" title=\"1847. Closest Room\"></a>1847. Closest Room</h2><p>首先想到暴力解法，对于每一个<code>query</code>, 遍历一遍<code>rooms</code>，就可以找到答案。时间复杂度为 <code>O(k * n)</code>，显然会TLE。<br>解法时间复杂度应该是类似<code>O(n log n)</code>这种形式。</p>\n<p>这里需要用到一个所谓**离线计算(offline query)**的技术。<br>所谓在线计算，就是<code>queries</code>的解答顺序是不变的，类似一个函数，每次被call，解答一次。<br>所谓离线计算，就是<code>queries</code>的解答顺序是可以变的，需要一次性求解一个数组的<code>queries</code>。此时，我们可以通过对<code>queries</code>重新排序得到均摊速度更快的算法。</p>\n<p>首先，将<code>queries</code>按<code>minisize</code>排序，将<code>rooms</code>按<code>size</code>排序。<br>用双指针的方式，保证对于当前的<code>query</code>，符合要求的<code>rooms</code>都被加入候选集合中。这里我们用<code>TreeSet</code>维护候选集合，以实现<code>log n</code>的搜索最近<code>room</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">closestRoom</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; rooms, vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// brute force: k * n</span></span><br><span class=\"line\">        <span class=\"comment\">// need: k * log n + n log n</span></span><br><span class=\"line\">        <span class=\"comment\">// online, sort queries by minisize from big to small, find close candidate</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = rooms.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(rooms.<span class=\"built_in\">begin</span>(), rooms.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; a, <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; b) -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] &gt; b[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> k = queries.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">using</span> pii = pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;;</span><br><span class=\"line\">        vector&lt;pii&gt; searchOrder; <span class=\"comment\">// miniSize, index</span></span><br><span class=\"line\">        searchOrder.<span class=\"built_in\">reserve</span>(k);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i) &#123;</span><br><span class=\"line\">            searchOrder.<span class=\"built_in\">push_back</span>(&#123;queries[i][<span class=\"number\">1</span>], i&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(searchOrder.<span class=\"built_in\">begin</span>(), searchOrder.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; a, <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; b) -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a.first &gt; b.first;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        set&lt;<span class=\"keyword\">int</span>&gt; candidate;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(k, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; k; ++j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; n &amp;&amp; rooms[i][<span class=\"number\">1</span>] &gt;= searchOrder[j].first) &#123;</span><br><span class=\"line\">                candidate.<span class=\"built_in\">insert</span>(rooms[i++][<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> prefer = queries[searchOrder[j].second][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!candidate.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> it = candidate.<span class=\"built_in\">lower_bound</span>(prefer);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (it == candidate.<span class=\"built_in\">begin</span>()) &#123;</span><br><span class=\"line\">                    ans[searchOrder[j].second] = *it;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (it == candidate.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    ans[searchOrder[j].second] = *<span class=\"built_in\">prev</span>(it);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(*it - prefer) &lt; (prefer - *<span class=\"built_in\">prev</span>(it))) &#123;</span><br><span class=\"line\">                        ans[searchOrder[j].second] = *it;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        ans[searchOrder[j].second] = *<span class=\"built_in\">prev</span>(it);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans[searchOrder[j].second] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n log n + k log n + k log k),<br>空间复杂度: O(k + n).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/05/02/LeetCode-weekly-contest-239/",
            "url": "https://youngforest.github.io/2021/05/02/LeetCode-weekly-contest-239/",
            "title": "LeetCode weekly contest 239",
            "date_published": "2021-05-02T03:47:52.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>78 / 10870</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>0:52:57</td>\n<td>0:02:22</td>\n<td>0:09:37</td>\n<td>0:27:13</td>\n<td>0:47:57  1</td>\n</tr>\n</tbody></table>\n<p>连续3周免打卡了，昨晚双周赛也做的不错手速场。<br>最近的周赛确实难度有所降低，看来我还是适合做简单题目。Hard+还是不大行。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1848-Minimum-Distance-to-the-Target-Element\"><a href=\"#1848-Minimum-Distance-to-the-Target-Element\" class=\"headerlink\" title=\"1848. Minimum Distance to the Target Element\"></a>1848. Minimum Distance to the Target Element</h2><p>签到题。<br>One pass，记录最优答案。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMinDistance</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = -INF;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(i - start) &lt; <span class=\"built_in\">abs</span>(ans - start)) &#123;</span><br><span class=\"line\">                    ans = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(ans - start);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1849-Splitting-a-String-Into-Descending-Consecutive-Values\"><a href=\"#1849-Splitting-a-String-Into-Descending-Consecutive-Values\" class=\"headerlink\" title=\"1849. Splitting a String Into Descending Consecutive Values\"></a>1849. Splitting a String Into Descending Consecutive Values</h2><p>Backtracking, 搜索可能的分割点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">splitString</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"meta\">        @cache</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span>(<span class=\"params\">i: <span class=\"built_in\">int</span>, last: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">bool</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt;= n: <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i != <span class=\"number\">0</span>:</span><br><span class=\"line\">                final = <span class=\"built_in\">int</span>(s[i:])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> final &lt; last <span class=\"keyword\">and</span> last - final == <span class=\"number\">1</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i + <span class=\"number\">1</span>, n):</span><br><span class=\"line\">                new = <span class=\"built_in\">int</span>(s[i:j])</span><br><span class=\"line\">                <span class=\"keyword\">if</span> new &lt; last <span class=\"keyword\">and</span> (i == <span class=\"number\">0</span> <span class=\"keyword\">or</span> last - new == <span class=\"number\">1</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> dfs(j, new): <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(<span class=\"number\">0</span>, <span class=\"built_in\">float</span>(<span class=\"string\">&#x27;inf&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N^2),<br>空间复杂度: O(N).</p>\n<p>虽然我们使用了backtracking，看起来好想时间复杂度很高，O(N ^ N), 但其实在<code>dfs</code>中的<code>for</code>循环中，符合条件可以<code>dfs</code>到下一层的可能路径只有1条。<br>参考<a href=\"https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/discuss/1186795/C%2B%2B-Backtracking-solution.-O(N-2)-and-time-complexity-analytics\">这个题解的分析</a>.</p>\n<h2 id=\"1850-Minimum-Adjacent-Swaps-to-Reach-the-Kth-Smallest-Number\"><a href=\"#1850-Minimum-Adjacent-Swaps-to-Reach-the-Kth-Smallest-Number\" class=\"headerlink\" title=\"1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number\"></a>1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number</h2><p>首先，我们需要复习一下<a href=\"https://leetcode.com/problems/next-permutation/\">LC 31. Next Permutation</a>. 学习一下求解下一个枚举排列的方法。幸运的是，C++ STL 里已经提供了<code>std::next_permutation</code>函数可以直接用，均摊时间复杂度为<strong>O(1)</strong>.<br>使用<code>k</code>次<code>next_permutation</code>找到the Kth Smallest Number<br>后，只需要采用贪心的思路就可以找到最小交换次数。<br>即发现一个不相等的位置，就在后面找到一个最近的相等的数，通过交换挪的当前位置。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMinSwaps</span><span class=\"params\">(string num, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> s = num;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(std::<span class=\"built_in\">next_permutation</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>()) &amp;&amp; k - <span class=\"number\">1</span> &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// std::cout &lt;&lt; s &lt;&lt; &#x27;\\n&#x27;;</span></span><br><span class=\"line\">            --k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = num.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num[j] == s[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// find next digit and swap it here</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; i &lt; n <span class=\"keyword\">and</span> num[i] != s[j]; ++i);</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class=\"line\">            ans += i - j;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x = i; x &gt; j; --x) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(num[x], num[x - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(k + n^2),<br>空间复杂度: O(n).</p>\n<h2 id=\"1851-Minimum-Interval-to-Include-Each-Query\"><a href=\"#1851-Minimum-Interval-to-Include-Each-Query\" class=\"headerlink\" title=\"1851. Minimum Interval to Include Each Query\"></a>1851. Minimum Interval to Include Each Query</h2><p>本题和<a href=\"https://youngforest.github.io/2021/05/02/LeetCode-biweekly-contest-51/#1847-Closest-Room\">昨晚双周赛的最后一题</a>有些像，需要用到离线计算的技术。<br>intervals按照size从小到大排序，没新增一个interval，更新可以覆盖到的query的答案。<br>这里需要用<code>multimap</code>维护待解决的<code>queries</code>。因为支持二分查找和删除，以及重复的query.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">minInterval</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// brute-foce: queries.length * intervals.length</span></span><br><span class=\"line\">        <span class=\"comment\">// smarter: queries.length * log + intervals.length * log</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = intervals.<span class=\"built_in\">size</span>(), m = queries.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">// sort interval by size less&lt;&gt;, find new queries</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(m, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">        multimap&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; indexQueries;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            indexQueries.<span class=\"built_in\">insert</span>(&#123;queries[i], i&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(intervals.<span class=\"built_in\">begin</span>(), intervals.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; lhs, <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; rhs) -&gt; <span class=\"keyword\">bool</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lhs[<span class=\"number\">1</span>] - lhs[<span class=\"number\">0</span>] &lt; rhs[<span class=\"number\">1</span>] - rhs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; v : intervals) &#123;</span><br><span class=\"line\">            size = v[<span class=\"number\">1</span>] - v[<span class=\"number\">0</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> left = indexQueries.<span class=\"built_in\">lower_bound</span>(v[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> right = indexQueries.<span class=\"built_in\">upper_bound</span>(v[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = left; it != right; ++it) &#123;</span><br><span class=\"line\">                ans[it-&gt;second] = size;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = left; it != right;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> nit = <span class=\"built_in\">next</span>(it);</span><br><span class=\"line\">                indexQueries.<span class=\"built_in\">erase</span>(it);</span><br><span class=\"line\">                it = nit;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>n = intervals.length, m = queries.length<br>时间复杂度: O(n log n + m log m + n log m),<br>空间复杂度: O(m).</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/04/25/LeetCode-weekly-contest-238/",
            "url": "https://youngforest.github.io/2021/04/25/LeetCode-weekly-contest-238/",
            "title": "LeetCode weekly contest 238",
            "date_published": "2021-04-25T09:58:13.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>383 / 11635</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>1:53:50</td>\n<td>0:01:05</td>\n<td>0:13:02</td>\n<td>0:20:59</td>\n<td>1:28:50 5</td>\n</tr>\n</tbody></table>\n<span id=\"more\"></span>\n\n<h2 id=\"1837-Sum-of-Digits-in-Base-K\"><a href=\"#1837-Sum-of-Digits-in-Base-K\" class=\"headerlink\" title=\"1837. Sum of Digits in Base K\"></a>1837. Sum of Digits in Base K</h2><p>签到题。10进制转6进制。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumBase</span>(<span class=\"params\">self, n: <span class=\"built_in\">int</span>, k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            ans += n % k</span><br><span class=\"line\">            n //= k</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(log_k n),<br>空间复杂度: O(1).</p>\n<h2 id=\"1838-Frequency-of-the-Most-Frequent-Element\"><a href=\"#1838-Frequency-of-the-Most-Frequent-Element\" class=\"headerlink\" title=\"1838. Frequency of the Most Frequent Element\"></a>1838. Frequency of the Most Frequent Element</h2><p>本周周赛Q2 Q3都是滑动窗口题。事实上，从零宝大数据来看，Q2难度还是比Q3大的。</p>\n<p>首先想出暴力解法，尝试每个元素，试图把比它小的元素增至它，看最多有多少个。<br>时间复杂度: O(N ^ 2), 估计会TLE。<br>Q2 通常情况下还是可以暴力解的，虽然本题不可以。</p>\n<p>在暴力解的基础上，尝试优化。观察到，“试图把比它小的元素增至它”这个操作或许可以在O(1)的情况下完成，而不需要暴力尝试每个比它小的元素。因为那些元素已经被升至上一个尝试元素了。</p>\n<p>先排序。然后，从小到大尝试把所有值都增至<code>nums[r]</code>。<br>窗口<code>[l:r]</code>维护这些被增至目标值<code>nums[r]</code>的元素。<br>当<code>r</code>右移时，把窗口里的元素都从上个值更新到<code>nums[r]</code>。<br>如果用了过多的增操作，则增加<code>l</code>，释放增操作。<br>取窗口最宽值作为答案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxFrequency</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># brute force: N ^ 2</span></span><br><span class=\"line\">        <span class=\"comment\"># for each element, try to make it most frequency</span></span><br><span class=\"line\">        <span class=\"comment\"># sliding window</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        l = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> r &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"comment\"># make all increment to nums[r]</span></span><br><span class=\"line\">                k -= (nums[r] - nums[r-<span class=\"number\">1</span>]) * (r - l)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> k &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                k += nums[r] - nums[l]</span><br><span class=\"line\">                l += <span class=\"number\">1</span></span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(r - l + <span class=\"number\">1</span>, ans)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(n log n + n),<br>空间复杂度: O(1).</p>\n<h2 id=\"1839-Longest-Substring-Of-All-Vowels-in-Order\"><a href=\"#1839-Longest-Substring-Of-All-Vowels-in-Order\" class=\"headerlink\" title=\"1839. Longest Substring Of All Vowels in Order\"></a>1839. Longest Substring Of All Vowels in Order</h2><p>相比上题，本题更是明显的滑动窗口题。<br>窗口<code>[l:r]</code>的不变量是字串递增。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">longestBeautifulSubstring</span>(<span class=\"params\">self, word: <span class=\"built_in\">str</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># brute force: N^3, enumerate all substring * check each substring</span></span><br><span class=\"line\">        <span class=\"comment\"># sliding window: N</span></span><br><span class=\"line\">        <span class=\"comment\"># at least once, incresing</span></span><br><span class=\"line\">        l = <span class=\"number\">0</span></span><br><span class=\"line\">        r = <span class=\"number\">0</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(word)</span><br><span class=\"line\">        cnt = [<span class=\"number\">0</span>] * <span class=\"number\">26</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span>():</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"string\">&#x27;aeiou&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> cnt[<span class=\"built_in\">ord</span>(i) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)] &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        ans = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> r &lt; n:</span><br><span class=\"line\">            cnt[<span class=\"built_in\">ord</span>(word[r]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> r &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> word[r] &lt; word[r-<span class=\"number\">1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">while</span> l &lt; r:</span><br><span class=\"line\">                    cnt[<span class=\"built_in\">ord</span>(word[l]) - <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;a&#x27;</span>)] -= <span class=\"number\">1</span></span><br><span class=\"line\">                    l += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> check():</span><br><span class=\"line\">                ans = <span class=\"built_in\">max</span>(ans, r - l + <span class=\"number\">1</span>)</span><br><span class=\"line\">            r += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(word.length),<br>空间复杂度: O(1).</p>\n<h2 id=\"1840-Maximum-Building-Height\"><a href=\"#1840-Maximum-Building-Height\" class=\"headerlink\" title=\"1840. Maximum Building Height\"></a>1840. Maximum Building Height</h2><p>还是挺难的一道Hard题。<br>相邻差值为1. 一开始想到用BFS，从高度限制小的开始遍历，更新周围的高度。也算是经典算法。<br>然后TLE后，才注意到<code>n &lt;= 10^9</code>这个限制。O(N)的算法也肯定超时。<br>注意<code>restrictions.length &lt;= 10^5</code>这一限制，大概率是要从这里下手的。<br>因此，BFS时只更新被限制的块，块中间再用二分搜索找最高点（其实可以用O(1)的数学解法的，比赛时没好想法就二分暴力了）。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxBuilding</span><span class=\"params\">(<span class=\"keyword\">int</span> n, vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; restrictions)</span> </span>&#123;</span><br><span class=\"line\">        map&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; rtxMap;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">bool</span>&gt; seen;</span><br><span class=\"line\">        seen.<span class=\"built_in\">reserve</span>(restrictions.<span class=\"built_in\">size</span>() + <span class=\"number\">2</span>);</span><br><span class=\"line\">        rtxMap[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        rtxMap[n<span class=\"number\">-1</span>] = INF;</span><br><span class=\"line\">        seen[<span class=\"number\">0</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        seen[n<span class=\"number\">-1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// bfs: O(N), TLE</span></span><br><span class=\"line\">        <span class=\"keyword\">using</span> pii = pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;;</span><br><span class=\"line\">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq;</span><br><span class=\"line\">        pq.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; v : restrictions) &#123;</span><br><span class=\"line\">            pq.<span class=\"built_in\">push</span>(&#123;v[<span class=\"number\">1</span>], v[<span class=\"number\">0</span>] - <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">            rtxMap[v[<span class=\"number\">0</span>] - <span class=\"number\">1</span>] = v[<span class=\"number\">1</span>];</span><br><span class=\"line\">            seen[v[<span class=\"number\">0</span>] - <span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [height, idx] = pq.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; height &lt;&lt; &quot;, &quot; &lt;&lt; idx &lt;&lt; endl;</span></span><br><span class=\"line\">            pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (seen[idx]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, height);</span><br><span class=\"line\">            seen[idx] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> j : &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>&#125;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> next = idx + j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next &gt;= n || next &lt; <span class=\"number\">0</span> || seen[next]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">auto</span> it = rtxMap.<span class=\"built_in\">lower_bound</span>(next);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (it != rtxMap.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x = it-&gt;first;</span><br><span class=\"line\">                        it-&gt;second = <span class=\"built_in\">min</span>(it-&gt;second, height + x - idx);</span><br><span class=\"line\">                        pq.<span class=\"built_in\">push</span>(&#123;it-&gt;second, x&#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">auto</span> it = rtxMap.<span class=\"built_in\">lower_bound</span>(idx);</span><br><span class=\"line\">                    <span class=\"comment\">// 2 5</span></span><br><span class=\"line\">                    <span class=\"comment\">// next = 4</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (it != rtxMap.<span class=\"built_in\">begin</span>()) &#123;</span><br><span class=\"line\">                        --it;</span><br><span class=\"line\">                        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x = it-&gt;first;</span><br><span class=\"line\">                        it-&gt;second = <span class=\"built_in\">min</span>(it-&gt;second, height + idx - x);</span><br><span class=\"line\">                        pq.<span class=\"built_in\">push</span>(&#123;it-&gt;second, x&#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = rtxMap.<span class=\"built_in\">begin</span>(); <span class=\"built_in\">next</span>(it) != rtxMap.<span class=\"built_in\">end</span>(); ++it) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> leftIdx = it-&gt;first, leftHeight = it-&gt;second;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> rightIdx = <span class=\"built_in\">next</span>(it)-&gt;first, rightHeight = <span class=\"built_in\">next</span>(it)-&gt;second;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leftIdx + <span class=\"number\">1</span> == rightIdx) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// cout &lt;&lt; leftIdx &lt;&lt; &quot;, &quot; &lt;&lt; leftHeight &lt;&lt; &quot;, &quot; &lt;&lt; rightIdx &lt;&lt; &quot;, &quot; &lt;&lt; rightHeight &lt;&lt; endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> lo = <span class=\"built_in\">min</span>(leftHeight, rightHeight), hi = <span class=\"built_in\">min</span>(leftHeight + rightIdx - leftIdx, rightHeight + rightIdx - leftIdx);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> mid = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">bool</span> deter = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mid - leftHeight &lt; rightIdx - leftIdx <span class=\"keyword\">and</span> mid - rightHeight &lt; rightIdx - leftIdx <span class=\"keyword\">and</span> mid - leftHeight + mid - rightHeight - <span class=\"number\">1</span> &lt; rightIdx - leftIdx) deter = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (deter) &#123;</span><br><span class=\"line\">                    lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    hi = mid;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// t, t, t, f, f</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, lo - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>m = restrictions.length</code><br>时间复杂度: O(m log m),<br>空间复杂度: O(m).</p>\n<p><a href=\"https://leetcode-cn.com/problems/maximum-building-height/solution/zui-gao-jian-zhu-gao-du-by-leetcode-solu-axbb/910208\">零神题解</a>里有2次扫描的算法。虽然时间复杂度是一样的，但实现比较简单，常数上会更好些。</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/04/18/LeetCode-weekly-contest-237/",
            "url": "https://youngforest.github.io/2021/04/18/LeetCode-weekly-contest-237/",
            "title": "LeetCode weekly contest 237",
            "date_published": "2021-04-18T08:55:22.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>345 / 11446</td>\n<td>YoungForest</td>\n<td>18</td>\n<td>0:40:04</td>\n<td>0:03:21</td>\n<td>0:05:10</td>\n<td>0:25:30</td>\n<td>0:35:04  1</td>\n</tr>\n</tbody></table>\n<p>久违的四题并进入前500名。终于可以免打卡了。<br>已经连续打卡7周了，快要遭不住了呀。最近LeetCode难度提升不小，大佬入场也很多。要同时达到4题和前500属实不易。<br>今天手速也算正常发挥.</p>\n<h2 id=\"1832-Check-if-the-Sentence-Is-Pangram\"><a href=\"#1832-Check-if-the-Sentence-Is-Pangram\" class=\"headerlink\" title=\"1832. Check if the Sentence Is Pangram\"></a>1832. Check if the Sentence Is Pangram</h2><p>签到题。<br>统计每个单词出现的次数，判断是否都大于0.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">checkIfPangram</span><span class=\"params\">(string sentence)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">cnt</span><span class=\"params\">(<span class=\"number\">26</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> c : sentence) &#123;</span><br><span class=\"line\">            ++cnt[c - <span class=\"string\">&#x27;a&#x27;</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : cnt) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1833-Maximum-Ice-Cream-Bars\"><a href=\"#1833-Maximum-Ice-Cream-Bars\" class=\"headerlink\" title=\"1833. Maximum Ice Cream Bars\"></a>1833. Maximum Ice Cream Bars</h2><p>贪心。优先买便宜的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxIceCream</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; costs, <span class=\"keyword\">int</span> coins)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(<span class=\"built_in\">begin</span>(costs), <span class=\"built_in\">end</span>(costs));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : costs) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (coins &gt;= i) &#123;</span><br><span class=\"line\">                ++ans;</span><br><span class=\"line\">                coins -= i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(costs.length * log cost.length),<br>空间复杂度: O(log cost.length).</p>\n<h2 id=\"1834-Single-Threaded-CPU\"><a href=\"#1834-Single-Threaded-CPU\" class=\"headerlink\" title=\"1834. Single-Threaded CPU\"></a>1834. Single-Threaded CPU</h2><p>使用优先队列选择执行任务，根据题目要求，需要按<code>processTime, index</code>的顺序取。<br>另外，任务还需要按照<code>enqueueTime</code>排序，加入到等待的优先队列中。</p>\n<p>此题C++是有坑的。<br><code>tasks.length == n</code><br><code>1 &lt;= n &lt;= 10^5</code><br><code>1 &lt;= enqueueTimei, processingTimei &lt;= 10^9</code>,<br>因此，时间最后会超出<code>int</code>范围，需要使用<code>long long</code>解决。<br>当然, 选择<code>Python</code>就没这个问题了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> ll = <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">getOrder</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">using</span> pii = pair&lt;ll, <span class=\"keyword\">int</span>&gt;; <span class=\"comment\">// processTime, index</span></span><br><span class=\"line\">        <span class=\"comment\">// events</span></span><br><span class=\"line\">        <span class=\"keyword\">using</span> tii = tuple&lt;ll, ll, ll&gt;;  <span class=\"comment\">// enqueueTime, processTime, index</span></span><br><span class=\"line\">        vector&lt;tii&gt; events;</span><br><span class=\"line\">        events.<span class=\"built_in\">reserve</span>(tasks.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tasks.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            events.<span class=\"built_in\">push_back</span>(&#123;tasks[i][<span class=\"number\">0</span>], tasks[i][<span class=\"number\">1</span>], i&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(<span class=\"built_in\">begin</span>(events), <span class=\"built_in\">end</span>(events));</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        ans.<span class=\"built_in\">reserve</span>(tasks.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        ll now = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; wait; </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; events.<span class=\"built_in\">size</span>() || !wait.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; events.<span class=\"built_in\">size</span>() &amp;&amp; get&lt;<span class=\"number\">0</span>&gt;(events[i]) &lt;= now) &#123;</span><br><span class=\"line\">                wait.<span class=\"built_in\">push</span>(&#123;get&lt;<span class=\"number\">1</span>&gt;(events[i]), get&lt;<span class=\"number\">2</span>&gt;(events[i])&#125;);</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wait.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                wait.<span class=\"built_in\">push</span>(&#123;get&lt;<span class=\"number\">1</span>&gt;(events[i]), get&lt;<span class=\"number\">2</span>&gt;(events[i])&#125;);</span><br><span class=\"line\">                now = get&lt;<span class=\"number\">0</span>&gt;(events[i]);</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> run = wait.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            wait.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(run.second);</span><br><span class=\"line\">            now += run.first;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N log N), N = tasks.length,<br>空间复杂度: O(N).</p>\n<h2 id=\"1835-Find-XOR-Sum-of-All-Pairs-Bitwise-AND\"><a href=\"#1835-Find-XOR-Sum-of-All-Pairs-Bitwise-AND\" class=\"headerlink\" title=\"1835. Find XOR Sum of All Pairs Bitwise AND\"></a>1835. Find XOR Sum of All Pairs Bitwise AND</h2><p>问题咋一看无从下手，只想到暴力方法，枚举所有的pair，时间复杂度显然不够：<code>arr1.length * arr2.length = 10^10</code>。<br>但其实细想，对于这种位操作来说，每一位之间都是相互独立的。我们可以把问题简化成针对特定位的。只关注一个位的话，解法就呼之欲出了。<br>我们只需要统计<code>arr1</code>和<code>arr2</code>中0 和 1的数目。<br>假设<code>arr1</code>有<code>x</code>个0、<code>y</code>个1，<code>arr2</code>有<code>a</code>个0，<code>b</code>个1。<br>AND 为 1的数目即为<code>b*y</code>，为0的数目为<code>ax + ay + bx</code>。<br>再异或的话，只需要判断1的个数，即<code>b*y</code>，是不是奇数就OK了。<br>这里C++又有一个坑，因为<code>arr.length</code>最大为 10^ 5, <code>b*y</code>是可以<code>int</code>溢出的。LeetCode因为编译器开了溢出检查，因此会报类似下面的错误。我也因此罚时一次。<br>解决方案是要么用<code>long long</code>，要么 分别判断 <code>(b % 2 == 1) &amp;&amp; (y % 2 == 1)</code>.</p>\n<blockquote>\n<p>Line 24: Char 26: runtime error: signed integer overflow: 100000 * 100000 cannot be represented in type ‘int’ (solution.cpp)<br>SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:26</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\">pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; <span class=\"title\">extract</span><span class=\"params\">(<span class=\"keyword\">const</span> vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num &amp; (<span class=\"number\">1</span> &lt;&lt; i)) ++y;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ++x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;x, y&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getXORSum</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr1, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// brute-force: arr1.length * arr2.length = 10^10</span></span><br><span class=\"line\">        <span class=\"comment\">// smart: 32 * (arr1.length + arr2.length)</span></span><br><span class=\"line\">        <span class=\"comment\">// x0 y1</span></span><br><span class=\"line\">        <span class=\"comment\">// a0 b1</span></span><br><span class=\"line\">        <span class=\"comment\">// AND 0 = (ax + ay + bx)</span></span><br><span class=\"line\">        <span class=\"comment\">// AND 1 = (by)</span></span><br><span class=\"line\">        <span class=\"comment\">// if AND 1 % 2 == 1:</span></span><br><span class=\"line\">        <span class=\"comment\">//     k += (1 &lt;&lt; i)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">31</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [x, y] = <span class=\"built_in\">extract</span>(arr1, i);</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> [a, b] = <span class=\"built_in\">extract</span>(arr2, i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((b % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &amp;&amp; (y % <span class=\"number\">2</span> == <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                ans += (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/04/18/LeetCode-biweekly-contest-50/",
            "url": "https://youngforest.github.io/2021/04/18/LeetCode-biweekly-contest-50/",
            "title": "LeetCode biweekly contest 50",
            "date_published": "2021-04-18T03:57:36.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (4)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1032 / 10097</td>\n<td>YoungForest</td>\n<td>12</td>\n<td>0:20:28</td>\n<td>0:09:10</td>\n<td>0:12:51</td>\n<td>0:20:28</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<p>因为洗澡迟到了8分钟，否则应该可以进前500的。<br>本次的双周赛是变相的手速场，141人作出4题。剩下的比拼前3题的手速。<br>我花10min很顺利地做完了前三题，Q4却思考了一个小时也并未有重大突破。<br>虽然有些许眉目，觉得是个DP，但事后发现问题早已超纲，没做出来也实属正常。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"1827-Minimum-Operations-to-Make-the-Array-Increasing\"><a href=\"#1827-Minimum-Operations-to-Make-the-Array-Increasing\" class=\"headerlink\" title=\"1827. Minimum Operations to Make the Array Increasing\"></a>1827. Minimum Operations to Make the Array Increasing</h2><p>贪心。在保持递增的同时，使得数字尽可能小。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">minOperations</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// greedy</span></span><br><span class=\"line\">        <span class=\"comment\">// time: O(N)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> last = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; last) &#123;</span><br><span class=\"line\">                last = i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans += last + <span class=\"number\">1</span> - i;</span><br><span class=\"line\">                ++last;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1828-Queries-on-Number-of-Points-Inside-a-Circle\"><a href=\"#1828-Queries-on-Number-of-Points-Inside-a-Circle\" class=\"headerlink\" title=\"1828. Queries on Number of Points Inside a Circle\"></a>1828. Queries on Number of Points Inside a Circle</h2><p>由于点数和圆数都比较小（&lt;= 500），因此直接暴力即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">inside</span><span class=\"params\">(<span class=\"keyword\">const</span> vector&lt;<span class=\"keyword\">int</span>&gt;&amp; p, <span class=\"keyword\">const</span> vector&lt;<span class=\"keyword\">int</span>&gt;&amp; c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (p[<span class=\"number\">0</span>] - c[<span class=\"number\">0</span>]) * (p[<span class=\"number\">0</span>] - c[<span class=\"number\">0</span>]) + (p[<span class=\"number\">1</span>] - c[<span class=\"number\">1</span>]) * (p[<span class=\"number\">1</span>] - c[<span class=\"number\">1</span>]) &lt;= c[<span class=\"number\">2</span>] * c[<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">countPoints</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; points, vector&lt;vector&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        ans.<span class=\"built_in\">reserve</span>(queries.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; v : queries) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; p : points) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">inside</span>(p, v)) ++count;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(points.length * queries.length),<br>空间复杂度: O(queries.length).</p>\n<h2 id=\"1829-Maximum-XOR-for-Each-Query\"><a href=\"#1829-Maximum-XOR-for-Each-Query\" class=\"headerlink\" title=\"1829. Maximum XOR for Each Query\"></a>1829. Maximum XOR for Each Query</h2><p>利用前缀和（其实是前缀XOR）快速进行<code>Remove</code>操作，然后用互补的方式构造<code>k</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">getMaximumXor</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> maximumBit)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentXOR = <span class=\"built_in\">accumulate</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>, [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) -&gt; <span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a ^ b;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> findMax = [&amp;](<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a) -&gt; <span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// argmax a ^ k</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = maximumBit - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!(a &amp; (<span class=\"number\">1</span> &lt;&lt; i))) &#123;</span><br><span class=\"line\">                    k |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        vector&lt;<span class=\"keyword\">int</span>&gt; ans;</span><br><span class=\"line\">        ans.<span class=\"built_in\">reserve</span>(nums.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = nums.<span class=\"built_in\">rbegin</span>(); it != nums.<span class=\"built_in\">rend</span>(); ++it) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x = *it;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">findMax</span>(currentXOR));</span><br><span class=\"line\">            currentXOR ^= x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(nums.length * maximumBit),<br>空间复杂度: O(nums.length).</p>\n<h2 id=\"1830-Minimum-Number-of-Operations-to-Make-String-Sorted\"><a href=\"#1830-Minimum-Number-of-Operations-to-Make-String-Sorted\" class=\"headerlink\" title=\"1830. Minimum Number of Operations to Make String Sorted\"></a>1830. Minimum Number of Operations to Make String Sorted</h2><p><a href=\"https://leetcode.com/problems/minimum-number-of-operations-to-make-string-sorted/\">Problem link</a>.</p>\n",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/04/11/LCCUP-21-Spring-Team/",
            "url": "https://youngforest.github.io/2021/04/11/LCCUP-21-Spring-Team/",
            "title": "力扣2021春季赛 - 战队赛",
            "date_published": "2021-04-11T13:53:03.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (2)</th>\n<th>Q2 (4)</th>\n<th>Q3 (6)</th>\n<th>Q4 (8)</th>\n<th>Q5 (9)</th>\n<th>Q6(12)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>228 / 781</td>\n<td>佛系刷题</td>\n<td>6/41</td>\n<td>1:00:00</td>\n<td>0:42:42</td>\n<td>1:00:00</td>\n<td>null</td>\n<td>null</td>\n<td>null</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://leetcode-cn.com/contest/season/2021-spring/ranking/team/\">比赛链接</a></p>\n<p>之前LC-CN举办的春季赛和秋季赛我都没参加，因为实验室之前每周六下午开组会，时间完美冲突。现在老板改为平时开小组会，一月开一次大组会，终于有机会参加2021年的春季赛了。<br>周一清明节参加了个人赛，<a href=\"https://youngforest.github.io/2021/04/05/LCCUP-21-Spring-Solo/\">总结博客于此</a>.<br>周六和 <strong>佛系刷题群</strong> 的 老赖 还有 George 组队一起佛系出征，最后的结果果然很佛系，2题结束。我第一题，George第二题（还是我提供思路，帮忙 review + debug). 不得不说，跟2个人组队打比赛还不如我一个人效果好。怪不得ACM比赛的队伍都要磨合好久。</p>\n<h2 id=\"LCP-33-蓄水\"><a href=\"#LCP-33-蓄水\" class=\"headerlink\" title=\"LCP 33. 蓄水\"></a>LCP 33. 蓄水</h2><p>签到题。虽然是Easy，不过作为竞赛第一题，本题的难度还是相当大的。</p>\n<p>观察 + 暴力。</p>\n<p>操作共分为 升级 和 蓄水 2种。显然 <strong>蓄水</strong>操作应排在<strong>升级</strong>之后.<br>一个朴素的暴力方法是，我们先枚举所有可能的蓄水次数，升级次数就因之而定，然后在其中选最小的。枚举蓄水次数也存在剪枝的过程。先试小的，如果已经比全局最小总次数大了，就直接结束了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">storeWater</span><span class=\"params\">(vector&lt;<span class=\"keyword\">int</span>&gt;&amp; bucket, vector&lt;<span class=\"keyword\">int</span>&gt;&amp; vat)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// time: max(buckets[i]) * buckets.size() = 10^4 * 100</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = numeric_limits&lt;<span class=\"keyword\">int</span>&gt;::<span class=\"built_in\">max</span>();</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = bucket.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">accumulate</span>(vat.<span class=\"built_in\">begin</span>(), vat.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>) == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> check = [&amp;](<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> x) -&gt; <span class=\"keyword\">int</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> need = vat[i] - bucket[i] * x;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (need &gt; <span class=\"number\">0</span>) ans += (need + x - <span class=\"number\">1</span>) / x;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x = <span class=\"number\">1</span>; x &lt;= <span class=\"number\">1e4</span>; ++x) &#123; <span class=\"comment\">// 蓄水次数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt;= ans) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            ans = <span class=\"built_in\">min</span>(ans, x + <span class=\"built_in\">check</span>(x));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(max(vat[i]) * buckets.length) = O(10^4 * 100),<br>空间复杂度: O(1).</p>\n<h2 id=\"LCP-34-二叉树染色\"><a href=\"#LCP-34-二叉树染色\" class=\"headerlink\" title=\"LCP 34. 二叉树染色\"></a>LCP 34. 二叉树染色</h2><p>DFS。需要注意的是，因为蓝色<strong>连接体</strong>节点数目为k，我们需要枚举把当前剩下的蓝色点数分配给左子树和右子树的方式。另外，观察到k的数目其实不大，只有10。更加印证了我的猜想。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"># class TreeNode:</span></span><br><span class=\"line\"><span class=\"comment\">#     def __init__(self, x):</span></span><br><span class=\"line\"><span class=\"comment\">#         self.val = x</span></span><br><span class=\"line\"><span class=\"comment\">#         self.left = None</span></span><br><span class=\"line\"><span class=\"comment\">#         self.right = None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxValue</span>(<span class=\"params\">self, root: TreeNode, k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\"><span class=\"meta\">        @cache</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span>(<span class=\"params\">root: TreeNode, remain: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">            ans = dfs(root.left, k) + dfs(root.right, k)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, remain):</span><br><span class=\"line\">                ans = <span class=\"built_in\">max</span>(ans, dfs(root.left, i) + dfs(root.right, remain - <span class=\"number\">1</span> - i) + root.val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ans</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(root, k)</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(结点数 * k)，<br>空间负载的: O(结点数 * k).</p>\n<h2 id=\"LCP-35-电动车游城市\"><a href=\"#LCP-35-电动车游城市\" class=\"headerlink\" title=\"LCP 35. 电动车游城市\"></a>LCP 35. 电动车游城市</h2><h2 id=\"LCP-36-最多牌组数\"><a href=\"#LCP-36-最多牌组数\" class=\"headerlink\" title=\"LCP 36. 最多牌组数\"></a>LCP 36. 最多牌组数</h2><h2 id=\"LCP-37-最小矩形面积\"><a href=\"#LCP-37-最小矩形面积\" class=\"headerlink\" title=\"LCP 37. 最小矩形面积\"></a>LCP 37. 最小矩形面积</h2><h2 id=\"LCP-38-守卫城堡\"><a href=\"#LCP-38-守卫城堡\" class=\"headerlink\" title=\"LCP 38. 守卫城堡\"></a>LCP 38. 守卫城堡</h2>",
            "tags": [
                "Competitive Programming"
            ]
        },
        {
            "id": "https://youngforest.github.io/2021/04/11/LeetCode-weekly-contest-236/",
            "url": "https://youngforest.github.io/2021/04/11/LeetCode-weekly-contest-236/",
            "title": "LeetCode weekly contest 236",
            "date_published": "2021-04-11T08:00:09.000Z",
            "content_html": "<table>\n<thead>\n<tr>\n<th>Rank</th>\n<th>Name</th>\n<th>Score</th>\n<th>Finish Time</th>\n<th>Q1 (3)</th>\n<th>Q2 (5)</th>\n<th>Q3 (5)</th>\n<th>Q4 (6)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1513 / 12115</td>\n<td>YoungForest</td>\n<td>12</td>\n<td>0:45:18</td>\n<td>0:02:57</td>\n<td>0:08:59</td>\n<td>0:40:18  1</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<h2 id=\"1822-Sign-of-the-Product-of-an-Array\"><a href=\"#1822-Sign-of-the-Product-of-an-Array\" class=\"headerlink\" title=\"1822. Sign of the Product of an Array\"></a>1822. Sign of the Product of an Array</h2><p>签到题。多少负数，是否有0。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">arraySign</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        x = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            x *= i</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> x == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1823-Find-the-Winner-of-the-Circular-Game\"><a href=\"#1823-Find-the-Winner-of-the-Circular-Game\" class=\"headerlink\" title=\"1823. Find the Winner of the Circular Game\"></a>1823. Find the Winner of the Circular Game</h2><p>经典的约瑟夫环问题。随便Google了一个: <a href=\"https://blog.csdn.net/u011500062/article/details/72855826\">约瑟夫环——公式法</a>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cir</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> m)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            p=(p+m)%i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findTheWinner</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">cir</span>(n, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1824-Minimum-Sideway-Jumps\"><a href=\"#1824-Minimum-Sideway-Jumps\" class=\"headerlink\" title=\"1824. Minimum Sideway Jumps\"></a>1824. Minimum Sideway Jumps</h2><p>动态规划。</p>\n<p>dp[i][j] 表示从i的位置，第j个lane 到末尾需要的最小side jumps.<br>需要注意的是 本题<code>N &lt;= 5 * 10^5</code>，Python TOP-BOTTOM的DP会爆栈。<br>因此比赛时Runtime Error一次，加了<br><code>sys.setrecursionlimit(110000)</code>仍然不行，遂改成了Bottom-Up 的DP。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">minSideJumps</span>(<span class=\"params\">self, obstacles: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>]</span>) -&gt; <span class=\"built_in\">int</span>:</span></span><br><span class=\"line\">        n = <span class=\"built_in\">len</span>(obstacles) - <span class=\"number\">1</span></span><br><span class=\"line\">        dp = [[<span class=\"built_in\">float</span>(<span class=\"string\">&#x27;inf&#x27;</span>)] * <span class=\"number\">4</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n + <span class=\"number\">1</span>)]</span><br><span class=\"line\">        dp[n][<span class=\"number\">1</span>] = dp[n][<span class=\"number\">2</span>] = dp[n][<span class=\"number\">3</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n - <span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> obstacles[i+<span class=\"number\">1</span>] != j:</span><br><span class=\"line\">                    dp[i][j] = <span class=\"built_in\">min</span>(dp[i][j], dp[i+<span class=\"number\">1</span>][j])</span><br><span class=\"line\">                <span class=\"keyword\">for</span> nj <span class=\"keyword\">in</span> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>):</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> j == nj: <span class=\"keyword\">continue</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> obstacles[i] != nj <span class=\"keyword\">and</span> obstacles[i+<span class=\"number\">1</span>] != nj:</span><br><span class=\"line\">                        dp[i][j] = <span class=\"built_in\">min</span>(dp[i][j], dp[i+<span class=\"number\">1</span>][nj] + <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>][<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度: O(N),<br>空间复杂度: O(1).</p>\n<h2 id=\"1825-Finding-MK-Average\"><a href=\"#1825-Finding-MK-Average\" class=\"headerlink\" title=\"1825. Finding MK Average\"></a>1825. Finding MK Average</h2>",
            "tags": [
                "Competitive Programming"
            ]
        }
    ]
}